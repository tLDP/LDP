<sect1 id="VNC">

<title>VNC</title>

  8.13.  Tunnelling, mobile IP and virtual private networks

  The Linux kernel allows the tunnelling (encapsulation) of protocols.
  It can do IPX tunnelling through IP, allowing the connection of two
  IPX networks through an IP only link. It can also do IP-IP tunnelling,
  which it is essential for mobile IP support, multicast support and
  amateur radio. (see
  http://metalab.unc.edu/mdw/HOWTO/NET3-4-HOWTO-6.html#ss6.8)

  Mobile IP specifies enhancements that allow transparent routing of IP
  datagrams to mobile nodes in the Internet.  Each mobile node is always
  identified by its home address, regardless of its current point of
  attachment to the Internet.  While situated away from its home, a
  mobile node is also associated with a care-of address, which provides
  information about its current point of attachment to the Internet.
  The protocol provides for registering the care-of address with a home
  agent.  The home agent sends datagrams destined for the mobile node
  through a tunnel to the care-of address.  After arriving at the end of
  the tunnel, each datagram is then delivered to the mobile node.

  Point-to-Point Tunneling Protocol (PPTP) is a networking technology
  that allows the use of the Internet as a secure virtual private
  network (VPN). PPTP is integrated with the Remote Access Services
  (RAS) server which is built into Windows NT Server. With PPTP, users
  can dial into a local ISP, or connect directly to the Internet, and
  access their network as if they were at their desks. PPTP is a closed
  protocol and its security has recently being compromised. It is highly
  recomendable to use other Linux based alternatives, since they rely on
  open standards which have been carefully examined and tested.


  ·  A client implementation of the PPTP for Linux is available  here
     <http://www.pdos.lcs.mit.edu/~cananian/Projects/PPTP/>

  ·  More on Linux PPTP can be found here
     <http://bmrc.berkeley.edu/people/chaffee/linux_pptp.html>

     Mobile IP:

  ·  http://www.hpl.hp.com/personal/Jean_Tourrilhes/MobileIP/mip.html

  ·  http://metalab.unc.edu/mdw/HOWTO/NET3-4-HOWTO-6.html#ss6.12

     Virtual Private Networks related documents:


  ·  http://metalab.unc.edu/mdw/HOWTO/mini/VPN.html

  ·  http://sites.inka.de/sites/bigred/devel/cipe.html


7.4.  VNC

  VNC stands for Virtual Network Computing. It is, in essence, a remote
  display system which allows one to view a computing 'desktop'
  environment not only on the machine where it is running, but from
  anywhere on the Internet and from a wide variety of machine
  architectures. Both clients and servers exist for Linux as well as for
  many other platforms. It is possible to execute MS-Word in a Windows
  NT or 95 machine and have the output displayed in a Linux machine. The
  opposite is also true; it is possible to execute an application in a
  Linux machine and have the output displayed in any other Linux or
  Windows machine. One of the available clients is a Java applet,
  allowing the remote display to be run inside a web browser. Another
  client is a port for Linux using the SVGAlib graphics library,
  allowing 386s with as little as 4 MB of RAM to become fully functional
  X-Terminals.

  ·  VNC web site <http://www.orl.co.uk/vnc/>

<para>
Virtual Network Computing (VNC) allows a user to operate a session running on another machine.
Although Linux and all other Unix-like OSes already have this functionality built in, VNC
provides further advantages because it's cross-platform, running on Linux, BSD, Unix, Win32,
MacOS, and PalmOS. This makes it far more versatile.

For example, let's assume the machine that you are attempting to connect to is running Linux.
You can use VNC to access applications running on that other Linux desktop. You can also use
VNC to provide technical support to users on Window's based machines by taking control of
their desktops from the comfort of your server room. VNC is usually installed as seperate
packages for the client and server, typically named 'vnc' and 'vnc-server'.

VNC uses screen numbers to connect clients to servers. This is because Unix machines allow
multiple graphical sessions to be stated simultaneously (check this out by logging in to a
virtual terminal and typing startx -- :1).

For platforms (Windows, MacOS, Palm, etc) which don't have this capability, you'll connect
to 'screen 0' and take over the session of the existing user. For Unix systems, you'll need
to specify a higher number and receive a new desktop.

If you prefer the Windows-style approach where the VNC client takes over the currently
running display, you can use x0rfbserver - see the sidebox below.

VNC Servers and Clients

On Linux, the VNC server (which allows the machine to be used remotely) is actually
run as a replacement X server. To be able to start a VNC session to a machine, log
into it and run vncserver. You'll be prompted for a password -  in future you can
change this password with the vncpasswd command. After you enter the password, you'll
be told the display number of the newly created machine.

It is possible to control a remote macine by using the vncviewer command. If it is
typed on its own it will prompt for a remote machine, or you can use:
vncviewer [host]:[screen-number]

> The VPN HOWTO, deprecated!!!!
> VPN HOWTO
> Linux VPN Masquerade HOWTO
</para>

VPN HOWTO

Matthew D. Wilson

matthew@shinythings.com

Dec 1999
Revision History                                                             
Revision 2.0           2002-05-30            Revised by: tab                 
Updated to Docbook 4.1 and applied GFDL per Matthew Wilson                   
Revision 1.0           1999-12-01            Revised by: mdw                 
Initial release                                                              


This HOWTO describes how to set up a Virtual Private Network with Linux.

-----------------------------------------------------------------------------
Table of Contents
1. Introduction
    1.1. Why I wrote this HOWTO
    1.2. Acknowledgements and Thanks
    1.3. Format of this document
    1.4. Legal Information
    1.5. Document History
    1.6. Related Documents
   
   
2. Theory
    2.1. What is a VPN?
    2.2. But really, what IS a VPN?
    2.3. So how does it work?
    2.4. SSH and PPP
    2.5. Alternative VPN Systems
   
   
3. Server
    3.1. Security - keeping people out
    3.2. User Access - letting people in
    3.3. Restricting Users
    3.4. Networking
   
   
4. Client
    4.1. The Kernel
    4.2. Bring up the link
    4.3. Scripting
    4.4. LRP - Linux Router Project
   
   
5. Implementation
    5.1. Planning
    5.2. Gather the tools
    5.3. Server: Build the kernel
    5.4. Server: Configure Networking
    5.5. Server: Configure pppd
    5.6. Server: Configure sshd
    5.7. Server: Set up user accounts
    5.8. Add vpn-users group
    5.9. create the vpn-users home directory
    5.10. The .ssh directory
    5.11. Adding users
    5.12. Server: Administration
    5.13. Client: Build the kernel
    5.14. Client: Configure Networking
    5.15. Client: Configure pppd
    5.16. Client: Configure ssh
    5.17. Client: Bring up the connection
    5.18. Client: Set the routes
    5.19. Client: Scripting
   
   
6. Addenda
    6.1. Pitfalls
    6.2. Hardware and Software Requirements
   
   

-----------------------------------------------------------------------------
Chapter 1. Introduction

1.1. Why I wrote this HOWTO

 I work at Real Networks, and we needed VPN service. This was my first real
project, and I truly learned more about Linux with this than with any other
task. I ended up using my experience with that project to write this
document, to share with others what I learned, so that they can do
ultra-nifty things with Linux too!
-----------------------------------------------------------------------------

1.2. Acknowledgements and Thanks

 I want to first and foremost thank my wife Julie, without her, I wouldn't be
where I am today. I also want to thank Arpad Magosanyi, the author of the
first VPN mini-howto and pty-redir, the utility that makes all of this
possible. Jerry, Rod, Glen, Mark V., Mark W., and David, You guys rock!
Thanks for all your help.
-----------------------------------------------------------------------------

1.3. Format of this document

 This document is broken down into 5 chapters.

 

Section 1: Introduction
    This section
   
Section 2: Theory
    Basic VPN theory. What is a VPN, and how does it work. Read this if you
    are entirely new to VPN.
   
Section 3: Server
    This section describes how a VPN server is set up.
   
Section 4: Client
    This section describes how a VPN client is set up.
   
Section 5: Implementation
    A step by step implementation of a sample VPN setup.
   
Section 6: Addenda
    Other bits and pieces of info that you might find helpful.
   

-----------------------------------------------------------------------------
1.4. Legal Information

1.4.1. Copyright

Copyright (c) 2002 Matthew D. Wilson.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, no Front-Cover Texts, and no Back-Cover Texts. A copy of the
license is included in the section entitled "GNU Free Documentation License".
-----------------------------------------------------------------------------

1.4.2. Disclaimer

 The author assumes no responsibility for anything done with this document,
nor does he make any warranty, implied or explicit. If you break it, it's not
my fault. Remember, what you do here could make very large holes in the
security model of your network. You've been warned.
-----------------------------------------------------------------------------

1.4.3. GNU Free Documentation License

Version 1.1, March 2000

   
    Copyright (C) 2000 Free Software Foundation, Inc. 59 Temple Place, Suite
    330, Boston, MA 02111-1307 USA Everyone is permitted to copy and
    distribute verbatim copies of this license document, but changing it is
    not allowed.
   
-----------------------------------------------------------------------------
1.4.4. PREAMBLE

The purpose of this License is to make a manual, textbook, or other written
document "free" in the sense of freedom: to assure everyone the effective
freedom to copy and redistribute it, with or without modifying it, either
commercially or noncommercially. Secondarily, this License preserves for the
author and publisher a way to get credit for their work, while not being
considered responsible for modifications made by others.

This License is a kind of "copyleft", which means that derivative works of
the document must themselves be free in the same sense. It complements the
GNU General Public License, which is a copyleft license designed for free
software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free program
should come with manuals providing the same freedoms that the software does.
But this License is not limited to software manuals; it can be used for any
textual work, regardless of subject matter or whether it is published as a
printed book. We recommend this License principally for works whose purpose
is instruction or reference.
-----------------------------------------------------------------------------

1.4.5. APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work that contains a notice
placed by the copyright holder saying it can be distributed under the terms
of this License. The "Document", below, refers to any such manual or work.
Any member of the public is a licensee, and is addressed as "you".

A "Modified Version" of the Document means any work containing the Document
or a portion of it, either copied verbatim, or with modifications and/or
translated into another language.

A "Secondary Section" is a named appendix or a front-matter section of the
Document that deals exclusively with the relationship of the publishers or
authors of the Document to the Document's overall subject (or to related
matters) and contains nothing that could fall directly within that overall
subject. (For example, if the Document is in part a textbook of mathematics,
a Secondary Section may not explain any mathematics.) The relationship could
be a matter of historical connection with the subject or with related
matters, or of legal, commercial, philosophical, ethical or political
position regarding them.

The "Invariant Sections" are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says
that the Document is released under this License.

The "Cover Texts" are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the
Document is released under this License.

A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the general
public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or for
automatic translation to a variety of formats suitable for input to text
formatters. A copy made in an otherwise Transparent file format whose markup
has been designed to thwart or discourage subsequent modification by readers
is not Transparent. A copy that is not "Transparent" is called "Opaque".

Examples of suitable formats for Transparent copies include plain ASCII
without markup, Texinfo input format, LaTeX input format, SGML or XML using a
publicly available DTD, and standard-conforming simple HTML designed for
human modification. Opaque formats include PostScript, PDF, proprietary
formats that can be read and edited only by proprietary word processors, SGML
or XML for which the DTD and/or processing tools are not generally available,
and the machine-generated HTML produced by some word processors for output
purposes only.

The "Title Page" means, for a printed book, the title page itself, plus such
following pages as are needed to hold, legibly, the material this License
requires to appear in the title page. For works in formats which do not have
any title page as such, "Title Page" means the text near the most prominent
appearance of the work's title, preceding the beginning of the body of the
text.
-----------------------------------------------------------------------------

1.4.6. VERBATIM COPYING

You may copy and distribute the Document in any medium, either commercially
or noncommercially, provided that this License, the copyright notices, and
the license notice saying this License applies to the Document are reproduced
in all copies, and that you add no other conditions whatsoever to those of
this License. You may not use technical measures to obstruct or control the
reading or further copying of the copies you make or distribute. However, you
may accept compensation in exchange for copies. If you distribute a large
enough number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and you may
publicly display copies.
-----------------------------------------------------------------------------

1.4.7. COPYING IN QUANTITY

If you publish printed copies of the Document numbering more than 100, and
the Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover Texts:
Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover.
Both covers must also clearly and legibly identify you as the publisher of
these copies. The front cover must present the full title with all words of
the title equally prominent and visible. You may add other material on the
covers in addition. Copying with changes limited to the covers, as long as
they preserve the title of the Document and satisfy these conditions, can be
treated as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit legibly, you
should put the first ones listed (as many as fit reasonably) on the actual
cover, and continue the rest onto adjacent pages.

If you publish or distribute Opaque copies of the Document numbering more
than 100, you must either include a machine-readable Transparent copy along
with each Opaque copy, or state in or with each Opaque copy a
publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the general
network-using public has access to download anonymously at no charge using
public-standard network protocols. If you use the latter option, you must
take reasonably prudent steps, when you begin distribution of Opaque copies
in quantity, to ensure that this Transparent copy will remain thus accessible
at the stated location until at least one year after the last time you
distribute an Opaque copy (directly or through your agents or retailers) of
that edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give them
a chance to provide you with an updated version of the Document.
-----------------------------------------------------------------------------

1.4.8. MODIFICATIONS

You may copy and distribute a Modified Version of the Document under the
conditions of sections 2 and 3 above, provided that you release the Modified
Version under precisely this License, with the Modified Version filling the
role of the Document, thus licensing distribution and modification of the
Modified Version to whoever possesses a copy of it. In addition, you must do
these things in the Modified Version:

 A. Use in the Title Page (and on the covers, if any) a title distinct from
    that of the Document, and from those of previous versions (which should,
    if there were any, be listed in the History section of the Document). You
    may use the same title as a previous version if the original publisher of
    that version gives permission.
   
 B. List on the Title Page, as authors, one or more persons or entities
    responsible for authorship of the modifications in the Modified Version,
    together with at least five of the principal authors of the Document (all
    of its principal authors, if it has less than five).
   
 C. State on the Title page the name of the publisher of the Modified
    Version, as the publisher.
   
 D. Preserve all the copyright notices of the Document.
   
 E. Add an appropriate copyright notice for your modifications adjacent to
    the other copyright notices.
   
 F. Include, immediately after the copyright notices, a license notice giving
    the public permission to use the Modified Version under the terms of this
    License, in the form shown in the Addendum below.
   
 G. Preserve in that license notice the full lists of Invariant Sections and
    required Cover Texts given in the Document's license notice.
   
 H. Include an unaltered copy of this License.
   
 I. Preserve the section entitled "History", and its title, and add to it an
    item stating at least the title, year, new authors, and publisher of the
    Modified Version as given on the Title Page. If there is no section
    entitled "History" in the Document, create one stating the title, year,
    authors, and publisher of the Document as given on its Title Page, then
    add an item describing the Modified Version as stated in the previous
    sentence.
   
 J. Preserve the network location, if any, given in the Document for public
    access to a Transparent copy of the Document, and likewise the network
    locations given in the Document for previous versions it was based on.
    These may be placed in the "History" section. You may omit a network
    location for a work that was published at least four years before the
    Document itself, or if the original publisher of the version it refers to
    gives permission.
   
 K. In any section entitled "Acknowledgements" or "Dedications", preserve the
    section's title, and preserve in the section all the substance and tone
    of each of the contributor acknowledgements and/or dedications given
    therein.
   
 L. Preserve all the Invariant Sections of the Document, unaltered in their
    text and in their titles. Section numbers or the equivalent are not
    considered part of the section titles.
   
 M. Delete any section entitled "Endorsements". Such a section may not be
    included in the Modified Version.
   
 N. Do not retitle any existing section as "Endorsements" or to conflict in
    title with any Invariant Section.
   

If the Modified Version includes new front-matter sections or appendices that
qualify as Secondary Sections and contain no material copied from the
Document, you may at your option designate some or all of these sections as
invariant. To do this, add their titles to the list of Invariant Sections in
the Modified Version's license notice. These titles must be distinct from any
other section titles.

You may add a section entitled "Endorsements", provided it contains nothing
but endorsements of your Modified Version by various parties--for example,
statements of peer review or that the text has been approved by an
organization as the authoritative definition of a standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list of
Cover Texts in the Modified Version. Only one passage of Front-Cover Text and
one of Back-Cover Text may be added by (or through arrangements made by) any
one entity. If the Document already includes a cover text for the same cover,
previously added by you or by arrangement made by the same entity you are
acting on behalf of, you may not add another; but you may replace the old
one, on explicit permission from the previous publisher that added the old
one.

The author(s) and publisher(s) of the Document do not by this License give
permission to use their names for publicity for or to assert or imply
endorsement of any Modified Version.
-----------------------------------------------------------------------------

1.4.9. COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified versions,
provided that you include in the combination all of the Invariant Sections of
all of the original documents, unmodified, and list them all as Invariant
Sections of your combined work in its license notice.

The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there are
multiple Invariant Sections with the same name but different contents, make
the title of each such section unique by adding at the end of it, in
parentheses, the name of the original author or publisher of that section if
known, or else a unique number. Make the same adjustment to the section
titles in the list of Invariant Sections in the license notice of the
combined work.

In the combination, you must combine any sections entitled "History" in the
various original documents, forming one section entitled "History"; likewise
combine any sections entitled "Acknowledgements", and any sections entitled
"Dedications". You must delete all sections entitled "Endorsements."
-----------------------------------------------------------------------------

1.4.10. COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in the
collection, provided that you follow the rules of this License for verbatim
copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute it
individually under this License, provided you insert a copy of this License
into the extracted document, and follow this License in all other respects
regarding verbatim copying of that document.
-----------------------------------------------------------------------------

1.4.11. AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version of the
Document, provided no compilation copyright is claimed for the compilation.
Such a compilation is called an "aggregate", and this License does not apply
to the other self-contained works thus compiled with the Document, on account
of their being thus compiled, if they are not themselves derivative works of
the Document.

If the Cover Text requirement of section 3 is applicable to these copies of
the Document, then if the Document is less than one quarter of the entire
aggregate, the Document's Cover Texts may be placed on covers that surround
only the Document within the aggregate. Otherwise they must appear on covers
around the whole aggregate.
-----------------------------------------------------------------------------

1.4.12. TRANSLATION

Translation is considered a kind of modification, so you may distribute
translations of the Document under the terms of section 4. Replacing
Invariant Sections with translations requires special permission from their
copyright holders, but you may include translations of some or all Invariant
Sections in addition to the original versions of these Invariant Sections.
You may include a translation of this License provided that you also include
the original English version of this License. In case of a disagreement
between the translation and the original English version of this License, the
original English version will prevail.
-----------------------------------------------------------------------------

1.4.13. TERMINATION

You may not copy, modify, sublicense, or distribute the Document except as
expressly provided for under this License. Any other attempt to copy, modify,
sublicense or distribute the Document is void, and will automatically
terminate your rights under this License. However, parties who have received
copies, or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.
-----------------------------------------------------------------------------

1.4.14. FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions of the GNU
Free Documentation License from time to time. Such new versions will be
similar in spirit to the present version, but may differ in detail to address
new problems or concerns. See [http://www.gnu.org/copyleft/] http://
www.gnu.org/copyleft/.

Each version of the License is given a distinguishing version number. If the
Document specifies that a particular numbered version of this License "or any
later version" applies to it, you have the option of following the terms and
conditions either of that specified version or of any later version that has
been published (not as a draft) by the Free Software Foundation. If the
Document does not specify a version number of this License, you may choose
any version ever published (not as a draft) by the Free Software Foundation.
-----------------------------------------------------------------------------

1.4.15. How to use this License for your documents

To use this License in a document you have written, include a copy of the
License in the document and put the following copyright and license notices
just after the title page:

   
      Copyright (c) YEAR YOUR NAME. Permission is granted to copy, distribute
    and/or modify this document under the terms of the GNU Free Documentation
    License, Version 1.1 or any later version published by the Free Software
    Foundation; with the Invariant Sections being LIST THEIR TITLES, with the
    Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST. A
    copy of the license is included in the section entitled "GNU Free
    Documentation License".
   
If you have no Invariant Sections, write "with no Invariant Sections" instead
of saying which ones are invariant. If you have no Front-Cover Texts, write
"no Front-Cover Texts" instead of "Front-Cover Texts being LIST"; likewise
for Back-Cover Texts.

If your document contains nontrivial examples of program code, we recommend
releasing these examples in parallel under your choice of free software
license, such as the GNU General Public License, to permit their use in free
software.
-----------------------------------------------------------------------------

1.5. Document History

 The original "VPN mini-HOWTO" was written by Arpad Magosanyi, <
mag@bunuel.tii.matav.hu>, in 1997. He has since allowed me to take up the
document and extend it into a full HOWTO. All of this would not be possible
without his original document. Thanks again Arpad. :)

 Version 1.0 of this HOWTO was completed on December 10, 1999.
-----------------------------------------------------------------------------

1.6. Related Documents

 

  *  [/HOWTO/Networking-Overview-HOWTO.html] Networking Overview HOWTO
   
  *  [/HOWTO/NET3-4-HOWTO.html] Networking HOWTO
   
  *  [/HOWTO/VPN-Masquerade-HOWTO.html] VPN-Masquerade HOWTO
   

-----------------------------------------------------------------------------
Chapter 2. Theory

2.1. What is a VPN?

 VPN stands for Virtual Private Network. A VPN uses the Internet as it's
transport mechanism, while maintaining the security of the data on the VPN.
-----------------------------------------------------------------------------

2.2. But really, what IS a VPN?

 There are several answers to that question. It really depends on your
network layout. The most common configuration is to have a single main
internal network with remote nodes using VPN to gain full access to the
central net. The remote nodes are commonly remote offices or employees
working from home. You can also link two small (or large) networks to form an
even larger single network.
-----------------------------------------------------------------------------

2.3. So how does it work?

 Put simply, to make a VPN, you create a secure tunnel between the two
networks and route IP through it. If I've lost you already, you should read
[http://www.tldp.org/HOWTO/Networking-Overview-HOWTO.html]  The Linux
Networking Overview HOWTO to learn more about networking with Linux.

 Here are some diagrams to illustrate this concept:
                                \          \                                         
                 --------       /          /      --------                           
   Remote ______| Client |______\ Internet \_____| Server |______ Private            
   Network      | Router |      /          /     | Router |       Network            
                 --------       \          \      --------                           
                                /          /                                         
                                                                                     
                                                                                     
                         Client Router                                               
               ----------------------------------------------------                  
              |   /->    10.0.0.0/255.0.0.0   \                    |                 
  Remote      |  |-->  172.16.0.0/255.240.0.0  |--> Tunnel >---\   |                 
  Network >---|--|--> 192.168.0.0/255.255.0.0 /                 |--|----> Internet   
 192.168.12.0 |  |                                              |  |                 
              |   \-----> 0.0.0.0/0.0.0.0 --> IP Masquerade >--/   |                 
               ----------------------------------------------------                  
                                                                                     
                                                                                     
                        Server Router                                                
             ----------------------------------------------------                    
            |                   /->    10.0.0.0/255.0.0.0    \   |                   
            |   /--> Tunnel >--|-->  172.16.0.0/255.240.0.0   |--|----> Private      
Internet >--|--|                \--> 192.168.0.0/255.255.0.0 /   |      Network      
            |  |                                                 |     172.16.0.0/12 
            |   \-----> 0.0.0.0/0.0.0.0 -----> /dev/null         |    192.168.0.0/16 
             ----------------------------------------------------                    

 The above diagram shows how the network might be set up. If you don't know
what IP Masquerading is, you should probably read the The Linux Networking
Overview HOWTO and come back once you understand how it works.

 The Client Router is a Linux box acting as the gateway/firewall for the
remote network. The remote network uses the local IP address 192.168.12.0.
For the sake of a simple diagram, I left out the local routing information on
the routers. The basic idea is to route traffic for all of the private
networks (10.0.0.0, 172.16.0.0, and 192.168.0.0) through the tunnel. The
setup shown here is one way. That is, while the remote network can see the
private network, the private network cannot necessarily see the remote
network. In order for that to happen, you must specify that the routes are
bidirectional.

 From the diagram you should also note that all of the traffic coming out of
the client router appears to be from the client router, that is, all from one
IP address. You could route real numbers from inside your network but that
brings all sorts of security problems with it.
-----------------------------------------------------------------------------

2.4. SSH and PPP

 The system that I describe to implement VPN uses SSH and PPP. Basically I
use ssh to create a tunnel connection, and then use pppd to run TCP/IP
traffic though it. That's what makes up the tunnel.

 The real trick to getting ssh and pppd to play well together is the utility
written by Arpad Magosanyi that allows the redirection of standard in and
standard out to a pseudo tty. This allows pppd to talk through ssh as if it
were a serial line. On the server side, pppd is run as the users shell in the
ssh session, completing the link. After that, all you need to do is the
routing.
-----------------------------------------------------------------------------

2.5. Alternative VPN Systems

 There are of course other ways of setting up a VPN. Here are a couple of
other systems:
-----------------------------------------------------------------------------

2.5.1. PPTP

 PPTP is a Microsoft protocol for VPN. It is supported under Linux, but is
known to have serious security issues. I do not describe how to use it here
since it is covered by the [http://www.tldp.org/HOWTO/
VPN-Masquerade-HOWTO.html] Linux VPN Masquerade HOWTO.
-----------------------------------------------------------------------------

2.5.2. IP Sec

 IP Sec is a different set of protocols from SSH. I don't actually know all
that much about it, so if someone wants to help me out with a description,
I'd be most appreciative. Again, I do not describe how to use it here since
it is covered by the [http://www.tldp.org/HOWTO/VPN-Masquerade-HOWTO.html]
Linux VPN Masquerade HOWTO.
-----------------------------------------------------------------------------

2.5.3. CIPE

 CIPE is a kernel level network encryption system that may be better suited
to enterprise setups. You can find out more about it at [http://sites.inka.de
/sites/bigred/devel/cipe.html] the CIPE homepage.
-----------------------------------------------------------------------------

Chapter 3. Server

 This section tells you how to set up the server side of things. I figured
that this should go first since without a server, your client is kind of
useless.
-----------------------------------------------------------------------------

3.1. Security - keeping people out

 Security is very important for a VPN. That's why you're building one in the
first place, isn't it? You need to keep a few things in mind while setting up
your server.
-----------------------------------------------------------------------------

3.1.1. Trim your daemons

 Since this server is going to be on both sides of your firewall, and set up
to forward traffic into your network, it's a good idea to secure the box as
well as you possibly can. You can read up more on Linux security in the [/
HOWTO/Security-HOWTO.html] Linux Security HOWTO. In this case I killed
everything but sshd and a Roxen Web server. I use the web server to download
a couple of files (my scripts, etc) for setting up new machines to access the
VPN. I don't use an FTP server since it's harder to configure one to be
secure than it is to just make a few files available with a web server. Plus,
I only need to be able to download files. If you really want to run different
servers on your gateway, you might want to think about restricting access to
them to only those machines on your private network.
-----------------------------------------------------------------------------

3.1.2. Don't allow passwords

 Yes, it sounds kind of silly, but it got your attention, didn't it? No, you
don't use passwords, you disable them completely. All authentication on this
machine should be done via ssh's public key authentication system. This way,
only those with keys can get in, and it's pretty much impossible to remember
a binary key that's 530 characters long.

 So how do you do that? It requires editing the /etc/passwd file. The second
field contains either the password hash, or alternatively 'x' telling the
authentication system to look in the /etc/shadow file. What you do is change
that field to read "*" instead. This tells the authentication system that
there is no password, and that none should be allowed.

Here's how a typical /etc/passwd file looks:
...                                                                          
nobody:x:65534:100:nobody:/dev/null:                                         
mwilson:x:1000:100:Matthew Wilson,,,:/home/mwilson:/bin/bash                 
joe:*:504:101:Joe Mode (home),,,:/home/vpn-users:/usr/sbin/pppd              
bill:*:504:101:Bill Smith (home),,,:/home/vpn-users:/usr/sbin/pppd           
frank:*:504:101:Frank Jones (home),,,:/home/vpn-users:/usr/sbin/pppd         
...                                                                          

 Note that I've done more than just editing the second field. I'll explain
the other fields later on.
-----------------------------------------------------------------------------

3.2. User Access - letting people in

 User access is done via ssh's authentication scheme. As stated above, this
is how users get access to the system, while maintaining a high level of
security. If you're not familiar with ssh, check out [http://www.ssh.org/]
http://www.ssh.org/. Note that I am using ssh version 1, not version 2. There
is a big difference, notably that version 1 is free, and 2 isn't.
-----------------------------------------------------------------------------

3.2.1. Configuring sshd

 You'll need to configure sshd. The idea is to disable password
authentication and rhosts authentication. The following options should be
present in your /etc/sshd_config file.
PermitRootLogin yes                                                          
IgnoreRhosts yes                                                             
StrictModes yes                                                              
QuietMode no                                                                 
CheckMail no                                                                 
IdleTimeout 3d                                                               
X11Forwarding no                                                             
PrintMotd no                                                                 
KeepAlive yes                                                                
RhostsAuthentication no                                                      
RhostsRSAAuthentication no                                                   
RSAAuthentication yes                                                        
PasswordAuthentication no                                                    
PermitEmptyPasswords no                                                      
UseLogin no                                                                  
-----------------------------------------------------------------------------

3.3. Restricting Users

 Now that you're keeping the bad people out, and only letting the good people
in, you may need to make sure that the good people behave themselves. This is
most easily done by not letting them do anything except run pppd. This may or
may not be necessary. I restrict users because the system that I maintain is
dedicated to VPN, so users have no business doing anything else on it.
-----------------------------------------------------------------------------

3.3.1. sudo or not sudo

 There is this neat little program called sudo that allows the admin on a
Unix system to grant certain users the ability to run certain programs as
root. This is necessary in this case since pppd must be run as root. You'll
need to use this method if you want to allow users shell access. Read up on
how to setup and use sudo in the sudo man page. Using sudo is best on
multi-use systems that typically host a small number of trusted users.

 If you decide to not allow users to have shell access, then the best way to
keep them from gaining it is to make their shell pppd. This is done in the /
etc/passwd file. You can see /etc/passwd file that I did this for the last
three users. The last field of the /etc/passwd file is the user's shell. You
needn't do anything special to pppd in order to make it work. It gets
executed as root when the user connects. This is certainly the simplest setup
to be had, as well as the most secure, and ideal for large scale and
corporate systems. I describe exactly what all needs to be done later in this
document. You can Section 5.7 if you like.
-----------------------------------------------------------------------------

3.4. Networking

 Now that your users have access to the system, we need to make sure that
they have access to the network. We do that by using the Linux kernel's
firewalling rules and routing tables. Using the route and ipfwadm commands,
we can set up the kernel to handle network traffic in the appropriate ways.
For more info on ipfwadm, ipchains and route see the [http://www.tldp.org/
HOWTO/Linux-Networking-HOWTO.html] Linux Networking HOWTO.
-----------------------------------------------------------------------------

3.4.1. The Kernel

 In order for any of this to work, you must have your kernel configured
correctly. If you don't know how to build your own kernel, then you should
read the [http://www.tldp.org/HOWTO/Kernel-HOWTO.html]  Kernel HOWTO. You'll
need to make sure that the following kernel options are turned on in addition
to basic networking. I use a 2.0.38 kernel in my system.

 For 2.0 kernels:

  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_FORWARD
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_IP_MASQUERADE (optional)
   
  *  CONFIG_IP_MASQUERADE_ICMP (optional)
   
  *  CONFIG_PPP
   

 For 2.2 kernels:

  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_ADVANCED_ROUTER
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_IP_MASQUERADE (optional)
   
  *  CONFIG_IP_MASQUERADE_ICMP (optional)
   
  *  CONFIG_PPP
   

-----------------------------------------------------------------------------
3.4.2. Filter Rules

 First, we write firewall filter rules that allow our users to access our
internal nets, while restricting them from accessing the outside internet.
This sounds strange, but since the users already have access to the internet,
why let them use the tunnel to access the net? It wastes both bandwidth and
processor resources.

 The filter rules that we use depend upon which internal nets we use, but
translate to: "Allow traffic coming from our VPNs that is destined for our
internal nets to go there." So how do we do that? As always, it depends. If
you are running a 2.0 kernel, you use the tool called ipfwadm, but if you are
using a 2.2 kernel, you use the utility called ipchains.

 To set the rules with ipfwadm, run it with options similar to the following:
# /sbin/ipfwadm -F -f                                                        
# /sbin/ipfwadm -F -p deny                                                   
# /sbin/ipfwadm -F -a accept -S 192.168.13.0/24 -D 172.16.0.0/12             

 To set the rules with ipchains, run it with options similar to the
following:
# /sbin/ipchains -F forward                                                  
# /sbin/ipchains -P forward DENY                                             
# /sbin/ipchains -A forward -j ACCEPT -s 192.168.13.0/24 -d 172.16.0.0/12    

 For those using 2.2 kernels, please read Section 6.1.3.
-----------------------------------------------------------------------------

3.4.3. Routing

 Now that users are allowed to access our nets, we need to tell the kernel
where to send the packets. On my system, I have two ethernet cards, one is on
the external network, while the other is on the internal network. This helps
keep things secure, as outbound traffic is masqueraded by the gateway, and
any incoming traffic is filtered and routed by the Cisco Router. For most
setups, the routing should be simple.

 Next, route all traffic destined for the private networks out the internal
interface, and all other traffic out the external interface. The specific
routing commands depend on which internal nets you are using. Below is an
example of what they might look like. These lines are of course in addition
to your basic routes for your local nets. I also doubt that you are using all
3 groups of internal numbers:
Assuming that 172.16.254.254 is the internal gateway:                             
                                                                                  
# /sbin/route add -net 10.0.0.0 netmask 255.0.0.0 gw 172.16.254.254 dev eth1      
# /sbin/route add -net 172.16.0.0 netmask 255.240.0.0 gw 172.16.254.254 dev eth1  
# /sbin/route add -net 192.168.0.0 netmask 255.255.0.0 gw 172.16.254.254 dev eth1 

 One additional note on routing. If you are using two way routing for say, a
remote office, then you will need to do one more thing. You need to set up
routes on the server that point back to the client. The easiest way to
accomplish this is to run a cron job every minute that quietly sets back
routes. If the client is not connected, route will just spit out an error
(that you've conveniently sent to /dev/null.)
-----------------------------------------------------------------------------

Chapter 4. Client

 Now we examine the client end. In practice, when used to allow access to a
remote network, this box can easily serve as a Samba (Windows Networking)
server, DHCP server, and even an internal web server. The important thing to
remember is that this box should be as secure as possible, as it runs your
whole remote network.
-----------------------------------------------------------------------------

4.1. The Kernel

 First things first, you must have ppp available in your kernel. If you are
going to allow multiple machines to use the tunnel, then you need to have
firewalling and forwarding available too. If the client is going to be a
single machine, ppp is enough.
-----------------------------------------------------------------------------

4.2. Bring up the link

 The link is created by running pppd through a pseudo terminal that is
created by pty-redir and connected to ssh. This is done with something
similar to the following sequence of commands:
# /usr/sbin/pty-redir /usr/bin/ssh -t -e none -o 'Batchmode yes' -c blowfish -i /root/.ssh/identity.vpn -l joe > /tmp/vpn-device  
# sleep 10                                                                                                                        
                                                                                                                                  
# /usr/sbin/pppd `cat /tmp/vpn-device`                                                                                            
# sleep 15                                                                                                                        
                                                                                                                                  
# /sbin/route add -net 172.16.0.0 gw vpn-internal.mycompany.com netmask 255.240.0.0                                               
# /sbin/route add -net 192.168.0.0 gw vpn-internal.mycompany.com netmask 255.255.0.0                                              

 What this does is run ssh, redirecting the input and output to pppd. The
options passed to ssh configure it to run without escape characters (-e),
using the blowfish crypto algorithm (-c), using the identity file specified
(-i), in terminal mode (-t), with the options 'Batchmode yes' (-o). The sleep
commands are used to space out the executions of the commands so that each
can complete their startup before the next is run.
-----------------------------------------------------------------------------

4.3. Scripting

 If you don't want to have to type those commands in every time that you want
to get the tunnel running, I've written a set of bash scripts that keep the
tunnel up and running. You can download the package from [http://
www.shinythings.com/vpnd/vpnd.tar.gz] here. Just download and uncompress it
into /usr/local/vpn. Inside you'll find three files:

 

  *  vpnd: The script that controls the tunnel connection.
   
  *  check-vpnd: a script to be run by cron to check that vpnd is still up.
   
  *  pty-redir: a small executable needed to initialize the tunnel.
   

 You'll need to edit the vpnd script to set things like the client's username
and the server's names. You may also need to modify the starttunnel section
of the script to specify which networks you are using. Below is a copy of the
script for your reading enjoyment. You'll note that you could put the script
in a different directory, you just need to change the VPN_DIR variable.
#! /bin/bash                                                                                              
#                                                                                                         
# vpnd: Monitor the tunnel, bring it up and down as necessary                                             
#                                                                                                         
                                                                                                          
USERNAME=vpn-username                                                                                     
IDENTITY=/root/.ssh/identity.vpn                                                                          
                                                                                                          
VPN_DIR=/usr/local/vpn                                                                                    
LOCK_DIR=/var/run                                                                                         
VPN_EXTERNAL=vpn.mycompany.com                                                                            
VPN_INTERNAL=vpn-internal.mycompany.com                                                                   
PTY_REDIR=${VPN_DIR}/pty-redir                                                                            
SSH=${VPN_DIR}/${VPN_EXTERNAL}                                                                            
PPPD=/usr/sbin/pppd                                                                                       
ROUTE=/sbin/route                                                                                         
CRYPTO=blowfish                                                                                           
PPP_OPTIONS="noipdefault ipcp-accept-local ipcp-accept-remote local noauth nocrtscts lock nodefaultroute" 
ORIG_SSH=/usr/bin/ssh                                                                                     
                                                                                                          
                                                                                                          
starttunnel () {                                                                                          
   $PTY_REDIR $SSH -t -e none -o 'Batchmode yes' -c $CRYPTO -i $IDENTITY -l $USERNAME > /tmp/vpn-device   
   sleep 15                                                                                               
                                                                                                          
   $PPPD `cat /tmp/vpn-device` $PPP_OPTIONS                                                               
   sleep 15                                                                                               
                                                                                                          
   # Add routes (modify these lines as necessary)                                                         
   /sbin/route add -net 10.0.0.0 gw $VPN_INTERNAL netmask 255.0.0.0                                       
   /sbin/route add -net 172.16.0.0 gw $VPN_INTERNAL netmask 255.240.0.0                                   
   /sbin/route add -net 192.168.0.0 gw $VPN_INTERNAL netmask 255.255.0.0                                  
}                                                                                                         
                                                                                                          
stoptunnel () {                                                                                           
   kill `ps ax | grep $SSH | grep -v grep | awk '{print $1}'`                                             
}                                                                                                         
                                                                                                          
resettunnel () {                                                                                          
   echo "reseting tunnel."                                                                                
   date >> ${VPN_DIR}/restart.log                                                                         
   eval stoptunnel                                                                                        
   sleep 5                                                                                                
   eval starttunnel                                                                                       
}                                                                                                         
                                                                                                          
checktunnel () {                                                                                          
   ping -c 4 $VPN_EXTERNAL 2>/dev/null 1>/dev/null                                                        
                                                                                                          
   if [ $? -eq 0 ]; then                                                                                  
      ping -c 4 $VPN_INTERNAL 2>/dev/null 1>/dev/null                                                     
      if [ $? -ne 0 ]; then                                                                               
         eval resettunnel                                                                                 
      fi                                                                                                  
   fi                                                                                                     
}                                                                                                         
                                                                                                          
settraps () {                                                                                             
   trap "eval stoptunnel; exit 0" INT TERM                                                                
   trap "eval resettunnel" HUP                                                                            
   trap "eval checktunnel" USR1                                                                           
}                                                                                                         
                                                                                                          
runchecks () {                                                                                            
   if [ -f ${LOCK_DIR}/tunnel.pid ]; then                                                                 
      OLD_PID=`cat ${LOCK_DIR}/vpnd.pid`                                                                  
      if [ -d /proc/${OLD_PID} ]; then                                                                    
         echo "vpnd is already running on process ${OLD_PID}."                                            
         exit 1                                                                                           
      else                                                                                                
         echo "removing stale pid file."                                                                  
         rm -rf ${LOCK_DIR}/vpnd.pid                                                                      
         echo $$ > ${LOCK_DIR}/vpnd.pid                                                                   
         echo "checking tunnel state."                                                                    
         eval checktunnel                                                                                 
      fi                                                                                                  
   else                                                                                                   
      echo $$ > ${LOCK_DIR}/vpnd.pid                                                                      
      eval starttunnel                                                                                    
   fi                                                                                                     
}                                                                                                         
                                                                                                          
case $1 in                                                                                                
    check)  if [ -d /proc/`cat ${LOCK_DIR}/vpnd.pid` ]; then                                              
               kill -USR1 `cat ${LOCK_DIR}/vpnd.pid`                                                      
               exit 0                                                                                     
            else                                                                                          
               echo "vpnd is not running."                                                                
               exit 1                                                                                     
            fi ;;                                                                                         
                                                                                                          
    reset)  if [ -d /proc/`cat ${LOCK_DIR}/vpnd.pid` ]; then                                              
               kill -HUP `cat ${LOCK_DIR}/vpnd.pid`                                                       
               exit 0                                                                                     
            else                                                                                          
               echo "vpnd is not running."                                                                
               exit 1                                                                                     
            fi ;;                                                                                         
                                                                                                          
   --help | -h)                                                                                           
            echo "Usage: vpnd [ check | reset ]"                                                          
            echo "Options:"                                                                               
            echo "     check    Sends running vpnd a USR1 signal, telling it to check"                    
            echo "              the tunnel state, and restart if neccesary."                              
            echo "     reset    Sends running vpnd a HUP signal, telling it to reset"                     
            echo "              it's tunnel connection." ;;                                               
esac                                                                                                      
                                                                                                          
ln -sf $ORIG_SSH $SSH                                                                                     
settraps                                                                                                  
runchecks                                                                                                 
                                                                                                          
while true; do                                                                                            
   i=0                                                                                                    
   while [ $i -lt 600 ]; do                                                                               
      i=((i+1))                                                                                           
      sleep 1                                                                                             
   done                                                                                                   
   eval checktunnel                                                                                       
done                                                                                                      
                                                                                                          
-----------------------------------------------------------------------------

4.4. LRP - Linux Router Project

 I actually run this setup on Pentium 90's running the LRP distribution of
Linux. LRP is a distribution of Linux that fits in, and boots off of a single
floppy disk. You can learn more about it at [http://www.linuxrouter.org/]
http://www.linuxrouter.org/ You can download my LRP package for the VPN
client from [http://www.shinythings.com/vpnd/vpnd.lrp] here. You will also
need both the ppp and ssh packages from the LRP site.
-----------------------------------------------------------------------------

Chapter 5. Implementation

 In this section, I explain step by step how to set up your VPN system. I'll
start with the server, and then move on to the client. For the purposes of an
example, I will invent a situation that would require a couple of different
kinds of VPN set up.
-----------------------------------------------------------------------------

5.1. Planning

 Let's imagine that we have a company, called mycompany.com. At our head
office, we are using the 192.168.0.0 reserved network, breaking the class B
into 256 class C networks to allow routing. We have just set up two small
remote offices, and want to add them to our network. We also want to allow
employees who work from home to be able to use their DSL and cable modem
connections instead of making them use dialup. To start, we need to plan
things out a little.

 I decide that I want to give each remote office a class C network range to
allow them to expand as necessary. So, I reserve the 192.168.10.0 and
192.168.11.0 nets. I also decide that for home users, I've got enough numbers
that I don't need to masquerade them on the VPN server side. Each client gets
it's own internal IP. So, I need to reserve another class C for that, say
192.168.40.0. The only thing that I must now do is to add these ranges to my
router. Let's imagine that our company owns a small Cisco (192.168.254.254)
that handles all of the traffic through our OC1. Just set routes on the Cisco
such that traffic headed to these reserved nets goes to our VPN server
(192.168.40.254). I put the VPN server into the home user's net for reasons
that should become clear later. We'll name the external interface of the
server vpn.mycompany.com, and the internal vpn-internal.mycompany.com.

 As for external numbers, we don't need to know them explicitly. You should
have your own numbers, supplied by your ISP.
-----------------------------------------------------------------------------

5.2. Gather the tools

 We will need a few pieces of software. Get the following packages, and
install them where specified.
-----------------------------------------------------------------------------

5.2.1. For the Server:

 

  *  pppd (version 2.3 or greater)
   
  *  ssh (version 1.2.26 or better)
   

-----------------------------------------------------------------------------
5.2.2. For the Client:

 

  *  pppd (same version as server)
   
  *  ssh
   
  *  [ftp://ftp.vein.hu/ssa/contrib/mag/pty-redir-0.1.tar.gz] pty-redir
   

-----------------------------------------------------------------------------
5.3. Server: Build the kernel

 To start, you probably need to rebuild your kernel for the server. You need
to make sure that the following kernel options are turned on in addition to
basic networking and everything else that you might need. If you've never
built your own kernel before, read the [/HOWTO/Kernel-HOWTO.html] Kernel
HOWTO.

 For 2.0 kernels:

  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_FORWARD
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_PPP
   

 For 2.2 kernels:

  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_ADVANCED_ROUTER
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_PPP
   

-----------------------------------------------------------------------------
5.4. Server: Configure Networking

 If you are building a server that has only one network card, I suggest that
you think about buying another, and rewiring your network. The best way to
keep your network private is to keep it on it's own wires. So if you do have
two network cards, you'll need to know how to configure both of them. We'll
use eth0 for the external interface, and eth1 for the internal interface.
-----------------------------------------------------------------------------

5.4.1. Configuring the interfaces

 We first should configure the external interface of the server. You should
already know how to do this, and probably already have it done. If you don't,
then do so now. If you don't know how, go back and read the [/HOWTO/
NET3-4-HOWTO.html] Networking HOWTO

 Now we bring up the internal interface. According to the numbers that we've
chosen, the internal interface of the server is 192.168.40.254. so we have to
configure that interface.

 For 2.0 kernels, use the following:
# /sbin/ifconfig eth1 192.168.40.254 netmask 255.255.255.0 broadcast 192.168.40.255  
# /sbin/route add -net 192.168.40.0 netmask 255.255.255.0 dev eth1                   

 For 2.2 kernels, use the following:
# /sbin/ifconfig eth1 192.168.40.254 netmask 255.255.255.0 broadcast 192.168.40.255  

 That gets our basic interfaces up. You can now talk to machines on both
local networks that are attached to the server.
-----------------------------------------------------------------------------

5.4.2. Setting routes

 We can now talk to machines on our local nets, but we can't get to the rest
of our internal network. That requires a few more lines of code. In order to
reach the other machines on other subnets, we need have a route that tells
traffic to go to the Cisco router. Here's that line:
# /sbin/route add -net 192.168.0.0 gw 192.168.254.254 netmask 255.255.0.0 dev eth1  

 That line tells the kernel that any traffic destined for the 192.168.0.0
network should go out eth1, and that it should be handed off to the Cisco.
Traffic for our local net still gets where it is supposed to because the
routing tables are ordered by the size of the netmask. If we were to have
other internal nets in our network, we would have a line like the above for
each net.
-----------------------------------------------------------------------------

5.4.3. Making filter rules

 Now that we can reach every machine that we could need to, we need to write
the firewall filtering rules that allow or deny access through the VPN
server.

 To set the rules with ipfwadm, run it like so:
# /sbin/ipfwadm -F -f                                                        
# /sbin/ipfwadm -F -p deny                                                   
# /sbin/ipfwadm -F -a accept -S 192.168.40.0/24 -D 192.168.0.0/16            
# /sbin/ipfwadm -F -a accept -b -S 192.168.10.0/24 -D 192.168.0.0/16         
# /sbin/ipfwadm -F -a accept -b -S 192.168.11.0/24 -D 192.168.0.0/16         

 To set the rules with ipchains, run it like so:
# /sbin/ipchains -F forward                                                   
# /sbin/ipchains -P forward DENY                                              
# /sbin/ipchains -A forward -j ACCEPT -s 192.168.40.0/24 -d 192.168.0.0/16    
# /sbin/ipchains -A forward -j ACCEPT -b -s 192.168.10.0/24 -d 192.168.0.0/16 
# /sbin/ipchains -A forward -j ACCEPT -b -s 192.168.11.0/24 -d 192.168.0.0/16 

 This tells the kernel to deny all traffic except for the traffic that is
coming from the 192.168.40.0/24 network and destined for the 192.168.0.0/16
network. It also tells the kernel that traffic going between the 192.168.10.0
/24 and 192.168.0.0/16 nets is allowed, and the same for the 192.168.11.0
net. These last two are bidirectional rules, this is important for getting
the routing to work going both ways.
-----------------------------------------------------------------------------

5.4.4. Routing

 For home users, everything will work fine to here. However for the remote
offices, we need to do some routing. First of all, we need to tell the main
router, or Cisco, that the remote offices are behind the VPN server. So
specify routes on the Cisco that tell it to send traffic destined for the
remote offices to the VPN server. Now that that is taken care of, we must
tell the VPN server what to do with the traffic destined for the remote
offices. To do this, we run the route command on the server. The only problem
is that in order for the route command to work, the link must be up, and if
it goes down, the route will be lost. The solution is to add the routes when
the clients connects, or more simply, to run the route command frequently as
it's not a problem to run it more than is necessary. So, create a script and
add it to your crontab to be run every few minutes, in the script, put the
following:
/sbin/route add -net 192.168.11.0 gw 192.168.10.253 netmask 255.255.255.0    
/sbin/route add -net 192.168.10.0 gw 192.168.11.253 netmask 255.255.255.0    
-----------------------------------------------------------------------------

5.5. Server: Configure pppd

 Now we will configure pppd on the server to handle VPN connections. If you
are already using this server to handle dialup users or even dialing out
yourself, then you should note that these changes may affect those services.
I go over how to avoid conflicts at the end of this section.
-----------------------------------------------------------------------------

5.5.1. /etc/ppp/

 This directory may contain a number of files. You probably already have a
file called options. This file holds all of the global options for pppd.
These options cannot be overridden by pppd on the command line.
-----------------------------------------------------------------------------

5.5.2. /etc/ppp/options

 Your options file should contain at least the following:
ipcp-accept-local                                                            
ipcp-accept-remote                                                           
proxyarp                                                                     
noauth                                                                       

 The first two lines tell pppd to accept what the other end specifies for IP
addresses. This is necessary when hooking up remote offices, but can be
disabled if you are only connecting home users. It's okay to leave it on, as
it does not prevent the server from assigning addresses, it only says it that
it's okay to accept what the client asks for.

 The third line is very important. From the pppd man page:
proxyarp                                                                     
       Add an entry to this system's ARP [Address  Resolu-                   
       tion  Protocol]  table  with  the IP address of the                   
       peer and the Ethernet address of this system.  This                   
       will  have  the effect of making the peer appear to                   
       other systems to be on the local ethernet.                            

 This is important because if it is not done, local traffic will not be able
to get back through the tunnel.

 The last line is just as important. This tells pppd to allow connections
without username and password. This is safe since authentication is already
handled by sshd.
-----------------------------------------------------------------------------

5.5.3. Avoiding conflicts

 If you are handling other services with pppd, you should consider that the
configurations for these other services may not be the same as what the VPN
system needs. pppd is designed such that the options in the main options file
/etc/ppp/options cannot be overridden by options specified at runtime. This
is done for security reasons. In order to avoid conflict, determine which
options cause the conflict, and move them from the main file into a separate
options file that is loaded when the appropriate application of pppd is run.
-----------------------------------------------------------------------------

5.6. Server: Configure sshd

 The following is what my /etc/sshd_config file looks like. Yours should look
the same or similar:
# This is the ssh server system wide configuration file.                     
                                                                             
Port 22                                                                      
ListenAddress 0.0.0.0                                                        
HostKey /etc/ssh_host_key                                                    
RandomSeed /etc/ssh_random_seed                                              
ServerKeyBits 768                                                            
LoginGraceTime 600                                                           
KeyRegenerationInterval 3600                                                 
PermitRootLogin yes                                                          
IgnoreRhosts yes                                                             
StrictModes yes                                                              
QuietMode no                                                                 
FascistLogging yes                                                           
CheckMail no                                                                 
IdleTimeout 3d                                                               
X11Forwarding no                                                             
PrintMotd no                                                                 
KeepAlive yes                                                                
SyslogFacility DAEMON                                                        
RhostsAuthentication no                                                      
RhostsRSAAuthentication no                                                   
RSAAuthentication yes                                                        
PasswordAuthentication no                                                    
PermitEmptyPasswords no                                                      
UseLogin no                                                                  

 The important points to note are that password authentication is disabled as
are all of the "R" services. I have also turned off mail checking and the
message of the day as they can confuse pppd on the client side. I still allow
root login, but as this can only be done with a key, it is adequately safe.
-----------------------------------------------------------------------------

5.7. Server: Set up user accounts

 Now we'll set up the user accounts.
-----------------------------------------------------------------------------

5.8. Add vpn-users group

 just run:
# /usr/sbin/groupadd vpn-users                                               

 Now cat the /etc/group file and look at the last line. It should be the
entry for the vpn-users group. Note the third field. This is the group ID
(GID). Write it down, as we'll need it in a minute. For this example, the GID
is 101.
-----------------------------------------------------------------------------

5.9. create the vpn-users home directory

 We're going to use a single home directory for all of the users. So just
run:
# mkdir /home/vpn-users                                                      
-----------------------------------------------------------------------------

5.10. The .ssh directory

 Now create the .ssh directory in the vpn-users home directory.
# mkdir /home/vpn-users/.ssh                                                 
-----------------------------------------------------------------------------

5.11. Adding users

 Now comes the fun part. We're going to edit the /etc/passwd file by hand.
Normally you let the system handle this file, but for an unusual setup like
this, it is easier to do it yourself. To start, open the /etc/passwd file and
see what's in there. Here's an example of what you might find:
...                                                                          
nobody:x:65534:100:nobody:/dev/null:                                         
mwilson:x:1000:100:Matthew Wilson,,,:/home/mwilson:/bin/bash                 
joe:*:1020:101:Joe Mode (home),,,:/home/vpn-users:/usr/sbin/pppd             
bill:*:1020:101:Bill Smith (home),,,:/home/vpn-users:/usr/sbin/pppd          
frank:*:1020:101:Frank Jones (home),,,:/home/vpn-users:/usr/sbin/pppd        
...                                                                          

 You'll find the first user on most any system. The second one is me. After
that are a few made up vpn-users. The first field is the username, and the
second is the password field. The third is user ID (UID) and the fourth is
the group ID (GID). After that comes some info on who the people are in the
fifth field. The sixth field is the user's home directory, and the last is
their shell. As you can see, each field is separated by a colon. Look at the
last three lines. The only difference between them is the username in the
first field, and the user info in the fifth field. What we want to do is
create lines like this for each user. Don't just use one user for all of the
connections, you'll never be able to tell them apart if you do. So copy the
last line of this file and edit it so that it looks something like the above.
Make sure that the second field has an asterisk (*). The second field should
be unique to all the other IDs in the file. I used 1020. You should use a
number above 1000, since those below are typically reserved for system use.
The fourth field should be the group ID for vpn-users. I told you to write it
down, now is the time that you need it. So put the group ID in there. Lastly,
change the home directory to /home/vpn-users, and the shell to /usr/sbin/
pppd. Now copy that line to make more users. Just edit the first the fifth
fields and you're set.
-----------------------------------------------------------------------------

5.12. Server: Administration

 One of the advantages to using this system for user accounts is that you can
take advantage of the UNIX user administration commands. Since each client is
logged in as a user, you can use standard methods to get user statistics. The
following are a few commands that I like to use to see what all is going on.

 

who
     Prints the users currently logged in, as well as when they logged in,
    from where (name or IP), and on which port.
   
w
     This command prints a more extensive listing of who is currently logged
    in. It also tells you uptime and load averages for the system. It also
    lists the user's current process (which should be -pppd for VPN clients)
    as well as idle time, and current CPU usage for all processes as well as
    the current process. Read the w man page for more info.
   
last [username]
     This lists the login history for the specified user, or for all users if
    a username is not provided. It's most useful for finding out how well the
    tunnels are running as it prints the length of time that the user was
    logged in, or states that the user is still logged in. I should warn you
    that on a system that has been up a long time, this list can grow
    extremely long. Pipe is through grep or head to find out exactly what you
    want to know.
   

 You can also control which users are allowed to connect by modifying the /
home/vpn-users/.ssh/authorized_keys file. If you remove the user's public key
line from this file, they won't be able to log in.
-----------------------------------------------------------------------------

5.13. Client: Build the kernel

 Now we move onto the client. First we must rebuild the kernel so that it can
support all of the functions that we need. The minimum requirement is to have
ppp in the kernel. You will need forwarding, a firewall, and a gateway only
if you are going to allow other machines access to the tunnel. For this
example, I will setup one of the remote office machines in my example layout.
Add the following options to your kernel. Again, if you've never built a
kernel before, read the [/HOWTO/Kernel-HOWTO.html] Kernel HOWTO.

 For 2.0 kernels:

  *  CONFIG_PPP
   
  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_FORWARD
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_IP_MASQUERADE
   
  *  CONFIG_IP_MASQUERADE_ICMP
   

 For 2.2 kernels:

  *  CONFIG_PPP
   
  *  CONFIG_FIREWALL
   
  *  CONFIG_IP_ADVANCED_ROUTER
   
  *  CONFIG_IP_FIREWALL
   
  *  CONFIG_IP_ROUTER
   
  *  CONFIG_IP_MASQUERADE
   
  *  CONFIG_IP_MASQUERADE_ICMP
   

-----------------------------------------------------------------------------
5.14. Client: Configure Networking

 Now we should setup the networking on our client box. Let's assume that
we've configured the external network and that it works. Now we will
configure the internal interface of the client to service our intranet.
-----------------------------------------------------------------------------

5.14.1. Interface

 We need to first bring up the internal network interface. To do this, add
the following to your /etc/rc.d/rc.inet1 (or equivalent) file:

 For 2.0 Kernels:
/sbin/ifconfig eth1 192.168.10.253 broadcast 192.168.10.255 netmask 255.255.255.0  
/sbin/route add -net 192.168.10.0 netmask 255.255.255.0 dev eth1                   

 For 2.2 Kernels:
/sbin/ifconfig eth1 192.168.10.253 broadcast 192.168.10.255 netmask 255.255.255.0  
-----------------------------------------------------------------------------

5.14.2. Filter rules

 To set up the remote office, we will want to set up our filter rules that
allow traffic to go both directions through the tunnel. Add the following
lines to your /etc/rc.d/rc.inet1 (or equivalent) file:

 For 2.0 kernels:
/sbin/ipfwadm -F -f                                                          
/sbin/ipfwadm -F -p deny                                                     
/sbin/ipfwadm -F -a accept -b -S 192.168.10.0/24 -D 192.168.0.0/16           

 For 2.2 kernels:
/sbin/ipchains -F forward                                                    
/sbin/ipchains -P forward DENY                                               
/sbin/ipchains -A forward -j ACCEPT -b -s 192.168.10.0/24 -d 192.168.0.0/16  

 You may have noticed that these lines look like what we have on the server.
That's because they are the same. These rules just say where traffic is
allowed to go between these two networks.
-----------------------------------------------------------------------------

5.14.3. Routing

 The only extra routes that are needed are created by the script that bring
the tunnel up.
-----------------------------------------------------------------------------

5.15. Client: Configure pppd

 You may not need to edit the client's /etc/ppp/options file at all. You will
if the "auth" option is present, or some of the other priveledged options.
Try it, and if it fails, a black /etc/ppp/options will work. just keep adding
the options from the old file to figure out which one broke it (if it's not
obvious) and see if you can get around that. Maybe you don't need them at
all. You probably don't if you don't use pppd for anything else.
-----------------------------------------------------------------------------

5.16. Client: Configure ssh

 As root on the client, run the following lines:
# mkdir /root/.ssh                                                           
# ssh-keygen -f /root/.ssh/identity.vpn -P ""                                

 This will create two files, identity.vpn and identity.vpn.pub in the .ssh
directory. The first is your private key, and should be kept such. Never send
this over the net unless it is via an encrypted session. The second file is
your public key, and you can send this anywhere you want, it only serves to
allow you access to other systems, and cannot be used to get into your own.
It is a text file with one line in it that is your actual key. At the end of
the line is the comment field which you may change without fear of breaking
the key. an example key looks something like this:
1024 35 1430723736674162619588314275167.......250872101150654839 root@vpn-client.mycompany.com  

 It's actually a lot longer than that, but it wouldn't fit on the page if I
showed the whole thing. Copy your key into the /home/vpn-users/.ssh/
authorized_keys file on the server. Make sure that there is only one key per
line, and that each key is not broken onto multiple lines. You may alter the
comment field all that you like in order to help you remember which line goes
with which user. I highly recommend doing so.
-----------------------------------------------------------------------------

5.17. Client: Bring up the connection

 Now we'll try to actually make the connection to the VPN server. First we'll
need to make a single connection to set up the ssh known_hosts file. Run
this:
# ssh vpn.mycompany.com                                                      

 Answer "yes" when it asks you if you want to continue connecting. The server
will tell you "permission denied", but that's okay. It's important that you
use the same name for the server that you are using in your connection
scripts. Now run the following lines. You will obviously need to change the
options to suit your setup.
# /usr/sbin/pty-redir /usr/bin/ssh -t -e none -o 'Batchmode yes' -c blowfish -i /root/.ssh/identity.vpn -l vpn-user vpn.mycompany.com > /tmp/vpn-device  
                                                                                                                                                         
        (now wait about 10 seconds)                                                                                                                      
                                                                                                                                                         
# /usr/sbin/pppd `cat /tmp/vpn-device` 192.168.10.254:192.168.40.254                                                                                     

 Note the IP addresses specified on the pppd line. The first is the address
of the client end of the tunnel. The second is the address of the server end
of the tunnel, which is set to the server's internal address. If all of that
seemed to work, move on. If not, check that you have all of the options, and
that they are spelled right. If something is still going wrong, check Section
6.1.
-----------------------------------------------------------------------------

5.18. Client: Set the routes

 Now set the route to send traffic through the tunnel. Just run this:
# /sbin/route add -net 192.168.0.0 gw vpn-internal.mycompany.com netmask 255.255.0.0  

 You should now be able to communicate with machines on the other side of the
tunnel. Give it a try. If it doesn't work, try using ping and traceroute to
figure out where your problem might be. If in fact it does work, move on to
setting up scripts to do the work for you.
-----------------------------------------------------------------------------

5.19. Client: Scripting

 Use the vpnd script. Only you may need to modify it a little. Make the
following changes:

 

  *  Change the variables at the top to match your setup. Most should be just
    fine as they are, but you can change them should you need to.
   
  *  Line 27: add the local and remote IP addresses before $PPP_OPTIONS
   
  *  Line 31: Change this line, and the two after it to set routes for your
    internal nets.
   

-----------------------------------------------------------------------------
5.19.1. Keeping it running

 While bash scripts are generally stable, they have been known to fail. In
order to make sure that the vpnd script keeps running, add an entry to the
client's crontab that runs the check-vpnd script. I run mine every 5 minutes
or so. If vpnd is indeed running, check-vpnd doesn't use much CPU.
-----------------------------------------------------------------------------

Chapter 6. Addenda

6.1. Pitfalls

 Here are just a few of the snags that I've run into while using this system.
I put them here so that you can hopefully avoid them. If you run into any new
ones, please [mailto:matthew@shinythings.com]  email them to me so that I can
keep track, and help others avoid them.
-----------------------------------------------------------------------------

6.1.1. read: I/O error

 This error is associated with mis-matched versions off pppd. If you get it,
try upgrading both ends of the connection to the latest version of pppd. I've
found that pppd version 2.2 has this problem, so use version 2.3.7 or 2.3.8
instead.
-----------------------------------------------------------------------------

6.1.2. SIOCADDRT: Network is unreachable

 This error is generated by route. I've seen it happen when the sleep time
between ssh and ppd is not long enough. If you get this error, run ifconfig,
and you may see that there is no pppX interface. This means that ssh was not
done authenticating before pppd was launched, and therefore pppd did not make
the connection. just increase the delay, and your problems will be solved.

 I wonder however if there might be some pppd option that will fix this
problem.
-----------------------------------------------------------------------------

6.1.3. IPv4 Forwarding and 2.2 kernels

 In the new 2.2 kernel, you must specifically enable IP forwarding in the
kernel at boot up. This with the following command:
# echo 1 > /proc/sys/net/ipv4/ip_forward                                     

 Without this, the kernel will not forward any packets, and hence the server
will not work, nor will any of the gatewaying clients.
-----------------------------------------------------------------------------

6.1.4. Routing

 It should go without saying, but be careful when you are routing real
numbers that you don't route traffic destined for the VPN server's external
address through the tunnel. It won't make it. (yes, this is from personal
experience.)
-----------------------------------------------------------------------------

6.2. Hardware and Software Requirements

6.2.1. Minimum Hardware Requirements

 This system has been run on a 486SX33 with 8 megabytes of RAM. It didn't run
very well though, it had trouble handling heavy traffic.

 It doesn't take much more to make it work though. This system does work very
well on a Pentium 75 with 16 megs of RAM, using an LRP distribution running
off of a floppy, with a 6 meg ramdisk, and 10 megs of main memory. I've
tested this setup by running a 700kbit RealVideo stream through it for over
an hour.

 I now typically run it on Pentium 90s, as their PCI clocking plays nicer
with cheap 100Mbit Ethernet cards.
-----------------------------------------------------------------------------

6.2.2. Software Requirements

 This system works with both the 2.0 and 2.2 kernels. The script to keep the
tunnel up requires a reasonably modern bash. I have however noticed that
certain distribution's versions of bash don't play too well with the script.

 Also, if someone could help me refine my scripts (or even write an
executable) that would help a lot. I'm not sure why, but even my own bash
doesn't follow the rules and doesn't seem to interpret signals correctly. If
you do make any improvements, please email me at [mailto:
matthew@shinythings.com] matthew@shinythings.com.


  Linux VPN Masquerade HOWTO
  John D. Hardin <jhardin@wolfenet.com>
  $Revision$ $Date$

  How to configure a Linux firewall to masquerade IPsec- and PPTP-based
  Virtual Private Network traffic, allowing you to establish a VPN con­
  nection without losing the security and flexibility of your Linux
  firewall's internet connection and allowing you to make available a
  VPN server that does not have a registered internet IP address.  Brief
  information on configuring the VPN client and server is also given.
  ______________________________________________________________________

  Table of Contents



  1. Introduction

     1.1 Introduction
     1.2 Feedback, Credits & Resources
     1.3 Copyright & Disclaimer

  2. Background Knowledge

     2.1 What is a VPN?
     2.2 What is IPsec?
     2.3 What is PPTP?
     2.4 What is FWZ?
     2.5 Why masquerade a VPN client?
     2.6 Can several clients on my local network use IPsec simultaneously?
     2.7 Can several clients on my local network use PPTP simultaneously?
     2.8 Can I access the remote network from my entire local network?
     2.9 Why masquerade the VPN server?
     2.10 Why patch the Linux kernel?
     2.11 Current Status

  3. Configuring the Linux firewall

     3.1 Example network
     3.2 Determining what needs to be done on the firewall
     3.3 Patching and configuring the 2.0.x kernel for VPN Masquerade support
     3.4 Patching and configuring the 2.2.x kernel for VPN Masquerade support
     3.5 ipfwadm setup for a Private-IP VPN Client or Server
     3.6 ipchains setup for a Private-IP VPN Client or Server
     3.7 A note about dynamic IP addressing
     3.8 Additional setup for a Private-IP VPN Server
     3.9 ipfwadm setup for a Registered-IP VPN Server
     3.10 ipfwadm setup for a Registered-IP VPN Client
     3.11 ipchains setup for a Registered-IP VPN Server
     3.12 ipchains setup for a Registered-IP VPN Client
     3.13 VPN Masq and LRP
     3.14 VPN Masq on a system running FreeS/WAN or PoPToP

  4. Configuring the VPN client

     4.1 Configuring a MS W'95 client
     4.2 Configuring a MS W'98 client
     4.3 Configuring a MS W'ME client
     4.4 Configuring a MS NT client
     4.5 Configuring for network-to-network routing
     4.6 Masquerading Checkpoint SecuRemote-based VPNs

  5. Troubleshooting

     5.1 Testing
     5.2 Possible problems
     5.3 Troubleshooting
     5.4 MS PPTP Clients and domain-name issues
     5.5 MS PPTP Clients and Novell IPX
     5.6 MS network password issues
     5.7 If your IPsec session always dies after a certain amount of time
     5.8 If VPN masquerade fails to work after you reboot
     5.9 If your second PPTP session kills your first session

  6. IPsec masquerade technical notes and special security considerations

     6.1 Limitations and weaknesses of IPsec masquerade
     6.2 Proper routing of inbound encrypted traffic


  ______________________________________________________________________

  1.  Introduction



  1.1.  Introduction

  This document describes how to configure masquerading of IPsec and
  PPTP VPN traffic. SSH-based VPNs (such as that sold by F-Secure and
  outlined in the VPN mini-HOWTO) are based on standard TCP traffic and
  do not need any special kernel modifications.


  VPN Masquerade allows you to establish one or more IPsec and/or PPTP
  sessions to internet-accessible VPN servers via your Linux internet
  firewall without forcing you to connect to your ISP directly from the
  VPN client system - thus retaining all of the benefits of your Linux
  internet firewall. It also allows you to set up a VPN server with a
  Private Network IP address (as described in RFC1918) behind a
  masquerading Linux firewall, permitting you to provide relatively
  secure access to a private network via only one registered IP address
  - even if that IP address represents a dynamic dial-up link.

  It is strongly recommended that you understand, configure and test
  regular IP Masquerading before you attempt to set up VPN masquerading.
  Please see the IP Masquerade HOWTO and the IP Masquerade Resource page
  at <http://ipmasq.cjb.net/> before proceeding. Planning and setting up
  your VPN and firewall is beyond the scope of this document. Here are
  some resources:

  ·  <http://www.linux.org/help/ldp/howto/Firewall-HOWTO.html>

  ·  <http://hal2000.hal.vein.hu/~mag/linux-security/VPN-HOWTO.html>

  The patch for the 2.0.x-series kernels works well on Linux kernel
  version 2.0.36, has been incorporated into the 2.0.37 release, may
  work on versions earlier than 2.0.36, and should work on Linux kernels
  up to about version 2.1.102. The IP masquerade code in the kernel was
  restructured at about version 2.1.103, requiring a different patch for
  the 2.1.105+ and 2.2.x series of kernels. A patch is available for
  kernels from 2.2.5 to 2.2.17, and it may work on earlier kernels.



  1.2.  Feedback, Credits & Resources

  The home page for the Linux VPN Masquerade kernel patches is
  <http://www.impsec.org/linux/masquerade/ip_masq_vpn.html>

  Please feel free to send any feedback or comments regarding this
  document to me at <jhardin@wolfenet.com>. The current version can be
  found at:

  ·  HTML:  <ftp://ftp.rubyriver.com/pub/jhardin/masquerade/VPN-
     howto/VPN-Masquerade.html>

  ·  Postscript:  <ftp://ftp.rubyriver.com/pub/jhardin/masquerade/VPN-
     howto/VPN-Masquerade.ps.gz>

  ·  SGML source:  <ftp://ftp.rubyriver.com/pub/jhardin/masquerade/VPN-
     Masquerade.sgml>

     If you are working with a kernel whose version number is higher
     than any mentioned in this document, please see if there is an
     updated version of the HOWTO at the above site before contacting me
     directly.

  It can also be found via the Linux Documentation Project's HOWTO
  repository and in the /usr/doc/HOWTO/ directory on your nearest Linux
  system. These copies are not directly updated by me, so they may be
  somewhat out of date.

  I personally have experience with masquerading IPsec and PPTP clients
  running on MS W'98 and NT, configuring a registered-IP PPTP server,
  and using PPTP for network-to-network routing.

  The information on masquerading a Private-IP PPTP server is from
  discussions with Len Bayles <len@isdi.com>, Simon Cocking
  <simon@ibs.com.au> and C. Scott Ananian <cananian@lcs.mit.edu>.

  The home page for the PPTP-only Masquerade kernel patch for the
  2.1.105+ and early 2.2.x kernel series is
  <http://bmrc.berkeley.edu/people/chaffee/linux_pptp.html>.

  The home page for the ipportfw port-forwarding kernel patch and
  configuration tool for 2.0.x kernels is
  <http://www.ox.compsoc.org.uk/~steve/portforwarding.html>.  Port
  forwarding is built into the 2.2.x kernel, and the ipmasqadm
  configuration tool for controlling 2.2.x port forwarding can be
  obtained at <http://juanjox.kernelnotes.org/>.

  The home page for the ipfwd generic IP redirector is
  <http://www.pdos.lcs.mit.edu/~cananian/Projects/IPfwd/>.

  Profuse thanks to Gordon Chaffee <chaffee@cs.berkeley.edu> for coding
  and sharing a patch to traceroute that allows tracing GRE traffic. It
  should prove invaluable in troubleshooting if your GRE traffic is
  being blocked somewhere. The patch is available at
  <http://www.wolfenet.com/~jhardin/pptp-traceroute.patch.gz>

  More thanks to Steve Chinatti <chinatti@alumni.Princeton.EDU> for
  contributing his original IPsec masquerade hack, from which I
  shamelessly stole some very important ideas...

  More information on setting up firewall rules to run automatically -
  including how to automatically use the correct IP address in a
  dynamic-IP environment - can be found at
  <http://www.wolfenet.com/~jhardin/ipfwadm/invocation.html>

  The home page for Linux FreeS/WAN (IPsec for Linux) is
  <http://www.xs4all.nl/~freeswan/> - this is the preferred Linux VPN
  solution.

  A native Linux PPTP server called PoPToP is available at
  <http://www.moretonbay.com/vpn/pptp.html> - for the most up-to-date
  information about PPTP on Linux, go there.

  Paul Cadach <paul@odt.east.telecom.kz> has made patches that add MS-
  CHAP-v2, MPPE and Multilink support to Linux pppd. See
  <ftp://ftp.east.telecom.kz/pub/src/networking/ppp/ppp-2.3.5-my.tgz>
  for MS-CHAP and MPPE, and
  <ftp://ftp.east.telecom.kz/pub/src/networking/ppp/multilink/ppp-2.3.5-mp.tgz>
  for Multilink.  Another (possibly related) set of pppd patches are
  available at the PoPToP download site at
  <http://www.moretonbay.com/vpn/download_pptp.html>.

  The home page for the original Linux PPTP project is
  <http://www.pdos.lcs.mit.edu/~cananian/Projects/PPTP> and a patch to
  add PPTP server capability to it is available at
  <http://debs.fuller.edu/cgi-bin/display?list=pptp&msg=222>

  Thanks to Eric Raymond for maintaining the Jargon File, and Denis Howe
  for The Free On-line Dictionary of Computing.
  1.3.  Copyright & Disclaimer

  This document is copyright © 1999-2000 by John D. Hardin.  Permission
  is granted to redistribute it under the terms of the LDP License,
  available at  <http://www.linuxdoc.org/COPYRIGHT.html>

  The information presented in this document is correct to the best of
  my knowledge. IP Masquerading is experimental, and it is possible that
  I have made a mistake in writing or testing the kernel patch or
  composing the instructions in this document; you should determine for
  yourself if you want to make the changes outlined in this document.


       THE AUTHOR IS NOT RESPONSIBLE FOR ANY DAMAGES INCURRED DUE
       TO ACTIONS TAKEN BASED ON THE INFORMATION IN THIS DOCUMENT.
       BACK UP ANY AND ALL CRITICAL INFORMATION BEFORE IMPLEMENTING
       THE CHANGES OUTLINED IN THIS DOCUMENT. MAKE SURE YOU HAVE A
       WORKING, BOOTABLE KERNEL AVAILABLE BEFORE PATCHING AND
       RECOMPILING YOUR KERNEL AS OUTLINED IN THIS DOCUMENT.


  In other words, take sensible precautions.



  2.  Background Knowledge



  2.1.  What is a VPN?

  A Virtual Private Network, or "VPN", is a tunnel that carries private
  network traffic from one endpoint system to another over a public
  network (such as the Internet) without the traffic being aware that
  there are intermediate hops between the endpoints, or the intermediate
  hops being aware they are carrying the network packets that are
  traversing the tunnel.  The tunnel may optionally compress and/or
  encrypt the data, providing enhanced performance and some measure of
  security.

  The "Virtual" part stems from the fact that you are constructing a
  private link over a public network, rather than actually buying a
  direct hardwired link over leased lines. The VPN allows you to pretend
  you are using a leased line or direct telephone call to communicate
  between the endpoints.

  You may find the VPN FAQ at
  <http://kubarb.phsx.ukans.edu/~tbird/vpn/FAQ.html> informative.



  2.2.  What is IPsec?

  IPsec is a set of standard protocols for implementing secure
  communications and encryption key exchange between computers. It can
  be used to implement a VPN.

  An IPsec VPN generally consists of two communications channels between
  the endpoint hosts: a key-exchange channel over which authentication
  and encryption key information is passed, and one or more data
  channels over which private network traffic is carried.

  The key-exchange channel is a standard UDP connection to and from port
  500. The data channels carrying the traffic between the client and
  server use IP protocol number 50 (ESP).

  More information is available in F-Secure's IPsec FAQ at
  <http://www.Europe.F-Secure.com/support/vpn+/faq/techfaq.html>, and in
  RFC2402 (the AH protocol, IP protocol number 51), RFC2406 (the ESP
  protocol, IP protocol number 50), and RFC2408 (the ISAKMP key-exchange
  protocol).

  IPsec is a peer-to-peer protocol. However, since most people will be
  exposed to it in the form of an originate-only Windows client being
  used to access a central network security gateway, "client" will be
  used to refer to the endpoint host that the user is sitting in front
  of and "server" will be used to refer to the central network security
  gateway.

  Important note: If your VPN is based on the AH protocol (including
  AH+ESP), it cannot be masqueraded. The AH protocol specifies a
  cryptographic checksum across portions of the IP header, including the
  IP addresses. IP Masquerade is implemented by modifying the source IP
  address for outbound packets and the destination IP address for
  inbound packets. Since the masquerading gateway cannot participate in
  the encryption key exchange, it cannot generate the correct
  cryptographic checksums for the modified IP headers. Thus the modified
  IP packets will be discarded by the recipient as invalid, because they
  fail the cryptographic checksum test.



  2.3.  What is PPTP?

  PPTP stands for Point-to-Point Tunnelling Protocol. It is a Microsoft-
  proposed protocol for implementing a VPN.

  The PPTP VPN protocol consists of two communications channels between
  the client and server: a control channel over which link-management
  information is passed, and a data channel over which (possibly
  encrypted) private network traffic is carried.

  The control channel is a standard TCP connection to port 1723 on the
  server. The data channel carrying the private network traffic uses IP
  protocol number 47 (GRE), a generic encapsulation protocol described
  in RFC1701. The transparent transmission of data over the data channel
  is achieved by negotiating a standard PPP connection over it, just as
  if it were a dialup connection directly from the client to the server.
  The options negotiated over the tunnel by PPP control whether the data
  is compressed and/or encrypted, thus PPTP itself has nothing to do
  with encryption.

  The details of the PPTP protocol are documented in RFC2637.

  Microsoft's implementation of the PPTP protocol is not considered very
  secure. If you're interested in the details, here are three separate
  analyses:

  <http://www.counterpane.com/pptp.html>

  <http://www.geek-girl.com/bugtraq/1999_1/0664.html>

  <http://oliver.efri.hr/~crv/security/bugs/NT/pptp2.html>



  2.4.  What is FWZ?

  FWZ is a proprietary encryption protocol developed by Check Point
  Software Technologies.  It is used in VPNs that are built around their
  Firewall-1 product.

  A Checkpoint-based firewall can be configured in several modes. The
  "FWZ Encapsulation" mode cannot be masqueraded. The "IKE" mode, which
  uses standard IPsec protocols, can be masqueraded with minor
  configuration changes on the VPN gateway.



  2.5.  Why masquerade a VPN client?

  Most current VPN clients assume you will be connecting the client
  computer directly to the internet. Doing this when you have only a
  single connection for internet access bypasses your Linux firewall and
  the security and access-sharing capabilities that it provides.
  Extending the Linux firewall to also masquerade VPN traffic allows you
  to retain the firewalling security provided by the Linux firewall as
  well as permitting the other systems on your local network to access
  the internet regardless of whether or not the VPN network connection
  is active.

  If your firewall is being used in a corporate setting you may also
  wish to require your VPN client users to go through that firewall for
  security reasons, rather than providing them with modems so they can
  dial out on their own when they need to use VPN. VPN Masquerade allows
  you to do so even if the desktops do not have registered IP addresses.



  2.6.  Can several clients on my local network use IPsec simultane­
  ously?

  Yes, though there may occasionally be minor problems.

  The IPsec protocols define a method for identifying the traffic
  streams called the Security Parameters Index ("SPI").  Unfortunately
  the SPI used by outbound traffic is different from the SPI used by
  inbound traffic, and there is no other identifying information
  available that is not encrypted, so association of the inbound and
  outbound data streams is difficult and not perfectly reliable.

  IPsec Masquerade attempts to associate inbound and outbound ESP
  traffic by serializing new connections. While this has worked well in
  testing, it cannot be guaranteed to be perfectly reliable, and the
  serialization of new traffic may result in some timeouts if the link
  is saturated or if many local IPsec hosts attempt to initiate
  communications or rekey with the same remote IPsec host
  simultaneously.

  It is also assumed that should this association scheme fail to
  associate the traffic streams correctly, the IPsec hosts themselves
  will discard the incorrectly routed traffic because it will have the
  wrong SPI values. This is required by the IPsec RFCs.

  These problems could be eliminated if there was some way to sniff the
  new SPI values from the ISAKMP key exchange before any ESP traffic
  appears, but unfortunately that portion of the key exchange is
  encrypted.

  To minimize the problems associated with this, it is recommended that
  you open a command window on your masqueraded IPsec host and run the
  "ping" program pinging a host on the remote network for as long as you
  have the tunnel up.

  See the IPsec technical notes at the end of the document for more
  details.


  2.7.  Can several clients on my local network use PPTP simultaneously?

  Yes.

  You must enable PPTP Call ID masquerade when configuring your kernel
  in order to distinguish between multiple data streams from the same
  server.  PPTP masq with Call ID masq enabled will support many
  concurrent masqueraded sessions with no restrictions on which server a
  client can call.

  The PPTP RFC specifies in section 3.1.3 that there may only be one
  control channel connection between two systems. This should mean that
  you can only masquerade one PPTP session at a time with a given remote
  server, but in practice the MS implementation of PPTP does not enforce
  this, at least not as of NT 4.0 Service Pack 4. If the PPTP server
  you're trying to connect to only permits one connection at a time,
  it's following the protocol rules properly.  Note that this does not
  affect a masqueraded server, only multiple masqueraded clients
  attempting to contact the same remote server.

  For another alternative, see the next question...



  2.8.  Can I access the remote network from my entire local network?

  Yes. However, your VPN client must be able to forward IP traffic.

  This means that you'll either have to use a Linux VPN client or a MS
  NT VPN client. The IP stack in W'95 and W'98 does not support IP
  forwarding. NT Workstation will work for this, and is less expensive
  than NT Server if you're only using it to route encrypted traffic.

  If you cannot install a Linux or NT-based VPN client, then you'll have
  to enable PPTP Call-ID masquerade if you are using PPTP, and install
  VPN client software on every system you want to provide access for.
  This is inefficient, aesthetically revolting, a security weakness, and
  may not work if the PPTP server correctly implements the protocol, but
  it's cheaper than licensing NT.

  Network-to-network routing this way works very well. This is how I
  have my home network set up for telecommuting. It does require a
  little more networking knowhow than simply giving everybody their own
  VPN client.

  In my experience, network-to-network routing in a pure-MS environment
  requires RRAS be installed at both ends of the tunnel.



  2.9.  Why masquerade the VPN server?

  If your VPN server has a registered IP address you do not need to
  masquerade it, simply configure your firewall to route the VPN traffic
  properly as described below.

  If your VPN server has a Private-Network IP address you will need to
  redirect the inbound traffic to it and masquerade the outbound traffic
  from it. Masquerading allows you to make a VPN server available to the
  internet even if you only have one assigned IP address. This should
  work even if your IP address is dynamically assigned: you would
  publicize the IP address for clients through the use of a third-party
  dynamic DNS service such as that provided by DDNS.ORG or CJB.NET and
  configure the clients to connect to a system named our-
  company.ddns.org or something similar. Note that this is a security
  risk, because it is possible for an incorrect IP address to be
  retrieved from the dynamic DNS server through timing problems, a
  failure to properly register the current dynamic IP address, or a
  third party registering a different IP address under the system name.



  2.10.  Why patch the Linux kernel?

  The largest problem in masquerading VPN traffic is that the stock
  Linux IP masquerade has no special awareness of IP protocols other
  than TCP, UDP and ICMP.

  All IP traffic may be forwarded and filtered by IP address, but
  masquerading IP protocols other than TCP, UDP and ICMP requires
  modifying the kernel.

  The PPTP control channel is plain TCP and requires no special setup
  beyond letting it through the firewall and masquerading it.

  Masquerading the IPsec and PPTP data channels requires a modification
  that adds support for the ESP and GRE protocols to the masquerading
  code, and masquerading the ISAKMP key exchange protocol requires a
  modification that prevents masquerade from altering the UDP source
  port number and adds tracking of the ISAKMP cookie values instead of
  the port number.



  2.11.  Current Status

  The 2.0.x kernel patch works on kernel 2.0.36 and is incorporated into
  the standard 2.0.37 and higher kernel releases. It may work on earlier
  kernels but I have not tested it, and I recommend you upgrade to
  kernel 2.0.38 anyway for security reasons if you are running an older
  kernel.

  The 2.2.x kernel patch works on kernels from 2.2.5 to 2.2.17 and may
  work on earlier kernels, but that has not been tested. It has been
  submitted for inclusion in the standard 2.2.18 release.

  I don't have the resources to follow the development kernels, so at
  this time no work on VPN Masquerade for 2.3.x or 2.4.x has taken
  place. If you know someone who is working on this, please let me know.

  The 2.0.x kernel patch has been tested and works on x86 and Sparc
  systems, and the 2.2.x kernel patch has been tested and works on x86
  and PowerPC systems, but there should be no major problems in porting
  to other architectures. I believe the architecture dependencies would
  only be in endian-ness within the bitmaps in the GRE header definition
  used to format debugging log messages.  If anyone ports this to a non-
  Intel architecture I'd appreciate hearing about it so I can merge any
  changes into the master copy.

  A PPTP-only kernel patch for the 2.1.105+ and early 2.2.x kernels is
  available at
  <http://bmrc.berkeley.edu/people/chaffee/linux_pptp.html>.

  See the VPN Masquerade home page at
  <http://www.impsec.org/linux/masquerade/ip_masq_vpn.html> for the
  status of the VPN Masq patches, and
  <http://bmrc.berkeley.edu/people/chaffee/linux_pptp.html> for the
  status of the 2.1.105+/2.2.x PPTP-only Masq patch.



  3.  Configuring the Linux firewall



  3.1.  Example network

  For the Private-IP configuration examples in this document we will use
  this sample network:


       Internet-------- 200.200.200.*   ppp0 or  200.200.200.200 eth1
                                        Dual-Homed Linux Firewall
                   .--- 10.0.0.1        eth0
                   |
                   |--- 10.0.0.2        VPN client or server
                   |



  For the registered-IP configuration examples in this document we will
  use this sample network:


       Internet-------- 200.200.200.200 eth1
                                        Dual-Homed Linux Firewall
                   .--- 222.0.0.1       eth0
                   |
                   |--- 222.0.0.2       VPN client or server
                   |



  The VPN server that the example clients connect to will be 199.0.0.1

  The VPN clients that the connect to the example server will be
  199.0.0.2 and 199.0.0.3



  3.2.  Determining what needs to be done on the firewall

  If your VPN client or server has a registered internet IP address you
  do not need to masquerade or modify your kernel - the stock kernel
  will successfully route all VPN traffic. You can skip directly to the
  registered-IP setup sections below.

  If your VPN client or server has a Private-Network IP address as
  described in RFC1918 you will need to patch your kernel (unless your
  kernel is 2.0.37 or higher in the 2.0.x series).

  If you are setting up a masqueraded VPN server, you will also have to
  obtain and install the following two packages:


  ·  To redirect the inbound TCP/UDP traffic (the 1723/tcp PPTP control
     channel or the 500/udp ISAKMP channel), you need the appropriate
     ipportfw port-forwarding kernel patch and configuration tool from
     <http://www.ox.compsoc.org.uk/~steve/portforwarding.html>.  Port
     forwarding has been incorporated into the 2.2.x kernel. See man
     ipmasqadm for configuration details. If ipmasqadm is not included
     with your distribution it can be obtained at
     <http://juanjox.kernelnotes.org/>.


  ·  To redirect the initial inbound tunnel traffic (GRE for PPTP and
     ESP for IPsec), you need the ipfwd generic-IP redirector from
     <http://www.pdos.lcs.mit.edu/~cananian/Projects/IPfwd/>.

  You do not need port forwarding or ipfwd if you are masquerading only
  clients.


  3.3.  Patching and configuring the 2.0.x kernel for VPN Masquerade
  support


  1. Install the kernel source (preferably version 2.0.37), which you
     can obtain from  <http://www.kernel.org/> or a mirror. The sources
     should be automatically extracted into a directory named
     /usr/src/linux.


  2. Configure and test standard IP Masquerading (see the IP Masquerade
     HOWTO). Doing this will familiarize you with recompiling your
     kernel and introduce you to IP Masquerading in general.


  3. Back up your kernel sources.


  4. Obtain the kernel patch if necessary.

     If your kernel version is 2.0.36 or lower, obtain the 2.0.x VPN
     Masquerade kernel patch from the VPN Masquerade home page in the
     "Resources" section above.

     If your kernel version is 2.0.37 or higher in the 2.0.x series, you
     do not need to apply any patches. The VPN Masquerade code is
     included in the kernel. Skip the discussion of patching the kernel.

     For the purposes of this document we'll assume you've saved the
     appropriate patch in /usr/src/ip_masq_vpn.patch.gz.


  5. Apply the VPN Masquerade patch to your kernel if necessary:


  ·  Change to the kernel source directory:

       cd /usr/src/linux



  ·  Apply the patch:

       zcat ../ip_masq_vpn.patch.gz | patch -l -p0 > vpn-patch.log
       2>&1



       Note that the options are "dash lowercase L, dash lowercase
       P zero". You may get odd results if you change the order of
       the arguments, as patch seems to be sensitive to the order
       they appear on the command line.



  ·  Check the vpn-patch.log file to see if any hunks failed.  If you
     get failed hunks, then you probably either omitted the options or
     ran the patch program from the wrong directory. Restore your kernel
     from the backup and try again.


  6. If you are masquerading a VPN server, obtain and install the
     ipportfw patch from the site given above.

     There is a known conflict between the VPN Masquerade patch and two
     other networking patches: the IP Firewall Chains patch and the
     ipportfw patch.  They are all trying to add options at the same
     location in net/ipv4/Config.in, and the changes made by one patch
     alter the context that the other patches are looking for.

     If you're applying the VPN Masquerade patch and the IP Firewall
     Chains or ipportfw patches to your 2.0.x kernel, you will have to
     manually edit net/ipv4/Config.in and add the block of configuration
     options from the patch file that fails to work. Looking at the
     patch file should show you where in net/ipv4/Config.in the new
     options should be added.

     The syntax of patch files is simple. For each block of changes to
     make, there are two sections: the first shows the "before" state,
     with an indication of lines to be changed or deleted; the second
     shows the "after" state, with an indication of the lines that have
     been changed or added. Use the first section to find where to add
     the lines, and add the lines that are indicated in the second
     section.

     This should not be a problem once those patches are updated for
     2.0.37+



  7. Configure your kernel and select the following options - say YES to
     the following:



    * Prompt for development and/or incomplete code/drivers
      CONFIG_EXPERIMENTAL
      - You must enable this to see the VPN Masq options.

    * Networking support
      CONFIG_NET

    * Network firewalls
      CONFIG_FIREWALL

    * TCP/IP networking
      CONFIG_INET

    * IP: forwarding/gatewaying
      CONFIG_IP_FORWARD

    * IP: firewalling
      CONFIG_IP_FIREWALL

    * IP: masquerading (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE
      - This is required.

    * IP: PPTP masq support (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE_PPTP
      - Enables PPTP data channel masquerading, if you are
        masquerading a PPTP client or server.

    * IP: PPTP Call ID masq support (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE_PPTP_MULTICLIENT
      - Enables PPTP Call ID masquerading; only necessary if
        you will be masquerading more than one client trying
        to connect to the same remote server. DO NOT enable
        this option if you will be masquerading a PPTP server.

    * IP: IPsec ESP & ISAKMP masq support (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE_IPSEC
      - Enables IPsec masquerade, if you are masquerading an
        IPsec host.

    * IP: IPSEC masq table lifetime (minutes)
      - See your network administrator to determine what the
        "rekey interval" or "key lifetime" is set to. The
        default lifetime of masq table entries is thirty
        minutes.  If your rekey interval is greater than
        thirty minutes, then you should increase the lifetime
        to a value slightly greater than the rekey interval.

    * IP: always defragment
      CONFIG_IP_ALWAYS_DEFRAG
      - Highly recommended for a firewall.



  NOTE: These are just the settings you need for masquerading.  Select
  whatever other options you need for your specific setup.



  8. Recompile the kernel and install it for testing. Don't replace a
     known working kernel with your new kernel until you have proven it
     works.


  To determine whether the running kernel includes VPN Masquerade
  support, run the following command:


       grep -i masq /proc/ksyms



  ...and look for the following entries:

  ·  IPsec masquerade: ip_masq_out_get_isakmp, ip_masq_in_get_isakmp,
     ip_fw_masq_esp and ip_fw_demasq_esp

  ·  PPTP masquerade: ip_fw_masq_gre and ip_fw_demasq_gre

  ·  PPTP Call-ID masquerade: ip_masq_pptp

  If you don't see these entries, VPN Masquerade support is probably not
  available. If you get complaints about /proc/ksyms not being available
  or /proc not being available, make sure that you have enabled the
  /proc filesystem in your kernel configuration.


  See the Kernel HOWTO for more details on configuring and recompiling
  your kernel.


  If you are using IPsec masquerade and your system is generating
  General Protection errors (see /var/log/messages) or is locking up,
  see the VPN Masquerade home page for an update. This patch is for
  2.0.38, but should work on earlier kernels. It has been submitted to
  Alan Cox for inclusion in the 2.0.39 kernel.



  3.4.  Patching and configuring the 2.2.x kernel for VPN Masquerade
  support


  1. Install the kernel source (preferably version 2.2.17 or later),
     which you can obtain from  <http://www.kernel.org/> or a mirror.
     The sources should be automatically extracted into a directory
     named /usr/src/linux.


  2. Configure and test standard IP Masquerading (see the IP Masquerade
     HOWTO). Doing this will familiarize you with recompiling your
     kernel and introduce you to IP Masquerading in general.


  3. Back up your kernel sources.


  4. Obtain the kernel patch from the VPN Masquerade home page in the
     "Resources" section above.

     For the purposes of this document we'll assume you've saved the
     appropriate patch in /usr/src/ip_masq_vpn.patch.gz.


  5. Apply the VPN Masquerade patch to your kernel if necessary:


  ·  Change to the source directory:

  cd /usr/src



  ·  Apply the patch:

       zcat ip_masq_vpn.patch.gz | patch -l -p0 > vpn-patch.log
       2>&1



       Note that the options are "dash lowercase L, dash lowercase
       P zero". You may get odd results if you change the order of
       the arguments, as patch seems to be sensitive to the order
       they appear on the command line.



       Also note that the directory you run the patch command in is
       different for the 2.2.x kernel patch



  ·  Check the vpn-patch.log file to see if any hunks failed.  If you
     get failed hunks, then you probably either omitted the options or
     ran the patch program from the wrong directory. Restore your kernel
     from the backup and try again.


  6. If you are masquerading a VPN server you do not need the ipportfw
     patch as port forwarding is now built-in. See the ipmasqadm man
     page for more details.  If ipmasqadm is not included with your
     distribution it can be obtained at
     <http://juanjox.kernelnotes.org/>.



  7. Configure your kernel and select the following options - say YES to
     the following:



    * Prompt for development and/or incomplete code/drivers
      CONFIG_EXPERIMENTAL
      - You must enable this to see the VPN Masq options.

    * Networking support
      CONFIG_NET

    * Network firewalls
      CONFIG_FIREWALL

    * TCP/IP networking
      CONFIG_INET

    * IP: firewalling
      CONFIG_IP_FIREWALL

    * IP: always defragment
      CONFIG_IP_ALWAYS_DEFRAG
      - Required for masquerading. This may or may not
        be in your kernel config. If not, you should
        run this in your startup scripts:
          echo 1 > /proc/sys/net/ipv4/ip_always_defrag

    * IP: masquerading (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE
      - This is required.

    * IP: masquerading special modules support
      CONFIG_IP_MASQUERADE_MOD
      - This is required.

    * IP: ipportfw masq support (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE_IPPORTFW
      - Enable this if you will be masquerading a VPN server.

    * IP: PPTP masq support
      CONFIG_IP_MASQUERADE_PPTP
      - Enables PPTP data channel masquerading, if you are
        masquerading a PPTP client or server. This is now
        available as a module.
        Note that you no longer need to specify Call-ID masquerade.

    * IP: IPsec ESP & ISAKMP masq support (EXPERIMENTAL)
      CONFIG_IP_MASQUERADE_IPSEC
      - Enables IPsec masquerade, if you are masquerading an
        IPsec host. This is now available as a module.

    * IP: IPsec masq table lifetime (minutes)
      - See your network administrator to determine what the
        "rekey interval" or "key lifetime" is set to. The default
        lifetime of masq table entries is thirty minutes. If
        your rekey interval is greater than thirty minutes,
        then you should increase the lifetime to a value
        slightly greater than the rekey interval.

    * IP: Enable parallel sessions (possible security risk - see help)
      CONFIG_IP_MASQUERADE_IPSEC_PAROK
      - See the IPsec masquerade technical notes and special
        security considerations section of the HOWTO for
        security considerations to be aware of when
        masquerading IPsec traffic. If you are only
        masquerading one IPsec client this setting has no
        effect.



  Say NO to the following:



         * IP: GRE tunnels over IP
           CONFIG_NET_IPGRE
           - This, confusingly, has *NOTHING* to do with PPTP.
             It enables support for GRE tunnels as used by Cisco
             routers. The fact that you see this option does not
             imply that PPTP support is available. You still need
             to apply the VPN Masquerade patch if the PPTP options
             listed above do not appear when you are configuring
             your kernel. DO NOT enable this unless you are setting
             up a GRE tunnel to a Cisco router.



  NOTE: These are just the settings you need for masquerading.  Select
  whatever other options you need for your specific setup.



  8. Recompile the kernel and install it for testing. Don't replace a
     known working kernel with your new kernel until you have proven it
     works.



  To determine whether the running kernel includes VPN Masquerade
  support, run the following command:


       grep -i masq /proc/ksyms



  ...and look for the following entries:

  ·  IPsec masquerade: ip_masq_esp and ip_demasq_esp

  ·  PPTP masquerade: ip_masq_pptp_tcp and ip_demasq_pptp_tcp

     Or run:


       lsmod



  ...and look for the following entries:

  ·  IPsec masquerade: ip_masq_ipsec

  ·  PPTP masquerade: ip_masq_pptp

  If you don't see these entries, VPN Masquerade support is probably not
  available - did you remember to modprobe ip_masq_pptp.o or modprobe
  ip_masq_ipsec.o if you compiled them as modules? If VPN masquerade
  stops working after you reboot, did you remember to add the modprobe
  commands into your /etc/rc.d/rc.local startup script?


  If you get complaints about /proc/ksyms not being available or /proc
  not being available, make sure that you have enabled the /proc
  filesystem in your kernel configuration.


  See the Kernel HOWTO for more details on configuring and recompiling
  your kernel.



  3.5.  ipfwadm setup for a Private-IP VPN Client or Server

  The firewall must now be configured to masquerade the outbound VPN
  traffic.  You may wish to visit
  <http://www.wolfenet.com/~jhardin/ipfwadm.html> to take a look at a
  GUI wrapper around the ipfwadm command that automates a lot of
  security-related packet filtering setup.

  The minimum firewall rules are:


       # Set the default forwarding policy to DENY:
       ipfwadm -F -p deny
       # Allow local-network traffic
       ipfwadm -I -a accept    -S 10.0.0.0/8 -D 0.0.0.0/0  -W eth0
       ipfwadm -O -a accept    -S 0.0.0.0/0  -D 10.0.0.0/8 -W eth0
       # Masquerade traffic for internet addresses and allow internet traffic
       ipfwadm -F -a accept -m -S 10.0.0.0/8 -D 0.0.0.0/0  -W ppp0
       ipfwadm -O -a accept    -S 0.0.0.0/0  -D 0.0.0.0/0  -W ppp0
       ipfwadm -I -a accept    -S 0.0.0.0/0  -D 0.0.0.0/0  -W ppp0


       or, if you have a permanent connection,

       ipfwadm -F -a accept -m -S 10.0.0.0/8 -D 0.0.0.0/0  -W eth1
       ipfwadm -O -a accept    -S 0.0.0.0/0  -D 0.0.0.0/0  -W eth1
       ipfwadm -I -a accept    -S 0.0.0.0/0  -D 0.0.0.0/0  -W eth1



  This is a completely open setup, though. It will masquerade any traf­
  fic from any host on the local network destined for any host on the
  internet, and provides no security at all.

  A tight firewall setup would only allow traffic between the client and
  the server, and would block everything else:



  # Set the default policy to DENY:
  ipfwadm -I -p deny
  ipfwadm -O -p deny
  ipfwadm -F -p deny
  # Allow local-network traffic
  ipfwadm -I -a accept -S 10.0.0.0/8 -D 0.0.0.0/0  -W eth0
  ipfwadm -O -a accept -S 0.0.0.0/0  -D 10.0.0.0/8 -W eth0
  # Masquerade only VPN traffic between the VPN client and the VPN server
  ipfwadm -F -a accept -m -P udp -S 10.0.0.2/32 500 -D 199.0.0.1/32 500  -W ppp0
  ipfwadm -F -a accept -m -P tcp -S 10.0.0.2/32     -D 199.0.0.1/32 1723 -W ppp0
  ipfwadm -F -a deny      -P tcp -S 10.0.0.2/32     -D 199.0.0.1/32      -W ppp0
  ipfwadm -F -a deny      -P udp -S 10.0.0.2/32     -D 199.0.0.1/32      -W ppp0
  ipfwadm -F -a accept -m -P all -S 10.0.0.2/32     -D 199.0.0.1/32      -W ppp0
  ipfwadm -O -a accept    -P udp -S 200.200.200.0/24 500 -D 199.0.0.1/32 500  -W ppp0
  ipfwadm -O -a accept    -P tcp -S 200.200.200.0/24     -D 199.0.0.1/32 1723 -W ppp0
  ipfwadm -O -a deny      -P tcp -S 200.200.200.0/24     -D 199.0.0.1/32      -W ppp0
  ipfwadm -O -a deny      -P udp -S 200.200.200.0/24     -D 199.0.0.1/32      -W ppp0
  ipfwadm -O -a accept    -P all -S 200.200.200.0/24     -D 199.0.0.1/32      -W ppp0
  ipfwadm -I -a accept    -P udp -S 199.0.0.1/32 500     -D 200.200.200.0/24 500 -W ppp0
  ipfwadm -I -a accept    -P tcp -S 199.0.0.1/32 1723    -D 200.200.200.0/24     -W ppp0
  ipfwadm -I -a deny      -P tcp -S 199.0.0.1/32         -D 200.200.200.0/24     -W ppp0
  ipfwadm -I -a deny      -P udp -S 199.0.0.1/32         -D 200.200.200.0/24     -W ppp0
  ipfwadm -I -a accept    -P all -S 199.0.0.1/32         -D 200.200.200.0/24     -W ppp0


  or, if you have a permanent connection,

  ipfwadm -F -a accept -m -P udp -S 10.0.0.2/32 500 -D 199.0.0.1/32 500  -W eth1
  ipfwadm -F -a accept -m -P tcp -S 10.0.0.2/32     -D 199.0.0.1/32 1723 -W eth1
  ipfwadm -F -a deny      -P tcp -S 10.0.0.2/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -F -a deny      -P udp -S 10.0.0.2/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -F -a accept -m -P all -S 10.0.0.2/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -O -a accept    -P udp -S 200.200.200.200/32 500 -D 199.0.0.1/32 500  -W eth1
  ipfwadm -O -a accept    -P tcp -S 200.200.200.200/32     -D 199.0.0.1/32 1723 -W eth1
  ipfwadm -O -a deny      -P tcp -S 200.200.200.200/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -O -a deny      -P udp -S 200.200.200.200/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -O -a accept    -P all -S 200.200.200.200/32     -D 199.0.0.1/32      -W eth1
  ipfwadm -I -a accept    -P udp -S 199.0.0.1/32 500  -D 200.200.200.200/32 500 -W eth1
  ipfwadm -I -a accept    -P tcp -S 199.0.0.1/32 1723 -D 200.200.200.200/32     -W eth1
  ipfwadm -I -a deny      -P tcp -S 199.0.0.1/32      -D 200.200.200.200/32     -W eth1
  ipfwadm -I -a deny      -P udp -S 199.0.0.1/32      -D 200.200.200.200/32     -W eth1
  ipfwadm -I -a accept    -P all -S 199.0.0.1/32      -D 200.200.200.200/32     -W eth1



  Note: these rules only allow VPN traffic and block everything else.
  You will have to add rules for any other traffic you wish to permit,
  such as DNS, HTTP, POP, IMAP, etc.



  3.6.  ipchains setup for a Private-IP VPN Client or Server

  The minimum ipchains firewall rules are:



  # Set the default forwarding policy to DENY:
  ipchains -P forward DENY
  # Allow local-network traffic
  ipchains -A input   -j ACCEPT -s 10.0.0.0/8 -d 0.0.0.0/0  -i eth0
  ipchains -A output  -j ACCEPT -s 0.0.0.0/0  -d 10.0.0.0/8 -i eth0
  # Masquerade traffic for internet addresses and allow internet traffic
  ipchains -A forward -j MASQ   -s 10.0.0.0/8 -d 0.0.0.0/0  -i ppp0
  ipchains -A output  -j ACCEPT -s 0.0.0.0/0  -d 0.0.0.0/0  -i ppp0
  ipchains -A input   -j ACCEPT -s 0.0.0.0/0  -d 0.0.0.0/0  -i ppp0


  or, if you have a permanent connection,

  ipchains -A forward -j MASQ   -s 10.0.0.0/8 -d 0.0.0.0/0  -i eth1
  ipchains -A output  -j ACCEPT -s 0.0.0.0/0  -d 0.0.0.0/0  -i eth1
  ipchains -A input   -j ACCEPT -s 0.0.0.0/0  -d 0.0.0.0/0  -i eth1



  This is a completely open setup, though. It will masquerade any traf­
  fic from any host on the local network destined for any host on the
  internet, and provides no security at all.

  A tight firewall setup would only allow traffic between the client and
  the server, and would block everything else:


       # Set the default policy to DENY:
       ipchains -P input   DENY
       ipchains -P output  DENY
       ipchains -P forward DENY
       # Allow local-network traffic
       ipchains -A input  -j ACCEPT -s 10.0.0.0/8 -d 0.0.0.0/0  -i eth0
       ipchains -A output -j ACCEPT -s 0.0.0.0/0  -d 10.0.0.0/8 -i eth0
       # Masquerade only VPN traffic between the VPN client and the VPN server
       # IPsec
       ipchains -A forward -j MASQ   -p udp -s 10.0.0.2/32 500      -d 199.0.0.1/32 500     -i ppp0
       ipchains -A output  -j ACCEPT -p udp -s 200.200.200.0/24 500 -d 199.0.0.1/32 500     -i ppp0
       ipchains -A input   -j ACCEPT -p udp -s 199.0.0.1/32 500     -d 200.200.200.0/24 500 -i ppp0
       ipchains -A forward -j MASQ   -p 50  -s 10.0.0.2/32          -d 199.0.0.1/32         -i ppp0
       ipchains -A output  -j ACCEPT -p 50  -s 200.200.200.0/24     -d 199.0.0.1/32         -i ppp0
       ipchains -A input   -j ACCEPT -p 50  -s 199.0.0.1/32         -d 200.200.200.0/24     -i ppp0
       # PPTP
       ipchains -A forward -j MASQ   -p tcp -s 10.0.0.2/32       -d 199.0.0.1/32 1723 -i ppp0
       ipchains -A output  -j ACCEPT -p tcp -s 200.200.200.0/24  -d 199.0.0.1/32 1723 -i ppp0
       ipchains -A input   -j ACCEPT -p tcp -s 199.0.0.1/32 1723 -d 200.200.200.0/24  -i ppp0
       ipchains -A forward -j MASQ   -p 47  -s 10.0.0.2/32       -d 199.0.0.1/32      -i ppp0
       ipchains -A output  -j ACCEPT -p 47  -s 200.200.200.0/24  -d 199.0.0.1/32      -i ppp0
       ipchains -A input   -j ACCEPT -p 47  -s 199.0.0.1/32      -d 200.200.200.0/24  -i ppp0


       or, if you have a permanent connection,



  # IPsec
  ipchains -A forward -j MASQ   -p udp -s 10.0.0.2/32 500        -d 199.0.0.1/32 500       -i eth1
  ipchains -A output  -j ACCEPT -p udp -s 200.200.200.200/32 500 -d 199.0.0.1/32 500       -i eth1
  ipchains -A input   -j ACCEPT -p udp -s 199.0.0.1/32 500       -d 200.200.200.200/32 500 -i eth1
  ipchains -A forward -j MASQ   -p 50  -s 10.0.0.2/32            -d 199.0.0.1/32           -i eth1
  ipchains -A output  -j ACCEPT -p 50  -s 200.200.200.200/32     -d 199.0.0.1/32           -i eth1
  ipchains -A input   -j ACCEPT -p 50  -s 199.0.0.1/32           -d 200.200.200.200/32     -i eth1
  # PPTP
  ipchains -A forward -j MASQ   -p tcp -s 10.0.0.2/32        -d 199.0.0.1/32 1723  -i eth1
  ipchains -A output  -j ACCEPT -p tcp -s 200.200.200.200/32 -d 199.0.0.1/32 1723  -i eth1
  ipchains -A input   -j ACCEPT -p tcp -s 199.0.0.1/32 1723  -d 200.200.200.200/32 -i eth1
  ipchains -A forward -j MASQ   -p 47  -s 10.0.0.2/32        -d 199.0.0.1/32       -i eth1
  ipchains -A output  -j ACCEPT -p 47  -s 200.200.200.200/32 -d 199.0.0.1/32       -i eth1
  ipchains -A input   -j ACCEPT -p 47  -s 199.0.0.1/32       -d 200.200.200.200/32 -i eth1



  Note: these rules only allow VPN traffic. You will have to add rules
  for any other traffic you wish to permit, such as DNS, HTTP, POP,
  IMAP, etc.

  Also note how there rules are much neater and easier to make sense of
  than the equivalent ipfwadm rules. This is because ipchains allows
  specification of all IP protocols, not just TCP, UDP, ICMP or ALL.



  3.7.  A note about dynamic IP addressing

  If your firewall is assigned a dynamic IP address by your ISP (dialup
  accounts are this way, as are some cable internet services), then you
  should add the following to the startup script /etc/rc.d/rc.local:


       echo 7 > /proc/sys/net/ipv4/ip_dynaddr



  This enables dynamic IP address following, which means that should
  your connection drop and be reestablished, any active sessions will be
  updated to the new IP address rather than using the old IP address.
  This does not mean that the session will continue across the interrup­
  tion, rather that it will be closed down quickly.

  If you do not do this, then there may be a "dead period" after you
  redial and before old masq table entries expire where you're being
  masqueraded with the wrong IP address, which will prevent your
  establishing a connection.

  This is particularly helpful if you are using a demand-dial daemon
  such as diald to manage your dialup connection.

  See /usr/src/linux/Documentation/networking/ip_dynaddr.txt for more
  details.



  3.8.  Additional setup for a Private-IP VPN Server

  If you are setting up VPN masquerade for a Private-IP VPN server (that
  is, you wish to provide for inbound connections as well as outbound
  connections), you also need to install two packet-forwarding
  utilities. One (ipportfw) forwards inbound TCP or UDP traffic
  addressed to a specific port on the firewall system to a system on the
  local network behind the firewall. This is used to redirect the
  initial inbound 1723/tcp PPTP control channel or 500/udp ISAKMP
  traffic to the VPN server. The other (ipfwd) is a more generic
  forwarding utility that allows you to do this for any IP protocol. It
  is used to forward the initial inbound 47/ip (GRE) or 50/ip (ESP) data
  channel traffic to the VPN server.

  Outbound responses to the inbound 1723/tcp or 500/udp traffic are
  masqueraded using the normal IP-Masquerade facilities in the Linux
  kernel.  The outbound 47/ip or 50/ip traffic is masqueraded using the
  VPN-Masquerade kernel patch you installed earlier.

  Once these utilities are installed, you must configure them to forward
  the traffic to the VPN server.



  ·  Configuring ipportfw under 2.0.x kernels

     The following commands will set up ipportfw to forward the initial
     inbound 500/udp traffic to the IPsec server:


       # Static-IP ipportfw setup for IPsec
       # Clear the ipportfw forwarding table
       /sbin/ipportfw -C
       # Forward traffic addressed to the firewall's 500/udp port
       # to the IPsec server's 500/udp port
       /sbin/ipportfw -A -u 200.200.200.200/500 -R 10.0.0.2/500



  The following commands will set up ipportfw to forward the initial
  inbound 1723/tcp traffic to the PPTP server:


       # Static-IP ipportfw setup for PPTP
       # Clear the ipportfw forwarding table
       /sbin/ipportfw -C
       # Forward traffic addressed to the firewall's 1723/tcp port
       # to the PPTP server's 1723/tcp port
       /sbin/ipportfw -A -t 200.200.200.200/1723 -R 10.0.0.2/1723



  Note that the ipportfw command line requires the internet IP address
  of the firewall, and you cannot specify the interface (e.g. ppp0) as
  you can with ipfwadm. This means that for a dynamic-IP connection
  (such as a typical dialup PPP connection) you have to run these com­
  mands every time you connect to the internet and are assigned a new IP
  address. You can do this quite easily - simply add the following to
  your /etc/ppp/ip-up or /etc/ppp/ip-up.local script:


       # Dynamic-IP ipportfw setup for IPsec
       # Clear the ipportfw forwarding table
       /sbin/ipportfw -C
       # Forward traffic addressed to the firewall's 500/udp port
       # to the IPsec server's 500/udp port
       /sbin/ipportfw -A -u ${4}/500 -R 10.0.0.2/500



  or:


       # Dynamic-IP ipportfw setup for PPTP
       # Clear the ipportfw forwarding table
       /sbin/ipportfw -C
       # Forward traffic addressed to the firewall's 1723/tcp port
       # to the PPTP server's 1723/tcp port
       /sbin/ipportfw -A -t ${4}/1723 -R 10.0.0.2/1723



  See  <http://www.wolfenet.com/~jhardin/ipfwadm/invocation.html> for
  more information on firewalling with a dynamic IP.



  ·  Configuring ipfwd under both 2.0.x and 2.2.x kernels

     The following command will set up ipfwd to forward the initial
     inbound 50/ip traffic to the IPsec server:


       /sbin/ipfwd --masq 10.0.0.2 50 &



  The following command will set up ipfwd to forward the initial inbound
  47/ip traffic to the PPTP server:


       /sbin/ipfwd --masq 10.0.0.2 47 &



  It should only be run once, from your /etc/rc.d/rc.local script.


  The techniques described here can be generalized to allow masquerading
  of most any type of server - HTTP, FTP, SMTP, and so forth. Servers
  that are purely TCP- or UDP-based will not require ipfwd.


  If you are masquerading a PPTP server you also need to make sure that
  you have not enabled PPTP Call ID masquerade in the kernel. Enabling
  PPTP Call ID masquerade builds in some assumptions that you're
  masquerading only PPTP clients, so enabling it will prevent proper
  masquerade of the PPTP server traffic. This also means that with the
  2.0.x version of the patch you cannot simultaneously masquerade a PPTP
  server and PPTP clients.



  3.9.  ipfwadm setup for a Registered-IP VPN Server

  Setting up a registered-IP VPN server behind a Linux firewall is a
  simple matter of making sure the appropriate routing and packet-filter
  commands are in place. Masquerading is not required.

  Unfortunately the 2.0.x-series kernels will not let us specify IP
  protocol 47 or 50 directly, so this firewall is less secure than it
  could be. If this is a problem for you, then install the IP Firewall
  Chains kernel patch or move to the 2.1.x or 2.2.x series kernel, where
  you can filter by IP protocol.

  The firewall rules will look something like this:


       # This section should follow your other firewall rules.

       # Specify the acceptable clients explicitly for tighter security.
       # Allow the IPsec ISAKMP traffic in and out.
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P udp -S 199.0.0.2/32 500 -D 222.0.0.2/32 500
       ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P udp -D 199.0.0.2/32 500 -S 222.0.0.2/32 500
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P udp -S 199.0.0.3/32 500 -D 222.0.0.2/32 500
       ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P udp -D 199.0.0.3/32 500 -S 222.0.0.2/32 500
       # Allow the PPTP control channel in and out.
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P tcp -S 199.0.0.2/32 -D 222.0.0.2/32 1723
       ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P tcp -D 199.0.0.2/32 -S 222.0.0.2/32 1723
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P tcp -S 199.0.0.3/32 -D 222.0.0.2/32 1723
       ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P tcp -D 199.0.0.3/32 -S 222.0.0.2/32 1723

       # Block all other TCP and UDP traffic from the internet.
       # This is essentially a "default deny TCP/UDP" that
       # only applies to the internet interface.
       ipfwadm -I -a deny -W eth1 -V 200.200.200.200 -P tcp
       ipfwadm -I -a deny -W eth1 -V 200.200.200.200 -P udp

       # Specify the acceptable clients explicitly for tighter security.
       # Note that this is too open since we're forced to
       # specify "-P all" rather than "-P 47" or "-P 50"...
       # Allow the PPTP data channel and IPsec ESP traffic in and out.
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P all -S 199.0.0.2/32 -D 222.0.0.2/32
       ipfwadm -0 -a accept -W eth1 -V 200.200.200.200 -P all -D 199.0.0.2/32 -S 222.0.0.2/32
       ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P all -S 199.0.0.3/32 -D 222.0.0.2/32
       ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P all -D 199.0.0.3/32 -S 222.0.0.2/32

       # Block all other traffic from the internet.
       # This is essentially a "default deny" that
       # only applies to the internet interface.
       ipfwadm -I -a deny -W eth1 -V 200.200.200.200



  If you are installing firewall rules on forwarding and/or rules on the
  inner interface, you will have do do something similar. The above
  example only covers VPN traffic; you will have to merge it into your
  existing firewall setup to allow any other traffic you need.



  3.10.  ipfwadm setup for a Registered-IP VPN Client

  Setting up a registered-IP VPN client behind a Linux firewall is
  similar to setting up a registered-IP VPN server.

  The firewall rules will look something like this:



  # Allow the IPsec ISAKMP traffic out and in.
  ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P udp -S 222.0.0.2/32 500 -D 199.0.0.1/32 500
  ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P udp -D 222.0.0.2/32 500 -S 199.0.0.1/32 500
  # Allow the PPTP control channel out and in.
  ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P tcp -S 222.0.0.2/32 -D 199.0.0.1/32 1723
  ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P tcp -D 222.0.0.2/32 -S 199.0.0.1/32 1723

  # Block all other TCP and UDP traffic from the internet.
  # This is essentially a "default deny TCP/UDP" that
  # only applies to the internet interface.
  ipfwadm -I -a deny -W eth1 -V 200.200.200.200 -P tcp
  ipfwadm -I -a deny -W eth1 -V 200.200.200.200 -P udp

  # Note that this is too open since we're forced to
  # specify "-P all" rather than "-P 47" or "-P 50"...
  # Allow the PPTP data channel and IPsec ESP traffic out and in
  ipfwadm -O -a accept -W eth1 -V 200.200.200.200 -P all -S 222.0.0.2/32 -D 199.0.0.1/32
  ipfwadm -I -a accept -W eth1 -V 200.200.200.200 -P all -D 222.0.0.2/32 -S 199.0.0.1/32

  # Block all other traffic from the internet.
  # This is essentially a "default deny" that
  # only applies to the internet interface.
  ipfwadm -I -a deny -W eth1 -V 200.200.200.200



  3.11.  ipchains setup for a Registered-IP VPN Server

  Setting up a registered-IP VPN server behind a Linux firewall is a
  simple matter of making sure the appropriate routing and packet-filter
  commands are in place. Masquerading is not required.

  The firewall rules will look something like this:


       # Specify the acceptable clients explicitly for tighter security.
       # Allow the IPsec ISAKMP traffic in and out.
       ipchains -A input  -j ACCEPT -p udp -s 199.0.0.2/32 500 -d 222.0.0.2/32 500 -i eth1
       ipchains -A output -j ACCEPT -p udp -d 199.0.0.2/32 500 -s 222.0.0.2/32 500 -i eth1
       ipchains -A input  -j ACCEPT -p udp -s 199.0.0.3/32 500 -d 222.0.0.2/32 500 -i eth1
       ipchains -A output -j ACCEPT -p udp -d 199.0.0.3/32 500 -s 222.0.0.2/32 500 -i eth1
       # Allow the IPsec ESP traffic in and out.
       ipchains -A input  -j ACCEPT -p 50  -s 199.0.0.2/32     -d 222.0.0.2/32     -i eth1
       ipchains -A output -j ACCEPT -p 50  -d 199.0.0.2/32     -s 222.0.0.2/32     -i eth1
       ipchains -A input  -j ACCEPT -p 50  -s 199.0.0.3/32     -d 222.0.0.2/32     -i eth1
       ipchains -A output -j ACCEPT -p 50  -d 199.0.0.3/32     -s 222.0.0.2/32     -i eth1
       # Allow the PPTP control channel in and out.
       ipchains -A input  -j ACCEPT -p tcp -s 199.0.0.2/32 -d 222.0.0.2/32 1723 -i eth1
       ipchains -A output -j ACCEPT -p tcp -d 199.0.0.2/32 -s 222.0.0.2/32 1723 -i eth1
       ipchains -A input  -j ACCEPT -p tcp -s 199.0.0.3/32 -d 222.0.0.2/32 1723 -i eth1
       ipchains -A output -j ACCEPT -p tcp -d 199.0.0.3/32 -s 222.0.0.2/32 1723 -i eth1
       # Allow the PPTP tunnel in and out.
       ipchains -A input  -j ACCEPT -p 47  -s 199.0.0.2/32 -d 222.0.0.2/32      -i eth1
       ipchains -A output -j ACCEPT -p 47  -d 199.0.0.2/32 -s 222.0.0.2/32      -i eth1
       ipchains -A input  -j ACCEPT -p 47  -s 199.0.0.3/32 -d 222.0.0.2/32      -i eth1
       ipchains -A output -j ACCEPT -p 47  -d 199.0.0.3/32 -s 222.0.0.2/32      -i eth1



  If you are installing firewall rules on forwarding and/or rules on the
  inner interface, you will have do do something similar. The above
  example only covers VPN traffic; you will have to merge it into your
  existing firewall setup to allow any other traffic you need.
  3.12.  ipchains setup for a Registered-IP VPN Client

  Setting up a registered-IP VPN client behind a Linux firewall is
  similar to setting up a registered-IP VPN server.

  The firewall rules will look something like this:


       # Allow the IPsec ISAKMP traffic out and in.
       ipchains -A output -j ACCEPT -p udp -s 222.0.0.2/32 500 -d 199.0.0.1/32 500 -i eth1
       ipchains -A input  -j ACCEPT -p udp -d 222.0.0.2/32 500 -s 199.0.0.1/32 500 -i eth1
       # Allow the IPsec ESP traffic out and in.
       ipchains -A output -j ACCEPT -p 50  -s 222.0.0.2/32     -d 199.0.0.1/32     -i eth1
       ipchains -A input  -j ACCEPT -p 50  -d 222.0.0.2/32     -s 199.0.0.1/32     -i eth1
       # Allow the PPTP control channel out and in.
       ipchains -A output -j ACCEPT -p tcp -s 222.0.0.2/32 -d 199.0.0.1/32 1723 -i eth1
       ipchains -A input  -j ACCEPT -p tcp -d 222.0.0.2/32 -s 199.0.0.1/32 1723 -i eth1
       # Allow the PPTP tunnel out and in.
       ipchains -A output -j ACCEPT -p 47  -s 222.0.0.2/32 -d 199.0.0.1/32      -i eth1
       ipchains -A input  -j ACCEPT -p 47  -d 222.0.0.2/32 -s 199.0.0.1/32      -i eth1



  3.13.  VPN Masq and LRP

  The Linux Router Project at  <http://www.linuxrouter.org/> provides a
  Linux-based firewall-on-a-floppy kit. With a '386 PC, two network
  cards, and a diskette drive, you can set up a full-featured
  masquerading firewall. No hard disk is needed.


  VPN Masquerade is supposed to be included in LRP version 2.2.9 - to
  verify it is available, see if ip_masq_ipsec or ip_masq_pptp are
  listed in the loadable modules in Package Settings -> Modules, or grep
  /proc/ksyms as described above. If you want to add VPN masquerade to
  an earlier version of LRP then somebody on the LRP mailing list may be
  able to provide a diskette image for you, or you can roll your own
  kernel using the instructions available on the LRP home page.


  The firewall rules would be added to the startup script file in
  Network Settings -> Direct Network Setup.



  3.14.  VPN Masq on a system running FreeS/WAN or PoPToP

  If you are going to be using the firewall as an IPsec gateway with
  FreeS/WAN, you must not enable IPsec masquerade.  If you are going to
  be using the firewall as a PPTP server with PoPToP, or a PPTP client
  using the Linux PPTP client software, you must not enable PPTP
  masquerade.

  VPN masquerade and a VPN client or server using the same protocols
  cannot at this time coexist on the same computer.

  Your firewall can, however, be a FreeS/WAN IPsec VPN gateway while
  masquerading PPTP traffic, or vice-versa.


  4.  Configuring the VPN client



  4.1.  Configuring a MS W'95 client


  1. Set up your routing so that the Linux firewall is your default
     gateway:


     a. Open Control Panel/Network or right-click "Network Neighborhood"
        and click on Properties.

     b. Click on the Configuration tab.

     c. In the list of installed network components, double-click on the
        "TCP/IP -> whatever-NIC-you-have" line.

     d. Click on the Gateway tab.

     e. Enter the local-network IP address of your Linux firewall.
        Delete any other gateways.

     f. Click on the "OK" button.


  2. Test masquerading. For example, run "telnet my.isp.mail.server
     smtp" and you should see the mail server's welcome banner.

  3. Install and configure the VPN software. For IPsec software follow
     the manufacturer's instructions. For MS PPTP:


     a. Open Control Panel/Network or right-click "Network Neighborhood"
        and click on Properties.

     b. Click on the Configuration tab.

     c. Click on the "Add" button, then double-click on the "Adapter"
        line.

     d. Select "Microsoft" as the manufacturer and add the "Virtual
        Private Networking Adapter" adapter.

     e. Reboot when prompted to.

     f. If you need to use strong (128-bit) encryption, download the
        strong encryption DUN 1.3 update from the MS secure site at
        <http://mssecure.www.conxion.com/cgi-bin/ntitar.pl> and install
        it, then reboot again when prompted to.

     g. Create a new dial-up phonebook entry for your PPTP server.

     h. Select the VPN adapter as the device to use, and enter the PPTP
        server's internet IP address as the telephone number.

     i. Select the Server Types tab, and check the compression and
        encryption checkboxes.

     j. Click on the "TCP/IP Settings" button.

     k. Set the dynamic/static IP address information for your client as
        instructed to by your PPTP server's administrator.

     l. If you wish to have access to your local network while the PPTP
        connection is up, uncheck the "Use default gateway on remote
        network" checkbox.


     m. Reboot a few more times, just from habit... :)



  4.2.  Configuring a MS W'98 client


  1. Set up your routing so that the Linux firewall is your default
     gateway and test masquerading as described above.

  2. Install and configure the VPN software. For IPsec software follow
     the manufacturer's instructions. For MS PPTP:


     a. Open Control Panel/Add or Remove Software and click on the
        Windows Setup tab.

     b. Click on the Communications option and click the "Details"
        button.

     c. Make sure the "Virtual Private Networking" option is checked.
        Then click the "OK" button.

     d. Reboot when prompted to.

     e. If you need to use strong (128-bit) encryption, download the
        strong encryption VPN Security update from the MS secure site at
        <http://mssecure.www.conxion.com/cgi-bin/ntitar.pl> and install
        it, then reboot again when prompted to.


  3. Create and test a new dial-up phonebook entry for your VPN server
     as described above.



  4.3.  Configuring a MS W'ME client

  I haven't seen one of these yet. I expect the procedure is very
  similar to that for W'98. Could someone who has done this let me know
  what, if any, differences there are? Thanks.


  4.4.  Configuring a MS NT client


       Note: this section may be incomplete as it's been a while
       since I've installed PPTP on an NT system.



  1. Set up your routing so that the Linux firewall is your default
     gateway:


     a. Open Control Panel/Network or right-click "Network Neighborhood"
        and click on Properties.

     b. Click on the Protocols tab and double-click on the "TCP/IP"
        line.

     c. Enter the local-network IP address of your Linux firewall in the
        "Default Gateway" box.

     d. Click on the "OK" button.

  2. Test masquerading. For example, run "telnet my.isp.mail.server
     smtp" and you should see the mail server's welcome banner.

  3. Install and configure the VPN software. For IPsec software follow
     the manufacturer's instructions. For MS PPTP:


     a. Open Control Panel/Network or right-click "Network Neighborhood"
        and click on Properties.

     b. Click on the Protocols tab.

     c. Click on the "Add" button, then double-click on the "Point-to-
        Point Tunneling Protocol" line.

     d. When it asks for the number of Virtual Private Networks, enter
        the number of PPTP servers you could possibly be communicating
        with.

     e. Reboot when prompted to.

     f. If you need to use strong (128-bit) encryption, download the
        strong encryption PPTP update from the MS secure site at
        <http://mssecure.www.conxion.com/cgi-bin/ntitar.pl> and install
        it, then reboot again when prompted to.

     g. Create a new dial-up phonebook entry for your PPTP server.

     h. Select the VPN adapter as the device to use, and enter the PPTP
        server's internet IP address as the telephone number.

     i. Select the Server Types tab, and check the compression and
        encryption checkboxes.

     j. Click on the "TCP/IP Settings" button.

     k. Set the dynamic/static IP address information for your client as
        instructed to by your PPTP server's administrator.

     l. If you wish to have access to your local network while the PPTP
        connection is up, see MS Knowledge Base article Q143168 for a
        registry fix.  (Sigh.)

     m. Make sure you reapply the most recent Service Pack, to ensure
        that your RAS and PPTP libraries are up-to-date for security and
        performance enhancements.



  4.5.  Configuring for network-to-network routing

  Yet to be written.

  You really ought to look at FreeS/WAN (IPsec for Linux) at
  <http://www.xs4all.nl/~freeswan/> instead of masquerading.


  4.6.  Masquerading Checkpoint SecuRemote-based VPNs

  It is possible to masquerade Checkpoint SecuRemote-based VPN traffic
  under certain circumstances.

  First, you must configure the SecuRemote firewall to allow masqueraded
  sessions. On the SecuRemote firewall do the following:


  1. Run fwstop

  2. Edit $FWDIR/conf/objects.C and after the ":props (" line, add or
     modify the following lines to read:


       :userc_NAT (true)
       :userc_IKE_NAT (true)



  3. Run fwstart

  4. Re-install your security policy.

  5. Verify the change took effect by checking both
     $FWDIR/conf/objects.C and $FWDIR/database/objects.C


  If you use the IPsec protocols (called "IKE" by CheckPoint) you don't
  have to do anything else special to masquerade the VPN traffic.
  Simply configure your masquerading gateway to masquerade IPsec traffic
  as described above.

  Checkpoint's proprietary FWZ protocol is more complicated. There are
  two modes that FWZ can be used in: encapsulated mode and transport
  mode. In encapsulated mode, integrity checking is done over the whole
  IP packet, just as in IPsec's AH protocol. Changing the IP address
  breaks this integrity guarantee, thus encapsulated FWZ tunnels cannot
  be masqueraded.

  In transport mode, only the data portion of the packet is encrypted,
  and the IP headers are not verified against changes. In this mode,
  masquerading should work with the modifications described above.

  The configuration for encapsulated or transport mode is done in the
  FireWall-1 GUI. In the network object for the Firewall, under the VPN
  tab, edit the FWZ properties. The third tab in FWZ properties allows
  you to set encapsulated mode.

  You will only be able to masquerade one client at a time.

  Further information can be found at:

  ·  <http://www.phoneboy.com/fw1/nat.html>,

  ·  <http://www.phoneboy.com/fw1/faq/0141.html>

  ·  <http://www.phoneboy.com/fw1/faq/0372.html>



  5.  Troubleshooting



  5.1.  Testing

  To test VPN Masquerade:


  1. Bring up your ISP connection from your Linux box and verify that it
     still works properly.

  2. Verify that regular masquerading still works properly by, for
     example, trying to browse a Web site or access an FTP server from a
     masqueraded box on your local network.

  3. PPTP: Verify that you have masquerading of the PPTP control channel
     properly configured: try to telnet from the PPTP client system to
     port 1723 on your PPTP server. Don't expect to see anything, but if
     you get a timeout or an error saying the connection failed, take a
     look at the masquerade rules on your Linux box to ensure that you
     are indeed masquerading traffic from your PPTP client to TCP port
     1723 on your PPTP server.

  4. PPTP: Attempt to establish a PPTP connection. I recommend you also
     run RASMON if it is available, as this will give you a minimal
     amount of information about the status of the connection. If you
     establish a PPTP connection on the first try, congratulations!
     You're done!

  5. IPsec: Attempt to establish an IPsec connection.



  5.2.  Possible problems

  There are several things that may prevent a VPN session from being
  established.  We'll work through them going from the client to the
  server and back again.  We will assume you're using a Windows-based
  client for the examples, as that's the most common case.


  1. Connect information: the "telephone number" in the VPN dialup
     configuration must be the Internet IP address of the VPN server, or
     the IP address of the firewall if the server is being masqueraded.

  2. PPTP and strong encryption: unless both client and server have the
     128-bit NDISWAN.SYS or W'95/'98 PPTP software, you will not be able
     to establish a strongly-encrypted session. Unfortunately in my
     experience this problem does not generate any obvious error
     messages, it just keeps trying and trying and trying... The strong
     encryption update can be obtained from the Microsoft secure site
     URL given in the "Configuring a MS Client" section.

     This may also affect IPsec clients, if they use the MS-supplied
     encryption libraries rather than using their own libraries.


  3. Routing: verify that the default route on your VPN client is
     pointing at the Linux masquerade box. Run the route print command
     and look for an 0.0.0.0 entry.

     If other masqueraded services (such as HTTP, FTP, IRC, etc.) work
     from your VPN client system then this probably is not the problem.


  4. Masquerading: there are two parts to the VPN session.

     For IPsec, the authentication and key exchange service (ISAKMP),
     which is a normal UDP session to port 500 on the remote IPsec host,
     must be configured for masquerading as you would any other UDP
     service (such as DNS).

     For PPTP, the control channel, which is a normal TCP session to
     port 1723 on the PPTP server, must be configured for masquerading
     as you would any other TCP service (such as HTTP).

     The encrypted data channel in IPsec is carried over ESP, IP
     protocol 50.  The encrypted data channel in PPTP is carried over
     GRE, IP protocol 47.  (Note that these are not TCP or UDP port
     numbers!)  Since the 2.0 Linux kernel only lets you specify TCP,
     UDP, ICMP and ALL IP protocols when creating masquerade rules, you
     must also masquerade ALL protocol traffic if you are masquerading
     only specific services. If you are masquerading everything, you
     don't need to worry about this.

     In order to isolate the firewall rules from the kernel masquerade
     code, try establishing a VPN connection with your firewall
     completely open, then if it works, tighten the firewall rules.

     2.0.x ipfwadm completely open firewall:


       ipfwadm -I -p accept
       ipfwadm -O -p accept
       ipfwadm -F -a accept -m



  2.2.x ipchains completely open firewall:


       ipchains -P input   ACCEPT
       ipchains -P output  ACCEPT
       ipchains -P forward MASQ



  Do not leave your firewall completely open for any longer than it
  takes to prove that a masqueraded VPN connection can be established!


  5. Intermediary hops and the Internet: All routers between your Linux
     firewall and the remote IPsec host must forward packets carrying IP
     protocol 50.  All routers between your Linux firewall and the PPTP
     server must forward packets carrying IP protocol 47.  If you had
     IPsec or PPTP working when your VPN client system directly dialled
     your ISP then this probably is not the problem.

     To isolate whether an intermediary hop is blocking GRE traffic, use
     a patched traceroute to trace the progress of GRE packets. See the
     resources section for information on the traceroute patch. A
     similar patch for ESP is in the works.


  6. The remote firewall: the firewall at the server end must allow a
     system with the IP address assigned to your Linux box by your ISP
     to connect to port 500/udp on the IPsec host or port 1723/tcp on
     the PPTP server. If you had the VPN working when your VPN client
     system directly dialled your ISP then this probably is not the
     problem.

  7. The server firewall and ESP: the IPsec encrypted data is carried
     over IP protocol 50. If the firewall the remote IPsec host is
     behind does not forward ESP traffic in both directions, IPsec will
     not work. Again, if you had IPsec working when your IPsec client
     system directly dialled your ISP then this probably is not the
     problem.

  8. The server firewall and GRE: the PPTP data channel is carried as a
     GRE-encapsulated (IP protocol 47) PPP session. If the firewall your
     PPTP server is behind does not forward GRE traffic in both
     directions, PPTP will not work. Again, if you had PPTP working when
     your PPTP client system directly dialed your ISP then this probably
     isn't the problem.

  9. The patch: If your IPsec client successfully authenticates you but
     cannot establish a network connection, the patch may not be
     masquerading ESP traffic properly. If your PPTP client establishes
     the control channel (RASMON beeps and the little telephone lights
     up) and sends GRE traffic (the upper light in RASMON blinks) but
     gets no GRE traffic back (the lower light in RASMON does not blink
     in response) the patch may not be masquerading GRE traffic
     properly.

     Look in /var/log/messages for log entries showing that VPN traffic
     was seen. Turning on VPN debugging may help you to determine
     whether or not the patch is at fault. Also run a sniffer on your
     internet connection and look for outbound VPN traffic (see below).


  10.
     Multiple clients: the older PPTP patch does NOT support
     masquerading of multiple PPTP clients attempting to access the same
     PPTP server. If you're trying to do this, you should take a look at
     your network design and consider whether you should set up a PPTP
     router for your local clients. The 2.0 patch incorporates Call-ID
     masquerading, which allows multiple simultaneous sessions. Note: do
     not enable PPTP Call-ID masquerade if you are masquerading a PPTP
     Server. At the current time this will prevent the server's outbound
     traffic from being masqueraded.



  5.3.  Troubleshooting

  Most problems can be localized by running a packet sniffer (e.g.
  tcpdump with the -v option) on your VPN firewall.  If everything is
  working properly, you'll see the following traffic:


  ·  Client local network:

     IPsec: UDP (destination UDP port 500) and ESP (IP protocol 50)
     traffic from your IPsec client local network IP to the remote IPsec
     host's Internet IP. If you don't see this, your IPsec client is
     misconfigured.

     PPTP: TCP (destination TCP port 1723) and GRE (IP protocol 47)
     traffic from your PPTP client local network IP to the PPTP server's
     Internet IP. If you don't see this, your PPTP client is
     misconfigured.


  ·  ISP side of client firewall: UDP and ESP or TCP and GRE traffic
     from the client firewall Internet IP (remember - we're
     masquerading) to the VPN server's Internet IP. If you don't see
     this, your masquerade is misconfigured or the patch isn't working.

  ·  ISP side of server firewall: UDP and ESP or TCP and GRE traffic
     from the client Internet IP to the VPN server's Internet IP. If you
     don't see this, the Internet is down :) or some intermediary is
     blocking ESP or GRE traffic.

  ·  Boundary network (DMZ) side of server firewall: UDP and ESP or TCP
     and GRE traffic from the client internet IP to the server IP. If
     you don't see this, check your firewall rules for forwarding UDP
     port 500 and IP protocol 50 or TCP port 1723 and IP protocol 47,
     and the configuration of ipportfw and ipfwd if you're masquerading
     the server.

  ·  Boundary network side of server firewall: UDP (source port 500) and
     ESP or TCP (source port 1723) and GRE traffic from the VPN server
     IP to the client internet IP. If you don't see this, check the VPN
     server configuration, including the packet filtering rules on the
     VPN server.

  ·  ISP side of server firewall: UDP and ESP or TCP and GRE traffic
     from the VPN server IP (or firewall IP if the server is
     masqueraded) to the client internet IP. If you don't see this,
     check your firewall rules for forwarding UDP port 500 and IP
     protocol 50 or TCP port 1723 and IP protocol 47.

  ·  ISP side of client firewall: UDP and ESP or TCP and GRE traffic
     from the VPN server IP to the client firewall internet IP. If you
     don't see this, the Internet is acting up again.

  ·  Client local network: UDP and ESP or TCP and GRE traffic from the
     VPN server internet IP to the VPN client local network IP. If you
     see the UDP traffic but not the ESP traffic, or the TCP traffic but
     not the GRE traffic, the patch isn't working or wasn't properly
     installed.


  You may find it helpful to turn on VPN debugging and recompile your
  kernel. Add the following to /etc/syslog.conf


       # debugging
       *.=debug           /var/log/debug



  and watch /var/log/messages and /var/log/debug for log messages about
  the VPN traffic. Note that logging - especially verbose logging - will
  cause a great deal of disk activity and will cause the log files to
  grow very large very quickly. Don't turn on debugging unless you need
  to, and turn it off when you're done.



  5.4.  MS PPTP Clients and domain-name issues

  Thanks to Charles Curley <ccurley@trib.com> for the following:


       If you use PPTP (Point to Point Tunneling Protocol) to
       access a Microsoft Networking (SMB) environment and have
       your own Microsoft Networking environment in your local pri­
       vate network (Samba or Windows), give your local workgroup a
       name that does not show up in the remote environment. The
       reason is that while your PPTP client is logged into the
       remote environment, it will see the remote environment's
       domain name servers, and will only see the remote computers
       in that workgroup.

       You should avoid the lazy option. Microsoft ships Windows
       set up for a default workgroup name of WORKGROUP. Some
       people will be lazy and accept that as their workgroup when
       they set up their computers. So there is a good chance that
       the remote environment will have a workgroup called
       WORKGROUP, administrators willing or not.
  I think that this will apply regardless of the VPN in use, as name
  services aren't dependent on the transport. If your client(s) can see
  the WINS servers on the remote network then you may experience this,
  PPTP or no PPTP.



  5.5.  MS PPTP Clients and Novell IPX

  If you're having trouble with IPX traffic over your PPTP link, please
  see sections 3.5 and 5.2 in this MS Knowledge Base article:
  <http://microsoft.com/ntserver/nts/downloads/recommended/dun13win95/ReleaseNotes.asp>

  The same considerations probably apply to Win'98 as well.

  Thanks to David Griswold <dgriswol@ix.netcom.com>



  5.6.  MS network password issues

  When you are using a VPN to access a MS network you should remember
  that you will have to provide two different authentication tokens -
  one to connect to the VPN server (the VPN password) and the other to
  access resources on the remote network once the connection is
  established (the network password).

  The VPN password - the username and password you enter into your VPN
  client when initiating the call to the VPN server - is only used by
  the VPN server to grant you permission to connect to the network via
  the VPN. It isn't used for anything else once you're connected.

  The VPN password is not used to prove your identity to other computers
  on the remote network. You must provide another username/password pair
  - your network password - for that.

  There are two ways to supply a network password. Your network password
  may be the same username/password pair you supplied when logging onto
  the local network when you started your computer up. If it is
  different, you can configure your VPN client to ask you for your
  network password for the remote network once the VPN connection is
  established.

  If you are successfully connecting to the VPN server but you cannot
  access any of the resources provided by the remote network, then you
  aren't providing a valid network username/password pair for the remote
  network.  Verify that the username and password for your local network
  will also work on the remote network, or set your VPN client to prompt
  you for a username and password for use on the remote network and "log
  on" to the remote network once the VPN connection is established.



  5.7.  If your IPsec session always dies after a certain amount of time

  If you're having trouble with your IPsec tunnel regularly dying,
  particularly if checking the system logs on the firewall shows that
  ISAKMP packets with "zero cookie" values are being seen, here's what's
  happening:

  Earlier versions of the IPsec Masq patch did not change the timeout
  for masq table entries for ISAKMP UDP packets. The masq table entries
  for the ISAKMP UDP traffic would time out fairly quickly (relative to
  the data channel) and be removed; if the remote IPsec host then
  decided to initiate rekeying before the local IPsec host did, the
  inbound ISAKMP traffic for the rekey couldn't be routed to the
  masqueraded host. The rekey traffic would be discarded, the remote
  IPsec host would think the link had failed, and the connection would
  eventually be terminated.

  The 2.0.x patch has been modified from its original version to
  increase the timeout on ISAKMP UDP masq table entries. Get the current
  version of the patch, available via the sites given in the Resources
  section, and repatch and recompile your kernel.

  Also verify that your IPsec Masq Table Lifetime parameter is
  configured to be the same as or slightly longer than your rekey
  interval.



  5.8.  If VPN masquerade fails to work after you reboot

  Did you remember to put modprobe ip_masq_pptp.o or modprobe
  ip_masq_ipsec.o commands into your /etc/rc.d/rc.local startup script
  if you compiled VPN Masq support as modules?



  5.9.  If your second PPTP session kills your first session

  The PPTP RFC specifies that there may only be one control channel
  between two systems. This may mean that only one masqueraded client
  will be able to contact a given PPTP server at a time. See ``'' for
  more details.


  6.  IPsec masquerade technical notes and special security considera­
  tions


  6.1.  Limitations and weaknesses of IPsec masquerade

  Traffic that uses the AH protocol cannot be masqueraded. The AH
  protocol incorporates a cryptographic checksum across the IP addresses
  that the masquerade gateway cannot correctly regenerate. Thus, all
  masqueraded AH traffic will be discarded as having invalid checksums.

  IPsec traffic  using transport-mode ESP also cannot be reliably
  masqueraded.  Transport mode ESP essentially encrypts everything after
  the IP header.  Since, for example, the TCP and UDP checksums include
  the IP source and destination addresses, and the TCP/UDP checksum is
  within the encrypted payload and thus cannot be recalculated after the
  masquerade gateway alters the IP addresses, the TCP/UDP header will
  fail the checksum test at the remote gateway and the packet will be
  discarded. Protocols that do not include information about the source
  or destination IP addresses may successfully use masqueraded transport
  mode.

  Apart from these limitations, IPsec masquerade is secure and reliable
  when only one IPsec host is being masqueraded at a time, or when each
  masqueraded host is communicating with a different remote host. When
  more than one masqueraded host is communicating with the same remote
  host, a few weaknesses show up:


  ·  Transport-mode communications are subject to collisions.

     If two or more masqueraded hosts are using transport mode to
     communicate with the same remote host, and the security policy of
     the remote host permits multiple transport-mode sessions with the
     same peer, it is possible for sessions to experience collisions.
     This happens because the IP address of the masquerading gateway
     will be used to identify the sessions, and any other identifying
     information cannot be masqueraded because it is within the
     encrypted portion of the packet.

     If the remote host's security policy does not permit multiple
     transport-mode sessions with the same peer, the situation is even
     worse: the more-recently-negotiated transport mode session will
     likely completely take over all of the traffic from the older
     session, causing the older session to "go dead". While the
     established sessions from the older transport-mode IPsec session
     may be quickly reset if the remote host isn't expecting to receive
     the traffic, at least one packet of information will be sent to the
     wrong host. This information will probably be discarded by the
     recipient, but it will still be sent.

     Thus, a transport-mode collision may result in leaking of
     information between the two sessions or termination of one or both
     sessions. Using IPsec in transport mode via a masquerading gateway
     is not recommended if there is the possibility that other transport
     mode IPsec sessions will be attempted via the same masquerading
     gateway to the same remote IPsec host.

     IPsec using tunnel mode with extruded network addressing (where the
     masqueraded IPsec host is assigned an IP address from the remote
     host's network) is not subject to these problems, as the IP
     addresses assigned from the remote network will be used to identify
     the sessions instead of using the IP address of the masquerading
     host.



  ·  ISAKMP communications are subject to cookie collisions.

     If two or more masqueraded hosts establishing a session to the same
     remote host happen to select the same initiator cookie when
     initiating ISAKMP traffic, the masquerading gateway will route all
     of the ISAKMP traffic to the second host. There is a 1 in 2^64
     (i.e. very small) chance of this collision happening for each host,
     at the time of establishing the initial ISAKMP connection.

     Correcting this requires including the responder cookie in the key
     used to route inbound ISAKMP traffic. This modification is
     incorporated into IPsec masquerade for the 2.2.x kernel, and the
     short window between the time the masqueraded host initiates the
     ISAKMP exchange and the remote host responds is covered by
     discarding any new ISAKMP traffic that would collide with the
     current outstanding traffic. This modification will be backported
     to the 2.0.x code soon.



  ·  There may be a collision between SPI values on inbound traffic.

     Two or more masqueraded IPsec hosts communicating with the same
     remote IPsec host may negotiate to use the same SPI value for
     inbound traffic. If this happens the masquerading gateway will
     route all of the inbound traffic to the first host to receive any
     inbound traffic using that SPI. The possibility of this happening
     is about 1 in 2^32 for each outstanding ESP session, and may occur
     on any rekey.

     Since the SPI values refer to different SAs having different
     encryption keys the first host will not be able to decrypt the data
     intended for the other hosts, so no data leakage will occur. There
     is no way for the masquerading gateway to detect or prevent this
     collision. The only way to prevent this collision is for the remote
     IPsec host to check the SPI value proposed by the masqueraded host
     to see if that SPI value is already in use by another SA from the
     same IP address. It is not likely that this will be done, since it
     imposes more overhead on an already expensive operation (the rekey)
     to benefit a small percentage of users in case of a relatively rare
     event.



  ·  Inbound and outbound SPI values may be misassociated.

     This is discussed in detail in the next section.


  To avoid these problems the 2.2.x code by default prevents the
  establishment of multiple connections to the same remote host. If the
  weaknesses exposed by multiple connections to the same remote host are
  acceptable, you can enable "parallel sessions".

  Blocking parallel sessions for security reasons can be annoying: there
  is no way for the IPsec masquerade code to sniff the session and see
  when it is terminating, so the masquerade table entries will persist
  for the IPsec Masq Table Lifetime even if the session terminates
  immediately after it is established. If parallel sessions are
  prevented, this means that the server will be unavailable to other
  clients until the masq table entry for the most recent session has
  timed out and been deleted. This can be up to several hours.



  6.2.  Proper routing of inbound encrypted traffic

  The portion of the ISAKMP key exchange where the ESP SPI values are
  communicated is encrypted, so the ESP SPI values must be determined by
  inspection of the actual ESP traffic. Also, the outbound ESP traffic
  does not contain any indication of what the inbound SPI will be. This
  means there is no perfectly reliable way to associate inbound ESP
  traffic with outbound ESP traffic.

  IPsec masq attempts to associate inbound and outbound ESP traffic by
  serializing initial ESP traffic on a by-remote-host basis. What this
  means is:


  ·  If an outbound ESP packet with an SPI value that has not previously
     been seen (or whose masquerade table entry has expired) is received
     (which shall hereafter be called an "initial packet"), a masquerade
     table entry for that SourceAddr+SPI+DestAddr combination is
     created. It is marked as "outstanding", that is, no inbound ESP
     traffic has been received for it yet. This is done by setting the
     "inbound SPI" value in the masq table entry to zero, which is a
     value reserved for uses such as this. This will happen at the
     initiation of a new ESP connection and at regular intervals when an
     existing ESP connection rekeys.


  ·  As long as the masq table entry is outstanding, no other initial
     ESP packets for the same remote host will be processed. The packets
     are immediately discarded, and a system log entry is made saying
     the traffic is temporarily blocked. This also applies to initial
     traffic from the same masqueraded host going to the same remote
     host if the SPI values differ. Traffic to other remote hosts, and
     traffic where both SPI values are known ("established" traffic) is
     not affected by this.

  ·  This could easily lead to a Denial of Service of the remote host,
     so this outstanding ESP masq table entry is given a short lifetime,
     and only a limited number of retries of the same traffic are
     allowed. This permits round-robin access to the remote host if
     several masqueraded hosts are attempting to initialize
     simultaneously and responses aren't coming back very quickly, for
     example due to network congestion or a slow remote host.  The retry
     limitation begins once there is a collision, so the masqueraded
     IPsec host can wait as long as necessary for a reply until there's
     a need for serialization.


  ·  When an ESP packet from the outstanding remote host is received and
     the SPI value does not appear in any masq table entry, it is
     assumed that the packet is the response to the outstanding initial
     packet. The SPI value is stored in that masq table entry, thus
     associating the SPI values, and the inbound ESP traffic is routed
     to the masqueraded host. At this point another initial packet for
     the remote server may be processed.


  ·  Any ESP traffic with a zero SPI value is discarded as invalid, per
     the RFC requirements.


  There are several ways this can fail to associate traffic properly:


  ·  Network delays or a slow remote host can cause the response to the
     first initial packet to be delayed long enough that the init masq
     table entry expires and a different masqueraded host is given a
     chance to initialize. This could cause the response to be
     associated with the wrong outbound SPI, which would cause inbound
     traffic to be routed to the wrong masqueraded host. If this happens
     the masqueraded host receiving the traffic in error will discard it
     because it has an unexpected SPI value, and everybody will
     eventually time out, rekey and try again. This can be addressed by
     editing /usr/src/linux/net/ipv4/ip_masq.c (ip_masq_ipsec.c in
     2.2.x) and increasing the INIT lifetime or the number of INIT
     retries permitted, at the cost of increasing the blocking (and DoS)
     window.


  ·  Sessions idle or semi-idle (with infrequent inbound traffic and no
     outbound traffic) for a long period of time may be idle long enough
     for the masq table entry to expire. If the remote host sends
     traffic to an established yet masq-expired session while an
     outstanding init to the same remote host is underway, the traffic
     may be misrouted for the same reason as described above. This can
     be addressed by making sure the IPsec Masq Table Lifetime kernel
     configuration parameter is slightly longer than the rekey interval,
     which is the longest time any given SPI pair should be used.  The
     problem here is that you may not know all of the rekey intervals if
     you're masquerading for many remote servers, or some may have their
     rekey intervals set to unreasonably high values, such as several
     hours.


  ·  If there is a delay between a rekey and the transmission of
     outbound ESP traffic using the new SPI, and during this delay
     inbound ESP traffic using the new SPI is received, there will be no
     masq table entry describing how to route the inbound traffic. If
     another masqueraded host has a pending init with the same remote
     host, the traffic will be misassociated. Note that serialization of
     ESP initial traffic does not affect ISAKMP rekey traffic.

  The best solution is to have some way to preload the masq table with
  the properly associated out-SPI/in-SPI pair or some other mapping of
  remote_host + inbound_SPI to masqueraded_host. This cannot be done by
  inspecting the ISAKMP key exchange, as it is encrypted. It may be
  possible to use RSIP (a.k.a. Host-NAT) to communicate with the
  masqueraded IPsec host and request notification of SPI information
  once it has been negotiated. This is being investigated. If something
  is done to implement this it will be done no sooner than the 2.3.x
  series, as RSIP is a fairly complex client/server NAT protocol.

  When an inbound ESP packet with a new SPI is received the masquerading
  firewall attempts to guess which masqueraded host(s) the unassociated
  inbound traffic is intended for. If the inbound ESP traffic is not
  matched to an established session or a pending session initialization,
  then the packet is sent to the masqueraded host(s) who most recently
  rekeyed with that remote host. The "incorrect" masqueraded hosts will
  discard the traffic as being improperly encrypted, and the "correct"
  host will get its data. When the "correct" host responds, the normal
  ESP init serialization process occurs.


  The VPN HOWTO
  Arpad Magosanyi <mag@bunuel.tii.matav.hu> v0.2,7 Aug1997
  v0.3, 2001-12-01

  Archived Document Notice: This document has been archived by the LDP
  because it does not apply to modern Linux systems. It is no longer
  being actively maintained.

  1.  Changes


  The 'no controlling tty problem' -> -o 'BatchMode yes' by Zot O'Connor
  <zot@crl.com>

  warning about kernel 2.0.30 by mag

  2.  Blurb


  This is the Linux VPN howto, a collection of information on how to set
  up a Virtual Protected Network in Linux (and other unices in general).

  2.1.  Copyright


  This document is part of the Linux Documentation Project. The
  copyright notice is the following:

  The VPN mini HOWTO written by me can be copied, distributed, and/or
  modified  under the terms of the GNU Free Documentation License,
  Version 1.1 or any later version published by the Free Software
  Foundation; with the Invariant Section being the section entitled
  "About the ppp over ssh vpn technique", with any Front-Cover Text
  containing the p= hrase "Based on the work of Arpad Magosanyi", and
  with any Back-Cover Text.


  2.2.  Disclaimer


  As usual: the author not responsible for any damage. For the correct
  wording, see the relevant part of the GNU GPL 0.1.1

  2.3.  Disclaimer


  We are dealing with security: you are not safe if you haven't got good
  security policy, and other rather boring things.

  2.4.  Credits


  Thanks to all of who has written the tools used.

  Thanks to Zot O'Connor <zot@crl.com> for pointing out the "no
  controlling tty" problem, and it's solution.

  2.5.  State of this document


  This is very preliminary. You should have thorough knowledge of
  administrating IP, at least some knowledge of firewalls, ppp and ssh.
  You should know them anyway if you want to set up a VPN. I just
  decided to write down my experiences not to forget them. There are
  possibly some security holes indeed. To be fair I've tried it on hosts
  configured as routers not firewalls, saying: It's simple from that
  point.

  2.6.  Related documentations


  ·  The Linux Firewall-HOWTO /usr/doc/HOWTO/Firewall-HOWTO

  ·  The Linux PPP-HOWTO /usr/doc/HOWTO/PPP-HOWTO.gz

  ·  The ssh documentations /usr/doc/ssh/*

  ·  The Linux Network Admins' Guide

  ·  NIST Computer Security Special Publications
     http://csrc.ncsl.nist.gov/nistpubs/

  ·  Firewall list (majordomo@greatcircle.com)

  3.  Introduction


  As firewalls are in more and more widely use in internet and intranet
  security, the ability to do nice VPNs is important. Here are my
  experiences. Comments are welcome.

  3.1.  Naming conventions


  I will use the terms "master firewall" and "slave firewall", though
  making a VPN has nothing to do with client-server architecture. I
  simply refer to them as the active and passive participants of the
  connection's setup. The host which is starts the setup will be
  referred as the master, and the passive participant will be the slave.

  4.  Doing it


  4.1.  Planning


  Before you start to set up your system, you should know the networking
  details. I assume you have two firewalls protecting one intranet per
  firewall, and they are both connected to the internet. So now you
  should have two network interfaces (at least) per firewall. Take a
  sheet of paper, write down their IP addresses and network mask. You
  will need one more IP adresses per firewall for the VPN you want to do
  now. Those addresses should be outside of your existing subnets. I
  suggest using addresses from the "private" address ranges. They are
  the followings:

  ·  10.0.0.0 - 10.255.255.255

  ·  172.16.0.0 - 172.31.255.255

  ·  192.168.0.0 - 192.168.255.255

  For the sake of example, here's a sample configuration: The two
  bastions are called fellini and polanski. They have one interface for
  the internet (-out), one for the intranet (-in), and one for the vpn
  (-vpn). The addresses and netmasks:

  ·  fellini-out: 193.6.34.12 255.255.255.0

  ·  fellini-in: 193.6.35.12 255.255.255.0


  ·  fellini-vpn: 192.168.0.1 point-to-point

  ·  polanski-out: 193.6.36.12 255.255.255.0

  ·  polanski-in: 193.6.37.12 255.255.255.0

  ·  polanski-vpn: 192.168.0.2 point-to-point

  So we have the plan.

  4.2.  Gathering the tools


  You will need a

  ·  Linux firewall

  ·  kernel

  ·  very minimal configuration

  ·  ipfwadm

  ·  fwtk

  ·  Tools for the VPN

  ·  ssh

  ·  pppd

  ·  sudo

  ·  pty-redir

  Current versions:

  ·  kernel: 2.0.29 Use a stable kernel, and it must be newer than
     2.0.20, because the ping'o'death bug. At the time of writing 2.0.30
     is the last "stable" kernel, but it has some bugs. If you want to
     have the fast and cool networking code introduced in it, try a
     prepatch. the 3rd is working for me nicely.

  ·  base system: I prefer Debian. YMMV. You absolutely don't want to
     use any big packages, and you never even tought of using sendmail,
     of course. You also definitely don't want to enable telnet, ftp,
     and the 'r' commands (as usual in case of any other unix hosts).

  ·  ipfwadm: I've used 2.3.0

  ·  fwtk: I've used 1.3

  ·  ssh: >= 1.2.20. There are problems with the underlying protocol in
     the older versions.

  ·  pppd: I've used 2.2.0f for the tests, but I'm not sure if is it
     secure, this is why I turned the setuid bit off, and used sudo to
     launch it.

  ·  sudo: 1.5.2 the newest I am aware of

  ·  pty-redir: It is written by me. Try
     ftp://ftp.vein.hu/ssa/contrib/mag/pty-redir-0.1.tar.gz. Its version
     number is 0.1 now. Tell me it there is any problem with it.


  4.3.  Compile and install


  Compile or otherwise install the gathered tools. Look at every one's
  documentation (and the firewall-howto) for details. Now we have the
  tools.

  4.4.  Configure the other subsystems


  Configure your firewall rules, etc. You need to enable ssh traffic
  between the two firewll hosts. It means a connection to port 22 on the
  slave from the master. Start sshd on the slave and verify if you can
  login. This step is untested, please tell me your results.

  4.5.  Set up the accounts for the VPN


  Create an account on the slave firewall use your favourite tool (e.g.
  vi, mkdir, chown, chmod) you might create an account on the master
  also, but I think you want to set up the connection at boot time, so
  your ordinary root account will do. Can anyone point out risks on
  using the root account on the master?

  4.6.  Generate an ssh key for your master account


  Use the ssh-keygen program. Set empty password for the private key if
  you want to do automatic setup of the VPN.

  4.7.  Set up automatic ssh login for the slave account


  Copy the newly generated public key in the slave account under
  .ssh/authorized_keys, and set up file permissions like the following:

  drwx------ 2 slave slave 1024 Apr 7 23:49 ./
  drwx------ 4 slave slave 1024 Apr 24 14:05 ../
  -rwx------ 1 slave slave 328 Apr 7 03:04 authorized_keys
  -rw------- 1 slave slave 660 Apr 14 15:23 known_hosts
  -rw------- 1 slave slave 512 Apr 21 10:03 random_seed



  The first row being ~slave/.ssh, and the second is ~slave.

  4.8.  Tighten ssh security on the bastions.


  It means the followings on my setup in sshd_conf:

  PermitRootLogin no
  IgnoreRhosts yes
  StrictModes yes
  QuietMode no
  FascistLogging yes
  KeepAlive yes
  RhostsAuthentication no
  RhostsRSAAuthentication no
  RSAAuthentication yes
  PasswordAuthentication no
  PermitEmptyPasswords no



  Password authentication is turned off, so login is only possible with
  authorized keys. (You've turned off telnet and the 'r' commands of
  course).

  4.9.  Enable execution of ppp and route for both accounts.


  As the master account is the root in my case, it has nothing to do.
  For the slave account, the following lines appear in /etc/sudoers:

  Cmnd_Alias VPN=/usr/sbin/pppd,/usr/local/vpn/route
  slave ALL=NOPASSWD: VPN



  As you can see, I am using some scripts to set up ppp and the routing
  tables on the slave host.

  4.10.  Do the scripting


  On the master host there is a full-blown init script I am using:



  #! /bin/sh
  # skeleton      example file to build /etc/init.d/ scripts.
  #               This file should be used to construct scripts for /etc/init.d.
  #
  #               Written by Miquel van Smoorenburg <miquels@cistron.nl>.
  #               Modified for Debian GNU/Linux
  #               by Ian Murdock <imurdock@gnu.ai.mit.edu>.
  #
  # Version:      @(#)skeleton  1.6  11-Nov-1996  miquels@cistron.nl
  #

  PATH=/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/bin/X11/:
  PPPAPP=/home/slave/ppp
  ROUTEAPP=/home/slave/route
  PPPD=/usr/sbin/pppd
  NAME=VPN
  REDIR=/usr/local/bin/pty-redir
  SSH=/usr/bin/ssh
  MYPPPIP=192.168.0.1
  TARGETIP=192.168.0.2
  TARGETNET=193.6.37.0
  MYNET=193.6.35.0
  SLAVEWALL=polanski-out
  SLAVEACC=slave

  test -f $PPPD || exit 0

  set -e

  case "$1" in
    start)
          echo setting up vpn
          $REDIR $SSH -o 'Batchmode yes' -t -l $SLAVEACC $SLAVEWALL sudo $PPPAPP >/tmp/device
          TTYNAME=`cat /tmp/device`
  echo tty is $TTYNAME
          sleep 10s
          if [ ! -z $TTYNAME ]
          then
          $PPPD $TTYNAME ${MYPPPIP}:${TARGETIP}
          else
                  echo FAILED!
                  logger "vpn setup failed"
          fi
          sleep 5s
          route add -net $TARGETNET gw $TARGETIP
          $SSH -o 'Batchmode yes' -l $SLAVEACC $SLAVEWALL sudo $ROUTEAPP
      ;;
    stop)
          ps -ax | grep "ssh -t -l $SLAVEACC " | grep -v grep | awk '{print $1}' | xargs kill
      ;;
    *)
      # echo "Usage: /etc/init.d/$NAME {start|stop|reload}"
      echo "Usage: /etc/init.d/$NAME {start|stop}"
      exit 1
      ;;
  esac

  exit 0



  The slave uses one script for routing setup (/usr/local/vpn/route):



  #!/bin/bash
  /sbin/route add -net 193.6.35.0 gw 192.168.0.1



  and its .ppprc consists of the following:

  passive



  5.  Look at what's happening:


  The master logs in into the slave, starts pppd, and redirects this all
  thing into a local pty. It consists of the following steps:

  ·  allocating a new pty

  ·  sshing into the slave

  ·  running pppd on the slave

  ·  the master runs pppd in this local pty

  ·  and sets up the routing table on the client.

  There are (not very tight) timing considerations involved, this is why
  that 'sleep 10s'.

  6.  Doing it by hand.


  6.1.  Logging in


  You've already tried if ssh works well, aren't you? If the slave
  refuses to log you in, read the logs. Perhaps there are problems with
  file permissions or the sshd setup.

  6.2.  Firing up ppp


  Log in into slave, and issue:

  sudo /usr/sbin/pppd passive



  You should see garbage coming at this point. If it works good, if not,
  there is some problem either with sudo, either with pppd. Look what
  the commands had said, and at the logs and at the /etc/ppp/options,
  and the .ppprc file.  If it works, write this 'passive' word into
  .ppprc, and try again. To get rid off the garbage and continue
  working, press enter,'~' and '^Z'.  You should have the master's
  prompt now, and kill %1. See the section about tuning if you want to
  know more of the escape character.

  6.3.  Together the two


  Well, then



  ssh -l slave polanski sudo /usr/sbin/pppd



  should work also, and deliver the garbage right into your face.

  6.4.  Pty redirecting


  Try to redirect this whole thing this time:

  /usr/local/bin/pty-redir /usr/bin/ssh -l slave polanski sudo /usr/sbin/pppd



  Nice long sentence isn't it?  You should use the full path into the
  ssh executable, as the pty-redir program allows only this form for
  security reasons.  Now you've got a device name from the program.
  Let's say, you've got /dev/ttyp0  You can use the ps command to look
  what has happened. Look for 'p0'

  6.5.  Is anything on the device?


  Try

  /usr/sbin/pppd /dev/ttyp0 local 192.168.0.1:192.168.0.2



  to establish the connection. Look at the output of the ifconfig
  command to see if the device has established, and use ping to check
  your virtual net.

  6.6.  Setting up the routes


  Set up the routes on the master host, and on the slave also. Now you
  should be able to ping one host in one intranet from other host in the
  other intranet.  Set up the additional firewalling rules. Now as you
  have the VPN, you can set up the rules concerning the connectivity of
  the two intranets.

  7.  Tuning


  7.1.  Configuration tuning


  As I said this HOWTO is mainly a quick memo on how I had set up a VPN.
  There are things in the configuration I didn't experiment yet. These
  things will go into their place when I try them, or anyone tells me
  "it works in the following way" The most important thing is that the
  connection ppp uses is not 8-bit yet. I believe it has something to do
  either with ssh configuration or the pty setup. In this configuration
  ssh uses the tilde (~) character as an escape character. It might stop
  or slow down the communication, as any newline-tilde sequence causes
  ssh to give a prompt. Ssh documentation said:  <On most systems,
  setting the escape character to ``none'' will also make the session
  transparent even if a tty is used.> The corresponding flag to ssh is
  '-e', and you can also set it in the configuration file.


  7.2.  Bandwith vs. cicles


  Creating anything virtual comes with utilization of real-world
  resources. A VPN eats up bandwidth and computing resources. The goal
  would be to get balance between the two. You can tune it with the '-C'
  switch or the 'CompressionLevel' option. You might try using another
  cipher, but I don't recommend it. Also note that the round-trip-time
  can be longer if you use better compression. Any experiments on it are
  welcome.

  8.  Vulnerability analisis


  I try to cover here the vulnerability issues arising from this
  particular setup and VPNs in general. Any comments are warmly welcome.

  ·  sudo: Well, I'm excessively using sudo. I believe it's still safer
     than using setuid bits. It's still a backdraw of Linux that it
     hasn't got more fine-grained access control. Waiting for POSIX.6
     compatibility <http://www.xarius.demon.co.uk/software/posix6/>.
     What is worse, there are shell scripts which are getting called
     through sudo. Bad enough. Any idea out there?

  ·  pppd: It runs suid root also. It can be configured by user's
     .ppprc. There might be some nice buffer overruns in it. The bottom
     line: secure your slave account as tightly as you can.

  ·  ssh: Beware that ssh older than 1.2.20 has security holes. What is
     worse, we made a configuration such when the master account had
     been compromised, the slave account is also compromised, and wide
     open to attacks using the two sudoed programs. It is because I've
     choosen not to have password on the master's secret key to enable
     automatic setup of the VPN.

  ·  firewall: With inproperly set firewall rules on one bastion, you
     open both of the intranets. I recommend using IP masquerading (as
     setting up incorrect routes is a bit less trivial), and doing hard
     control on the VPN interfaces.



  8.1.  About the ppp over ssh VPN technique

  I developed this technique when there was no usable, standard VPN for
  Linux. Now this is no longer the case.  At the time of writing this,
  you have the following alternatives: If you want to use standard IPSEC
  VPN, you can use FreeS/WAN or pipsecd.  For PPTP you can use PoPToP
  (but be aware that PPTP protocol has weaknesses).  It is also worth to
  mention CIPE which is a lightweight alternative for IPSEC.

  This wide range of alternatives means that the ssh/ppp implementation
  described in this howto is in the most cases not the best solution.
  This is due the fact that this implementation is complex to set up and
  has performance problems because of its tcp based nature.

  I believe that the ssh/ppp technique is no longer beneficial for
  building a VPN for non-illegal purposes in most cases, so I have
  discontinued maintaining this HOWTO.

  The Linux Cipe+Masquerading mini-HOWTO
  Anthony Ciaravalo, acj@home.com
  v1.2, 21 April 1999

  How to setup a VPN using Cipe on a linux masquerading firewall.
  ______________________________________________________________________

  Table of Contents


  1. Introduction

     1.1 Copyright statement
     1.2 Disclaimer
     1.3 Feedback
     1.4 Getting the files

  2. Firewall Configuration

     2.1 VPN Network Diagram
     2.2 A little reference
     2.3 Additional notes about scripts and the VPN

  3. Machine A Specific Configuration

     3.1 /etc/cipe/options.machineB
     3.2 /etc/cipe/options.machineC
     3.3 /etc/rc.d/rc.cipe
     3.4 Gateway

  4. Machine B Specific Configuration

     4.1 /etc/cipe/options.machineA
     4.2 /etc/rc.d/rc.cipe
     4.3 Gateway

  5. Machine C Specific Configuration

     5.1 /etc/cipe/options.machineA
     5.2 /etc/rc.d/rc.cipe
     5.3 Gateway

  6. Common Machine Configuration

     6.1 /etc/cipe/ip-up
        6.1.1 Kernel 2.0, ipfwadm, cipe 1.0.x
        6.1.2 Kernel 2.1/2.2, ipchains, cipe 1.2.x
     6.2 /etc/cipe/ip-down
        6.2.1 Kernel 2.0, ipfwadm, cipe 1.0.x
        6.2.2 Kernel 2.1/2.2, ipchains, cipe 1.2.x

  7. Example masquerading firewall scripts

     7.1 Kernel 2.0, ipfwadm
     7.2 Kernel 2.1/2.2, ipchains

  8. Putting it all together

  9. Connecting to the WAN

  10. References

     10.1 Web Sites
     10.2 Documentation


  ______________________________________________________________________

  1.  Introduction

  This is the Linux Cipe+Masquerading mini-HOWTO.  It shows how to setup
  a Virtual Private Network between your LAN and other LAN's using Cipe
  on linux masquerading firewall machines.  It also shows an example
  masquerading firewall configuration.


  1.1.  Copyright statement

  C)opyright 1998, 1999 Anthony Ciaravalo, acj@home.com

  Unless otherwise stated, Linux HOWTO documents are copyrighted by
  their respective authors. Linux HOWTO documents may be reproduced and
  distributed in whole or in part, in any medium physical or electronic,
  as long as this copyright notice is retained on all copies. Commercial
  redistribution is allowed and encouraged; however, the author would
  like to be notified of any such distributions.

  All translations, derivative works, or aggregate works incorporating
  any Linux HOWTO documents must be covered under this copyright notice.
  That is, you may not produce a derivative work from a HOWTO and impose
  additional restrictions on its distribution. Exceptions to these rules
  may be granted under certain conditions; please contact the Linux
  HOWTO coordinator at the address given below.

  If you have questions, please contact Tim Bynum, the Linux HOWTO
  coordinator, at tjbynum@wallybox.cei.net or linux-
  howto@metalab.unc.edu


  1.2.  Disclaimer

  Use of the information and examples in this document is at your own
  risk.  There are many security issues involved when connecting
  networks across the internet.  Even though information is encrypted,
  an improperly configured firewall may result in a security breach.
  Precautions can be taken to protect your cipe connections, but it does
  not guarantee 100% security.  The author does not guarantee the
  information provided in this document will provide a secure networking
  environment.  Even though I have tried to be as accurate as possible
  creating this document, I am not responsible for any problems or
  damages incurred due to actions taken based on the information in this
  document.


  1.3.  Feedback

  Send questions, comments, suggestions, or corrections to acj@home.com.


  1.4.  Getting the files

  This howto was written based on Cipe versions 1.0.1 and 1.2.0.  See
  reference section for link to Cipe home page.



  2.  Firewall Configuration

  This howto assumes you already configured your kernel to support IP
  masquerade.  See references below for information on configuring your
  kernel for a linux firewall.

  2.1.  VPN Network Diagram

  This setup uses a star/hub configuration.  It will set up a cipe
  connection from Machine A to Machine B and another from Machine A to
  Machine C.



       ______________________________________________________________________

                          Machine A
                       eth0: 192.168.1.1
                       eth1: real ip 1
                      /               \
                     /                 \
            Machine B                  Machine C
          eth0: 192.168.2.1           eth0:192.168.3.1
          eth1: real ip 2             eth1: real ip 3
       ______________________________________________________________________



  2.2.  A little reference



       ______________________________________________________________________

       eth0 is the local network (fake address)
       eth1 is the internet address (real address)

       Port A is any valid port you would like to choose
       Port B is any other valid port you would like to choose

       Key A is any valid key you would like to choose  (read cipe doc for info)
       Key B is any valid key you would like to choose
       ______________________________________________________________________



  2.3.  Additional notes about scripts and the VPN

  The ip-up scripts currently only allow class c traffic through the
  cipe interface.  If you wish for machine B to communicate with Machine
  C then you will need to change the appropriate ip-up and ip-down
  scripts.  Specifically, you need to change the ptpaddr and myaddr
  netmasks.  There are two ip-up scripts, one for ipchains and one for
  ipfwadm.  Same with the ip-down scripts.  Change the appropriate
  incoming, outgoing, and forwarding cipe interface firewall rules
  netmask from /24 to /16. Any cipe firewall rule changes you make in
  ip-up for ipfwadm, make sure the ip-down script reflects the change so
  it will be properly removed from the list when the interface goes
  down.  For the ipchains file, anything added in a chain does not need
  ip-down reflection since ip-down will flush all the rules in the user
  defined chain.

  You will also need to uncomment the network route in the rc.cipe for
  Machine B and C that adds each others network to their route table.



  3.  Machine A Specific Configuration

  3.1.  /etc/cipe/options.machineB



       ______________________________________________________________________

       #uncomment 1 below
       #name for cipe 1.0.x
       #device          cip3b0
       #name for cipe 1.2.x
       device          cipcb0

       # remote internal (fake) ip address
       ptpaddr         192.168.2.1
       # my cipe (fake) ip address
       ipaddr          192.168.1.1
       # my real ip address and cipe port
       me              (real ip 1):(port A)
       # remote real ip address and cipe port
       peer            (real ip 2):(port A)
       #unique 128 bit key
       key             (Key A)
       ______________________________________________________________________



  3.2.  /etc/cipe/options.machineC



       ______________________________________________________________________

       #uncomment 1 below
       #name for cipe 1.0.x
       #device          cip3b1
       #name for cipe 1.2.x
       device          cipcb1

       # remote internal (fake) ip address
       ptpaddr         192.168.3.1
       # my cipe (fake) ip address
       ipaddr          192.168.1.1
       # my real ip address and cipe port
       me              (real ip 1):(port B)
       # remote real ip address and cipe port
       peer            (real ip 3):(port B)
       #unique 128 bit key
       key             (Key B)
       ______________________________________________________________________



  3.3.  /etc/rc.d/rc.cipe



  ______________________________________________________________________

  !#/bin/bash
  #rc.cipe  3/29/1999
  #Send questions or comments to acj@home.com.

  #Setup script path
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #Options filenames in cipe directory for cipe interfaces
  options="options.machineB options.machineC"

  #Automatically obtain options filenames from cipe directory
  #options=`/bin/ls /etc/cipe/options.*`

  #Uncomment 1 below for the cipe module name
  #cipemod="cip3b"        #for cipe 1.0
  cipemod="cipcb"        #for cipe 1.2

  #Check for cipe module and load if not already loaded
  grep $cipemod /proc/modules >/dev/null
  if [ "$?" = "1" ]; then
          echo Loading cipe module.
          modprobe $cipemod
          if [ "$?" = "1" ]; then
                  echo Error loading cipe module...exiting.
                  exit
          fi
  else
          echo Cipe module already loaded.
  fi

  #Remove any existing cipe interfaces
  cipeif=`cat /proc/net/dev | cut -f1 -d: | grep $cipemod`

  if [ "$cipeif" != "" ]; then
          echo Removing existing cipe interface(s).
          for i in $cipeif; do
                  ifconfig $i down
          done
  fi

  #Setup cipe interfaces
  echo -n "Setting up cipe interface(s): "
  for config in $options; do
          echo -n $config" "
          ciped -o $config
  done
  echo
  echo

  #Add routes for other remote networks via cipe interface(s)
  #route add -net x.x.x.x netmask x.x.x.x gw x.x.x.x

  ______________________________________________________________________



  3.4.  Gateway

  All machines on network 192.168.1.0 must have 192.168.1.1 as gateway.
  If you don't it will not work.


  4.  Machine B Specific Configuration

  4.1.  /etc/cipe/options.machineA



       ______________________________________________________________________

       #uncomment 1 below
       #name for cipe 1.0.x
       #device          cip3b0
       #name for cipe 1.2.x
       device          cipcb0

       #remote internal (fake) ip address
       ptpaddr         192.168.1.1
       # my cipe (fake) ip address
       ipaddr          192.168.2.1
       # my real ip address and cipe port
       me              (real ip 1):(port A)
       # remote real ip address and cipe port
       peer            (real ip 2):(port A)
       #unique 128 bit key
       key             (Key A)
       ______________________________________________________________________



  4.2.  /etc/rc.d/rc.cipe



  ______________________________________________________________________



  !#/bin/bash
  #rc.cipe  3/29/1999
  #Send questions or comments to acj@home.com.

  #Setup script path
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #Options filenames in cipe directory for cipe interfaces
  options="options.machineA"

  #Automatically obtain options filenames from cipe directory
  #options=`/bin/ls /etc/cipe/options.*`

  #Uncomment 1 below for the cipe module name
  #cipemod="cip3b"        #for cipe 1.0
  cipemod="cipcb"        #for cipe 1.2

  #Check for cipe module and load if not already loaded
  grep $cipemod /proc/modules >/dev/null
  if [ "$?" = "1" ]; then
          echo Loading cipe module.
          modprobe $cipemod
          if [ "$?" = "1" ]; then
                  echo Error loading cipe module...exiting.
                  exit
          fi
  else
          echo Cipe module already loaded.
  fi

  #Remove any existing cipe interfaces
  cipeif=`cat /proc/net/dev | cut -f1 -d: | grep $cipemod`

  if [ "$cipeif" != "" ]; then
          echo Removing existing cipe interface(s).
          for i in $cipeif; do
                  ifconfig $i down
          done
  fi

  #Setup cipe interfaces
  echo -n "Setting up cipe interface(s): "
  for config in $options; do
          echo -n $config" "
          ciped -o $config
  done
  echo
  echo

  #Add routes for other remote networks via cipe interface(s)
  #route add -net x.x.x.x netmask x.x.x.x gw x.x.x.x
  #route to machine C network
  #route add -net 192.168.3.0 netmask 255.255.255.0 gw 192.168.3.1
  ______________________________________________________________________



  4.3.  Gateway

  All machines on network 192.168.2.0 must have 192.168.2.1 as gateway.
  If you don't it will not work.



  5.  Machine C Specific Configuration

  5.1.  /etc/cipe/options.machineA



       ______________________________________________________________________

       #uncomment 1 below
       #name for cipe 1.0.x
       #device          cip3b0
       #name for cipe 1.2.x
       device          cipcb0

       #remote internal (fake) ip address
       ptpaddr         192.168.1.1
       # my cipe (fake) ip address
       ipaddr          192.168.3.1
       # my real ip address and cipe port
       me              (real ip 3):(port B)
       #remote real ip address and cipe port
       peer            (real ip 1):(port B)
       #unique 128 bit key
       key             (Key B)
       ______________________________________________________________________



  5.2.  /etc/rc.d/rc.cipe



  ______________________________________________________________________

  !#/bin/bash
  #rc.cipe  3/29/1999
  #Send questions or comments to acj@home.com.

  #Setup script path
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #Options filenames in cipe directory for cipe interfaces
  options="options.machineA"

  #Automatically obtain options filenames from cipe directory
  #options=`/bin/ls /etc/cipe/options.*`

  #Uncomment 1 below for the cipe module name
  #cipemod="cip3b"        #for cipe 1.0
  cipemod="cipcb"        #for cipe 1.2

  #Check for cipe module and load if not already loaded
  grep $cipemod /proc/modules >/dev/null
  if [ "$?" = "1" ]; then
          echo Loading cipe module.
          modprobe $cipemod
          if [ "$?" = "1" ]; then
                  echo Error loading cipe module...exiting.
                  exit
          fi
  else
          echo Cipe module already loaded.
  fi

  #Remove any existing cipe interfaces
  cipeif=`cat /proc/net/dev | cut -f1 -d: | grep $cipemod`

  if [ "$cipeif" != "" ]; then
          echo Removing existing cipe interface(s).
          for i in $cipeif; do
                  ifconfig $i down
          done
  fi

  #Setup cipe interfaces
  echo -n "Setting up cipe interface(s): "
  for config in $options; do
          echo -n $config" "
          ciped -o $config
  done
  echo
  echo

  #Add routes for other remote networks via cipe interface(s)
  #route add -net x.x.x.x netmask x.x.x.x gw x.x.x.x
  #route to machine B network
  #route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.2.1
  ______________________________________________________________________



  5.3.  Gateway

  All machines on network 192.168.2.0 must have 192.168.2.1 as gateway.
  If you don't it will not work.

  6.  Common Machine Configuration

  6.1.  /etc/cipe/ip-up

  6.1.1.  Kernel 2.0, ipfwadm, cipe 1.0.x



  ______________________________________________________________________

  #!/bin/bash
  # ip-up <interface> <myaddr> <daemon-pid> <local> <remote> <arg>
  #3/29/1999
  #An example ip-up script for the older 1.x 2.x kernels using ipfwadm that
  #will setup routes and firewall rules to connect your local class c network
  #to a remote class c network.

  #The rules are configured to prevent spoofing and stuffed routing between
  #the networks.  There are also additional security enhancements commented
  #out towards the bottom of the script.
  #Send questions or comments to acj@home.com.

  #--------------------------------------------------------------------------
  #Set some script variables
  device=$1               # the CIPE interface
  me=$2                   # our UDP address
  pid=$3                  # the daemon's process ID
  ipaddr=$4               # IP address of our CIPE device
  vptpaddr=$5              # IP address of the remote CIPE device
  option=$6               # argument supplied via options

  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #comment/uncomment to enable/disbale kernel logging for all unauthorized
  #access attempts. Must be same as ip-down script in order to remove rules.
  log="-o"

  #--------------------------------------------------------------------------
  umask 022

  # just a logging example
  #echo "UP   $*" >> /var/adm/cipe.log

  # many systems like these pid files
  #echo $3 > /var/run/$device.pid

  #--------------------------------------------------------------------------

  #add route entry for remote cipe network
  network=`expr $ptpaddr : '\([0-9]*\.[0-9]*\.[0-9]*\.\)'`0
  route add -net $network netmask 255.255.255.0 dev $device

  #need to add route entry for host in 2.0 kernels
  route add -host $ptpaddr dev $device

  #--------------------------------------------------------------------------
  #cipe interface incoming firewall rules
  #must be inserted into list in reverse order

  #deny all other incoming packets to cipe interface
  ipfwadm -I -i deny -W $device -S 0/0 -D 0/0 $log

  #accept incoming packets from remotenet to localnet on cipe interface
  ipfwadm -I -i accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #accept incoming packets from localnet to remotenet on cipe interface
  ipfwadm -I -i accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #deny incoming packets, cipe interface, claiming to be from localnet; log
  ipfwadm -I -i deny -W $device -S $ipaddr/24 -D $ipaddr/24 $log

  #--------------------------------------------------------------------------
  #cipe interface outgoing firewall rules
  #must be inserted into list in reverse order
  #deny all other outgoing packets from cipe interface
  ipfwadm -O -i deny -W $device -S 0/0 -D 0/0 $log

  #accept outgoing from remotenet to localnet on cipe interface
  ipfwadm -O -i accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #accept outgoing from localnet to remotenet on cipe interface
  ipfwadm -O -i accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #deny outgoing to localnet from localnet, cipe interface, deny; log
  ipfwadm -O -i deny -W $device -S $ipaddr/24 -D $ipaddr/24 $log

  #--------------------------------------------------------------------------
  #The forwarding is configured so machines on your local network do not get
  #masqueraded to the remote network.  This provides better access control
  #between networks.  Must be inserted into list in reverse order

  #deny all other forwarding through cipe interface; log
  ipfwadm -F -i deny -W $device -S 0/0 -D 0/0 $log

  #accept forwarding from remotenet to localnet on cipe interfaces
  ipfwadm -F -i accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #accept forwarding from localnet to remotenet on cipe interfaces
  ipfwadm -F -i accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #--------------------------------------------------------------------------
  #Make sure forwarding is enabled in the kernel. The kernel by default may
  #have forwarding disabled.
  /bin/echo 1 > /proc/sys/net/ipv4/ip_forward

  #--------------------------------------------------------------------------
  #Optional security enhancement - set default forward policy to
  #DENY or REJECT.  If your forwarding default policy is DENY/REJECT
  #you will need to add the following rules to your main forward chain.  It
  #is a good idea to have all default policies set for DENY or
  #REJECT.

  #define machine interfaces
  #localif="eth0"
  #staticif="eth1"                ;cable modem users
  #staticif="ppp0"                ;dialup users

  #a real sloppy way to get the peer ip address from the options file - a new
  #argument with peer ip:port passed to script would be nice.
  #both lines need to be uncommented
  #peerfile=`grep $device /etc/cipe/options.* | cut -f1 -d:`
  #peer=`grep peer $peerfile | cut -f1 -d: | awk '{print $2}'`

  #must log peer ip address for ip-down script
  #echo $peer > /var/run/$device.peerip

  #accept forwarding from localnet to remotenet on internal network interface
  #ipfwadm -F -i accept -W $localif -S $ipaddr/24 -D $ptpaddr/24
  #accept forwarding from remotenet to localnet on internal network interface
  #ipfwadm -F -i accept -W $localif -S $ptpaddr/24 -D $ipaddr/24
  #accept forwarding on staticif from me to peer
  #myaddr=`echo $me | cut -f1 -d:`
  #ipfwadm -F -i accept -W $staticif -S $myaddr -D $peer
  #--------------------------------------------------------------------------
  #Other optional security enhancement
  #block all incoming requests from everywhere to our cipe udp port
  #except our peer's udp port

  #need to determine udp ports for the cipe interfaces
  #get our udp port
  #if [ "$option" = "" ]; then
  #       myport=`echo $me | cut -f2 -d:`
  #else
  #       myport=$option
  #fi

  #get remote udp port -- peerfile variable must be set above
  #peerport=`grep peer $peerfile | cut -f2 -d:`

  #must log peer udp port for ip-down script
  #echo $peerport > /var/run/$device.peerport

  #get our ip address
  #myaddr=`echo $me | cut -f1 -d:`

  #deny and log all requests to cipe udp port must be inserted first
  #ipfwadm -I -i deny -P udp -W $staticif -S 0/0 -D $myaddr $myport $log
  #accept udp packets from peer at udp cipe port to my udp cipe port
  #ipfwadm -I -i accept -P udp -W $staticif -S $peer $peerport \
  #-D $myaddr $myport

  exit 0
  ______________________________________________________________________



  6.1.2.  Kernel 2.1/2.2, ipchains, cipe 1.2.x



  ______________________________________________________________________

  #!/bin/bash
  # ip-up <interface> <myaddr> <daemon-pid> <local> <remote> <arg>
  #3/29/1999
  #An example ip-up script for the newer 2.1/2.2 kernels using ipchains that
  #will setup routes and firewall rules to connect your local class c network
  #to a remote class c network.  This script creates 3 user defined chains
  #-input, output, and forward - for each cipe interface, based on the
  #interface name. It will then insert a rule into each of the built-in
  #input, output, and forward chains to use the user defined chains. The
  #rules are configured to prevent spoofing and stuffed routing between the
  #networks. There are also additional security enhancements commented out
  #towards the bottom of the script.
  #Send questions or comments to acj@home.com.

  #--------------------------------------------------------------------------

  #Set some script variables
  device=$1               # the CIPE interface
  me=$2                   # our UDP address
  pid=$3                  # the daemon's process ID
  ipaddr=$4               # IP address of our CIPE device
  ptpaddr=$5              # IP address of the remote CIPE device
  option=$6               # argument supplied via options

  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #comment/uncomment to enable/disbale kernel logging for all unauthorized
  #access attempts. Must be same as ip-down script in order to remove rules.
  log="-l"

  #--------------------------------------------------------------------------
  umask 022
  # just a logging example
  #echo "UP   $*" >> /var/adm/cipe.log

  # many systems like these pid files
  #echo $3 > /var/run/$device.pid

  #--------------------------------------------------------------------------
  #add route entry for remote cipe network
  network=`expr $ptpaddr : '\([0-9]*\.[0-9]*\.[0-9]*\.\)'`0
  route add -net $network netmask 255.255.255.0 dev $device

  #--------------------------------------------------------------------------
  #create new ipchain for cipe interface input rules
  ipchains -N $device"i"
  #flush all rules in chain (sanity flush)
  ipchains -F $device"i"
  #deny incoming packets, cipe interface, claiming to be from localnet; log
  ipchains -A $device"i" -j DENY -i $device -s $ipaddr/24 -d $ipaddr/24 $log
  #accept incoming packets from localnet to remotenet on cipe interface
  ipchains -A $device"i" -j ACCEPT -i $device -s $ipaddr/24 -d $ptpaddr/24
  #accept incoming packets from remotenet to localnet on cipe interface
  ipchains -A $device"i" -j ACCEPT -i $device -s $ptpaddr/24 -d $ipaddr/24
  #deny all other incoming packets
  ipchains -A $device"i" -j DENY -s 0/0 -d 0/0 $log

  #--------------------------------------------------------------------------
  #create new ipchain for cipe interface output rules
  ipchains -N $device"o"
  #flush all rules in chain (sanity flush)
  ipchains -F $device"o"
  #deny outgoing to localnet from localnet, cipe interface, deny; log
  ipchains -A $device"o" -j DENY -i $device -s $ipaddr/24 -d $ipaddr/24 $log
  #accept outgoing from localnet to remotenet on cipe interface
  ipchains -A $device"o" -j ACCEPT -i $device -s $ipaddr/24 -d $ptpaddr/24
  #accept outgoing from remotenet to localnet on cipe interface
  ipchains -A $device"o" -j ACCEPT -i $device -s $ptpaddr/24 -d $ipaddr/24
  #deny all other outgoing packets
  ipchains -A $device"o" -j DENY -s 0/0 -d 0/0 $log

  #--------------------------------------------------------------------------
  #The forward chain is configured so machines on your local network do not
  #get masqueraded to the remote network.  This provides better access
  #control between networks.

  #create new ipchain for cipe interface forward rules
  ipchains -N $device"f"
  #flush all rules in chain (sanity flush)
  ipchains -F $device"f"
  #accept forwarding from localnet to remotenet on cipe interfaces
  ipchains -A $device"f" -j ACCEPT -i $device -s $ipaddr/24 -d $ptpaddr/24
  #accept forwarding from remotenet to localnet on cipe interfaces
  ipchains -A $device"f" -j ACCEPT -i $device -s $ptpaddr/24 -d $ipaddr/24
  #deny all other forwarding; log
  ipchains -A $device"f" -j DENY -s 0/0 -d 0/0 $log

  #--------------------------------------------------------------------------
  #Make sure forwarding is enabled in the kernel. New kernels by default have
  #forwarding disabled.
  /bin/echo 1 > /proc/sys/net/ipv4/ip_forward

  #--------------------------------------------------------------------------
  #insert rules to main input, output, and forward chains to enable new rules
  #for the cipe interface
  ipchains -I input -i $device -j $device"i"
  ipchains -I output -i $device -j $device"o"
  ipchains -I forward -i $device -j $device"f"

  #--------------------------------------------------------------------------
  #Optional security enhancement - set built-in forward chain policy to
  #DENY or REJECT.  If your main forward chain default policy is DENY/REJECT
  #you will need to add the following rules to your main forward chain.  It
  #is a good idea to have all built-in chain default policies set for DENY or
  #REJECT.

  #define machine interfaces
  #localif="eth0"
  #staticif="eth1"                ;cable modem users
  #staticif="ppp0"                ;dialup users

  #a real sloppy way to get the peer ip address from the options file - a new
  #argument with peer ip:port passed to script would be nice.
  #both lines need to be uncommented
  #peerfile=`grep $device /etc/cipe/options.* | cut -f1 -d:`
  #peer=`grep peer $peerfile | cut -f1 -d: | awk '{print $2}'`

  #must log peer ip address for ip-down script
  #echo $peer > /var/run/$device.peerip

  #accept forwarding from localnet to remotenet on internal network interface
  #ipchains -I forward -j ACCEPT -i $localif -s $ipaddr/24 -d $ptpaddr/24
  #accept forwarding from remotenet to localnet on internal network interface
  #ipchains -I forward -j ACCEPT -i $localif -s $ptpaddr/24 -d $ipaddr/24
  #accept forwarding on staticif from me to peer
  #myaddr=`echo $me | cut -f1 -d:`
  #ipchains -I forward -j ACCEPT -i $staticif -s $myaddr -d $peer
  #--------------------------------------------------------------------------
  #Other optional security enhancement
  #block all incoming requests from everywhere to our cipe udp port
  #except our peer's udp port

  #need to determine udp ports for the cipe interfaces
  #get our udp port
  #if [ "$option" = "" ]; then
  #       myport=`echo $me | cut -f2 -d:`
  #else
  #       myport=$option
  #fi

  #get remote udp port -- peerfile variable must be set above
  #peerport=`grep peer $peerfile | cut -f2 -d:`

  #must log peer udp port for ip-down script
  #echo $peerport > /var/run/$device.peerport

  #get our ip address
  #myaddr=`echo $me | cut -f1 -d:`

  #deny and log all requests to cipe udp port must be inserted first
  #ipchains -I input -j DENY -p udp -i $staticif -s 0/0 \
  #-d $myaddr $myport $log
  #accept udp packets from peer at udp cipe port to my udp cipe port
  #ipchains -I input -j ACCEPT -p udp -i $staticif -s $peer $peerport \
  # -d $myaddr $myport

  #--------------------------------------------------------------------------
  # Set up spoofing protection in kernel as an additional security measure
  #--------------------------------------------------------------------------
  #Why do I have spoofing protection in the firewall rules in addition to
  #this script that sets up spoof protection for each interface in the
  #kernel? Guess I'm paranoid.

  if [ -e /proc/sys/net/ipv4/conf/all/rp_filter ]; then
          echo -n "Setting up IP spoofing protection..."
          iface="/proc/sys/net/ipv4/conf/$device/rp_filter"
          echo 1 > $iface
          echo "done."
  else
          echo "Cannot setup spoof protection in kernel for $device" \
                  | mail -s"Security Warning: $device" root
          exit 1
  fi

  exit 0
  ______________________________________________________________________



  6.2.  /etc/cipe/ip-down

  6.2.1.  Kernel 2.0, ipfwadm, cipe 1.0.x



  ______________________________________________________________________

  #!/bin/bash

  # ip-down <interface> <myaddr> <daemon-pid> <local> <remote> <arg>
  #3/29/1999
  #An example ip-down script for the older 1.x 2.x kernels using ipfwadm that
  #will remove firewall rules that were setup to connect your local class c
  #network to a remote class c network.

  #--------------------------------------------------------------------------
  #Set some script variables
  device=$1               # the CIPE interface
  me=$2                   # our UDP address
  pid=$3                  # the daemon's process ID
  ipaddr=$4               # IP address of our CIPE device
  ptpaddr=$5              # IP address of the remote CIPE device
  option=$6               # argument supplied via options

  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #comment/uncomment to enable/disbale kernel logging for all unauthorized
  #access attempts. Must be same as ip-down script in order to remove rules.
  log="-o"

  #--------------------------------------------------------------------------
  umask 022

  # just a logging example
  #echo "DOWN   $*" >> /var/adm/cipe.log

  # many systems like these pid files
  #rm -f /var/run/$device.pid

  #--------------------------------------------------------------------------
  #cipe interface incoming firewall rules

  #delete (deny all other incoming packets to cipe interface)
  ipfwadm -I -d deny -W $device -S 0/0 -D 0/0 $log

  #delete (accept incoming packets from remotenet to localnet on cipe
  #interface)
  ipfwadm -I -d accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #delete (accept incoming packets from localnet to remotenet on cipe
  #interface)
  ipfwadm -I -d accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #delete (deny incoming packets, cipe interface, claiming to be from
  #localnet and log)
  ipfwadm -I -d deny -W $device -S $ipaddr/24 -D $ipaddr/24 $log

  #--------------------------------------------------------------------------
  #cipe interface incoming firewall rules

  #delete (deny all other outgoing packets from cipe interface)
  ipfwadm -O -d deny -W $device -S 0/0 -D 0/0 $log

  #delete (accept outgoing from remotenet to localnet on cipe interface)
  ipfwadm -O -d accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #delete (accept outgoing from localnet to remotenet on cipe interface)
  ipfwadm -O -d accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #delete (deny outgoing to localnet from localnet, cipe interface, deny
  #and log)
  ipfwadm -O -d deny -W $device -S $ipaddr/24 -D $ipaddr/24 $log

  #--------------------------------------------------------------------------
  #cipe interface forwarding firewall rules

  #delete (deny all other forwarding through cipe interface; log)
  ipfwadm -F -d deny -W $device -S 0/0 -D 0/0 $log

  #delete (accept forwarding from remotenet to localnet on cipe interfaces)
  ipfwadm -F -d accept -W $device -S $ptpaddr/24 -D $ipaddr/24

  #delete (accept forwarding from localnet to remotenet on cipe interfaces)
  ipfwadm -F -d accept -W $device -S $ipaddr/24 -D $ptpaddr/24

  #--------------------------------------------------------------------------
  #Optional security enhancement - set default forward policy to
  #DENY or REJECT.  If your forwarding default policy is DENY/REJECT
  #you will need to add the following rules to your main forward chain.  It
  #is a good idea to have all default policies set for DENY or
  #REJECT.

  #define machine interfaces
  #localif="eth0"
  #staticif="eth1"                ;cable modem users
  #staticif="ppp0"                ;dialup users

  #a real sloppy way to get the peer ip address from the options file - a new
  #argument with peer ip:port passed to script would be nice.
  #both lines need to be uncommented
  #peerfile=`grep $device /etc/cipe/options.* | cut -f1 -d:`
  #peer=`grep peer $peerfile | cut -f1 -d: | awk '{print $2}'`

  #must log peer ip address for ip-down script
  #echo $peer > /var/run/$device.peerip

  #delete (accept forwarding from localnet to remotenet on internal network
  interface)
  #ipfwadm -F -d accept -W $localif -S $ipaddr/24 -D $ptpaddr/24
  #delete (accept forwarding from remotenet to localnet on internal network
  interface)
  #ipfwadm -F -d accept -W $localif -S $ptpaddr/24 -D $ipaddr/24
  #delete (accept forwarding on staticif from me to peer)
  #myaddr=`echo $me | cut -f1 -d:`
  #ipfwadm -F -d accept -W $staticif -S $myaddr -D $peer
  #--------------------------------------------------------------------------
  #Other optional security enhancement
  #block all incoming requests from everywhere to our cipe udp port
  #except our peer's udp port

  #need to determine udp ports for the cipe interfaces
  #get our udp port
  #if [ "$option" = "" ]; then
  #       myport=`echo $me | cut -f2 -d:`
  #else
  #       myport=$option
  #fi

  #get remote udp port -- peerfile variable must be set above
  #peerport=`grep peer $peerfile | cut -f2 -d:`

  #must log peer udp port for ip-down script
  #echo $peerport > /var/run/$device.peerport

  #get our ip address
  #myaddr=`echo $me | cut -f1 -d:`

  #delete (deny and log all requests to cipe udp port must be inserted first)
  #ipfwadm -I -d deny -P udp -W $staticif -S 0/0 -D $myaddr $myport $log
  #delete (accept udp packets from peer at udp cipe port to my udp cipe port)
  #ipfwadm -I -d accept -P udp -W $staticif -S $peer $peerport \
  #-D $myaddr $myport

  exit 0
  ______________________________________________________________________



  6.2.2.  Kernel 2.1/2.2, ipchains, cipe 1.2.x



  ______________________________________________________________________

  #!/bin/sh
  # ip-down <interface> <myaddr> <daemon-pid> <local> <remote> <arg>
  #3/29/1999
  #An example ip-down script for the newer 2.1/2.2 kernels using ipchains
  #that will remove firewall rules that were setup to connect your local
  #class c network to a remote class c network.  Optional security
  #enhancement rules removal is also added and commented towards end of
  #script.
  #Send questions or comments to acj@home.com.

  #--------------------------------------------------------------------------
  #Set some script variables
  device=$1               # the CIPE interface
  me=$2                   # our UDP address
  pid=$3                  # the daemon's process ID
  ipaddr=$4               # IP address of our CIPE device
  ptpaddr=$5              # IP address of the remote CIPE device
  option=$6               # argument supplied via options
  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #comment/uncomment to enable/disbale kernel logging for all unauthorized
  #access attempts
  #must be same as ip-up script in order to remove rules
  log="-l"

  #--------------------------------------------------------------------------
  umask 022

  # Logging example
  #echo "DOWN $*" >> /var/adm/cipe.log

  # remove the daemon pid file
  #rm -f /var/run/$device.pid

  #--------------------------------------------------------------------------
  #remove rules from main input, output, and forward chains for cipe
  #interface
  ipchains -D input -i $device -j $device"i"
  ipchains -D output -i $device -j $device"o"
  ipchains -D forward -i $device -j $device"f"

  #--------------------------------------------------------------------------
  #flush all rules in cipe interface input chain
  ipchains -F $device"i"
  #remove cipe interface input chain
  ipchains -X $device"i"

  #--------------------------------------------------------------------------
  #flush all rules in cipe interface output chain
  ipchains -F $device"o"
  #remove cipe interface output chain
  ipchains -X $device"o"

  #--------------------------------------------------------------------------
  #flush all rules in cipe interface forward chain
  ipchains -F $device"f"
  #remove cipe interface forward chain
  ipchains -X $device"f"

  #--------------------------------------------------------------------------
  #Remove optional security enhancement rules

  #get peer ip address
  #peer=`cat /var/run/$device.peerip`
  #define machine interfaces
  #localif="eth0"
  #staticif="eth1"                ;cable modem users
  #staticif="ppp0"                ;dialup users

  #get our ip address
  #myaddr=`echo $me |cut -f1 -d:`

  #delete (accept forwarding from localnet to remotenet on internal network
  #interface)
  #ipchains -D forward -j ACCEPT -i $localif -s $ipaddr/24 -d $ptpaddr/24
  #delete (accept forwarding from remotenet to localnet on internal network
  #interface)
  #ipchains -D forward -j ACCEPT -i $localif -s $ptpaddr/24 -d $ipaddr/24
  #delete (accept forwarding on staticif from me to peer)
  #ipchains -D forward -j ACCEPT -i $staticif -s $myaddr -d $peer

  #remove peer ip file
  #rm /var/run/$device.peerip

  #--------------------------------------------------------------------------
  #Remove other optional security enhancement rules

  #get peer udp port
  #peerport=`cat /var/run/$device.peerport`

  #get our udp port
  #if [ "$option" = "" ]; then
  #        myport=`echo $me | cut -f2 -d:`
  #else
  #        myport=$option
  #fi

  #delete (deny and log all requests to cipe udp port must be inserted first)
  #ipchains -D input -j DENY -p udp -i $staticif -s 0/0 \
  #-d $myaddr $myport $log
  #delete (accept udp packets from peer at udp cipe port to my udp cipe port)
  #ipchains -D input -j ACCEPT -p udp -i $staticif -s $peer $peerport \
  #-d $myaddr $myport

  #remove peer port file
  #rm /var/run/$device.peerport

  #--------------------------------------------------------------------------

  exit 0
  ______________________________________________________________________



  7.  Example masquerading firewall scripts

  7.1.  Kernel 2.0, ipfwadm



  ______________________________________________________________________

  #!/bin/sh
  #04/04/1999
  #example rc.firewall script for the 2.0 kernels using ipfwadm
  #I cant take full credit for this script.  I had found it a few
  #years ago and made slight modifications.
  #Send questions or comments to acj@home.com.

  #---------------------------------------------------------------------
  #Variables
  #---------------------------------------------------------------------

  #local ethernet interface
  localip=
  localif=eth0

  #static ethernet interface
  staticip=
  staticif=eth1

  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #---------------------------------------------------------------------
  #Incoming Firewall Policies
  #---------------------------------------------------------------------
  #flush incoming firewall policies
  /sbin/ipfwadm -I -f

  #set incoming firewall policy default to deny
  /sbin/ipfwadm -I -p deny

  #---------------------------------------------------------------------

  #local interface, local machines, going anywhere is valid
  /sbin/ipfwadm -I -a accept -V $localip -S $localip/24 -D 0.0.0.0/0
  #remote interface, claiming to be local machines (IP spoofing) deny and log
  /sbin/ipfwadm -I -a deny -V $staticip -S $localip/24 -D 0.0.0.0/0 -o
  #remote interface, any source, going to staticip address is valid
  /sbin/ipfwadm -I -a accept -V $staticip -S 0.0.0.0/0 -D $staticip/32
  #loopback interface is valid
  /sbin/ipfwadm -I -a accept -V 127.0.0.1 -S 0.0.0.0/0 -D 0.0.0.0/0
  #all other incoming is denied and logged
  /sbin/ipfwadm -I -a deny -S 0.0.0.0/0 -D 0.0.0.0/0 -o

  #---------------------------------------------------------------------
  #Outgoing Firewall Policies
  #---------------------------------------------------------------------

  #flush outgoing firewall policies
  /sbin/ipfwadm -O -f

  #set outgoing firewall policy default to deny
  /sbin/ipfwadm -O -p deny

  #---------------------------------------------------------------------

  #local interface, any source going to local net is valid
  /sbin/ipfwadm -O -a accept -V $localip -S 0.0.0.0/0 -D $localip/24
  #outgoing to localnet on static interface, stuffed routing, deny
  /sbin/ipfwadm -O -a deny -V $staticip -S 0.0.0.0/0 -D $localip/24 -o
  #outgoing from localnet on static interface, stuffed masquerading, deny
  /sbin/ipfwadm -O -a deny -V $staticip -S $localip/24 -D 0.0.0.0/0 -o
  #outgoing to localnet on static interface, stuffed masquerading, deny
  /sbin/ipfwadm -O -a deny -V $staticip -S 0.0.0.0/0 -D $localip/24 -o
  #anything else outgoing on remote interface is valid
  /sbin/ipfwadm -O -a accept -V $staticip -S $staticip/32 -D 0.0.0.0/0
  #loopback interface is valid
  /sbin/ipfwadm -O -a accept -V 127.0.0.1 -S 0.0.0.0/0 -D 0.0.0.0/0
  #all other outgoing is denied and logged
  /sbin/ipfwadm -O -a deny -S 0.0.0.0/0 -D 0.0.0.0/0 -o

  #--------------------------------------------------------------------------
  #Forwarding firewall policies
  #--------------------------------------------------------------------------

  #flush forwarding policies
  /sbin/ipfwadm -F -f

  #set forwarding policy default to deny
  /sbin/ipfwadm -F -p deny

  #masquerade from localnet on local interface to anywhere
  /sbin/ipfwadm -F -a masquerade -W $staticif -S $localip/24 -D 0.0.0.0/0
  #all other forwarding is denied
  /sbin/ipfwadm -F -a deny -S 0.0.0.0/0 -D 0.0.0.0/0

  exit 0
  ______________________________________________________________________



  7.2.  Kernel 2.1/2.2, ipchains



  ______________________________________________________________________

  #!/bin/sh
  #04/04/1999
  #example rc.firewall script for the newer 2.1/2.2 kernels using ipchains
  #that creates user defined chains for each interface.  There are firewall
  #rules for spoofing protection which may be unnecessary since the newer
  #kernels can have kernel spoofing protection enabled.  You might say it's
  #super paranoid checking.
  #Send questions or comments to acj@home.com.

  #---------------------------------------------------------------------
  #Variables
  #---------------------------------------------------------------------

  #local ethernet interface
  localip=
  localif=eth0

  #static ethernet interface
  staticip=
  staticif=eth1

  #loopback interface
  loopback=lo

  PATH="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

  #---------------------------------------------------------------------
  #Flush built-in input, output, and forward ipchains; set default policy
  #Good policy to deny all packets especially while setting up chains
  #---------------------------------------------------------------------

  #set incoming firewall policy default to deny
  ipchains -P input DENY

  #flush incoming firewall policies
  ipchains -F input

  #---------------------------------------------------------------------

  #set outgoing firewall policy default to deny
  ipchains -P output DENY

  #flush outgoing firewall policies
  ipchains -F output

  #---------------------------------------------------------------------

  #set forwarding firewall policy default to deny
  ipchains -P forward DENY

  #flush forwarding firewall policies
  ipchains -F forward

  #---------------------------------------------------------------------
  #flush all policies  -redundant for main policies, but also flushes user
  #defined policies
  #ipchains -F

  #remove all user defined policies - you may or may not want to enable this
  #ipchains -X

  #---------------------------------------------------------------------
  #Incoming Firewall Policies
  #---------------------------------------------------------------------
  #create new input chain for static ethernet interface
  ipchains -N $staticif"-i"

  #flush all rules in chain (sanity flush)
  ipchains -F $staticif"-i"

  #block incoming tcp SYN packets to all ports on staticif and log
  #this may be a little harsh but its a nice feature
  #ipchains -A $staticif"-i" -j DENY -p tcp -y -i $staticif -s 0/0 \
  #-d $staticip : -l

  #remote interface, claiming to be local machines (IP spoofing) deny and log
  ipchains -A $staticif"-i" -j DENY -i $staticif -s $localip/16 -d 0/0 -l

  #remote interface, any source, going to staticip address is valid
  ipchains -A $staticif"-i" -j ACCEPT -i $staticif -s 0/0 -d $staticip/32

  #all other incoming is denied and logged
  ipchains -A $staticif"-i" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new input chain for local ethernet interface
  ipchains -N $localif"-i"

  #flush all rules in chain (sanity flush)
  ipchains -F $localif"-i"

  #local interface, local machines, going anywhere is valid
  ipchains -A $localif"-i" -j ACCEPT -i $localif -s $localip/24 -d 0/0

  #all other incoming is denied and logged
  ipchains -A $localif"-i" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new input chain for loopback interface
  ipchains -N $loopback"-i"

  #flush all rules in chain (sanity flush)
  ipchains -F $loopback"-i"

  #loopback interface is valid
  ipchains -A $loopback"-i" -j ACCEPT -i $loopback -s 0/0 -d 0/0

  #all other incoming is denied and logged
  ipchains -A $loopback"-i" -j DENY -s 0/0 -d 0/0 -l

  #--------------------------------------------------------------------------
  #Forwarding firewall policies
  #--------------------------------------------------------------------------

  #create new forward chain for static ethernet interface
  ipchains -N $staticif"-f"

  #flush all rules in chain (sanity flush)
  ipchains -F $staticif"-f"

  #masquerade from localnet on static interface to anywhere
  ipchains -A $staticif"-f" -j MASQ -i $staticif -s $localip/24 -d 0/0

  #all other forwarding is denied and logged
  ipchains -A $staticif"-f" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new forward chain for local ethernet interface
  ipchains -N $localif"-f"

  #flush all rules in chain (sanity flush)
  ipchains -F $localif"-f"

  #all other forwarding is denied and logged
  ipchains -A $localif"-f" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new forward chain for loopback interface
  ipchains -N $loopback"-f"

  #flush all rules in chain (sanity flush)
  ipchains -F $loopback"-f"

  #all other forwarding is denied and logged
  ipchains -A $loopback"-f" -j DENY -s 0/0 -d 0/0 -l


  #---------------------------------------------------------------------
  #Outgoing Firewall Policies
  #---------------------------------------------------------------------

  #create new output chain for static ethernet interface
  ipchains -N $staticif"-o"

  #flush all rules in chain (sanity flush)
  ipchains -F $staticif"-o"

  #outgoing to localnet on remote interface(stuffed routing) deny & log
  ipchains -A $staticif"-o" -j DENY -i $staticif -s 0/0 -d $localip/24 -l

  #outgoing from local net on remote interface, stuffed masquerading, deny
  ipchains -A $staticif"-o" -j DENY -i $staticif -s $localip/24 -d 0/0 -l

  #anything else outgoing on remote interface is valid
  ipchains -A $staticif"-o" -j ACCEPT -i $staticif -s $staticip/32 -d 0/0

  #all other outgoing is denied and logged
  ipchains -A $staticif"-o" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new output chain for local ethernet interface
  ipchains -N $localif"-o"

  #flush all rules in chain (sanity flush)
  ipchains -F $localif"-o"

  #local interface, any source going to local net is valid
  ipchains -A $localif"-o" -j ACCEPT -i $localif -s 0/0 -d $localip/24

  #all other outgoing is denied and logged
  ipchains -A $localif"-o" -j DENY -s 0/0 -d 0/0 -l

  #---------------------------------------------------------------------

  #create new output chain for loopback interface
  ipchains -N $loopback"-o"

  #flush all rules in chain (sanity flush)
  ipchains -F $loopback"-o"

  #loopback interface is valid
  ipchains -A $loopback"-o" -j ACCEPT -i $loopback -s 0/0 -d 0/0
  #all other outgoing is denied and logged
  ipchains -A $loopback"-o" -j DENY -s 0/0 -d 0/0 -l

  #--------------------------------------------------------------------------
  #make sure forwarding is enabled in the kernel
  #--------------------------------------------------------------------------

  /bin/echo 1 > /proc/sys/net/ipv4/ip_forward

  #--------------------------------------------------------------------------
  #Add pointers to built-in chains to enable user defined chains
  #change the order in each chain to optimize filtering for an interface
  #--------------------------------------------------------------------------

  #add local interface input chain
  ipchains -A input -i $localif -j $localif"-i"

  #add static interface input chain
  ipchains -A input -i $staticif -j $staticif"-i"

  #add loopback interface input chain
  ipchains -A input -i $loopback -j $loopback"-i"

  #-------------------------------------------------------------------------

  #add local interface output chain
  ipchains -A output -i $localif -j $localif"-o"

  #add static interface output chain
  ipchains -A output -i $staticif -j $staticif"-o"

  #add loopback interface output chain
  ipchains -A output -i $loopback -j $loopback"-o"

  #-------------------------------------------------------------------------

  #add local interface forward chain
  ipchains -A forward -i $localif -j $localif"-f"

  #add static interface forward chain
  ipchains -A forward -i $staticif -j $staticif"-f"

  #add loopback interface forward chain
  ipchains -A forward -i $loopback -j $loopback"-f"

  #---------------------------------------------------------------------
  #Super Paranoid check --- even though default policy is set for deny,
  #block all packets on any interface
  #---------------------------------------------------------------------

  #all other incoming is denied and logged
  ipchains -A input -j DENY -s 0/0 -d 0/0 -l

  #all other output is denied and logged
  ipchains -A output -j DENY -s 0/0 -d 0/0 -l

  #all other forwarding is denied and logged
  ipchains -A forward -j DENY -s 0/0 -d 0/0 -l

  exit 0
  ______________________________________________________________________



  8.  Putting it all together

  This is an example rc.local script to start everything when your
  system boots.  It will add spoofing protection in the kernel if you
  are using a 2.2 kernel, setup the masquerading firewall policies, and
  start the cipe interface(s).



       ______________________________________________________________________

       #!/bin/bash
       #4/4/99
       #an example rc.local script
       #Send questions or comments to acj@home.com

       echo

       #Set up spoof protection in kernel -- from IPChains HOWTO by Paul Russell

       #this is only for the newer 2.1/2.2 kernels

       #if [ -e /proc/sys/net/ipv4/conf/all/rp_filter ]; then
       #   echo -n "Setting up IP spoofing protection..."
       #   for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
       #       echo 1 > $f
       #   done
       #   echo "done."
       #else
       #   echo PROBLEMS SETTING UP IP SPOOFING PROTECTION.  BE WORRIED.
       #   echo "CONTROL-D will exit from this shell and continue system startup."
       #   echo
       #   # Start a single user shell on the console
       #   /sbin/sulogin $CONSOLE
       #fi

       echo

       #Setup firewall policies
       if [ -x /etc/rc.d/rc.firewall ]; then
               echo Setting up firewall packet filtering policies.
               echo
               . /etc/rc.d/rc.firewall
       fi

       #Start cipe interfaces
       if [ -x /etc/rc.d/rc.cipe ]; then
               echo Starting VPN interfaces.
               . /etc/rc.d/rc.cipe
       fi

       exit 0
       ______________________________________________________________________



  9.  Connecting to the WAN

  At this point your cipe interface should be up and running.  Try
  pinging machines on the other network(s).  If you cannot ping check
  the following on the firewall machine:


  ·  Check that forwarding is enabled in the kernel.

  ·  Do an ifconfig to check if the cipe interface is up.



       cipcb0  Link encap:IPIP Tunnel  HWaddr
               inet addr:192.168.1.1  P-t-P:192.168.2.1  Mask:255.255.255.255
               UP POINTOPOINT NOTRAILERS RUNNING NOARP  MTU:1442  Metric:1
               RX packets:28163 errors:6 dropped:0 overruns:0 frame:6
               TX packets:29325 errors:0 dropped:0 overruns:0 carrier:0
               collisions:0 txqueuelen:100



  ·  Check the route table for a host entry for the other cipe host on
     the cipe interface.



       192.168.2.1    *      255.255.255.255 UH    0   0        0 cipcb0



  ·  Check the route table for a network entry to the other network(s)
     on the cipe interface.



       192.168.2.0    *      255.255.255.0   U     0   0        0  cipcb0



  ·  Check the log files for any error messages.

  If your other machines behind your firewall cannot access machines
  behind the other firewall check that the gateway is properly setup on
  both ends.

  Once you are able to ping, ftp, telnet, etc. to machines on the other
  network, the next step is to get your networks to see each other and
  access each other using SAMBA browsing.  A few hints: lmhosts or wins
  server is required, trusted domains for NT.  I have set these up, but
  that is not the purpose of this document (at least not for now).

  If you used the example firewall masquerading script, then all of your
  machines should also be able to connect to the internet.  If you
  cannot, then you might want to check the log files.  You may also want
  to try using tcpdump to see what is happening with the packets.



  10.  References

  10.1.  Web Sites

  Cipe Home Page <http://sites.inka.de/~bigred/devel/cipe.html>

  Masq Home Page <http://ipmasq.cjb.net>

  Samba Home Page <http://samba.anu.edu.au>

  Linux HQ <http://www.linuxhq.com>  ---great site for lots of linux
  info



  10.2.  Documentation

  cipe.info: info file included with cipe distribution

  Firewall HOWTO, by Mark Grennan, markg@netplus.net

  IP Masquerade mini-HOWTO,by  Ambrose Au, ambrose@writeme.com

  IPChains-Howto, by Paul Russell, Paul.Russell@rustcorp.com.au

</sect1>
