<sect1 id="X11">

<title>X11</title>

<para>
The X Window System was developed at MIT in the late 1980s, rapidly
becoming the industry standard windowing system for Unix graphics
workstations. The software is freely available, very versatile, and is
suitable for a wide range of hardware platforms. Any X environment
consists of two distinct parts, the X server and one or more X
clients. It is important to realise the distinction between the server
and the client. The server controls the display directly and is
responsible for all input/output via the keyboard, mouse or display.
The clients, on the other hand, do not access the screen directly -
they communicate with the server, which handles all input and output.
It is the clients which do the "real" computing work - running
applications or whatever. The clients communicate with the server,
causing the server to open one or more windows to handle input and
output for that client.
</para>

<para>
In short, the X Window System allows a user to log in into a remote
machine, execute a process (for example, open a web browser) and have
the output displayed on his own machine. Because the process is
actually being executed on the remote system, very little CPU power is
needed in the local one. Indeed, computers exist whose primary purpose
is to act as pure X servers.  Such systems are called X terminals.
</para>

<para>
A free port of the X Window System exists for Linux and can be found
at: Xfree <http://www.xfree86.org/>. It is included in most Linux
distributions.
<para>

<sect>
<para>	
This section provides an overview of the X Window System's architecture,
give a better understanding of its design, which components integrate with X
and fit together to provide a working graphical environment and what choices
are there regarding such components as window managers, toolkits and widget
libraries, and desktop environments.
</para>

-----------------------------------------------------------------------------
1. Preface

<para>
This document aims to provide an overview of the X Window System's
architecture, hoping to give people a better understanding of why it's
designed the way it's designed, which components integrate with X and fit
together to provide a working graphical environment and what choices are
there regarding those components.
</para>

<para>
We explore several concepts that get mentioned a lot but might be a bit
unclear for those without a technical background, such as widgets and
toolkits, window managers and desktop environments. Some examples of how
these components interact during day-to-day use of applications are provided.
</para>

<para>
This document is, deliberately, not too technically oriented. It's based on
the author's (empirical) knowledge of the subject, and while it's primarily
meant as a non-technical introduction, it can certainly benefit from any kind
of comments, further examples and explanations, and technical corrections.
The author welcomes all questions and comments regarding this document and
can be reached at roadmr@entropia.com.mx.
</para>

-----------------------------------------------------------------------------

2. Introduction

<para>
Back when UNIX was a new thing, around 1970, graphical user interfaces were
only a weird thing being played with in a laboratory (Xerox's PARC to be
precise). Nowadays, however, any operating system in hopes of being
competitive needs to have a GUI subsystem. GUIs are supposed to be easier to
use. This is not much of a concern under UNIX, which has traditionally been,
to some extent, pretty user-hostile, preferring versatility over ease of use.
However, there are several reasons why a GUI is desirable even on a UNIX
system. For instance, given UNIX's multitasking nature, it's natural to have
a lot of programs running at any given time. A GUI gives more control over
how things are displayed on-screen, thus providing with better facilities for
having a lot of programs on-screen at the same time. Also, some kinds of
information are better displayed in graphical form (some, even, can only be
displayed in graphical form; like pr0n and other inherently graphical data).
</para>

<para>
Historically, UNIX has had a lot of improvements done by academic types. A
good example is the BSD networking code added to it in the late 1970's, which
was, of course, the product of work at the University of California at
Berkeley. As it turns out, the X Window System (also called X, but never X
Windows), which is the foundation for most GUI subsystems found in modern
UNIX (unices?), Linux and the BSD's included, was also the result of an
academic project, namely the Athena project at the Massachusetts Institute of
Technology (MIT).
</para>

<para>
Unix has been a multiuser, multitasking, timesharing operating system since
its beginnings. Also, since the incorporation of networking technologies,
it's had the ability to allow a user to connect remotely and perform work on
the system. Previously this was accomplished either via dumb serial
terminals, or network connections (the legendary telnet).
</para>

<para>
When the time came to develop a GUI system that could run primarily under
Unix, these concepts were kept in mind and incorporated into the design.
Actually, X has a pretty complex design, which has often been mentioned as a
disadvantage. However, because of its design, it's also a really versatile
system, and this will become quite clear as we explain how all the parts
comprising a GUI under Unix fit together.
</para>

<para>
Before taking a look at X's architecture, a really brief tour of its history,
and how it ended up on your Linux system, is in order.
</para>

<para>
X was developed by the Athena project, and released in 1984. In 1988 an
entity called the "X Consortium" took over X, and to this day handles its
development and distribution. The X specification is freely available, this
was a smart move as it has made X almost ubiquitous. This is how XFree86 came
to be. XFree86 is the implementation of X we use on our Linux computers.
XFree86 also works on other operating systems, like the *BSD lineage, OS/2
and maybe others. Also, despite its name, XFree86 is also available for other
CPU architectures.
</para>

-----------------------------------------------------------------------------

3. The X Window System Architecture: overview

<para>
X was designed with a client-server architecture. The applications themselves
are the clients; they communicate with the server and issue requests, also
receiving information from the server.
</para>

<para>
The X server maintains exclusive control of the display and services requests
from the clients. At this point, the advantages of using this model are
pretty clear. Applications (clients) only need to know how to communicate
with the server, and need not be concerned with the details of talking to the
actual graphics display device. At the most basic level, a client tells the
server stuff like "draw a line from here to here", or "render this string of
text, using this font, at this position on-screen".
</para>

<para>
This would be no different from just using a graphics library to write our
application. However the X model goes a step further. It doesn't constrain
the client being in the same computer as the server. The protocol used to
communicate between clients and server can work over a network, or actually,
any "inter-process communication mechanism that provides a reliable octet
stream". Of course, the preferred way to do this is by using the TCP/IP
protocols. As we can see, the X model is really powerful; the classical
example of this is running a processor-intensive application on a Cray
computer, a database monitor on a Solaris server, an e-mail application on a
small BSD mail server, and a visualization program on an SGI server, and then
displaying all those on my Linux workstation's screen.
</para>

<para>
So far we've seen that the X server is the one handling the actual graphics
display. Also, since it's the X server which runs on the physical, actual
computer the user is working on, it's the X server's responsibility to
perform all actual interactions with the user. This includes reading the
mouse and keyboard. All this information is relayed to the client, which of
course will have to react to it.
</para>

<para>
X provides a library, aptly called Xlib, which handles all low-level
client-server communication tasks. It sounds obvious that, then, the client
has to invoke functions contained within Xlib to get work done.
</para>

<para>
At this point everything seems to be working fine. We have a server in charge
of visual output and data input, client applications, and a way for them to
communicate between each other. In picturing a hypothetical interaction
between a client and a server, the client could ask the server to assign a
rectangular area on the screen. Being the client, I'm not concerned with
where i'm being displayed on the screen. I just tell the server "give me an
area X by Y pixels in size", and then call functions to perform actions like
"draw a line from here to there", "tell me whether the user is moving the
mouse in my screen area" and so on.
</para>

-----------------------------------------------------------------------------

4. Window Managers

<para>
However, we never mentioned how the X server handles manipulation of the
clients' on-screen display areas (called windows). It's obvious, to anyone
who's ever used a GUI, that you need to have control over the "client
windows". Typically you can move and arrange them; change size, maximize or
minimize windows. How, then, does the X server handle these tasks? The answer
is: it doesn't.
</para>

<para>
One of X's fundamental tenets is "we provide mechanism, but not policy". So,
while the X server provides a way (mechanism) for window manipulation, it
doesn't actually say how this manipulation behaves (policy).
</para>

<para>
All that mechanism/policy weird stuff basically boils down to this: it's
another program's responsibility to manage the on-screen space. This program
decides where to place windows, gives mechanisms for users to control the
windows' appearance, position and size, and usually provides "decorations"
like window titles, frames and buttons, that give us control over the windows
themselves. This program, which manages windows, is called (guess!) a "window
manager".
</para>

<para>
"The window manager in X is just another client -- it is not part of the X
window system, although it enjoys special privileges -- and so there is no
single window manager; instead, there are many, which support different ways
for the user to interact with windows and different styles of window layout,
decoration, and keyboard and colormap focus."
</para>

<para>
The X architecture provides ways for a window manager to perform all those
actions on the windows; but it doesn't actually provide a window manager.
</para>

<para>
There are, of course, a lot of window managers, because since the window
manager is an external component, it's (relatively) easy to write one
according to your preferences, how you want windows to look, how you want
them to behave, where do you want them to be, and so on. Some window managers
are simplistic and ugly (twm); some are flashy and include everything but the
kitchen sink (enlightenment); and everything in between; fvwm, amiwm, icewm,
windowmaker, afterstep, sawfish, kwm, and countless others. There's a window
manager for every taste.
</para>

<para>
A window manager is a "meta-client", whose most basic mission is to manage
other clients. Most window managers provide a few additional facilities (and
some provide a lot of them). However one piece of functionality that seems to
be present in most window managers is a way to launch applications. Some of
them provide a command box where you can type standard commands (which can
then be used to launch client applications). Others have a nice application
launching menu of some sort. This is not standardized, however; again, as X
dictates no policy on how a client application should be launched, this
functionality is to be implemented in client programs. While, typically, a
window manager takes on this task (and each one does it differently), it's
conceivable to have client applications whose sole mission is to launch other
client applications; think a program launching pad. And of course, people
have written large amounts of "program launching" applications.
</para>

-----------------------------------------------------------------------------

5. Client Applications

<para>
Let's focus on the client programs for a moment. Imagine you wanted to write
a client program from scratch, using only the facilities provided by X. You'd
quickly find that Xlib is pretty spartan, and that doing things like putting
buttons on screen, text, or nice controls (scrollbars, radio boxes) for the
users, is terribly complicated.
</para>

<para>
Luckily, someone else went to the trouble of programming these controls and
giving them to us in a usable form; a library. These controls are usually
known as "widgets" and of course, the library is a "widget library". Then I
just have to call a function from this library with some parameters and have
a button on-screen. Examples of widgets include menus, buttons, radio
buttons, scrollbars, and canvases.
</para>

<para>
A "canvas" is an interesting kind of widget, because it's basically a
sub-area within the client where i can draw stuff. Understandably, since I
shouldn't use Xlib directly, because that would interfere with the widget
library, the library itself gives a way to draw arbitrary graphics within the
canvas widget.
</para>

<para>
Since the widget library is the one actually drawing the elements on-screen,
as well as interpreting user's actions into input, the library used is
largely responsible for each client's aspect and behavior. From a developer's
point of view, a widget library also has a certain API (set of functions),
and that might define which widget library i'll want to use.
</para>

-----------------------------------------------------------------------------

6. Widget Libraries or toolkits

<para>
The original widget library, developed for the Athena Project, is of course
the Athena widget library, also known as Athena Widgets. It's very basic,
very ugly, and the usage is not intuitive by today's standards (for instance,
to move a scrollbar or slider control, you don't drag it; instead, you click
the right button to scroll up and the left button to scroll down). As such,
it's pretty much not used a lot these days.
</para>

<para>
Just as it happens with window managers, there are a lot of toolkits, with
different design goals in mind. One of the earliest toolkits is the
well-known Motif, which was part of the Open Software Foundation's Motif
graphical environment, consisting of a window manager and a matching toolkit.
The OSF's history is beyond the scope of this document. the Motif toolkit,
being superior to the Athena widgets, became widely used in the 1980's and
early 1990's.
</para>

<para>
These days, Motif is not a popular toolkit choice. It's not free (speech),
and OSF Motif costs money if you want a developer license (i.e. to compile
your own programs with it), altough it's OK to distribute a binary linked
against Motif. Perhaps the best-known Motif application, for Linux users at
least, is Netscape Navigator/Communicator (prior to Mozilla).
</para>

<para>
For a while Motif was the only decent toolkit available, and there's a lot of
Motif software around. Of course people started developing alternatives, and
there are plenty of toolkits, such as XForms, FLTK and a few others.
</para>

<para>
Motif is not heard of much these days, specially in the free software world.
The reason is that there are now better alternatives, in terms of licensing,
performance (Motif is widely regarded as quite a pig) and features.
</para>

<para>
One such toolkit, the widely known and used Gtk, was specifically created to
replace Motif in the GIMP project (one possible meaning of Gtk is "GIMP
ToolKit, altough, with its widespread use, it could be interpreted as the GNU
ToolKit). Gtk is now very popular because it's relatively lightweight,
feature-rich, extensible and totally free (speech). The 0.6 release of the
GIMP included "Bloatif has been zorched" in the changelog. This sentence is a
testament to Motif's bloatedness.
</para>

<para>
Another very popular toolkit these days is Qt. It was not too well-known
until the advent of the KDE project, which utilizes Qt for all its GUI
elements. We certainly won't get into Qt's licensing issues and the KDE/GNOME
disjunctive. Gtk gets a lengthy mention because its history as a Motif
replacement is interesting; Qt gets a brief mention because it's really
popular.
</para>

<para>
Finally, another alternative worth mentioning is LessTif. The name is a pun
on Motif, and LessTif aims to be a free, API-compatible replacement for
Motif. It's not clear to what extent LessTif aims to be used in new
development, rather than just helping those with Motif code use a free
alternative while they (conceivably) port their apps to some other toolkit.
</para>

-----------------------------------------------------------------------------

7. What we have so far

<para>
Up to this point we have an idea of how X has a client-server architecture,
where the clients are our application programs. Under this client-server
graphic system, we have several possible window managers, which manage our
screen real estate; we also have our client applications, which are where we
actually get our work done, and clients can be programmed using several
possible different toolkits.
</para>

<para>
Here's where the mess begins. Each window manager has a different approach to
managing the clients; the behavior and decorations are different from one to
the next. Also, as defined by which toolkit each client uses, they can also
look and behave differently from each other. Since there's nothing that says
authors have to use the same toolkit for all their applications, it's
perfectly possible for a user to be running, say, six different applications,
each written using a different toolkit, and they all look and behave
differently. This creates a mess because behavior between the apps is not
consistent. If you've ever used a program written with the Athena widgets,
you'll notice it's not too similar to something written using Gtk. And you'll
also remember it's a mess using all these apps which look and feel so
different. This basically negates the advantage of using a GUI environment in
the first place.
</para>

<para>
On a more technical standpoint, using lots of different toolkits increases
resource usage. Modern operating systems support the concept of dynamic
shared libraries. This means that if I have two or three applications using
Gtk, and I have a dynamic shared version of Gtk, then those two or three
applications share the same copy of Gtk, both on the disk and in memory. This
saves resources. On the other hand, if I have a Gtk application, a Qt
application, something Athena-based, a Motif-based program such as Netscape,
a program that uses FLTK and another using XForms, I'm now loading six
different libraries in memory, one for each of the different toolkits. Keep
in mind that all the toolkits provide basically the same functionality.
</para>

<para>
There are other problems here. The way of launching programs varies from one
window manager to the next. Some have a nice menu for launching apps; others
don't, and they expect us to open a command-launching box, or use a certain
key combination, or even open an xterm and launch all your apps by invoking
the commands. Again, there's no standarization here so it becomes a mess.
</para>

<para>
Finally, there are niceties we expect from a GUI environment which our scheme
hasn't covered. Things like a configuration utility, or "control panel"; or a
graphical file manager. Of course, these can be written as client apps. And,
in typical free software fashion, there are hundreds of file managers, and
hundreds of system configuration programs, which conceivably, further the
mess of having to deal with a lot of disparate software components.
</para>

-----------------------------------------------------------------------------

8. Desktop environments to the rescue

<para>
Here's where the concept of a desktop environment kicks in. The idea is that
a desktop environment provides a set of facilities and guidelines aiming to
standardizing all the stuff we mentioned so that the problems we mentioned
earlier are minimized.
</para>

<para>
The concept of a desktop environment is something new to people coming for
the first time to Linux because it's something that other operating systems
(like Windows and the Mac OS) intrinsically have. For example, MacOS, which
is one of the earliest graphical user interfaces, provides a very consistent
look-and-feel during the entire computing session. For instance, the
operating system provides a lot of the niceties we mentioned: it provides a
default file manager (the finder), a systemwide control panel, and single
toolkit that all applications have to use (so they all look the same).
Application windows are managed by the system (strictly speaking there's a
window manager working there). Finally, there are a set of guidelines that
tell developers how their applications should behave, recommend control looks
and placement, and suggest behaviors according to those of other applications
on the system. All this is done in the sake of consistency and ease of use.
</para>

<para>
This begs the question, "why didn't the X developers do things that way in
the first place?". It makes sense; after all, it would have avoided all the
problems we mentioned earlier. The answer is that in designing X, its
creators chose to make it as flexible as possible. Going back to the policy/
mechanism paradigm, the MacOS provides mostly policies. Mechanisms are there,
but they don't encourage people to play with those. As a result I lose
versatility; if I don't like the way MacOS manages my windows, or the toolkit
doesn't provide a function I need, I'm pretty much out of luck. This doesn't
happen under X, altough as seen before, the price of flexibility is greater
complexity.
</para>

<para>
Under Linux/Unix and X, it all comes down to agreeing on stuff and sticking
to it. Let's take KDE for example. KDE includes a single window manager
(kwm), which manages and controls the behavior of our windows. It recommends
using a certain graphic toolkit (Qt), so that all KDE applications look the
same, as far as their on-screen controls go. KDE further extends Qt by
providing a set of environment-specific libraries (kdelibs) for performing
common tasks like creating menus, "about" boxes, program toolbars,
communicating between programs, printing, selecting files, and other things.
These make the programmer's work easier and standardize the way these special
features behave. KDE also provides a set of design and behavior guidelines to
programmers, with the idea that, if everybody follows them, programs running
under KDE will both look and behave very similarly. Finally, KDE provides, as
part of the environment, a launcher panel (kpanel), a standard file manager
(which is, at the time being, Konqueror), and a configuration utility
(control panel) from which we can control many aspects of our computing
environment, from settings like the desktop's background and the windows'
titlebar color to hardware configurations.
</para>

<para>
The KDE panel is an equivalent to the MS Windows taskbar. It provides a
central point from which to launch applications, and it also provides for
small applications, called "applets", to be displayed within it. This gives
functionality like the small, live clock most users can't live without.
</para>

-----------------------------------------------------------------------------

9. Specific Desktop Environments

<para>
We used KDE as an example, but it's by no means the earliest desktop
environment for Unix systems. Perhaps one of the earliest is CDE (Common
Desktop Environment), another sibling of the OSF. As per the CDE FAQ: "The
Common Desktop Environment is a standard desktop for UNIX, providing services
to end-users, systems administrators, and application developers consistently
across many platforms." The key here is consistency. However CDE wasn't as
feature-rich and easy as it needed to be. Along with Motif, CDE has
practically disappeared from the free software world, having been replaced by
better alternatives.
</para>

<para>
Under Linux, the two most popular desktop environments are KDE and GNOME, but
they're not the only ones. A quick internet search will reveal about half a
dozen desktop environments: GNUStep, ROX, GTK+XFce, UDE, to name a few. They
all provide the basic facilities we mentioned earlier. GNOME and KDE have had
the most support, both from the community and the industry, so they're the
most advanced ones, providing a large amount of services to users and
applications.
</para>

<para>
We mentioned KDE and the components that provide specific services under that
environment. As a good desktop environment, GNOME is somewhat similar in
that. The most obvious difference is that GNOME doesn't mandate a particular
window manager (the way KDE has kwm). The GNOME project has always tried to
be window manager-agnostic, acknowledging that most users get really attached
to their window managers, and forcing them to use something that manages
windows differently would detract from their audience. Originally GNOME
favored the Enlightenment window manager, and currently their preferred
window manager is Sawfish, but the GNOME control panel has always had a
window manager selector box.
</para>

<para>
Other than this, GNOME uses the Gtk toolkit, and provides a set of
higher-level functions and facilities through the gnome-libs set of
libraries. GNOME has its own set of programming guidelines in order to
guarantee a consistent behavior between compliant applications; it provides a
panel (called just "panel"), a file manager (gmc, altough it's probably going
to be superseded by Nautilus), and a control panel (the gnome control
center).
</para>

-----------------------------------------------------------------------------

10. How it all fits together

<para>
Each user is free to choose whichever desktop environment feels the best. The
end result is that, if you use an all-kde or all-gnome system, the look and
feel of the environment is very consistent; and your applications all
interact between them pretty nicely. This just wasn't possible when we had
apps written in a hodgepodge of different toolkits. The range of facilities
provided by modern desktop environments under Linux also enable some other
niceties, like component architectures (KDE has Kparts and GNOME uses the
Bonobo component framework), which allow you to do things like having a live
spreadsheet or chart inside a word processing document; global printing
facilities, similar to the printing contexts found in Windows; or scripting
languages, which let more advanced users write programs to glue applications
together and have them interact and cooperate in interesting ways.
</para>

<para>
Under the Unix concept of "desktop environment", you can have programs from
one environment running in another. I could conceivably use Konqueror within
GNOME, or Gnumeric under KDE. They're just programs, after all. Of course the
whole idea of a desktop environment is consistency, so it makes sense to
stick to apps that were designed for your particular environment; but if
you're willing to cope with an app that looks "out of place" and doesn't
interact with the rest of your environment, you are completely free to do so.
</para>

-----------------------------------------------------------------------------

11. A day in the life of an X system

<para>
This is an example of how a typical GNOME session goes, under a modern
desktop environment in a Linux system. It's very similar to how things work
under other environments, assuming they work on top of X.
</para>

<para>
When a Linux system starts X, the X server comes up and initializes the
graphic device, waiting for requests from clients. First a program called
gnome-session starts, and sets up the working session. A session includes
things such as applications I always open, their on-screen positions, and
such. Next, the panel gets started. The panel appears at the bottom (usually)
and it's sort of a dashboard for the windowing environment. It will let us
launch programs, see which ones are running, and otherwise control the
working environment. Next, the window manager comes up. Since we're using
GNOME, it could be any of several different window managers, but in this case
we'll assume we're running Sawfish. Finally, the file manager comes up (gmc
or Nautilus). The file manager handles presentation of the desktop icons (the
ones that appear directly on the desktop). At this point my GNOME environment
is ready to work.
</para>

<para>
So far all of the programs that have been started are clients, connecting to
the X server. In this case the X server happens to be in the same computer,
but as we saw before, it need not be.
</para>

<para>
We'll now open an xterm to type some commands. When we click on the xterm
icon, the panel spawns, or launches, the xterm application. It's another X
client application, so it starts, connects to the X server and begins
displaying its stuff. When the X server assigns screen space for my xterm, it
lets the window manager (Sawfish) decorate the window with a nice titlebar,
and decide where it will be on screen.
</para>

<para>
Let's do some browsing. We click on the Netscape icon on the panel, and up
comes a browser. Keep in mind that this browser doesn't use GNOME's
facilities, nor does it use the Gtk toolkit. It looks a bit out of place
here... also, it doesn't interact very nicely with the rest of the
environment. I'll open the "File" menu. Motif is providing the on-screen
controls, so it's the Motif library's job to make the appropriate calls to
the underlying Xlib, draw the necessary on-screen elements to display the
menu and let me select the "exit" option, closing the application.
</para>

<para>
Now I open a Gnumeric spreadsheet and start doing some stuff. At some point I
need to do some work on the xterm I had open, so I click on it. Sawfish sees
that, and, being in charge of managing windows, brings the xterm to the top
and gives it focus so I can work there.
</para>

<para>
After that, I go back to my spreadsheet, now that I'm finished I want to
print my document. Gnumeric is a GNOME application, so it can use the
facilities provided by the GNOME environment. When I print, Gnumeric calls
the gnome-print library, which actually communicates with the printer and
produces the hard copy I need.
</para>
</sect>

<sect>
<para>
LBX (Low Bandwidth X) is an X server extension which performs compres­
sion on the X protocol.  It is meant to be used in conjunction with X
applications and an X server which are separated by a slow network
connection, to improve display and response time.
</para>
______________________________________________________________________

1.  Introduction

<para>
Low-Bandwidth X (LBX) attempts to recognize that in this day and age,
not everyone will be a fast LAN hop or two away from the system that
they are running their applications on.
</para>

<para>
The X protocol can generate an extraordinary amount of traffic,
especially for simple-seeming things such as creating new windows.  As
anyone who has tried to use X over a dial-in modem at 28.8 or even
higher can attest, creating new X windows can involve an excruciating
wait.
</para>

<para>
LBX is fundamentally a compression and caching scheme designed to
minimize the amount of X traffic generated between two systems.
</para>

2.  What's The Status Of LBX?

<para>
As of the X Consortium's release of X11R6.3 in December, 1996, LBX is
a full extension to the X protocol.  For XFree86 folks, that's XFree86
version 3.3.
</para>

3.  Who Can Benefit From LBX?

<para>
If you use a modem to dial into a service provider, then run X
applications on remote machines with their DISPLAYs set to your local
machine (or vice versa), LBX will speed up that connection.  Also if
you set DISPLAYs from systems across WANs (other countries, for
example) or other slow links, LBX can help.
</para>

4.  Who Doesn't Need LBX?

<para>
LBX is useless, of course, if you're only running applications
locally, or if you're not running X at all.
</para>

<para>
Also, if you're running on a fast LAN, LBX won't be much help.  Some
people say "if LBX cuts down on network traffic, wouldn't it be good
to use even on fast LANs?"  It might be, if your goal is to reduce
network traffic.  But if your goal is to get better response time LBX
probably isn't what you want.  Although it does introduce caching and
compression, that comes at a cost on both ends (extra memory for
caching, and extra CPU for decompression).  If your link is fairly
speedy LBX will probably result in an overall slowdown.
</para>

5.  How Does LBX Work?

<para>
LBX works by introducing a proxy server at the client side, which
performs caching and compression.  The X server knows that the client
is using a proxy server, and decompresses accordingly.
</para>

<para>
Here's a normal setup for remote X clients.  In our discussion, LOCAL
is always the workstation sitting in front of you, whose monitor
you're looking at, and REMOTE is the remote workstation, where the
actual application is running.
</para>

<para>
<screen>
   ______________________________________________________________________
        REMOTE                               LOCAL
    +-----+                                             +-----+
    | APP |-\          Network            +----------+  |     |\
    +-----+  \--------------------------->| X SERVER |=>|     ||
    +-----+  /       (X Protocol)         +----------+  +-----+\
    | APP |-/                                          /_____//
    +-----+
   ______________________________________________________________________
</screen>
</para>

<para>
When using LBX, a proxy server (lbxproxy) is introduced on the remote
side, and the applications talk to that process instead of directly to
the LOCAL server.  That process then performs the caching and
compression of X requests and forwards them.  It looks like this:
</para>

<para>
<screen>
______________________________________________________________________
     REMOTE                                         LOCAL
                                                               +-----+
 +-----+  +-------+           Network            +----------+  |     |\
 | APP |->| PROXY |----------------------------->| X SERVER |=>|     ||
 +-----+  +-------+       (LBX/X Protocol)       +----------+  +-----+\
 +-----+   /                                                  /_____//
 | APP |--/
 +-----+
______________________________________________________________________
</screen>
</para>

<para>
Details on exactly what caching and compression LBX does is beyond the
scope of this document.
</para>

6.  What Do I Need To Use LBX?

<para>
You need an X server on your LOCAL system which has the LBX extension
compiled in.  Unless you explicitly told it not to when building it,
X11R6.3 servers automatically enable LBX.  Also, all XFree86 3.3
servers have LBX enabled by default.
</para>

<para>
You can use the xdpyinfo command to see if your server has the LBX
extension: run xdpyinfo and look at the list just under "number of
extensions"; you should see "LBX" listed there.
</para>

<para>
Next, you need to get an lbxproxy program compiled for the REMOTE
system.  This is the tricky part.  If the remote system is not the
same type as your local system, the lbxproxy on your local system will
do you no good, of course.
</para>

<para>
There is unfortunately no "broken out" distribution of lbxproxy, so
you will have to either (a) get and build most, if not all, of X11R6.3
for the remote system, or (b) find someplace to get a pre-compiled
lbxproxy binary for your system.  The latter is much simpler of
course.
</para>

<para>
The lbxproxy is simply a single executable.  There are no
configuration files, resource files, etc. associated with it.
</para>

7.  What Don't I Need To Use LBX?

<para>
The REMOTE system does not need a new X server (as always, the REMOTE
system doesn't need any X server running).
</para>

<para>
The application you want to run does not need to be linked with any
special version of X, or any special libraries; I regularly use
commercial X11R5 apps over LBX with no trouble.
</para>

<para>
You do not need root or other privileged access on the REMOTE system;
the lbxproxy process runs under your normal access permissions.
Further, you can run it right from your home directory: it does not
have to be installed anywhere.
</para>

8.  How Do I Start LBX?

<para>
OK, here it is... after all that it's actually quite simple.  Replace
LOCAL and REMOTE below with the hostnames of your local workstation
and remote system, respectively (don't get them mixed up!)
</para>

<para>
On LOCAL:
</para>

1. Start your X server.
2. Tell your X server that the remote system is allowed access.  Using
   the host-list method, type xhost +REMOTE.  If you use xauth you may
   need to do more than this; see the xauth(1) man page for more
   information.
   You should consult the Remote X Apps Mini-HOWTO
   <http://www.xs4all.nl/~zweije/xauth.html> if you're not familiar
   with remote X access permission setup.

<para>
On REMOTE:
</para>

1. Start lbxproxy and tell it to forward to the LOCAL X server, like
   this:
   <para>
   <screen>
       $ lbxproxy -display LOCAL:0 :1 &
   </screen>
   </para>

<para>
This tells lbxproxy to use display :1 on the REMOTE system; if that
system has >1 display already you can use :2 or whatever instead.
</para>

2. Set your DISPLAY environment variable to point to the display that
   lbxproxy is providing, instead of the normal display:

   <para>
   <screen>   
       $ DISPLAY=:1
       $ export DISPLAY
   </screen>
   </para>

<para>
Or, if you use csh or clones:
</para>

   <para>
   <screen>   
       % setenv DISPLAY :1
   </screen>
   </para>

3. If you're using xauth you will need to ensure that your cookie is
   available locally.  See the Remote X Apps Mini-HOWTO
   <http://www.xs4all.nl/~zweije/xauth.html> for more information on
   this.

4. Start your X applications!

<para>
That's it; all X apps that are started up pointing to :1 will use LBX.
Of course, there's no reason you couldn't also start X apps pointing
to LOCAL:0 and have both running at the same time.
</para>

9.  Problems

<para>
Here are some common problems:
</para>

   Q) lbxproxy exits with an "access denied" error.

   A) This means the LOCAL system isn't accepting connections from the
      REMOTE system due to permissions errors.  See the Remote X Apps
      Mini-HOWTO <http://www.xs4all.nl/~zweije/xauth.html> for details
      on these issues.

      As a simple trouble-shooting measure, try running a simple X app
      like xclock on REMOTE and have it display on the local system
      without using lbxproxy:

          $ xclock -display LOCAL:0

   If that doesn't work, it's xhost or some other basic X problem, not
   LBX.


10.  Documentation

The only documentation available in a standard X distribution may be
the lbxproxy(1) man page.

If you have access to the X source tree, then very interesting
information on LBX is available there:


·  xc/doc/specs/Xext/lbx.mif (Framemaker MIF)
·  xc/doc/hardcopy/Xext/lbx.PS.Z (Compressed Postscript)
·  xc/doc/hardcopy/Xext/lbxTOC.html (HTML)

More detailed discussion of specific LBX algorithms is available here:

·  xc/doc/specs/Xext/lbxalg.mif (Framemaker MIF)
·  xc/doc/specs/Xext/lbxalg.PS.Z (Compressed Postscript)

If you don't have access to the X11 source, you can obtain these files
from the X Consortium's FTP site <ftp://ftp.x.org/pub/R6.3/xc/doc/>.

11.  Alternatives

If you don't like lbxproxy for some reason: you're not satisfied with
the performance, it doesn't work for you, you don't want to hassle
with creating an lbxproxy for the remote host, or you simply are
interested in trying other options, there is at least one other
package for X protocol compression (anyone have others?)

11.1.  dxpc - The Differential X Protocol Compressor

·  Original Author: Brian Pane <brianp@cnet.com>
·  Current Maintainer: Zachary Vonler <lightborn@mail.utexas.edu>

<para>
dxpc <http://ccwf.cc.utexas.edu/~zvonler/dxpc/> works in essentially
the same way as LBX.  However, to avoid having to implement an X
extension and modify the X server code, dxpc uses two proxies: one
that runs on the REMOTE host, like lbxproxy, and one that runs on the
LOCAL host.
</para>

<para>
The REMOTE host proxy communicates between the X clients and the LOCAL
host proxy, and the LOCAL host proxy communicates between the X server
and the REMOTE host proxy.
</para>

<para>
So, to both the X clients and the X server, it looks like X protocol
as usual.
</para>

11.1.1.  Advantages

·  Since it's a completely separate application that does not require
   any X internals, it's much simpler to compile and install.
·  It's maintained separately, so you don't have to wait for the OSF
   to release new X versions for enhancements or fixes.
·  It provides more and better compression information and statistics
   than lbxproxy.

11.1.2.  Disadvantages

·  It is not a standard part of X; you must obtain and build it
   separately.
·  It is slightly more complex to set up, since it requires a LOCAL-
   side proxy as well as the REMOTE proxy.

11.1.3.  Where Can I Get dxpc?

<para>
The source for dxpc is available at ftp.x.org
<ftp://ftp.x.org/contrib/utilities/>.
</para>

<para>
There is a WWW homepage for dxpc that gives a lot of good information,
including pointers to the dxpc mailing list, access to the source
code, and a number of pre-built binaries for various platforms:
<http://ccwf.cc.utexas.edu/~zvonler/dxpc/>
</para>

11.2.  SSH (Secure Shell)

<para>
Ken Chase <lbxhowto@sizone.org> notes that ssh
<http://www.cs.hut.fi/ssh/> can be used for compression.  Although its
main purpose is to provide security, it also compresses the data it
sends.
</para>

<para>
Thus, if you run X over a ssh link you will automatically obtain some
amount of compression.
</para>

11.3.  Which Is Better?

<para>
I don't know.  Both LBX and dxpc are certainly better at raw
compression than ssh.  Of course, ssh provides the added advantage of
security.  And of course, there's no reason you can't use both ssh and
one of the other two, to get good compression and security.
</para>

<para>
It shouldn't be hard to run some benchmarking against these options
and get both subjective and statistical measurings of performance.
But I haven't done this, and I don't know of anyone who has.
</para>
</sect>

X11, LBX, DXPC, NXServer, SSH, MAS

Related HOWTOs:

· Remote X Apps HOWTO
· Linux XDMCP HOWTO
· XDM and X Terminal mini-HOWTO
· The Linux XFree86 HOWTO
· ATI R200 + XFree86 4.x mini-HOWTO
· Second Mouse in X mini-HOWTO
· Linux Touch Screen HOWTO
· XFree86 Video Timings HOWTO
· Linux XFree-to-Xinside mini-HOWTO
· XFree Local Multi-User HOWTO
· Using Xinerama to MultiHead XFree86 V. 4.0+
· Connecting X Terminals to Linux Mini-HOWTO
· How to change the title of an xterm
· X Window System Architecture Overview HOWTO
· The X Window User HOWTO
     
</sect1>
