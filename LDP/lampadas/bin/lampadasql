#!/bin/sh

check_var()
{
  [ -n "$1" ] && return
  echo "Environment variable $2 is not set."
  echo "Read the comments in file 'setenv.sh' how to fix that."
  exit -1
} 

check_file()
{
  [ -e "$1" ] && return
  echo "File $1 does not exist." 1>&2
  exit 1
}

all_files()
{
  for lang in "$@"; do
    lang="${lang%.m4}"
    file="$lang.m4"
    check_file "$file"

    filter="$LAMPADAS_SQL/$lang.input"
    if [ -x "$filter" ]; then
      echo "Using filter $filter" 1>&2
      $filter < "$file" \
      | m4 -P -DI18N_lang_code=$lang $LAMPADAS_SQL/common.m4 $COMMAND -
    else
      m4 -P -DI18N_lang_code=$lang $LAMPADAS_SQL/common.m4 $COMMAND "$file"
    fi
  done
}

check_var "$LAMPADAS_SQL" LAMPADAS_SQL
DEFAULT_LANG=$( echo "${LANG%_*}" | tr 'a-z' 'A-Z' )

if [ -z "$1" ]; then
        echo "\
USAGE: lampadasql command { language }

   This will pipe the file <command> together with each <language>
   through the m4 macro processor. The suffix '.m4' will be appended
   if not present.

   If no value for <language> is given, the first two letters of variable
   \$LANG are used. Right now that would be $DEFAULT_LANG.

   Typically the output of lampadasql is further piped into /usr/bin/psql
   to execute SQL statements:

   lampadasql update EN | psql lampadas
" 1>&2
	exit 1
fi

COMMAND="${1%.m4}.m4"
check_file "$COMMAND"
shift

if [ -z "$1" ]; then
  all_files $DEFAULT_LANG
else
  all_files "$@"
fi
