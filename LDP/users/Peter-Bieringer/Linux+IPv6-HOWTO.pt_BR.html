<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Linux IPv6 HOWTO (pt_BR)</TITLE
><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Linux IPv6 HOWTO (pt_BR)</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
></A
>Peter Bieringer</H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>pb&nbsp;at&nbsp;bieringer&nbsp;dot&nbsp;de</P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.66wip</TD
><TD
ALIGN="LEFT"
>2010-04-20</TD
><TD
ALIGN="LEFT"
>Revised by: PB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.65</TD
><TD
ALIGN="LEFT"
>2009-12-13</TD
><TD
ALIGN="LEFT"
>Revised by: PB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.64</TD
><TD
ALIGN="LEFT"
>2009-06-11</TD
><TD
ALIGN="LEFT"
>Revised by: PB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.60</TD
><TD
ALIGN="LEFT"
>2007-05-31</TD
><TD
ALIGN="LEFT"
>Revised by: PB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 0.51</TD
><TD
ALIGN="LEFT"
>2006-11-08</TD
><TD
ALIGN="LEFT"
>Revised by: PB</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN30"
></A
><P
>A meta deste HOWTO de IPv6 em Linux é responder as questões básicas e avançadas sobre a versão 6 do protocolo IP em um sistema com Linux. Este HOWTO dará ao leitor informação suficiente para instalar, configurar e usar aplicações IPv6 em máquinas com o Linux. Versões intermediárias deste HOWTO estão disponíveis nos endereços <A
HREF="http://mirrors.bieringer.de/Linux+IPv6-HOWTO/"
TARGET="_top"
>mirrors.bieringer.de</A
> ou <A
HREF="http://mirrors.deepspace6.net/Linux+IPv6-HOWTO/"
TARGET="_top"
>mirrors.deepspace6.net</A
>. Veja também <A
HREF="#REVISION-HISTORY"
>revision history</A
> para saber das mudanças.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
>1. <A
HREF="#CHAPTER-GENERAL"
>Geral</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#GENERAL-COPRIGHT"
>Copyright, licença e outros</A
></DT
><DT
>1.2. <A
HREF="#GENERAL-CATEGORY"
>Categoria</A
></DT
><DT
>1.3. <A
HREF="#AEN76"
>Versão, Histórico e To-Do</A
></DT
><DT
>1.4. <A
HREF="#GENERAL-TRANSLATIONS"
>Traduções</A
></DT
><DT
>1.5. <A
HREF="#AEN163"
>Técnico</A
></DT
><DT
>1.6. <A
HREF="#AEN184"
>Prefácio</A
></DT
><DT
>1.7. <A
HREF="#AEN207"
>Termos usados, glossário e atalhos</A
></DT
><DT
>1.8. <A
HREF="#AEN357"
>Necessidades para usar este HOWTO</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#CHAPTER-BASICS"
>Básico</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN382"
>O que é IPv6?</A
></DT
><DT
>2.2. <A
HREF="#BASIC-HISTORY-IPV6-LINUX"
>História do IPv6 no Linux</A
></DT
><DT
>2.3. <A
HREF="#AEN415"
>Como o endereço IPv6 se parece?</A
></DT
><DT
>2.4. <A
HREF="#AEN438"
>FAQ (Básico)</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#CHAPTER-ADDRESSTYPES"
>Tipos de endereço</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN467"
>Endereços sem um prefixo especial</A
></DT
><DT
>3.2. <A
HREF="#AEN504"
>Parte da rede, também conhecido como prefixo</A
></DT
><DT
>3.3. <A
HREF="#AEN645"
>Tipos de endereço (parte de host)</A
></DT
><DT
>3.4. <A
HREF="#AEN671"
>Tamanho de prefixos para roteamento</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#CHAPTER-SYSTEMCHECK"
>Verificação do sistema para IPv6</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#SYSTEMCHECK-KERNEL"
>Kernel com IPv6</A
></DT
><DT
>4.2. <A
HREF="#AEN776"
>Ferramentas de configuração de rede que suportam IPv6</A
></DT
><DT
>4.3. <A
HREF="#AEN797"
>Programas de teste e debug IPv6</A
></DT
><DT
>4.4. <A
HREF="#AEN861"
>Programas com suporte a IPv6</A
></DT
><DT
>4.5. <A
HREF="#AEN868"
>Programas cliente com suporte a IPv6</A
></DT
><DT
>4.6. <A
HREF="#AEN914"
>Programas servidores com suporte a IPv6</A
></DT
><DT
>4.7. <A
HREF="#FAQ-IPV6-READY-SYSTEM-CHECK"
>FAQ (checagem de sistema com suporte a IPv6)</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#CHAPTER-CONFIGURATION-INTERFACE"
>Configurando interfaces</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN936"
>Dispositivos de rede diferentes</A
></DT
><DT
>5.2. <A
HREF="#AEN979"
>Colocando as interfaces em up e down</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#CHAPTER-CONFIGURATION-ADDRESS"
>Configurando endereços IPv6</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN997"
>Mostrando os endereços IPv6 existentes</A
></DT
><DT
>6.2. <A
HREF="#AEN1015"
>Adicionando um endereço IPv6</A
></DT
><DT
>6.3. <A
HREF="#AEN1030"
>Removendo um endereço IPv6</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#CHAPTER-CONFIGURATION-ROUTE"
>Configurando rotas IPv6</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#AEN1048"
>Mostrando as rotas IPv6 existentes</A
></DT
><DT
>7.2. <A
HREF="#AEN1063"
>Adicionando uma rota IPv6 através de um gateway</A
></DT
><DT
>7.3. <A
HREF="#AEN1079"
>Removendo uma rota IPv6 através de um gateway</A
></DT
><DT
>7.4. <A
HREF="#AEN1094"
>Adicionando uma rota IPv6 através de uma interface</A
></DT
><DT
>7.5. <A
HREF="#AEN1110"
>Removendo uma rota IPv6 através de uma interface</A
></DT
><DT
>7.6. <A
HREF="#AEN1125"
>FAQ para rotas em IPv6</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#CHAPTER-NEIGHBOR-DISCOVERY"
>Descoberta de vizinhos</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#AEN1142"
>Mostrando os vizinhos usando "ip"</A
></DT
><DT
>8.2. <A
HREF="#AEN1148"
>Manipulando a tabela de vizinhos usando "ip"</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#CHAPTER-CONFIGURING-IPV6-IN-IPV4-TUNNELS"
>Configurando um túnel IPv6-in-IPv4</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#AEN1171"
>Tipos de túneis</A
></DT
><DT
>9.2. <A
HREF="#AEN1222"
>Mostrando os túneis existentes</A
></DT
><DT
>9.3. <A
HREF="#CONF-IPV6-IN-IPV4-POINT-TO-POINT-TUNNELS"
>Configuração de um túnel ponto a ponto</A
></DT
><DT
>9.4. <A
HREF="#CONFIGURING-IPV6TO4-TUNNELS"
>Configuração de túneis 6to4</A
></DT
></DL
></DD
><DT
>10. <A
HREF="#CHAPTER-CONFIGURING-IPV4-IN-IPV6-TUNNELS"
>Configurando túneis IPv4-in-IPv6</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#AEN1346"
>Mostrando os túneis existentes</A
></DT
><DT
>10.2. <A
HREF="#AEN1353"
>Configuração de túnel ponto a ponto</A
></DT
><DT
>10.3. <A
HREF="#AEN1359"
>Removendo túneis ponto a ponto</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#CHAPTER-KERNEL-SETTINGS"
>Configuraçoes de Kernel nos arquivos do /proc</A
></DT
><DD
><DL
><DT
>11.1. <A
HREF="#AEN1368"
>Como acessar os arquivos do /proc</A
></DT
><DT
>11.2. <A
HREF="#PROC-SYS-NET-IPV6."
>Entradas em /proc/sys/net/ipv6/</A
></DT
><DT
>11.3. <A
HREF="#PROC-SYS-NET-IPV4."
>Entradas relacionadas a IPv6 em /proc/sys/net/ipv4/</A
></DT
><DT
>11.4. <A
HREF="#PROC-NET"
>Entradas em /proc/net relacionadas com IPv6</A
></DT
></DL
></DD
><DT
>12. <A
HREF="#NETLINK"
>Netlink-Interface to kernel</A
></DT
><DT
>13. <A
HREF="#RESOLVER"
>Address Resolver</A
></DT
><DT
>14. <A
HREF="#NETWORK-DEBUGGING"
>Network debugging</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN1876"
>Server socket binding</A
></DT
><DT
>14.2. <A
HREF="#EXAMPLES-TCPDUMP"
>Examples for tcpdump packet dumps</A
></DT
></DL
></DD
><DT
>15. <A
HREF="#CHAPTER-SUPPORT-PERSISTENT-CONFIGURATION"
>Support for persistent IPv6 configuration in Linux distributions</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#AEN1928"
>Red Hat Linux and “clones”</A
></DT
><DT
>15.2. <A
HREF="#AEN1967"
>SuSE Linux</A
></DT
><DT
>15.3. <A
HREF="#CONFIGURATION-DEBIAN-LINUX"
>Debian Linux</A
></DT
></DL
></DD
><DT
>16. <A
HREF="#CHAPTER-AUTOCONFIGURATION"
>Auto-configuration</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#AEN2019"
>Stateless auto-configuration</A
></DT
><DT
>16.2. <A
HREF="#AEN2024"
>Stateful auto-configuration using Router Advertisement Daemon (radvd)</A
></DT
><DT
>16.3. <A
HREF="#AEN2028"
>Dynamic Host Configuration Protocol v6 (DHCPv6)</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#CHAPTER-MOBILITY"
>Mobility</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#AEN2047"
>Common information</A
></DT
></DL
></DD
><DT
>18. <A
HREF="#CHAPTER-FIREWALLING-SECURITY"
>Firewalling</A
></DT
><DD
><DL
><DT
>18.1. <A
HREF="#FIREWALLING-NETFILTER6."
>Firewalling using netfilter6</A
></DT
><DT
>18.2. <A
HREF="#AEN2130"
>Preparation</A
></DT
><DT
>18.3. <A
HREF="#AEN2208"
>Usage</A
></DT
></DL
></DD
><DT
>19. <A
HREF="#CHAPTER-SECURITY"
>Security</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#AEN2340"
>Node security</A
></DT
><DT
>19.2. <A
HREF="#AEN2344"
>Access limitations</A
></DT
><DT
>19.3. <A
HREF="#IPV6-SECURITY-AUDITING"
>IPv6 security auditing</A
></DT
></DL
></DD
><DT
>20. <A
HREF="#CHAPTER-ENCRYPTION-AUTHENTICATION"
>Encryption and Authentication</A
></DT
><DD
><DL
><DT
>20.1. <A
HREF="#AEN2387"
>Modes of using encryption and authentication</A
></DT
><DT
>20.2. <A
HREF="#AEN2398"
>Support in kernel (ESP and AH)</A
></DT
><DT
>20.3. <A
HREF="#AEN2408"
>Automatic key exchange (IKE)</A
></DT
><DT
>20.4. <A
HREF="#AEN2470"
>Additional informations:</A
></DT
></DL
></DD
><DT
>21. <A
HREF="#CHAPTER-QOS"
>Quality of Service (QoS)</A
></DT
><DD
><DL
><DT
>21.1. <A
HREF="#AEN2482"
>General</A
></DT
><DT
>21.2. <A
HREF="#AEN2486"
>Linux QoS using “tc”</A
></DT
></DL
></DD
><DT
>22. <A
HREF="#CHAPTER-HINTS-DAEMONS"
>Hints for IPv6-enabled daemons</A
></DT
><DD
><DL
><DT
>22.1. <A
HREF="#HINTS-DAEMONS-BIND"
>Berkeley Internet Name Domain (BIND) daemon “named”</A
></DT
><DT
>22.2. <A
HREF="#HINTS-DAEMONS-XINETD"
>Internet super daemon (xinetd)</A
></DT
><DT
>22.3. <A
HREF="#HINTS-DAEMONS-APACHE2."
>Webserver Apache2 (httpd2)</A
></DT
><DT
>22.4. <A
HREF="#HINTS-DAEMONS-RADVD"
>Router Advertisement Daemon (radvd)</A
></DT
><DT
>22.5. <A
HREF="#HINTS-DAEMONS-DHCPV6."
>Dynamic Host Configuration v6 Server (dhcp6s)</A
></DT
><DT
>22.6. <A
HREF="#HINTS-DAEMONS-ISC-DHCP"
>ISC Dynamic Host Configuration Server (dhcpd)</A
></DT
><DT
>22.7. <A
HREF="#HINTS-DAEMONS-DIBBLER"
>DHCP Server Dibbler</A
></DT
><DT
>22.8. <A
HREF="#HINTS-DAEMONS-TCPWRAPPER"
>tcp_wrapper</A
></DT
><DT
>22.9. <A
HREF="#HINTS-DAEMONS-VSFTPD"
>vsftpd</A
></DT
><DT
>22.10. <A
HREF="#HINTS-DAEMONS-PROFTPD"
>proftpd</A
></DT
><DT
>22.11. <A
HREF="#HINTS-DAEMONS-OTHERS"
>Other daemons</A
></DT
></DL
></DD
><DT
>23. <A
HREF="#CHAPTER-PROGRAMMING"
>Programming</A
></DT
><DD
><DL
><DT
>23.1. <A
HREF="#CHAPTER-SECTION-USING-API"
>Programming using C-API</A
></DT
><DT
>23.2. <A
HREF="#AEN3003"
>Other programming languages</A
></DT
></DL
></DD
><DT
>24. <A
HREF="#CHAPTER-INTEROPERABILITY"
>Interoperability</A
></DT
><DT
>25. <A
HREF="#CHAPTER-INFORMATION"
>Further information and URLs</A
></DT
><DD
><DL
><DT
>25.1. <A
HREF="#INFORMATION-BOOKS"
>Paper printed books, articles, online reviews (mixed)</A
></DT
><DT
>25.2. <A
HREF="#INFORMATION-CONFERENCES"
>Conferences, Meetings, Summits</A
></DT
><DT
>25.3. <A
HREF="#INFORMATION-ONLINEINFORMATION"
>Online information</A
></DT
><DT
>25.4. <A
HREF="#AEN3670"
>IPv6 Infrastructure</A
></DT
><DT
>25.5. <A
HREF="#INFORMATION-MAILLISTS"
>Maillists</A
></DT
><DT
>25.6. <A
HREF="#INFORMATION-ONLINETESTTOOLS"
>Online tools</A
></DT
><DT
>25.7. <A
HREF="#INFORMATION-TRAININGSANDSEMINARS"
>Trainings, Seminars</A
></DT
><DT
>25.8. <A
HREF="#INFORMATION-ONLINEDISCOVERY"
>'The Online Discovery' ...</A
></DT
></DL
></DD
><DT
>26. <A
HREF="#AEN4047"
>Revision history / Credits / The End</A
></DT
><DD
><DL
><DT
>26.1. <A
HREF="#REVISION-HISTORY"
>Revision history</A
></DT
><DT
>26.2. <A
HREF="#CREDITS"
>Credits</A
></DT
><DT
>26.3. <A
HREF="#AEN4584"
>The End</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-GENERAL"
></A
>Chapter 1. Geral</H1
><P
>As informações sobre as traduções disponíveis estão na seção<A
HREF="#GENERAL-TRANSLATIONS"
>Translations</A
>.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GENERAL-COPRIGHT"
>1.1. Copyright, licença e outros</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN41"
>1.1.1. Copyright</A
></H3
><P
>Escrito e com Copyright (C) 2001-2011 por Peter Bieringer</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN44"
>1.1.2. Licença</A
></H3
><P
>Este Linux IPv6 HOWTO está publicado sob a licença GNU GPL versão 2:</P
><P
>Linux IPv6 HOWTO, um guia para configurar e usar o IPv6 em sistemas Linux. </P
><P
>Copyright © 2001-2011 Peter Bieringer </P
><P
>Este documento é um software livre; voce pode redistribui-lo e/ou modifica-lo sob os termos da licença GNU GPL, tal como está publicado pela Free Software Foundation; seja pela versão 2 da Licença, ou (em sua opinião) qualquer versão posterior.</P
><P
>Este programa é distribuído na esperança de que seja útil, mas SEM QUALQUER GARANTIA; nem mesmo qualquer garantia de COMERCIALIZAÇÃO ou ADEQUAÇÃO PARA UM PROPÓSITO PARTICULAR. Veja a GNU GPL para mais detalhes.</P
><P
>Se voce quiser uma cópia da licença GNU GPL, solicite através de carta para o endereço Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110, USA.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN52"
>1.1.3. Sobre o autor</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN54"
>1.1.3.1. História do autor com a Internet e IPv6</A
></H4
><P
></P
><UL
><LI
><P
>1993: Eu entrei em contato com a internet utilizando um cliente de email e news baseado em console há bastante tempo (procure por "e91abier" no grupo <A
HREF="http://groups.google.com/"
TARGET="_top"
>groups.google.com</A
>, sou eu).</P
></LI
><LI
><P
>1996: Foi solicitado que eu produzisse um curso de IPv6, incluindo um workshop com o Sistema Operacional Linux.</P
></LI
><LI
><P
>1997: Comecei escrevendo um guia sobre como instalar, configurar e utilizar o IPv6 em Linux, chamado<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
> (veja <A
HREF="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO/IPv6-HOWTO-0.html#history"
TARGET="_top"
>IPv6 &#38; Linux - HowTo/History</A
> para mais informações).</P
></LI
><LI
><P
>2001: Comecei a escrever este novo Linux IPv6 HOWTO.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN68"
>1.1.3.2. Contato</A
></H4
><P
>O autor pode ser contactado através do endereço de email &#60;pb at bieringer dot de&#62; e também através de sua<A
HREF="http://www.bieringer.de/pb/"
TARGET="_top"
>homepage</A
>.</P
><P
>Atualmente ele mora em Munique [parte nordeste de Schwabing] / Bavaria / Alemanha (sul) / Europa (centro) / Terra (superfície).</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GENERAL-CATEGORY"
>1.2. Categoria</A
></H2
><P
>Este HOWTO deve ser listado na categoria "Networking/Protocols".</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN76"
>1.3. Versão, Histórico e To-Do</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN78"
>1.3.1. Versão</A
></H3
><P
>A versão atual deste documento é mostrada no começo do documento.</P
><P
>Informação CVS:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>CVS-ID: $Id$</PRE
></FONT
></TD
></TR
></TABLE
><P
>Para outras versões ou traduções disponíveis, veja o site<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>http://www.bieringer.de/linux/IPv6/</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN85"
>1.3.2. Histórico</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN87"
>1.3.2.1. Relevantes</A
></H4
><P
>2001-11-30: Começo do estilo do novo HOWTO.</P
><P
>2002-01-02: Maioria do conteúdo feito, primeira publicação do capítulo 1(versão 0.10).</P
><P
>2002-01-14: Mais conteúdo, algumas revisões, e publicação do documento completo (version 0.14).</P
><P
>2002-08-16: Tradução para o Polones em progresso</P
><P
>2002-10-31: Tradução para o Chines disponível (veja <A
HREF="#GENERAL-TRANSLATIONS"
>Translations</A
> para mais informações)</P
><P
>2002-11-10: Tradução para o Alemão em progresso</P
><P
>2003-02-10: Tradução para o Alemão disponível</P
><P
>2003-04-09: Tradução para o Frances em progresso</P
><P
>2003-05-09: Tradução para o Frances disponível</P
><P
>2003-10-16: Tradução para o Italiano em progresso</P
><P
>2004-03-12: Tradução para o Italiano disponível</P
><P
>2004-06-18: Tradução para o Grego em progresso</P
><P
>2005-07-25: Tradução para o Turco disponível</P
><P
>2007-03-28: Tradução para o Portugues-Brazil em progresso</P
><P
>2008-07-30: Tradução para o Espanhol disponível (mas ainda em progresso)</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN105"
>1.3.2.2. História completa</A
></H4
><P
>Veja <A
HREF="#REVISION-HISTORY"
>revision history</A
> no final deste documento</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN109"
>1.3.3. To-Do</A
></H3
><P
></P
><UL
><LI
><P
>Completar conteúdo que ainda falta</P
></LI
><LI
><P
>Finalizar a checagem gramatical</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GENERAL-TRANSLATIONS"
>1.4. Traduções</A
></H2
><P
>As traduções devem sempre conter a URL, número da versão c copyright do documento original (e o seu também). Por favor não traduza o changelog original, pois isto não terá muita importancia. Também não traduza a seção sobre traduções disponíveis, pois elas podem estar desatualizadas. Ao invés disso, adicione uma URL para a seção em Ingles deste HOWTO.</P
><P
>Aparentemente a frequencia de mudança deste documento ocorre menos de uma vez por mes. Desde a versão 0.2.7 parece que a maioria do conteúdo que eu fiz foi escrito. As traduções devem sempre ter a versão em ingles como original..</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN120"
>1.4.1. Linguagens</A
></H3
><P
>Nota: uma olhada nesta URL pode ajudar<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>http://www.bieringer.de/linux/IPv6/</A
>.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN124"
>1.4.1.1. Chines</A
></H4
><P
>A tradução para o Chines, feito por Burma Chen &#60;expns at yahoo dot com&#62; (informada a mim em 2002-10-31) e pode ser encontrada no TLDP:<A
HREF="http://www.ibiblio.org/pub/Linux/docs/HOWTO/translations/zh/Linux-IPv6-HOWTO.txt.gz"
TARGET="_top"
>http://www.ibiblio.org/pub/Linux/docs/HOWTO/translations/zh/Linux-IPv6-HOWTO.txt.gz (g'zipped txt)</A
>. É uma foto da tradução, eu não sei se está atualizada.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN128"
>1.4.1.2. Polones</A
></H4
><P
>Desde 2002-08-16 a tradução para o Polones foi iniciada e ainda está em progresso por Lukasz Jokiel &#60;Lukasz dot Jokiel at klonex dot com dot pl&#62;. Versão usada: CVS-version 1.29 do arquivo LyX, a qual foi a origem para a versão 0.2.7. O status é de ainda em progresso (2004-08-30).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN131"
>1.4.1.3. German</A
></H4
><P
>Em 2002-11-10 a versão Alemã foi iniciada por Georg Käfer &#60;gkaefer at gmx dot at&#62; iniciou a tradução para o alemão, e a primeira publicação foi feita em 2003-02-10. Ela está originalmenmte disponível na Deep Space 6<A
HREF="http://mirrors.deepspace6.net/Linux+IPv6-HOWTO-de/"
TARGET="_top"
>http://mirrors.deepspace6.net/Linux+IPv6-HOWTO-de/</A
> (e também em <A
HREF="http://mirrors.bieringer.de/Linux+IPv6-HOWTO-de/"
TARGET="_top"
>http://mirrors.bieringer.de/Linux+IPv6-HOWTO-de/</A
>). Esta versão se manterá atualizada tanto quanto for possível.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN136"
>1.4.1.4. Frances</A
></H4
><P
>Em 2003-04-09 foi iniciada a tradução da versão em Frances, por Michel Boucey &#60;mboucey at free dot fr&#62; e a primeira publicação foi em 2003-05-09. Ela está originalmente disponível na Deep Space 6<A
HREF="http://mirrors.deepspace6.net/Linux+IPv6-HOWTO-fr/"
TARGET="_top"
>http://mirrors.deepspace6.net/Linux+IPv6-HOWTO-fr/</A
> (e também em <A
HREF="http://mirrors.bieringer.de/Linux+IPv6-HOWTO-fr/"
TARGET="_top"
>http://mirrors.bieringer.de/Linux+IPv6-HOWTO-fr/</A
>).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN141"
>1.4.1.5. Espanhol</A
></H4
><P
>Um membro do projeto MontevideoLibre, localizado no Uruguai (América do Sul) iniciou a tradução para espanhol no formato wiki:<A
HREF="http://www.montevideolibre.org./manuales:libros:ipv6"
TARGET="_top"
>http://www.montevideolibre.org./manuales:libros:ipv6</A
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN145"
>1.4.1.6. Italiano</A
></H4
><P
>Em 2003-10-16 a tradução para uma versão em Italiano foi iniciada Michele Ferritto &#60;m dot ferritto at virgilio dot it&#62; para o<A
HREF="http://ildp.pluto.linux.it/"
TARGET="_top"
>ILDP</A
> (Italian Linux Documentation Project) e a sua primeira publicação foi em 2004-03-12. Ela está originalmente disponível no ILDP em <A
HREF="http://it.tldp.org/HOWTO/Linux+IPv6-HOWTO/"
TARGET="_top"
>http://it.tldp.org/HOWTO/Linux+IPv6-HOWTO/</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN150"
>1.4.1.7. Japones</A
></H4
><P
>Em 2003-05-14 Shino Taketani &#60;shino_1305 at hotmail dot com&#62; me enviou uma nota dizendo que planejava traduzir o HOWTO para o japones.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN153"
>1.4.1.8. Grego</A
></H4
><P
>Em 2004-06-18 Nikolaos Tsarmpopoulos &#60;ntsarb at uth dot gr&#62; me enviou uma nota dizendo que planejava traduzir o HOWTO para o Grego.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN156"
>1.4.1.9. Turco</A
></H4
><P
>Em 2005-07-18 Necdet Yucel &#60;nyucel at comu dot edu dot tr&#62; me enviou uma nota dizendo que a tradução em Turco estava disponível. E uma fotografia da tradução (versão 0.61) pode ser encontrada na URL<A
HREF="http://docs.comu.edu.tr/howto/ipv6-howto.html"
TARGET="_top"
>http://docs.comu.edu.tr/howto/ipv6-howto.html</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN160"
>1.4.1.10. Portuguese-Brazil</A
></H4
><P
>Em 2011-05-06 Gustavo Mendes de Carvalho &#60;gmcarvalho at gmail dot com&#62; iniciou a tradução deste HowTo para Portugues-Brazil. A primeira tentativa realizada em 2007 por Claudemir da Luz &#60;claudemir dot daluz at virtuallink dot com dot br&#62; nunca foi finalizada.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN163"
>1.5. Técnico</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="GENERAL-ORIGINAL-SOURCE"
>1.5.1. Fonte original deste HOWTO</A
></H3
><P
>Este HOWTO foi escrito usando LyX versão 1.6.1 em um sistema Linux Fedora 10 com o template SGML/XML (DocBook). Ele está disponível em<A
HREF="http://cvs.tldp.org/go.to/LDP/LDP/users/Peter-Bieringer/"
TARGET="_top"
>TLDP-CVS / users / Peter-Bieringer</A
> para contribuições.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN169"
>1.5.1.1. Divisor de linha de código</A
></H4
><P
>Eu utilizei um utilitário divisor de linha de código (Code line wrapping - "lyxcodelinewrapper.pl") feito por mim mesmo, e ele está disponível para seu próprio uso em<A
HREF="http://cvs.tldp.org/go.to/LDP/LDP/users/Peter-Bieringer/"
TARGET="_top"
>TLDP-CVS / users / Peter-Bieringer</A
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN173"
>1.5.1.2. Geração de SGML</A
></H4
><P
>O SGML/XML é gerado usando a função de exportar do LyX</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN176"
>1.5.2. Referencias On-line para a versão em HTML deste HOWTO</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN178"
>1.5.2.1. Página principal</A
></H4
><P
>Como boa prática, uma referencia à página principal deste HOWTO é recomendada.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN181"
>1.5.2.2. Páginas dedicadas</A
></H4
><P
>Como as páginas em HTML são geradas a partir dos arquivos SGML, os nomes dos arquivos em HTML podem ser bastante diferentes (randomicos). Entretanto, algumas páginas são etiquetadas em LyX, resultando em nomes estáticos. Estas etiquetas são úteis para referencias e não deveriam ser alteradas no futuro. Se voce acredita que eu esqueci qualquer etiqueta, por favor me avise, e eu colocarei.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN184"
>1.6. Prefácio</A
></H2
><P
>Algumas coisas antes:</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN187"
>1.6.1. Quantas versões deste HOWTO existem por aí ?</A
></H3
><P
>Incluindo esta, existem 3 (tres) documentos HOWTO disponíveis. Minhas desculpas se forem demais ;-)</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN190"
>1.6.1.1. Linux IPv6 FAQ/HOWTO (desatualizada)</A
></H4
><P
>O primeiro documento HOWTO relacionado a IPv6 foi escrito pelo Eric Osborne e era chamado<A
HREF="http://www.linuxhq.com/IPv6/"
TARGET="_top"
>Linux IPv6 FAQ/HOWTO</A
> (por favor use-o somente para fins históricos). Sua última versão foi a 3.2.1, lançada em 14 de Julho de 1997.</P
><P
>Por favor ajude: Se alguém souber a data de nascimento deste HOWTO, por favor me envie um e-mail (estas informações são necessárias para o "histórico").</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN195"
>1.6.1.2. IPv6 &#38; Linux - HowTo (mantida)</A
></H4
><P
>Esta segunda versão existe e se chama<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
> escrita por mim (Peter Bieringer) em HTML puro. Ele nasceu em Abril de 1997 e sua primeira versão em ingles foi publicada em Junho de 1997. Eu vou continuar a manter esta versão, mas isto deve acontecer devagar e não será por completo, em favor da atualização da versão do Linux IPv6 HOWTO que voce está lendo agora.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN199"
>1.6.1.3. Linux IPv6 HOWTO (este documento)</A
></H4
><P
>Já que este<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
> foi escrito em HTML puro, ele não é compatível com o <A
HREF="http://www.tldp.org/"
TARGET="_top"
>The Linux Documentation Project (TLDP)</A
>. Eu recebi então um pedido no final de Novembro de 2001 para reescrever este HowTo <A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
> em SGML. Entretanto, por causa da descontinuidade do HOWTO (<A
HREF="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO/IPv6-HOWTO-0.html#history"
TARGET="_top"
>Future of IPv6 &#38; Linux - HowTo</A
>), e como o IPv6 estava ficando mais e mais padronizado, eu decidi escrever um novo documento cobrindo os pontos básicos e um pouco avançados que permaneceram importantes ao longo destes anos. Algum conteúdo mais dinamico e avançado ainda pode ser encontrado neste segundo HOWTO (<A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
>).</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN207"
>1.7. Termos usados, glossário e atalhos</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN209"
>1.7.1. Rede</A
></H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Base 10</DT
><DD
><P
>Sistema numérico muito bem conhecido e representa qualquer valor com os dígitos 0 a 9.</P
></DD
><DT
>Base 16</DT
><DD
><P
>Geralmente usado em linguagens de programação, também conhecido como sistema numérico hexadecimal, representa qualquer valor com os dígitos 0 a 9 e caracteres A a F (case insensitive).</P
></DD
><DT
>Base 85</DT
><DD
><P
>Representação de um valor com 85 dígitos/caracteres diferentes, ele pode levar a strings menores, mas nunca vi ser usado em campo.</P
></DD
><DT
>Bit</DT
><DD
><P
>A menor unidade de armazenamento, representa on/verdade/1 e off/falso/0.</P
></DD
><DT
>Byte</DT
><DD
><P
>Geralmente uma coleção de 8 bits (mas não é necessariamente uma verdade - veja outros sistemas computacionais)</P
></DD
><DT
>Device</DT
><DD
><P
>Aqui, o hardware para a conexão de rede, veja também NIC</P
></DD
><DT
>Dual homed host</DT
><DD
><P
>Um sistema dual homed é um nó com duas redes (física ou virtual) com interfaces em dois links diferentes, mas sem encaminhar qualquer pacote entre eles (não é um router).</P
></DD
><DT
>Host</DT
><DD
><P
>Geralmente um sistema single homed com somente uma interface de rede ativa, exemplo Ethernet ou (não e) PPP.</P
></DD
><DT
>Interface</DT
><DD
><P
>Quase sempre o mesmo que "device", veja também NIC</P
></DD
><DT
>IP Header</DT
><DD
><P
>Cabeçalho de um pacote IP (cada pacote de rede tem um cabeçalho e seu tipo depende do nível de rede)</P
></DD
><DT
>Link</DT
><DD
><P
>Um link é o nível 2 de rede, ou meio de transporte de pacotes. exemplos são Ethernet, Token Ring, PPP, SLIP, ATM, ISDN, Frame Relay,...</P
></DD
><DT
>Node</DT
><DD
><P
>Um nó é um host ou um router.</P
></DD
><DT
>Octet</DT
><DD
><P
>É uma coleção de 8 bits, hoje bem similar a "byte".</P
></DD
><DT
>Port</DT
><DD
><P
>Informação utilizada pelo TCP/UDP dispatcher (camada 4) para transportar informações para as camadas superiores</P
></DD
><DT
>Protocolo</DT
><DD
><P
>Cada camada de rede que contém a maioria dos campos e informações para tornar a vida mais fácil ao enviar a informação transportada para as camadas superiores, veja camada 2 (MAC) e 3 (IP)</P
></DD
><DT
>Router</DT
><DD
><P
>Um router é um nó com 2 ou mais redes interfaces de rede (física ou virtual), capaz de encaminhar os pacotes entre as suas interfaces.</P
></DD
><DT
>Socket</DT
><DD
><P
>Um socket IP é definido pelo endereço de origem e destino, e suas portas</P
></DD
><DT
>Stack</DT
><DD
><P
>Relacionado às várias camadas de rede</P
></DD
><DT
>Subnetmask</DT
><DD
><P
>Redes IP usam bits de máscara para separar redes locais de redes remotas</P
></DD
><DT
>Tunnel</DT
><DD
><P
>Um túnel é tipicamente uma conexão ponto-a-ponto sobre a qual pacotes são trocados, e que carregam dados de outro protocolo. Exemplo túnel IPv6-in-IPv4.</P
></DD
></DL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="GLOSSAR"
>1.7.1.1. Atalhos</A
></H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>ACL</DT
><DD
><P
>Access Control List - Lista de controle de acesso</P
></DD
><DT
>API</DT
><DD
><P
>Application Programming Interface - Interface de programação de aplicação</P
></DD
><DT
>ASIC</DT
><DD
><P
>Application Specified Integrated Circuit</P
></DD
><DT
>BSD</DT
><DD
><P
>Berkeley Software Distribution</P
></DD
><DT
>CAN-Bus</DT
><DD
><P
>Controller Area Network Bus (physical bus system)</P
></DD
><DT
>ISP</DT
><DD
><P
>Internet Service Provider - Provedor de serviços Internet</P
></DD
><DT
>KAME</DT
><DD
><P
>Projeto - um esforço conjunto de seis companhias no Japão para fornecer grátis uma pilha IPv6 e IPsec (para ambos IPv4 e IPv6) para as variantes BSD existentes no mundo <A
HREF="http://www.kame.net/"
TARGET="_top"
>www.kame.net</A
></P
></DD
><DT
>LIR</DT
><DD
><P
>Local Internet Registry - No Brasil, o registro.br</P
></DD
><DT
>NIC</DT
><DD
><P
>Network Interface Card</P
></DD
><DT
>RFC</DT
><DD
><P
>Request For Comments - conjunto de notas técnicas organizacionais sobre a Internet</P
></DD
><DT
>USAGI</DT
><DD
><P
>UniverSAl playGround for Ipv6 Project - trabalho para entregar uma pilha IPv6 de qualidade para os sistemas Linux.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN340"
>1.7.2. Informações úteis</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN342"
>1.7.2.1. Sinal de divisão de linha longa de código</A
></H4
><P
>O caractere especial "¬" é usado para sinalizar que esta linha de código foi dividida para se obter uma melhor visualização em arquivos PFG e PS.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN345"
>1.7.2.2. Marcadores</A
></H4
><P
>Nos exemplos genéricos voce encontrará as seguintes marcações:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#60;myipaddress&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Para o uso real em seu sistema de linha de comando ou em scripts, isto deve ser substituído pelo conteúdo correto (removendo os sinais &#60; e &#62;). Desta forma o resultado seria</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>1.2.3.4</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN351"
>1.7.2.3. Comandos no shell</A
></H4
><P
>Comandos executados no shell por usuários normais (não root) começam com $</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ whoami</PRE
></FONT
></TD
></TR
></TABLE
><P
>Comandos executados pelo usuário root começam com #</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># whoami</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN357"
>1.8. Necessidades para usar este HOWTO</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN359"
>1.8.1. Prerequisitos pessoais</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN361"
>1.8.1.1. Experiencia com ferramentas Unix</A
></H4
><P
>Voce deve estar familiarizado com a maioria das ferramentas Unix, como grep, awk, find, etc. , e saber sobre a maioria das opções mais usadas de cada um deles.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN364"
>1.8.1.2. Experiencia com teoria de rede</A
></H4
><P
>Voce deve estar famliarizado com camadas, protocolos, endereços, cabos, conectores, etc. Se voce é novo nesta área, este é um bom local para voce iniciar seus estudos<A
HREF="http://www.rigacci.org/docs/biblio/online/intro_to_networking/book1.htm"
TARGET="_top"
>http://www.rigacci.org/docs/biblio/online/intro_to_networking/book1.htm</A
></P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN368"
>1.8.1.3. Experiencia com configuração IPv4</A
></H4
><P
>Voce deve definitivamente ter alguma experiencia em configuração de redes IPv4, caso contrário será difícil para voce entender o que realmente está acontecendo.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN371"
>1.8.1.4. Experiencia com Domain Name System (DNS)</A
></H4
><P
>Permitirá a voce entender o que é um Domain Name System (DNS), que serviço ele fornece e como usa-lo.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN374"
>1.8.1.5. Experiencia com estratégias de debug de rede</A
></H4
><P
>Voce deve pelo menos entender como usar o tcpdump e o que ele pode te mostrar. Caso contrário a depuração de problemas de rede será muito difícil para voce.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN377"
>1.8.2. Hardware compatível com o sistema Linux</A
></H3
><P
>É claro que voce vai precisar usar algum hardware (pode ser uma maquina virtual), e não somente ler este HOWTO para dormir. ;-7)</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-BASICS"
></A
>Chapter 2. Básico</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN382"
>2.1. O que é IPv6?</A
></H2
><P
>O IPv6 é um novo protocolo de camada 3 que tem a função de substituir o IPv4 (também conhecido apenas por IP). O IPv4 foi projetado a muito tempo atrás(<A
HREF="http://www.faqs.org/rfcs/rfc760.html"
TARGET="_top"
>RFC 760 / Internet Protocol</A
> de Janeiro de 1980) e desde o começo tem havido muitos pedidos de atender mais capacidades e funcionalidades. A última RFC é <A
HREF="http://www.faqs.org/rfcs/rfc2460.html"
TARGET="_top"
>RFC 2460 / Internet Protocol Version 6 Specification</A
>.As grandes mudanças no IPv6 foram o novo formato do cabeçalho, incluindo o tamanho da capacidade de endereços, de 32 para 128 bits. Já que a camada 3 é a responsável por transporte de pacotes fim a fim usando o roteamento baseado em endereços, ele deveria incluir os endereços IPv6 de origem e destino tal como o IPv4.</P
><P
>Para mais informações sobre a história do IPv6, de uma olhada nas RFC's mais antigas do IPv6 listadas aqui<A
HREF="http://www.switch.ch/lan/ipv6/references.html"
TARGET="_top"
>SWITCH IPv6 Pilot / References</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BASIC-HISTORY-IPV6-LINUX"
>2.2. História do IPv6 no Linux</A
></H2
><P
>Os anos de 1992, 1993 e 1994 do IPv6 no Linux (linhas gerais) são cobertos pelo seguinte documento:<A
HREF="http://www.laynetworks.com/IPv6.htm#CH3"
TARGET="_top"
>IPv6 or IPng (IP next generation)</A
>.</P
><P
>To-do: melhorar a linha do tempo, adicionar conteúdo...</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN394"
>2.2.1. O começo</A
></H3
><P
>O primeiro trecho de código de rede relacionado com o IPv6 foi adicionado ao kernel 2.1.8 do Linux em novembro de 1996 por Pedro Roque. Ele foi baseado na API do BSD:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>diff -u --recursive --new-file v2.1.7/linux/include/linux/in6.h
¬ linux/include/linux/in6.h 
--- v2.1.7/linux/include/linux/in6.h Thu Jan 1 02:00:00 1970 
+++ linux/include/linux/in6.h Sun Nov 3 11:04:42 1996 
@@ -0,0 +1,99 @@ 
+/* 
+ * Types and definitions for AF_INET6 
+ * Linux INET6 implementation 
+ * + * Authors: 
+ * Pedro Roque &#60;******&#62; 
+ * 
+ * Source: 
+ * IPv6 Program Interfaces for BSD Systems 
+ * &#60;draft-ietf-ipngwg-bsd-api-05.txt&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>As linhas mostradas foram copiadas do patch-2.1.8 (o email foi limpo para evitar spam).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN399"
>2.2.2. Enquanto isso</A
></H3
><P
>Por conta do buraco da manpower, a implementação do IPv6 no kernel foi incapaz de seguir os rascunhos propostos pelos novos RFC's publicados. Em outubro de 2000, um projeto foi iniciado no Japão, chamado<A
HREF="http://www.linux-ipv6.org/"
TARGET="_top"
>USAGI</A
>, cujo objetivo foi implantar todo o restante, ou desatualizado, suporte ao IPv6 para o Linux. Ele utiliza a implementação IPv6 atual para o FreeBSD feita pelo <A
HREF="http://www.kame.net/"
TARGET="_top"
>KAME project</A
>. De tempos em tempos, eles criavam fotos da versão vanilla do código do kernel do Linux.</P
><P
>Até a implementação do desenvolvimento na série 2.5 do kernel ter sido iniciado, os patches do<A
HREF="http://www.linux-ipv6.org/"
TARGET="_top"
>USAGI</A
> eram tão grandes, que os mantenedores de rede do Linux eram incapazes de inclui-lo completamente no código final do kernel do Linux série 2.4.x.</P
><P
>Durante o desenvolvimento da serie 2.5, o tentou inserir todas as suas extensões usadas nesta série.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN407"
>2.2.3. Atualmente</A
></H3
><P
>Muito do desenvolvimento feito para o IPv6 e patches do<A
HREF="http://www.linux-ipv6.org/"
TARGET="_top"
>USAGI</A
> e outros estão integrados na série vanilla do kernel 2.6.x.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN411"
>2.2.4. O futuro</A
></H3
><P
>O <A
HREF="http://www.linux-ipv6.org/"
TARGET="_top"
>USAGI</A
> e outros ainda mantém o trabalho na implementação de novas características e funcionalidades, como a mobilidade e outros. De tempos em tempos, novos patches com extensões são lançados e também integrados à série vanilla do kernel.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN415"
>2.3. Como o endereço IPv6 se parece?</A
></H2
><P
>Como já mencionado antes, os endereços IPv6 possuem 128 bits de tamanho. Este número de bits gera um número decimal extremamente grande, com 39 dígitos de tamanho:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2^128-1: 340282366920938463463374607431768211455</PRE
></FONT
></TD
></TR
></TABLE
><P
>Tais números não são endereços fáceis de serem memorizados. Os endereços IPv6 também tem um esquema orientado a bits (assim como o IPv4, mas não tão facilmente reconhecido). Assim a melhor notação de números tão grandes é em formato hexadecimal. Em hexadecimal, 4 bits (também conhecidos como "nibble") são representados por um dígito ou caractere, de 0-9 e A-F. Desta forma, o tamanho do endereço é reduzido para 32 caracteres.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2^128-1: 0xffffffffffffffffffffffffffffffff</PRE
></FONT
></TD
></TR
></TABLE
><P
>Esta representação ainda não é muito conveniente (com a possível mistura ou perda de um único dígito hexadecimal), então os desenvolvedores do IPv6 escolheram um formato hexadecimal com um ":" separando cada bloco de 16 bits. Com isso, o sinal inicial 0x (um prefixo para valores hexadecimais em linguagens de programação) foi removido:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2^128-1: ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff</PRE
></FONT
></TD
></TR
></TABLE
><P
>Um endereço utilizável seria:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:0100:f101:0210:a4ff:fee3:9566</PRE
></FONT
></TD
></TR
></TABLE
><P
>Para simplificar, os zeros iniciais de cada bloco de 16 bits pode ser omitido:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:0100:f101:0210:a4ff:fee3:9566  -&#62; 
¬ 2001:db8:100:f101:210:a4ff:fee3:9566</PRE
></FONT
></TD
></TR
></TABLE
><P
>Um bloco de 16 bits contendo somente zeros também pode ser omitida, sendo representada por "::", mas não mais de uma única vez no endereço. Caso contrário poderia haver duplicação de endereços.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:100:f101:0:0:0:1  -&#62;  2001:db8:100:f101::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>A maior redução possível é vista do endereço IPv6 de localhost:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0000:0000:0000:0000:0000:0000:0000:0001  -&#62;  ::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Há também um outro representação em modo compacto (Código base 85) baseado na<A
HREF="http://www.faqs.org/rfcs/rfc1924.html"
TARGET="_top"
>RFC 1924 / A Compact Representation of IPv6 Addresses</A
>(publicada em 1º Abril 1996), nunca vista em campo. Provavelmente é uma pegadinha ou mentirinha da data. Mas aqui está um exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ipv6calc --addr_to_base85 2001:0db8:0100:f101:0210:a4ff:fee3:9566 
9R}vSQZ1W=9A_Q74Lz&#38;R</PRE
></FONT
></TD
></TR
></TABLE
><A
NAME="AEN434"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Info: ipv6calc é uma calculadora de formato de endereços IPv6 que também faz conversões, e pode ser encontrada aqui: <A
HREF="http://www.deepspace6.net/projects/ipv6calc.html"
TARGET="_top"
>ipv6calc homepage</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/projects/ipv6calc.html"
TARGET="_top"
>Mirror</A
>)</P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN438"
>2.4. FAQ (Básico)</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN440"
>2.4.1. Porque o nome do sucessor do IPv4 é IPv6 e não IPv5 ?</A
></H3
><P
>No cabeçalho IP, os primeiros 4 bits são reservados para a versão do protocolo. Então em teoria qualquer número entre 0 e 15 seria possível.</P
><P
></P
><UL
><LI
><P
>4: já em uso pelo IPv4</P
></LI
><LI
><P
>5: está reservado para o Stream Protocol (STP,<A
HREF="http://www.faqs.org/rfcs/rfc1819.html"
TARGET="_top"
>RFC 1819 / Internet Stream Protocol Version 2</A
>) (o qual nunca foi realmente feito para o público)</P
></LI
></UL
><P
>O próximo número disponível era 6. Portando, assim nasceu o IPv6!</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN450"
>2.4.2. Endereços IPv6: porque um número tão grande de bits ?</A
></H3
><P
>Durante o desenvolvimento do IPv4, as pessoas pensaram que 32 bits seriam suficientes para o mundo. Olhando de volta, realmente 32 bits foram suficientes por bastante tempo. entretanto 32 bits não foram suficientes para prover endereços globais para todos os dispositivos de rede no futuro (ou será já no presente ?). Pense em telefones celulares, tablets, computadores virtuais, carros, GPS's, geladeiras, TV's, etc.</P
><P
>Assim, os desenvolvedores escolheram 128 bits, 4 vezes maior (no campo do tamanho do endereço) do que o IPv4.</P
><P
>Mas o tamanho utilizável é menor do que parece. Isto se deve por causa do esquema utilizado na definição do endereçamento: 64 bits são usados para identificar a interface. Os outros 64 bits são usados para o roteamento. Assumindo os níveis de agregação (/48, /32, ...), é possível que os endereços também se esgotem, mas esperamos que não em futuro próximo.</P
><P
>Para mais informações veja também<A
HREF="http://www.faqs.org/rfcs/rfc1715.html"
TARGET="_top"
>RFC 1715 / The H Ratio for Address Assignment Efficiency</A
> e <A
HREF="http://www.faqs.org/rfcs/rfc3194.html"
TARGET="_top"
>RFC 3194 / The Host-Density Ratio for Address Assignment Efficiency</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN458"
>2.4.3. Endereços IPv6: porque um número tão pequeno de bits em um nova versão ?</A
></H3
><P
>Enquanto existam (possivelmente) algumas pessoas (só sei do Jim Fleming...) na internet que estejam pensando sobre o IPv8 ou IPv16, estes projetos estão muito longe de serem aceitos e implementados. Enquanto isso, 128 bits foi a melhor escolha levando em consideração o overhead do cabeçalho e o transporte de dados. Considere o MTU mínimo no IPv4 (576 octetos) e no IPv6 (1280 octetos), o tamanho do cabeçalho em iIPv4 é de 20 octetos (mínimo, e pode aumentar até 60 octetos com outras opções usadas) e no IPv6 é de 40 octetos (fixo). Isto representa 3,4% de overhead no IPv4 (com o tamanho mínimo) e 3,1 % do menor MTU em IPv6. O overhead é praticamente igual. Mais bits para endereço necessitariam cabeçalhos maiores e consequentemente mais overhead. Além disso, considere o tamanho máximo de uma MTU em links normais (como em Ethernet hoje): são 1500 octetos (em alguns casos especiais 9.000 octetos usando jumbo frames). Assim, não seria um projeto apropriado se 10% a 20% dos dados transportados para a camada 3 fosse usado para endereçamento e não para dados propriamente ditos.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-ADDRESSTYPES"
></A
>Chapter 3. Tipos de endereço</H1
><P
>Como no IPv4, os endereços em IPv6 também podem ser divididos em duas partes - host e rede - com a utilização de máscaras de rede.</P
><P
>O IPv4 tem mostrado que algumas vezes é bom, se mais de um endereço IP puder ser configurado em uma interface, cada um deles com um propósito bem diferente (aliases, multicast). Então para continuar extensível, o IPv6 também suporta esta característica e permite que mais de 1 endereço seja configurado na mesma interface. Atualmente não existe qualquer limitação definida pela RFC, a não ser na implementação da pilha IPv6 (para evitar ataques DoS).</P
><P
>Ao usar este grande número de bits para endereço, o IPv6 define tipos de endereços baseado nos bits iniciais, os quais são, espera-se, não sejam quebrados no futuro, como acontece hoje com o IPv4 e as suas classes A, B e C.</P
><P
>Estes números de bits são separados para endereçar redes (os primeiros 64 bits) e para endereços de host (os últimos 64 bits), para facilitar a auto-configuração.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN467"
>3.1. Endereços sem um prefixo especial</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN469"
>3.1.1. Endereço localhost</A
></H3
><P
>Este é um endereço especial para a interface de loopback, similar ao 127.0.0.1 no IPv4. Em IPv6, este endereço de localhost é:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0000:0000:0000:0000:0000:0000:0000:0001 </PRE
></FONT
></TD
></TR
></TABLE
><P
>ou em sua forma comprimida:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Os pacotes com este endereço como origem ou destino nunca devem sair ou entrar em um host.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN476"
>3.1.2. Endereços não especificados</A
></H3
><P
>Este é um endereço especial, como "any" ou "0.0.0.0". Em IPv6 é representado assim:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0000:0000:0000:0000:0000:0000:0000:0000 </PRE
></FONT
></TD
></TR
></TABLE
><P
>ou:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::</PRE
></FONT
></TD
></TR
></TABLE
><P
>Este endereço é geralmente usado para especificação de portas (qualquer IPv6) ou tabelas de roteamento.</P
><P
>Nota: este endereço nunca pode ser usado como um endereço de destino.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN484"
>3.1.3. Endereços IPv6 vinculados a endereços IPv4</A
></H3
><P
>Existem dois endereços que contém endereços IPv4.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN487"
>3.1.3.1. IPv4-mapeado para IPv6</A
></H4
><P
>Um endereço IPv4-único para compatibilidade IPv6 é às vezes usado ou mostrado para sockets criados por um daemon IPv6, mas que só recebe conexões de endereços IPv4.</P
><P
>Estes endereços são definidos dentro de um prefixo especial, com o tamanho /96 (a.b.c.d é o endereço IPv4):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0:0:0:0:0:ffff:a.b.c.d/96</PRE
></FONT
></TD
></TR
></TABLE
><P
>ou em seu formato comprimido</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::ffff:a.b.c.d/96</PRE
></FONT
></TD
></TR
></TABLE
><P
>por exemplo, o endereço IP 1.2.3.4 seria assim:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::ffff:1.2.3.4</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN496"
>3.1.3.2. por exemplo, o endereço IP 1.2.3.4 seria assim:</A
></H4
><P
>Usado para tunelamento automático(<A
HREF="http://www.faqs.org/rfcs/rfc2893.html"
TARGET="_top"
>RFC 2893 / Transition Mechanisms for IPv6 Hosts and Routers</A
>), o qual é substituído pelo <A
HREF="#TUNNELING-6TO4."
>6to4 tunneling</A
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0:0:0:0:0:0:a.b.c.d/96</PRE
></FONT
></TD
></TR
></TABLE
><P
>ou em seu formato comprimido</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::a.b.c.d/96</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN504"
>3.2. Parte da rede, também conhecido como prefixo</A
></H2
><P
>Os designers definiram alguns tipos de endereços e deixaram muito disto para futuras definições quando novas necessidades surgirem. A <A
HREF="http://www.faqs.org/rfcs/rfc4291.html"
TARGET="_top"
>RFC 4291 / IP Version 6 Addressing Architecture</A
> define o esquema utilizado no endereçamento atual.</P
><P
>Vamos agora dar uma olhada nos diferentes tipos de prefixos (e também em tipos de endereços):</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN509"
>3.2.1. Endereço tipo "link local"</A
></H3
><P
>Estes são endereços epeciais que são válidos somente no link de uma interface. Usando este endereço como destino, os pacotes nunca serão encaminhados a um router. Isto é usado para links de comunicação, tais como:</P
><P
></P
><UL
><LI
><P
>Há alguém está aqui neste link ?</P
></LI
><LI
><P
>Há alguém aqui com endereços especiais (ex. procurando por um router) ?</P
></LI
></UL
><P
>Eles começam com (onde "x" é qualquer caractere hexadecimal, normalmente "0")</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>fe8<EM
>x:  &#60;- atualmente é o único em uso</EM
>
fe9<EM
>x:</EM
>
fea<EM
>x:</EM
>
feb<EM
>x:</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Um endereço com este prefixo é encontrado em cada interface com IPv6 habilitado após a auto-configuração stateless (a qual é normalmente sempre o caso).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN524"
>3.2.2. Endereço tipo "site local"</A
></H3
><P
>Estes endereços são similares aos da<A
HREF="http://www.faqs.org/rfcs/rfc1918.html"
TARGET="_top"
>RFC 1918 / Address Allocation for Private Internets</A
> em uso atualmente em IPv4, com a vantagem adicional de que qualquer pessoa que usar este tipo de endereço tem a capacidade de usar até 16 bits para a definição máxima de 65535 subredes. Comparável com o 10.0.0.0/8 do IPv4.</P
><P
>Outra vantagem: como é possível colocar mais de 1 endereço em uma interface com IPv6, voce pode configurar um endereço de "site local" junto com um endereço global.</P
><P
>Ele começa com:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>fec<EM
>x:  &#60;- mais usado, mais comum</EM
>
fed<EM
>x:</EM
>
fee<EM
>x:</EM
>
fef<EM
>x:</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>(onde o "x" é qualquer caractere hexadecimal, geralmente um "0")</P
><P
>Este tipo de endereço não deveria mais ser usado, <A
HREF="http://www.faqs.org/rfcs/rfc3879.html"
TARGET="_top"
>RFC 3879 / Deprecating Site Local Addresses</A
>, mas para um teste em laboratório, estes endereços ainda continuam sendo uma boa escolha (IMHO - em minha humilde opinião).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN538"
>3.2.3. Endereços locais Unicast IPv6</A
></H3
><P
>Por causa da definição original de endereços de site local não serem únicos, pode haver algum problema se duas redes já configuradas forem se conectar em um futuro próximo (overlap de subredes). Este e outros problemas foram os motivos para um novo tipo de endereço definido na<A
HREF="http://www.faqs.org/rfcs/rfc4193.html"
TARGET="_top"
>RFC 4193 / Unique Local IPv6 Unicast Addresses</A
>. </P
><P
>Ele começa com:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>fcx<EM
>x:</EM
>
fdx<EM
>x:  &#60;- atualmente o único em uso</EM
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Uma parte do prefixo (40 bits) é gerada usando um algoritmo pseudo-randomico e é improvável que dois resultados gerados por este algoritmo sejam iguais.</P
><P
>Exemplo de um prefixo gerado por este algoritmo (veja em: <A
HREF="http://www.goebel-consult.de/ipv6/createLULA"
TARGET="_top"
>Goebel Consult / createLULA</A
>):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>fd0f:8b72:ac90::/48</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN550"
>3.2.4. Endereço tipo Global "(Aggregatable) global unicast"</A
></H3
><P
>Atualmente, existe um tipo de endereço definido globalmente (o primeiro design, chamado "provider based") que foi jogado fora a alguns anos atrás<A
HREF="http://www.faqs.org/rfcs/rfc1884.html"
TARGET="_top"
>RFC 1884 / IP Version 6 Addressing Architecture [obsolete]</A
>, e voce consegue encontrar em algumas versões do kernel do Linux.</P
><P
>Ele começa com (os caracteres "x" são hexadecimais)</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2<EM
>xxx</EM
>: 
3<EM
>xxx</EM
>:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Nota: o prefixo "aggregatable" foi descartado nos atuais drafts. Há ainda alguns outros subtipos definidos. Veja abaixo:</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN559"
>3.2.4.1. Endereço de teste 6bone</A
></H4
><P
>Estes foram os primeiros endereços globais que foram definidos e usados. Eles começam com </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>3ffe:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>3ffe:ffff:100:f102::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Um endereço de teste especial para o 6bone que nunca seria globalmente único começa com</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>3ffe:ffff: </PRE
></FONT
></TD
></TR
></TABLE
><P
>e a maioria deles é mostrado em exemplos antigos. A razão para isso é, se endereços reais são mostrados, seria possível alguém copiar e colar estes endereços de arquivos de configuração antigos, o que inadvertidamente causaria um erro de duplicação de endereço de um endereço global único. Isto poderia causar sérios problemas para o host original (como nunca receber as respostas de requisições feitas). </P
><P
>Como o IPv6 agora já está em produção, este prefixo não é mais delegado e ele foi removido do processo de roteamento (veja<A
HREF="http://www.faqs.org/rfcs/rfc3701.html"
TARGET="_top"
>RFC 3701 / 6bone Phaseout</A
> para mais detalhes).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN570"
>3.2.4.2. Endereços 6to4</A
></H4
><P
>Estes endereços, feitos para um mecanismo de túnel especial [<A
HREF="http://www.faqs.org/rfcs/rfc3056.html"
TARGET="_top"
>RFC 3056 / Connection of IPv6 Domains via IPv4 Clouds</A
> e <A
HREF="http://www.faqs.org/rfcs/rfc2893.html"
TARGET="_top"
>RFC 2893 / Transition Mechanisms for IPv6 Hosts and Routers</A
>],utilizam um endereço IPv4 já fornecido e a sua possível subnet, e começam com</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2002:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Por exemplo, este endereço 192.168.1.1/5 ficaria:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2002:c0a8:0101:5::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Um pequeno comando em shell poderia ajudar voce a gerar este endereço, baseado em um endereço IPv4 fornecido:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ipv4="1.2.3.4"; sla="5"; printf "2002:%02x%02x:%02x%02x:%04x::1" `echo $ipv4
¬ | tr "." " "` $sla</PRE
></FONT
></TD
></TR
></TABLE
><P
>Veja também <A
HREF="#TUNNELING-6TO4."
>tunneling using 6to4</A
> e <A
HREF="#INFORMATION-JOINIPV6-6TO4-TUNNELING"
>information about 6to4 relay routers</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN583"
>3.2.4.3. Designado pelo provedor para roteamento hierárquico</A
></H4
><P
>Este endereço é delegado pelo ISP e começa com</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Prefixos de ISP's maiores (ou AS's) são delegados pelos <A
HREF="#INFORMATION-MAJORREGIONREGISTRIES"
>local registries</A
> e tem atualmente um tamanho de prefixo /32.</P
><P
>Qualquer outro ISP/empresa pode solicitar um prefixo de tamanho /48, mas isto depende da política de distribuição de endereços dos registros locais de cada país ou região.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN590"
>3.2.4.4. Endereços reservados para exemplos e documentação</A
></H4
><P
>Atualmente, dois blocos de endereço estão reservados para exemplos e documentação. Veja a<A
HREF="http://www.faqs.org/rfcs/rfc3849.html"
TARGET="_top"
>RFC 3849 / IPv6 Address Prefix Reserved for Documentation</A
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>3fff:ffff::/32
2001:0DB8::/32   EXAMPLENET-WF</PRE
></FONT
></TD
></TR
></TABLE
><P
>Estes endereços devem ser filtrados baseados no endereço de origem e NÃO devem ser roteados em roteadores de borda em direção à internet, se possível.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN596"
>3.2.5. Endereços Multicast</A
></H3
><P
>Endereços Multicast são usados por serviços específicos.</P
><P
>Eles sempre começam com (xx é o valor de escopo)</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ff<EM
>x</EM
>y:</PRE
></FONT
></TD
></TR
></TABLE
><P
>Existem divisões entre escopo e tipo:</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN603"
>3.2.5.1. Escopo Multicast</A
></H4
><P
>O escopo Multicast é um parametro usado para especificar a distancia máxima que um pacote multicast pode "viajar" a partir de sua origem.</P
><P
>Atualmente, os seguintes escopos (ou regiões) estão definidos:</P
><P
></P
><UL
><LI
><P
>ffx1: nó local, os pacotes nunca deixam o nó.</P
></LI
><LI
><P
>ffx2: link-local, os pacotes nunca são encaminhados pelos routers, assim eles nunca deixam o link especificado.</P
></LI
><LI
><P
>ffx5: site-local, os pacotes nunca deixam o site.</P
></LI
><LI
><P
>ffx8: organization-local, os pacotes nunca deixam a organização (não é tão fácil de implementar, mas deve ser coberto pelo protocolo de roteamento).</P
></LI
><LI
><P
>ffxe: escopo global.</P
></LI
><LI
><P
>outros são reservados</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN620"
>3.2.5.2. Tipos Multicast</A
></H4
><P
>Já existem muitos tipos definidos/reservados (veja<A
HREF="http://www.faqs.org/rfcs/rfc4291.html"
TARGET="_top"
>RFC 4291 / IP Version 6 Addressing Architecture</A
> para mais detalhes). Alguns exemplos são:</P
><P
></P
><UL
><LI
><P
>Endereço All Nodes: ID = 1h, endereça todos os host no nó local (ff01:0:0:0:0:0:0:1) ou no link conectado (ff02:0:0:0:0:0:0:1).</P
></LI
><LI
><P
>Endereço All Routers: ID = 2h, endereça tosos os routers no nó local (ff01:0:0:0:0:0:0:2), no link conectado (ff02:0:0:0:0:0:0:2), ou no site local (ff05:0:0:0:0:0:0:2)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN629"
>3.2.5.3. Endereço multicast solicitado nó link-local</A
></H4
><P
>Um endereço de multicast especial que é usado como endereço de destino para a descoberta da vizinhança , uma vez que no IPv6 não há ARP, como existe no IPv4.</P
><P
>Um exemplo deste endereço se parece com</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ff02::1:ff00:1234</PRE
></FONT
></TD
></TR
></TABLE
><P
>Os prefixos usados mostram que este é um endereço multicast link-local. O sufixo é gerado a partir do endereço de destino. Neste exemplo, um pacote deveria ser enviado ao endereço "fe80::1234", mas a parte de rede não conhece o MAC atual deste destino. Ele então substitui os 104 bits mais altos com "ff02:0:0:0:0:1:ff00::/104" e deixa os menores 24 bits intocados. Este endereço então é agora usado no link para achar o nó correspondente que tem que enviar uma resposta contendo o endereço MAC usado na camada 2.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN635"
>3.2.6. Endereços Anycast</A
></H3
><P
>Endereços Anycast são endereços especiais e eles são usados para muitas coisas, como o servidor DNS ou DHCP mais próximo, e outras coisas. Estes endereços são obtidos do espaço de endereçamento Unicast (aggregatable global ou site-local). O mecanismo anycast (do ponto de vista do cliente) será tratado pelos protocolos de roteamento dinamico.</P
><P
>Nota: Endereços anycast não podem ser usados como endereços de origem, pois eles se aplicam somente a endereços de destino.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN639"
>3.2.6.1. Endereços Anycast Subnet-router</A
></H4
><P
>Um exemplo simples para um endereço unicast é o anycast subnet-router. Assumindo que um nó tem os seguintes endereços globais IPv6 configurados:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:db8:100:f101:210:a4ff:fee3:9566/64  &#60;- Node's address</PRE
></FONT
></TD
></TR
></TABLE
><P
>O endereço unicast subnet-router será criado removendo o sufixo (os 64 bits menos significantes) completamente:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:db8:100:f101::/64  &#60;- subnet-router anycast address</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN645"
>3.3. Tipos de endereço (parte de host)</A
></H2
><P
>Para a auto-configuração e questões de mobilidade, foi decidido usar os 64 bits de menor significado como a parte de host do endereço na maioria dos tipos de endereços atuais. Desta forma, cada subnet pode suportar uma grande quantidade de endereços.</P
><P
>A parte de host pode ser verificada de maneira distinta:</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN649"
>3.3.1. Computado automaticamente (também conhecido como stateless)</A
></H3
><P
>Com a auto-configuração, a parte host do endereço é feita através da conversão do endereço MAC da interface (se disponível), através do método EUI-64, para um único endereço IPv6. Se nenhum MAC estiver disponível para este dispositivo (isto acontece bastante em dispositivos virtuais), outra coisa (como o endereço IPv4 ou o MAC da interface física) é usada no lugar.</P
><P
>Exemplo: uma placa de rede tem o seguinte endereço MAC (48 bit):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>00:10:a4:01:23:45</PRE
></FONT
></TD
></TR
></TABLE
><P
>Isto poderia ser expandido de acordo com o tutorial do IEEE -<A
HREF="http://standards.ieee.org/regauth/oui/tutorials/EUI64.html"
TARGET="_top"
>IEEE-Tutorial EUI-64</A
> resultando no endereço abaixo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>0210:a4ff:fe01:2345</PRE
></FONT
></TD
></TR
></TABLE
><P
>Com um prefixo já fornecido, o resultado é o endereço IPv6 mostrado abaixo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:0100:f101:0210:a4ff:fe01:2345</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN659"
>3.3.1.1. Problema de privacidade com os endereços automaticamente computados e uma solução</A
></H4
><P
>Por causa da parte host do endereço "automaticamente computado" ser único, (exceto quando um fabricante de placas de rede usa o mesmo MAC em mais de um NIC), o rastreamento de um cliente é possível quando não há um proxy de qualquer tipo.</P
><P
>Este é um problema já conhecido, e a sua solução foi definida através da extensão de privacidade, definida na<A
HREF="http://www.faqs.org/rfcs/rfc3041.html"
TARGET="_top"
>RFC 3041 / Privacy Extensions for Stateless Address Autoconfiguration in IPv6</A
> (já existe também um novo draft disponível: <A
HREF="http://www.ietf.org/ids.by.wg/ipv6.html"
TARGET="_top"
>draft-ietf-ipv6-privacy-addrs-v2-*</A
>). Usando um valor estático e um valor randomico, um novo sufixo é gerado de tempos em tempos.</P
><P
>Nota: isto é somente interessante em conexões finais de clientes, e não é realmente útil para servidores já conhecidos.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN666"
>3.3.2. Definido manualmente</A
></H3
><P
>Para servidores, provavelmente é mais fácil se lembrar de endereços mais simples, mas isto também pode ser resolvido. Em IPv6, é possível configurar um endereço adicional para uma interface. Veja o exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:100:f101::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Para sufixos manuais como o ::1 mostrado acima, é necessário que o sétimo bit mais significativo seja definido como 0 (o bit universal/local do identificador gerado automaticamente). Existe também uma outra combinação de bits (não utilizada) que é reservada para endereços unicast.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN671"
>3.4. Tamanho de prefixos para roteamento</A
></H2
><P
>Na fase inicial de projeto e design do IPv6, foi planejada a utilização hierárquica de roteamento para reduzir o tamanho das tabelas de roteamento ao menor valor possível. As razões por trás desta abordagem foram o grande número de rotas nos grandes roteadores de borda (cerca de 300.000 em janeiro de 2011), reduzindo a necessidade de memória nos routers e a capacidade de se utilizar chips ASIC (Application Specified Integrated Circuit) para manipular esta tabela, aumentando a velocidade (uma tabela menor aumenta a velocidade).</P
><P
>A visão de hoje é que o roteamento será mais hierárquico para redes com somente 1 ISP. Em redes com mais de 1 conexão, isto não é possível, e está sujeita a sistemas multi-homed (informações de multi-homing:<A
HREF="http://www.ietf.org/ids.by.wg/multi6.html"
TARGET="_top"
>drafts-ietf-multi6-*</A
>,<A
HREF="http://arneill-py.sacramento.ca.us/ipv6mh/"
TARGET="_top"
>IPv6 Multihoming Solutions</A
>).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN677"
>3.4.1. Tamanho de prefixo (também conhecido como "netmasks")</A
></H3
><P
>Semelhante ao IPv4, a rede roteável entra em cena. Por causa da notação do padrão de máscara de rede (128 bits) não parecer bom, os designers utilizaram o mesmo método utilizado no IPv4, chamado Classless Inter Domain Routing (CIDR,<A
HREF="http://www.faqs.org/rfcs/rfc1519.html"
TARGET="_top"
>RFC 1519 / Classless Inter-Domain Routing</A
>)o qual especifica o número de bits do endereço IP que será usado para o roteamento. E ele também é chamado notação "slash".</P
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:100:1:2:3:4:5/48</PRE
></FONT
></TD
></TR
></TABLE
><P
>Esta notação pode ser expandida:</P
><P
></P
><UL
><LI
><P
>Rede:</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:0100:0000:0000:0000:0000:0000</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Máscara de rede:</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ffff:ffff:ffff:0000:0000:0000:0000:0000</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN692"
>3.4.2. Encontrando uma rota</A
></H3
><P
>Em circunstancias normais, (sem QoS), a procura em uma tabela de roteamento resulta na rota mais adequada com o número mais significante de bits do endereço. Em outras palavras, a rota com o maior prefixo tem a preferencia.</P
><P
>Por exemplo, se uma tabela de rotas mostra as seguintes entradas (a lista é parcial):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:100::/48     ::            U  1 0 0 sit1 
2000::/3               ::192.88.99.1 UG 1 0 0 tun6to4</PRE
></FONT
></TD
></TR
></TABLE
><P
>Os endereços de destino mostrados dos pacotes IPv6 serão roteados através das interfaces mostradas</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:0db8:100:1:2:3:4:5/48  -&#62;  routed through device sit1
2001:0db8:200:1:2:3:4:5/48  -&#62;  routed through device tun6to4</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-SYSTEMCHECK"
></A
>Chapter 4. Verificação do sistema para IPv6</H1
><P
>Antes de voce começar a utilizar o IPv6 em uma máquina com Linux, é necessário testar para saber se seu sistema tem o suporte ao protocolo. Talvez voce tenha que fazer algum ajuste para prepara-lo antes de começar a usar.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SYSTEMCHECK-KERNEL"
>4.1. Kernel com IPv6</A
></H2
><P
>As distribuições mais novas de Linux já tem o kernel com suporte ao IPv6, e este suporte geralmente acontece com a compilação em módulos, mas é possível que estes módulos sejam carregados no momento do boot.</P
><P
>Nota: voce não deve usar o kernel da série 2.2, porque ele já não é mais atualizado. A série 2.4 também já não tem todas as atualizações de acordo com as últimas RFC's, então recomendamos utilizar um kernel da série 2.6.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN706"
>4.1.1. Verificação do suporte a IPv6 no kernel utilizado</A
></H3
><P
>Para verificar se o seu kernel já está com o suporte a IPv6 habilitado, de uma olhada nos arquivos do diretório /proc. A seguinte entrada deve existir:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/proc/net/if_inet6</PRE
></FONT
></TD
></TR
></TABLE
><P
>Para quem gosta de scripts, é possível usar estes comandos:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># test -f /proc/net/if_inet6 &#38;&#38; echo "Running kernel is IPv6 ready"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Se este teste falhar, provavelmente seu sistema não está com os módulos de IPv6 carregados.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN713"
>4.1.2. Tentando carregar os módulos para o IPv6</A
></H3
><P
>Voce pode tentar carregar os módulos do IPv6 com o comando</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># modprobe ipv6</PRE
></FONT
></TD
></TR
></TABLE
><P
>Se a carga ocorreu sem problemas, verifique o status com estes comandos:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># lsmod |grep -w 'ipv6' &#38;&#38; echo "IPv6 module successfully loaded"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Depois disso, rode os comandos novamente do item 4.1.1 para ter certeza de que está tudo certo.</P
><P
>Note: a remoção do módulo (rmmod) não é suportada, e recomendo não utilizar, pois pode haver alguma instabilidade no sistema.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN721"
>4.1.2.1. Carga automática do módulo</A
></H4
><P
>É possível automatizar a carga do módulo IPv6 conforme seja necessário. Para isto, basta adicionar a seguinte entrada no arquivo de configuração (/etc/modules.conf ou /etc/conf.modules):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>alias net-pf-10 ipv6  # automatically load IPv6 module on demand</PRE
></FONT
></TD
></TR
></TABLE
><P
>Também é possível desabilitar a carga do módulo automaticamente usando a seguinte entrada:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>alias net-pf-10 off   # disable automatically load of IPv6 module on demand</PRE
></FONT
></TD
></TR
></TABLE
><P
>Nota: no kernel da série 2.6, o mecanismo carregador de módulos mudou, e o novo arquivo de configuração é o /etc/modprobe.conf.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN728"
>4.1.3. Compilando o kernel 2.6 para suportar o IPv6</A
></H3
><P
>Se os dois resultados acima foram negativos, e o seu kernel não tem suporte para o IPv6, então voce tem algumas coisas a fazer:</P
><P
></P
><UL
><LI
><P
>Atualizar a sua distribuição para uma que suporte o IPv6 (recomendado para os novatos)</P
></LI
><LI
><P
>Compilar um novo kernel (fácil, se voce souber quais opções são necessárias)</P
></LI
><LI
><P
>Recompilar os fontes do kernel dado pela sua distribuição (nem sempre tão fácil)</P
></LI
><LI
><P
>Compilar um kernel com as extensões USAGI</P
></LI
></UL
><P
>Se voce decidir compilar um kernel, voce precisa ter alguma experiencia nisso e também ler o<A
HREF="http://www.tldp.org/HOWTO/Kernel-HOWTO.html"
TARGET="_top"
>Linux Kernel HOWTO</A
>.</P
><P
>Uma comparação entre o kernel vanilla e as extensões USAGI está disponível aqui<A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-kernel.html"
TARGET="_top"
>IPv6+Linux-Status-Kernel</A
>.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN744"
>4.1.3.1. Compilando um kernel vanilla</A
></H4
><P
>Mais detalhes e dicas sobre a compilação de um kernel com suporte a IPv6 pode ser encontrado em<A
HREF="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO/IPv6-HOWTO-2.html#kernel"
TARGET="_top"
>IPv6-HOWTO-2#kernel</A
>.</P
><P
>Nota: voce deve usar, sempre que possível, um kernel da séria 2.6, uma vez que o suporte ao IPv6 na série 2.4 já não teve as últimas atualizações definidas nas RFC's, e a série 2.2 não tem mais o suporte atualizado ou mesmo mantido por alguém.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN749"
>4.1.3.2. Compilando um kernel com as extensões USAGI</A
></H4
><P
>Para a família vanilla de kernel, recomendado somente para usuários avançados, os quais já estão familiarizados com o IPv6 e com compilação de kernel. Veja também<A
HREF="http://www.linux-ipv6.org/faq.html"
TARGET="_top"
>USAGI project / FAQ</A
> e <A
HREF="http://www.deepspace6.net/docs/best_ipv6_support.html"
TARGET="_top"
>Obtaining the best IPv6 support with Linux (Article)</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/docs/best_ipv6_support.html"
TARGET="_top"
>Mirror</A
>).</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN755"
>4.1.4. Dispositivos de rede com suporte a IPv6</A
></H3
><P
>Nem todos os dispositivos de rede tem suporte (ou terão) para transportar pacotes IPv6. Um status atualizado pode ser encontrado em<A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-kernel.html#transport"
TARGET="_top"
>IPv6+Linux-status-kernel.html#transport</A
>.</P
><P
>O maior problema disso é causado na implementação da camada de rede, já que o pacote IPv6 não é reconhecido pelo cabeçalho IP (6 ao invés de 4). Ele é reconhecido pelo protocolo da camada 2 (transporte). Da mesma maneira, qualquer protocolo da camada 2 que não usa numeração de protocolo não conseguirá encaminhar os pacotes IPv6.</P
><P
>Nota: mesmo assim o pacote ainda é transportado pelo link, mas no lado receptor, o encaminhamento não ocorrerá (voce pode verificar isso com a utilização do tcpdump).</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN761"
>4.1.4.1. Estes links nunca suportarão IPv6</A
></H4
><P
></P
><UL
><LI
><P
>Serial Line IP (SLIP, <A
HREF="http://www.faqs.org/rfcs/rfc1055.html"
TARGET="_top"
>RFC 1055 / SLIP</A
>), deveria ser chamado de SLIPv4, nome do dispositivo: slX</P
></LI
><LI
><P
>Parallel Line IP (PLIP), que nem o SLIP, nome do dispositivo: plipX</P
></LI
><LI
><P
>ISDN com encapsulamento rawip, nome do dispositivo: isdnX</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN771"
>4.1.4.2. Este link atualmente não suporta IPv6</A
></H4
><P
></P
><UL
><LI
><P
>ISDN com encapsulamento syncppp, nome do dispositivo: ipppX (problema de projeto do ipppd, que deveria ter sido resolvido com um PPP mais generalista na série de kernel 2.5)</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN776"
>4.2. Ferramentas de configuração de rede que suportam IPv6</A
></H2
><P
>Voce não irá muito longe, se voce estiver rodando um kernel com suporte a IPv6, mas não tiver ferramentas que o ajudem a configurar o IPv6. Existem vários pacotes para ajudá-lo neste trabalho.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN779"
>4.2.1. Pacote net-tools</A
></H3
><P
>O pacote net-tools inclui algumas ferramentas como ifconfig e route, que ajudam a configurar uma interface em IPv6. Veja a saída dos comandos ifconfig -? ou route -?, se eles mostrarem algo parecido com IPv6 ou inet6, então a ferramenta tem suporte a IPv6.</P
><P
>Novamente, para quem gosta de scripts:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig -? 2&#62;&#38; 1|grep -qw 'inet6' &#38;&#38; echo "utility 'ifconfig' is
¬ IPv6-ready"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Verificando o route:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -? 2&#62;&#38; 1|grep -qw 'inet6' &#38;&#38; echo "utility 'route' is IPv6-ready"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN786"
>4.2.2. Pacote iproute</A
></H3
><P
>Alexey N. Kuznetsov (atual mantenedor do código de rede no Linux) criou um grupo de ferramentas que configuram redes através do dispositivo netlink. O uso destas ferramentas dá mais funcionalidades do que as do pacote net-tools, mas elas não estão muito bem documentadas e não são para os fracos de coração.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip 2&#62;&#38;1 |grep -qw 'inet6' &#38;&#38; echo "utility 'ip' is IPv6-ready"</PRE
></FONT
></TD
></TR
></TABLE
><P
>Se o programa /sbin/ip não for encontrado em seu sistema, então eu recomendo que voce instale o pacote iproute.</P
><P
></P
><UL
><LI
><P
>Voce pode pega-lo através de sua distribuição (se houver)</P
></LI
><LI
><P
>Voce pode procurar o pacote RPM em<A
HREF="http://rpmfind.net/linux/rpm2html/search.php?query=iproute"
TARGET="_top"
>RPMfind/iproute</A
> (em alguns casos é recomendada a reconstrução do SRPMS)</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN797"
>4.3. Programas de teste e debug IPv6</A
></H2
><P
>Após a preparação do seu sistema para o IPv6, está na hora de usar este protocolo para a sua comunicação com outros sistemas. Primeiro voce deve aprender como analisar os pacotes através de um sniffer. Isto é altamente recomendável para que qualquer debug ou troubleshooting seja feito de maneira rápida.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROGRAM-PING6."
>4.3.1. Ping IPv6</A
></H3
><P
>Este programa está incluído no pacote iputils. Seu objetivo é enviar e testar o transporte de pacotes ICMPv6 echo-request packets e aguardar pelos pacotes ICMPv6 echo-reply.</P
><P
>Uso</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 &#60;hostwithipv6address&#62;
# ping6 &#60;ipv6address&#62;
# ping6 [-I &#60;device&#62;] &#60;link-local-ipv6address&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 -c 1 ::1 
PING ::1(::1) from ::1 : 56 data bytes 
64 bytes from ::1: icmp_seq=0 hops=64 time=292 usec

--- ::1 ping statistics --- 
1 packets transmitted, 1 packets received, 0% packet loss 
round-trip min/avg/max/mdev = 0.292/0.292/0.292/0.000 ms</PRE
></FONT
></TD
></TR
></TABLE
><P
>Dica: o comando ping6 precisa de acesso direto ao socket e por isso precisa de permissão de root. Então se usuários comuns (não-root) tentarem usar o ping6 e não obtiverem sucesso, podem ser um dos dois problemas:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>ping6 não está na variável PATH deste usuário (provavelmente porque o ping6 é geralmente localizado em /usr/sbin, e adicionar este diretório ao path do usuário comum não é muito recomendado)</P
></LI
><LI
><P
>ping6 não executa corretamente, geralmente porque faltam permissões de root. A sugestão neste caso é executar o comando chmod u+s /usr/sbin/ping6 para permitir o uso do programa.</P
></LI
></OL
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN813"
>4.3.1.1. Especificando a interface para o ping em IPv6</A
></H4
><P
>Ao usar um endereço link-local para pingar alguém em IPv6 o kernel pode não reconhecer ou saber através de qual interface (física ou virtual) o pacote deve ser enviado. Por causa disso, a seguinte mensagem de erro deve aparecer:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 fe80::212:34ff:fe12:3456 
connect: Invalid argument</PRE
></FONT
></TD
></TR
></TABLE
><P
>Neste caso, voce precisa especificar qual interface deve ser usada para enviar o pacote, como mostrado abaixo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 -I eth0 -c 1 fe80::2e0:18ff:fe90:9205 
PING fe80::212:23ff:fe12:3456(fe80::212:23ff:fe12:3456) from
¬ fe80::212:34ff:fe12:3478 eth0: 56 data bytes 
64 bytes from fe80::212:23ff:fe12:3456: icmp_seq=0 hops=64 time=445 usec

--- fe80::2e0:18ff:fe90:9205 ping statistics --- 
1 packets transmitted, 1 packets received, 0% packet loss round-trip
¬ min/avg/max/mdev = 0.445/0.445/0.445/0.000 ms</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN819"
>4.3.1.2. Ping6 para endereços multicast</A
></H4
><P
>Um mecanismo interessante para detectar hosts com endereço IPv6 é pingar o endereço all-node multicast:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 -I eth0 ff02::1
PING ff02::1(ff02::1) from fe80:::2ab:cdff:feef:0123 eth0: 56 data bytes
64 bytes from ::1: icmp_seq=1 ttl=64 time=0.104 ms
64 bytes from fe80::212:34ff:fe12:3450: icmp_seq=1 ttl=64 time=0.549 ms (DUP!) </PRE
></FONT
></TD
></TR
></TABLE
><P
>Diferente do IPv4, onde as respostas ao ping para endereços de broadcast podem ser desabilitadas, em IPv6 este comportamento não pode ser desabilitado, exceto pela utilização de um firewall IPv6 local.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROGRAM-TRACEROUTE6."
>4.3.2. Traceroute6 IPv6</A
></H3
><P
>Este programa geralmente está incluso no pacote iputils. É um programa conhecido, similar ao do IPv4. Veja o exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># traceroute6 www.6bone.net 
traceroute to 6bone.net (3ffe:b00:c18:1::10) from 2001:0db8:0000:f101::2, 30
¬ hops max, 16 byte packets 
 1 localipv6gateway (2001:0db8:0000:f101::1) 1.354 ms 1.566 ms 0.407 ms 
 2 swi6T1-T0.ipv6.switch.ch (3ffe:2000:0:400::1) 90.431 ms 91.956 ms 92.377 ms 
 3 3ffe:2000:0:1::132 (3ffe:2000:0:1::132) 118.945 ms 107.982 ms 114.557 ms 
 4 3ffe:c00:8023:2b::2 (3ffe:c00:8023:2b::2) 968.468 ms 993.392 ms 973.441 ms 
 5 3ffe:2e00:e:c::3 (3ffe:2e00:e:c::3) 507.784 ms 505.549 ms 508.928 ms 
 6 www.6bone.net (3ffe:b00:c18:1::10) 1265.85 ms * 1304.74 ms</PRE
></FONT
></TD
></TR
></TABLE
><P
>Nota: diferente das versões mais atuais co traceroute do IPv4, que usa pacotes ICMPv4 echo-request e pacotes UDP (default), o traceroute do IPv6 só é capaz de enviar pacotes UDP. Como voce já deve saber, pacotes ICMP echo-request são mais aceitos pelos firewalls e listas de acesso (ACL) de routers do que pacotes UDP.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROGRAM-TRACEPATH6."
>4.3.3. Tracepath6 IPv6</A
></H3
><P
>Este programa costuma estar incluído no pacote iputils. É um programa similar ao traceroute6 e ele traça o caminho para um endereço dado, descobrindo o MTU ao longo deste caminho. Veja o exemplo abaixo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tracepath6 www.6bone.net 
 1?: [LOCALHOST] pmtu 1480 
 1: 3ffe:401::2c0:33ff:fe02:14 150.705ms 
 2: 3ffe:b00:c18::5 267.864ms 
 3: 3ffe:b00:c18::5 asymm 2 266.145ms pmtu 1280 
 3: 3ffe:3900:5::2 asymm 4 346.632ms 
 4: 3ffe:28ff:ffff:4::3 asymm 5 365.965ms 
 5: 3ffe:1cff:0:ee::2 asymm 4 534.704ms 
 6: 3ffe:3800::1:1 asymm 4 578.126ms !N 
Resume: pmtu 1280</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROGRAM-TCPDUMP"
>4.3.4. Tcpdump IPv6</A
></H3
><P
>No Linux, o tcpdump é a maior ferramenta para a captura de pacotes. Abaixo estão alguns exemplos. O suporte ao IPv6 já está adicionado nas versões 3.6 ou superiores deste programa. </P
><P
>O tcpdump usa diversas expressões e argumentos para realizar a filtragem de pacotes para minimizar o volume de informações apresentado:</P
><P
></P
><UL
><LI
><P
>icmp6: filtra o tráfego ICMPv6 nativo</P
></LI
><LI
><P
>ip6: filtra o tráfego nativo IPv6 (incluindo ICMPv6)</P
></LI
><LI
><P
>proto ipv6: filtra o tráfego IPv6 tunelado em IPv4 (IPv6-in-IPv4)</P
></LI
><LI
><P
>not port ssh: para evitar mostrar os pacotes se voce estiver usando uma conexão SSH</P
></LI
></UL
><P
>Além disso, algumas opções são muito úteis para obter mais informações de cada pacote, bem interessantes para pacotes ICMPv6:</P
><P
></P
><UL
><LI
><P
>"-s 512": aumenta o tamanho do pacote capturado para 512 bytes. Se for usada a opção "-s 0" o pacote é capturado por inteiro</P
></LI
><LI
><P
>"-s 512": aumenta o tamanho do pacote capturado para 512 bytes. Se for usada a opção "-s 0" o pacote é capturado por inteiro</P
></LI
><LI
><P
>"-n": não resolve os endereços para nomes, muito útil quando o DNS reverso não está funcionando corretamente</P
></LI
></UL
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN854"
>4.3.4.1. Ping IPv6 para 2001:0db8:100:f101::1 nativo sobre um link local</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tcpdump -t -n -i eth0 -s 512 -vv ip6 or proto ipv6 
tcpdump: listening on eth0 
2001:0db8:100:f101:2e0:18ff:fe90:9205 &#62; 2001:0db8:100:f101::1: icmp6: echo
¬ request (len 64, hlim 64) 
2001:0db8:100:f101::1 &#62; 2001:0db8:100:f101:2e0:18ff:fe90:9205: icmp6: echo
¬ reply (len 64, hlim 64)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN857"
>4.3.4.2. Ping IPv6 para 2001:0db8:100::1 roteado através de um túnel IPv6-in-IPv4</A
></H4
><P
>Os endereços IPv4 1.2.3.4 e 5.6.7.8 são os tunnel endpoints (todos os endereços são exemplos)</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tcpdump -t -n -i ppp0 -s 512 -vv ip6 or proto ipv6 
tcpdump: listening on ppp0 
1.2.3.4 &#62; 5.6.7.8: 2002:ffff:f5f8::1 &#62; 2001:0db8:100::1: icmp6: echo request
¬ (len 64, hlim 64) (DF) (ttl 64, id 0, len 124) 
5.6.7.8 &#62; 1.2.3.4: 2001:0db8:100::1 &#62; 2002:ffff:f5f8::1: icmp6: echo reply (len
¬ 64, hlim 61) (ttl 23, id 29887, len 124) 
1.2.3.4 &#62; 5.6.7.8: 2002:ffff:f5f8::1 &#62; 2001:0db8:100::1: icmp6: echo request
¬ (len 64, hlim 64) (DF) (ttl 64, id 0, len 124) 
5.6.7.8 &#62; 1.2.3.4: 2001:0db8:100::1 &#62; 2002:ffff:f5f8::1: icmp6: echo reply (len
¬ 64, hlim 61) (ttl 23, id 29919, len 124)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN861"
>4.4. Programas com suporte a IPv6</A
></H2
><P
>As distribuições Linux atuais já contém a maioria dos serviços Cliente e Servidor em IPv6. Veja aqui em<A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-distributions.html"
TARGET="_top"
>IPv6+Linux-Status-Distribution</A
>. Se ainda não estiver incluído, voce pode verificar em <A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-apps.html"
TARGET="_top"
>IPv6 &#38; Linux - Current Status - Applications</A
> se o programa já está portado para o IPv6 e pronto para o Linux. Para os programas mais comuns existem dicas disponíveis em<A
HREF="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO/IPv6-HOWTO-3.html"
TARGET="_top"
>IPv6 &#38; Linux - HowTo - Part 3</A
> e <A
HREF="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO/IPv6-HOWTO-4.html"
TARGET="_top"
>IPv6 &#38; Linux - HowTo - Part 4</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN868"
>4.5. Programas cliente com suporte a IPv6</A
></H2
><P
>Para executar os testes abaixo, é necessário que seu sistema seja um host IPv6 e os exemplos mostrados podem ser feitos se voce tiver acesso ao 6bone.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN871"
>4.5.1. Verificando a resolução DNS para endereços IPv6</A
></H3
><P
>Por causa dos updates de segurança aplicados nos últimos anos, o Servidor DNS que roda a versão mais atual já tem a capacidade de entender os endereços IPv6 tipo AAAA (o named A6 mais novo ainda não é usado porque só no BIND9 o suporte aos root domais ARPA IP6 está em uso). Um teste bem simples para ver o sistema resolver endereços IPv6 é:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># host -t AAAA www.join.uni-muenster.de</PRE
></FONT
></TD
></TR
></TABLE
><P
>e a resposta deve ser alguma coisa parecida com isso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>www.join.uni-muenster.de. is an alias for tolot.join.uni-muenster.de. 
tolot.join.uni-muenster.de. has AAAA address
¬ 2001:638:500:101:2e0:81ff:fe24:37c6</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN877"
>4.5.2. Cliente de Telnet com suporte a IPv6</A
></H3
><P
>Cliente de telnet com suporte a IPv6 estão disponíveis. Um teste simples pode ser feito com o comando:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ telnet 3ffe:400:100::1 80
Trying 3ffe:400:100::1... 
Connected to 3ffe:400:100::1. 
Escape character is '^]'. 
HEAD / HTTP/1.0

HTTP/1.1 200 OK 
Date: Sun, 16 Dec 2001 16:07:21 
GMT Server: Apache/2.0.28 (Unix) 
Last-Modified: Wed, 01 Aug 2001 21:34:42 GMT 
ETag: "3f02-a4d-b1b3e080" 
Accept-Ranges: bytes 
Content-Length: 2637 
Connection: close 
Content-Type: text/html; charset=ISO-8859-1

Connection closed by foreign host.</PRE
></FONT
></TD
></TR
></TABLE
><P
>Se o cliente de telnet não entende o IPv6, a mensagem de erro será "cannot resolve hostname".</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN882"
>4.5.3. SSH com suporte a IPv6</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN884"
>4.5.3.1. openssh</A
></H4
><P
>As versões atuais do openssh já suportam IPv6. Dependendo da configuração utilizada, ele tem dois comportamentos:</P
><P
></P
><UL
><LI
><P
>--without-ipv4-default: o cliente tenta se conectar primeiro em IPv6, e ele usa IPv4 se a conexão em IPv6 não for estabelecida</P
></LI
><LI
><P
>--with-ipv4-default: a conexão é feita primeiro em IPv4 e para usar algum endereço IPv6, deve-se forçar a sua utilização. Veja o exemplo</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ ssh -6 ::1 
user@::1's password: ****** 
[user@ipv6host user]$</PRE
></FONT
></TD
></TR
></TABLE
><P
>Se seu cliente ssh não entende a opção "-6" então o suporte a IPv6 não está habilitado, como muitos pacotes de ssh na versão 1.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN894"
>4.5.3.2. ssh.com</A
></H4
><P
>O software cliente e servidor SSH da SSH.com já suporta o IPv6 e agora ele é grátis para todos os Linux e FreeBSD, independente se o seu uso é pessoal ou comercial.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN897"
>4.5.4. Browsers com suporte a IPv6</A
></H3
><P
>O status atual dos browsers com suporte a IPv6 pode ser encontrado aqui<A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-apps.html#HTTP"
TARGET="_top"
>IPv6+Linux-status-apps.html#HTTP</A
>.</P
><P
>A maioria deles ainda tem problemas pendentes, tais como:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Se a configuração de proxy usa somente endereços IPv4, os pedidos em IPv6 também serão enviados a este proxy, emas como o proxy não saberá resolver o endereço, o pedido não vai funcionar. A única solução é verificar se o seu software de proxy tem alguma atualização para resolver este problema.</P
></LI
><LI
><P
>Configuração automática de proxy (*.pac) não pode ser utilizada para manipular pedidos em IPv6 de maneira diferenciada (exemplo: não usar o proxy para o IPv6) por causa da sua natureza (escritos em Javascript e muito encrustado no código fonte, como é visto no Mozilla).</P
></LI
></OL
><P
>As versões anteriores de browsers também não entenderiam uma URL com o endereço IPv6, como no exemplo <A
HREF="http://[2001:a60:9002:1::186:6]/"
TARGET="_top"
>http://[2001:a60:9002:1::186:6]/</A
> (isto funciona somente se a URL for usada em um browser que suporte IPv6).</P
><P
>Um pequeno teste é tentar este endereço em um browser sem o proxy configurado.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN910"
>4.5.4.1. URLs para teste</A
></H4
><P
>Um bom ponto de partida para browsers que usam IPv6 é o site<A
HREF="http://www.kame.net/"
TARGET="_top"
>http://www.kame.net/</A
>.Se a tartaruga da página estiver animada, a sua conexão é em IPv6. caso contrário, a tartaruga ficará parada.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN914"
>4.6. Programas servidores com suporte a IPv6</A
></H2
><P
>Nesta parte deste HowTo, outros softwares cliente IPv6 são mencionados, assim como dicas para servidores com suporte a IPv6, como sshd, httpd, telnetd, etc, assim como outras dicas em<A
HREF="#CHAPTER-HINTS-DAEMONS"
>Hints for IPv6-enabled daemons</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FAQ-IPV6-READY-SYSTEM-CHECK"
>4.7. FAQ (checagem de sistema com suporte a IPv6)</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN920"
>4.7.1. Usando ferramentas</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN922"
>4.7.1.1. Q: Não consigo pingar (ping6) o endereço link-local</A
></H4
><P
>Mensagem de erro: "connect: Invalid argument"</P
><P
>O kernel não conhece qual interface física ou virtual voce quer utilizar para enviar o pacote ICMPv6. Assim, a solução poderia aparecer assim.</P
><P
>Solução:: Determine a interface, como: "ping6 -I eth0 fe80::2e0:18ff:fe90:9205", veja também<A
HREF="#PROGRAM-PING6."
>program ping6 usage</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN928"
>4.7.1.2. Q: Não consigo pingar (ping6) ou efetuar traceroute (traceroute6) como usuário normal</A
></H4
><P
>Menagem de erro: "icmp socket: Operation not permitted"</P
><P
>Estes utilitários criam pacotes especiais ICMPv6 e então os enviam. Isto é feito usando conexões brutas no kernel. Mas estas conexões somente podem ser usadas pelo usuário "root". Desta forma, esta mensagem vai aparecer para os usuários normais.</P
><P
>Solução: Se for realmente necessário que todos os usuários utilizem estas ferramentas, voce pode adicionar o "suid" bit usando o comando "chmod u+s /caminho/para/o/programa", e veja também este link<A
HREF="#PROGRAM-PING6."
>program ping6 usage</A
>Se nem todos os usuários necessitam usá-lo, voce pode mudar o grupo do programa, para "wheel" por exemplo, e todos os usuários pertencentes a este grupo poderão executar estes programas sem problema. Voce também pode configurar o "sudo" para isto também.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-CONFIGURATION-INTERFACE"
></A
>Chapter 5. Configurando interfaces</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN936"
>5.1. Dispositivos de rede diferentes</A
></H2
><P
>Em um nó, podem haver diferentes tipos de interfaces. Elas podem estar agrupadas em classes</P
><P
></P
><UL
><LI
><P
>Físicas, como eth0, tr0</P
></LI
><LI
><P
>Virtuais, como ppp0, tun0, tap0, sit0, isdn0, ippp0</P
></LI
></UL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN944"
>5.1.1. Físicas</A
></H3
><P
>As interfaces físicas, como Ethernet ou Token Ring são exemplos de interfaces comuns que não precisam de qualquer tipo de tratamento especial.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN947"
>5.1.2. Virtuais</A
></H3
><P
>As interfaces virtuais sempre precisam de algum tratamento especial</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN950"
>5.1.2.1. Interfaces Túnel IPv6-in-IPv4</A
></H4
><P
>Estas interfaces normalmente recebem o nome sit<EM
>x</EM
>. O nome sit é uma atalho para Simple Internet Transition. Esta interface tem a capacidade de encapsular os pacotes IPv6 em pacotes IPv4 e tunelar estes pacotes para um endpoint remoto.</P
><P
>A interface sit0 tem um papel especial e não pode ser usada para túneis dedicados.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN955"
>5.1.2.2. Interfaces PPP</A
></H4
><P
>As interfaces PPP obteem sua capacidade IPv6 do daemon PPP para IPv6.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN958"
>5.1.2.3. Interfaces ISDN HDLC</A
></H4
><P
>A capacidade IPv6 para HDLC com encapsulamento IP já está contida no kernel</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN961"
>5.1.2.4. Interfaces ISDN PPP</A
></H4
><P
>A interface ISDN PPP (ippp) não tem o suporte ao IPv6 no kernel. E também não há qualquer plano para suportar, porque o kernel da série 2.5 ele será substituído por uma camada de interface PPP mais genérica.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN964"
>5.1.2.5. SLIP + PLIP</A
></H4
><P
>Como mencionado anteriormente neste documento, esta interface não suporta o IPv6 (no envio até que funciona, mas a recepção não funciona).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN967"
>5.1.2.6. Dispositivo Ether-tap</A
></H4
><P
>Dispositivos Ether-tap já possuem o IPv6 habilitado e o stateless configurado. Para usá-lo, o módulo "ethertap" deve ter sido carregado antes.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN970"
>5.1.2.7. Dispositivos tun</A
></H4
><P
>Atualmente não foi testado por mim</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN973"
>5.1.2.8. ATM</A
></H4
><P
>01/2002: Não são mais suportados pelo kernel vanilla, mas somente pelas extensões USAGI</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN976"
>5.1.2.9. Outras</A
></H4
><P
>Eu esqueci de alguma ?</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN979"
>5.2. Colocando as interfaces em up e down</A
></H2
><P
>Existem dois métodos usados para colocar as interfaces em up ou down..</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN982"
>5.2.1. Usando "ip"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip link set dev &#60;interface&#62; up
# ip link set dev &#60;interface&#62; down</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip link set dev eth0 up
# ip link set dev eth0 down</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN988"
>5.2.2. Usando "ifconfig"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig &#60;interface&#62; up
# /sbin/ifconfig &#60;interface&#62; down</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig eth0 up
# /sbin/ifconfig eth0 down</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-CONFIGURATION-ADDRESS"
></A
>Chapter 6. Configurando endereços IPv6</H1
><P
>Existem várias maneiras de configurar um endereço IPv6 em uma interface. As mais comuns são "ifconfig" e "ip".</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN997"
>6.1. Mostrando os endereços IPv6 existentes</A
></H2
><P
>Antes de mais nada, voce precisa checar se já existe algum endereço IPv6 configurado e qual é o seu tipo (talvez atribuído durante uma auto-configuração stateless).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1000"
>6.1.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr show dev &#60;interface&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo para uma configuração de host estático:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr show dev eth0
2: eth0: &#60;BROADCAST,MULTICAST,UP&#38;gt; mtu 1500 qdisc pfifo_ fast qlen 100
inet6 fe80::210:a4ff:fee3:9566/10 scope link
inet6 2001:0db8:0:f101::1/64 scope global
inet6 fec0:0:0:f101::1/64 scope site </PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo de um host auto-configurado</P
><P
>Aqui voce pode ver a configuração de IPv6 através do processo auto-magically, além do tempo de vida do endereço.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr show dev eth0 
3: eth0: &#60;BROADCAST,MULTICAST,PROMISC,UP&#38;gt; mtu 1500 qdisc pfifo_fast qlen
¬ 100 
inet6 2002:d950:f5f8:f101:2e0:18ff:fe90:9205/64 scope global dynamic 
valid_lft 16sec preferred_lft 6sec 
inet6 3ffe:400:100:f101:2e0:18ff:fe90:9205/64 scope global dynamic 
valid_lft 2591997sec preferred_lft 604797sec inet6 fe80::2e0:18ff:fe90:9205/10
¬ scope link</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1009"
>6.1.2. Usando "ifconfig"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig &#60;interface&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo (a saída foi filtrada com o grep para mostrar somente os endereços IPv6). Aqui voce pode ver diferentes endereços IPv6 com diferentes escopos.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig eth0 |grep "inet6 addr:"
inet6 addr: fe80::210:a4ff:fee3:9566/10 Scope:Link
inet6 addr: 2001:0db8:0:f101::1/64 Scope:Global
inet6 addr: fec0:0:0:f101::1/64 Scope:Site</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1015"
>6.2. Adicionando um endereço IPv6</A
></H2
><P
>A adição de um endereço IPv6 é muito similar ao endereço "IP ALIAS" nas interfaces IPv4 no Linux.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1018"
>6.2.1. Usando "ip"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr add &#60;ipv6address&#62;/&#60;prefixlength&#62; dev &#60;interface&#62; </PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr add 2001:0db8:0:f101::1/64 dev eth0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1024"
>6.2.2. Usando "ifconfig"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig &#60;interface&#62; inet6 add &#60;ipv6address&#62;/&#60;prefixlength&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig eth0 inet6 add 2001:0db8:0:f101::1/64 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1030"
>6.3. Removendo um endereço IPv6</A
></H2
><P
>Como esta ação não é tão necessária, tenha cuidado ao remover endereços IPv6 que não existem, pois ao realizar esta ação em kernels mais antigos, voce pode causar um grande estrago no sistema.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1033"
>6.3.1. Usando "ip"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr del &#60;ipv6address&#62;/&#60;prefixlength&#62; dev &#60;interface&#62; </PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr del 2001:0db8:0:f101::1/64 dev eth0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1039"
>6.3.2. Usando "ifconfig"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig &#60;interface&#62; inet6 del &#60;ipv6address&#62;/&#60;prefixlength&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig eth0 inet6 del 2001:0db8:0:f101::1/64</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-CONFIGURATION-ROUTE"
></A
>Chapter 7. Configurando rotas IPv6</H1
><P
>Se voce quer deixar seu link e quer enviar pacotes a todo o mundo que está só aguardando a sua conexão em IPv6, voce vai precisar de uma rota. Se já houver um router com IPv6 habilitado (e uma rota para ele), estes passos abaixo vão te ensinar como adicionar mais rotas em IPv6.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1048"
>7.1. Mostrando as rotas IPv6 existentes</A
></H2
><P
>Antes de mais nada, é interessante verificar quais são as rotas IPv6 já configuradas (talvez atribuído durante uma auto-configuração).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1051"
>7.1.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route show [dev &#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route show dev eth0
2001:0db8:0:f101::/64 proto kernel metric 256 mtu 1500 advmss 1440
fe80::/10             proto kernel metric 256 mtu 1500 advmss 1440
ff00::/8              proto kernel metric 256 mtu 1500 advmss 1440
default               proto kernel metric 256 mtu 1500 advmss 1440</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1057"
>7.1.2. Usando "route"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 </PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo (a saída foi filtrada para a interface eth0). Aqui voce pode ver rotas IPv6 para diferentes endereços em uma única interface.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 |grep -w "eth0"
2001:0db8:0:f101 ::/64 :: UA  256 0 0 eth0 &#60;- Interface route for global
¬ address
fe80::/10        ::       UA  256 0 0 eth0 &#60;- Interface route for link-local
¬ address
ff00::/8         ::       UA  256 0 0 eth0 &#60;- Interface route for all multicast
¬ addresses
::/0             ::       UDA 256 0 0 eth0 &#60;- Automatic default route</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1063"
>7.2. Adicionando uma rota IPv6 através de um gateway</A
></H2
><P
>Bastante necessário quando se quer acessar outras redes com IPv6 usando um router IPv6-enabled em seu link.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1066"
>7.2.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add &#60;ipv6network&#62;/&#60;prefixlength&#62; via &#60;ipv6address&#62;
¬ [dev &#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add 2000::/3 via 2001:0db8:0:f101::1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1072"
>7.2.2. Usando "route"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 add &#60;ipv6network&#62;/&#60;prefixlength&#62; gw
¬ &#60;ipv6address&#62; [dev &#60;device&#62;] </PRE
></FONT
></TD
></TR
></TABLE
><P
>Um dispositivo pode ser necessário se o dispositivo do endereço IPv6 do gateway for um dispositivo link local.</P
><P
>Veja o exemplo abaixo, como adicionar uma rota para todos os endereços globais (2000::/3) através do gateway 2001:0db8:0:f101::1</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 add 2000::/3 gw 2001:0db8:0:f101::1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1079"
>7.3. Removendo uma rota IPv6 através de um gateway</A
></H2
><P
>Não é geralmente usada no modo manual, pois sugerimos a utilização de scripts ou shutdown nas interfaces (todas ou por interface)</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1082"
>7.3.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del &#60;ipv6network&#62;/&#60;prefixlength&#62; via &#60;ipv6address&#62;
¬ [dev &#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del 2000::/3 via 2001:0db8:0:f101::1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1088"
>7.3.2. Usando "route"</A
></H3
><P
>Uso: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del &#60;network&#62;/&#60;prefixlength&#62; gw &#60;ipv6address&#62; [dev
¬ &#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo para remover a rota adicionada anteriormente (acima):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del 2000::/3 gw 2001:0db8:0:f101::1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1094"
>7.4. Adicionando uma rota IPv6 através de uma interface</A
></H2
><P
>Nem sempre usado, mas quando usado é em links ponto a ponto.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1097"
>7.4.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add &#60;ipv6network&#62;/&#60;prefixlength&#62; dev &#60;device&#62;
¬ metric 1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add 2000::/3 dev eth0 metric 1</PRE
></FONT
></TD
></TR
></TABLE
><P
>A métrica "1" é usada aqui para se manter compatível com as métricas usadas pelo comando route, já que a métrica default ao se usar "ip" é "1024".</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1104"
>7.4.2. Usando "route"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 add &#60;ipv6network&#62;/&#60;prefixlength&#62; dev &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 add 2000::/3 dev eth0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1110"
>7.5. Removendo uma rota IPv6 através de uma interface</A
></H2
><P
>Nem sempre utilizado manualmente, pois recomenda-se a utilização de scripts.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1113"
>7.5.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del &#60;ipv6network&#62;/&#60;prefixlength&#62; dev &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del 2000::/3 dev eth0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1119"
>7.5.2. Usando "route"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del &#60;network&#62;/&#60;prefixlength&#62; dev &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del 2000::/3 dev eth0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1125"
>7.6. FAQ para rotas em IPv6</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1127"
>7.6.1. Suporte de uma rota default IPv6</A
></H3
><P
>Uma boa idéia do IPv6 foi o roteamento hierárquico, o que proporcionaria a necessidade de menos rotas nos roteadores.</P
><P
>Aqui estão alguns problemas no kernel atual do Linux:</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1131"
>7.6.1.1. Clientes (não roteando qualquer pacote!)</A
></H4
><P
>Um cliente pode configurar uma rota default prefixo "::/0", mas eles também aprendem uma rota no processo de auto configuração, ex.: uso do radvd no link abaixo mostra:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 route show | grep ^default
default via fe80::212:34ff:fe12:3450 dev eth0 proto kernel metric 1024 expires
¬ 29sec mtu 1500 advmss 1440</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1135"
>7.6.1.2. Roteadores em caso de packet forwarding</A
></H4
><P
>Os linux mais velhos (pelo menos inferiores ao kernel 2.4.17) não suportam rotas default. Voce pode configura-las, mas a pesquisa na tabela vai retornar uma falha quando deveria ser encaminhado (intenção normal do roteador). Se voce ainda está usando uma versão antiga de kernel, as "rotas default" podem ser configuradas usando o prefixo de endereço global "2000::/3".</P
><P
>Nota: tome cuidado com as rotas default sem filtragem de endereços em roteadores de borda, pois o tráfego multicast ou site-local pode sair para o mundo.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-NEIGHBOR-DISCOVERY"
></A
>Chapter 8. Descoberta de vizinhos</H1
><P
>A descoberta de vizinhos funciona como um sucessor do ARP (Address Resolution Protocol) em IPv4, no mundo IPv6. Voce pode obter estas informações sobre os vizinhos atuais, e adicionalmente voce pode configurar e excluir entradas. O kernel mantém o rastreamento das descobertas bem sucedidas (como no ARP em IPv4). Voce pode pesquisar as entradas nesta tabela usando o comando "ip".</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1142"
>8.1. Mostrando os vizinhos usando "ip"</A
></H2
><P
>Com o comando abaixo voce pode verificar a tabela de vizinhos aprendida ou configurada</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh show [dev &#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>O exemplo a seguir mostra um vizinho, o qual é um router acessível</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh show
fe80::201:23ff:fe45:6789 dev eth0 lladdr 00:01:23:45:67:89 router nud reachable</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1148"
>8.2. Manipulando a tabela de vizinhos usando "ip"</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1150"
>8.2.1. Adicionando uma entrada manualmente</A
></H3
><P
>Com o comando abaixo, voce consegue adicionar uma entrada manualmente</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh add &#60;IPv6 address&#62; lladdr &#60;link-layer address&#62; dev &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh add fec0::1 lladdr 02:01:02:03:04:05 dev eth0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1156"
>8.2.2. Excluindo uma entrada manualmente</A
></H3
><P
>Similar à adição de uma entrada, uma entrada pode ser excluída</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh del &#60;IPv6 address&#62; lladdr &#60;link-layer address&#62; dev &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh del fec0::1 lladdr 02:01:02:03:04:05 dev eth0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1162"
>8.2.3. Opções mais avançadas</A
></H3
><P
>A ferramenta "ip" não é tão documentada, mas é bem útil e forte. Veja o seu help online para mais informações:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 neigh help
Usage: ip neigh { add | del | change | replace } { ADDR [ lladdr LLADDR ] 
          [ nud { permanent | noarp | stale | reachable } ] 
          | proxy ADDR } [ dev DEV ] 
       ip neigh {show|flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Aparentemente algumas opções são somente para o IPv4... e se voce quiser contribuir com mais informações sobre outras opções da ferramenta e usos avançados, por favor, me envie.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-CONFIGURING-IPV6-IN-IPV4-TUNNELS"
></A
>Chapter 9. Configurando um túnel IPv6-in-IPv4</H1
><P
>Se voce quer deixar seu link e ter uma rede IPv6 à sua volta, voce vai precisar de um túnel IPv6-in-IPv4 para acessar a web em modo IPv6.</P
><P
>Existem alguns tipos de mecanismo e também algumas possibilidades da configuração deste túnel.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1171"
>9.1. Tipos de túneis</A
></H2
><P
>Existe mais de uma possibilidade de transportar pacotes IPvb6 em links IPv4.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1174"
>9.1.1. Túnel estático ponto a ponto: 6bone</A
></H3
><P
>Um túnel ponto a ponto é um túnel dedicado em direção a um ponto final., o qual sabe informações sobre uma rede IPv6A (para rotas de volta) e os endereços IPv4 deste túnel estão definidos na <A
HREF="http://www.faqs.org/rfcs/rfc2893.html"
TARGET="_top"
>RFC 2893 / Transition Mechanisms for IPv6 Hosts and Routers</A
>. Necessidades:</P
><P
></P
><UL
><LI
><P
>O endereço IPv4 local do túnel precisa ser estático, global, único e acessível a partir da outra ponta</P
></LI
><LI
><P
>Um prefixo global IPv6 deve ser designado a voce (veja o registro 6bone)</P
></LI
><LI
><P
>Um ponto final remoto do túnel deve ser capaz de rotear seu prefixo IPv6para seu ponto final local (uma configuração manual pode ser necessária)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1185"
>9.1.2. Túnel automático</A
></H3
><P
>Um túnel automático acontece quando um nó diretamente conectado a outro nó obtém um IPv4 do outro nó anterior.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TUNNELING-6TO4."
>9.1.3. 6to4-Tunneling</A
></H3
><P
>O túnel 6to4 (<A
HREF="http://www.faqs.org/rfcs/rfc3056.html"
TARGET="_top"
>RFC 3056 / Connection of IPv6 Domains via IPv4 Clouds</A
>) utiliza um mecanismo simples para criar túneis automáticos. Cada nó com um endereço global único é capaz de ser uma ponta final de um túnel 6to4 (se nenhum firewall no meio do caminho bloquear este tipo de tráfego). Túneis 6to4 não costumam ser túneis um a um. Este tipo de túnel pode ser dividido em Upstream e Downstream. Além disso, um endereço especial IPv6 indica que este nó vai usar o tunelamento 6to4 para se conectar a redes IPv6 mundiais.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1192"
>9.1.3.1. Geração de prefixo 6to4</A
></H4
><P
>O endereço 6to4 está definido abaixo (o esquema foi pego da <A
HREF="http://www.faqs.org/rfcs/rfc3056.html"
TARGET="_top"
>RFC 3056 / Connection of IPv6 Domains via IPv4 Clouds</A
>):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>|   3+13   |    32     |    16  |            64 bits             | 
+---+------+-----------+--------+--------------------------------+ 
|  FP+TLA  |  V4ADDR   | SLA ID |           Interface ID         | 
|  0x2002  |           |        |                                | 
+---+------+-----------+--------+--------------------------------+</PRE
></FONT
></TD
></TR
></TABLE
><P
>FP e TLA juntos (16 bits) tem o valor 0x2002. V4ADDR é o endereço único IPv4 (em notação hexadecimal). SLA é o identificador de rede (65536 redes locais possíveis) e são usados para representar a sua estrutura de rede local.</P
><P
>Para os gateways, tal prefixo é gerado normalmente usando o SLA “0000” e o sufixo "::1" (não é uma exigencia, pode ser arbitrário com um escopo local) e então assinalado a uma interface de túnel 6to4. Veja que a Microsoft também utiliza V4ADDR para o sufixo.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1199"
>9.1.3.2. Tunelamento Upstream 6to4</A
></H4
><P
>O nó tem que saber para qual ponta remota de túnel os pacotes IPv4 com pacotes IPv6 devem ser encaminhados. No início dos tempos de tunelamento 6to4, upstreams dedicados aceitavam que os routers fizessem isso. Veja <A
HREF="http://www.kfu.com/~nsayer/6to4/"
TARGET="_top"
>NSayer's 6to4 information</A
> para uma lista de routers.</P
><P
>Hoje em dia, os routers upstream 6to4 podem ser encontrados automaticamente, usando o endereço de unicast 192.88.99.1. Os protocolos de roteamento se incumbem desta função, veja <A
HREF="http://www.faqs.org/rfcs/rfc3068.html"
TARGET="_top"
>RFC 3068 / An Anycast Prefix for 6to4 Relay Routers</A
> para mais detalhes. </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1205"
>9.1.3.3. Tunelamento Downstream 6to4</A
></H4
><P
>O downstream (6bone -&#62; seu nó com 6to4 habilitado) não é realmente correto e pode variar de um host remoto estranho que originou os pacotes que foram enviados a voce. Existem duas possibilidades:</P
><P
></P
><UL
><LI
><P
>Estes hosts remotos usam endereços 6to4 e enviam os pacotes de volta diretamente a seu nó (veja abaixo)</P
></LI
><LI
><P
>Estes hosts remotos enviam os pacotes de volta à rede IPv6 e dependendo do roteamento, um router no meio do caminho cria um túnel automaticamente em direção ao seu nó.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1213"
>9.1.3.4. Tráfego 6to4 possível</A
></H4
><P
></P
><UL
><LI
><P
>6to4 para 6to4: normalmente é um túnel direto entre as duas pontas, ambos habilitados em 6to4</P
></LI
><LI
><P
>6to4 para não-6to4: é enviado via um túnel upstream</P
></LI
><LI
><P
>não-6to4 para 6to4: é enviado via um túnel downstream</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1222"
>9.2. Mostrando os túneis existentes</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1224"
>9.2.1. Usando "ip"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel show [&#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel show 
sit0: ipv6/ip remote any local any ttl 64 nopmtudisc 
sit1: ipv6/ip remote 195.226.187.50 local any ttl 64</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1230"
>9.2.2. Usando "route"</A
></H3
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 </PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo (a saída está filtrada para mostrar somente os túneis através da interface virtual sit0):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 | grep "\Wsit0\W*$" 
::/96      ::               U   256  2  0  sit0 
2002::/16  ::               UA  256  0  0  sit0 
2000::/3   ::193.113.58.75  UG    1  0  0  sit0 
fe80::/10  ::               UA  256  0  0  sit0 
ff00::/8   ::               UA  256  0  0  sit0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONF-IPV6-IN-IPV4-POINT-TO-POINT-TUNNELS"
>9.3. Configuração de um túnel ponto a ponto</A
></H2
><P
>Existem possibilidades para adicionar ou remover um túnel ponto a ponto.</P
><P
>Uma boa informação adicional sobre a configuração de túneis fornecida através do comando “ip” está aqui <A
HREF="http://www.deepspace6.net/docs/iproute2tunnel-en.html"
TARGET="_top"
>Configuring tunnels with iproute2 (article)</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/docs/iproute2tunnel-en.html"
TARGET="_top"
>Mirror</A
>).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1242"
>9.3.1. Adicionando túneis ponto a ponto</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1244"
>9.3.1.1. Usando "ip"</A
></H4
><P
>Um método comum para a criação de uma quantidade pequena de túneis.</P
><P
>Use-o para criar um dispositivo túnel (mas não depois, o TTL também deve ser especificado, porque seu valor default é 0).</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel add &#60;device&#62; mode sit ttl &#60;ttldefault&#62; remote
¬ &#60;ipv4addressofforeigntunnel&#62; local &#60;ipv4addresslocal&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel add sit1 mode sit ttl &#60;ttldefault&#62; remote
¬ &#60;ipv4addressofforeigntunnel1&#62; local &#60;ipv4addresslocal&#62;
# /sbin/ip link set dev sit1 up
# /sbin/ip -6 route add &#60;prefixtoroute1&#62; dev sit1 metric 1

# /sbin/ip tunnel add sit2 mode sit ttl &#60;ttldefault&#62;
¬ &#60;ipv4addressofforeigntunnel2&#62; local &#60;ipv4addresslocal&#62;
# /sbin/ip link set dev sit2 up
# /sbin/ip -6 route add &#60;prefixtoroute2&#62; dev sit2 metric 1

# /sbin/ip tunnel add sit3 mode sit ttl &#60;ttldefault&#62;
¬ &#60;ipv4addressofforeigntunnel3&#62; local &#60;ipv4addresslocal&#62;
# /sbin/ip link set dev sit3 up
# /sbin/ip -6 route add &#60;prefixtoroute3&#62; dev sit3 metric 1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1251"
>9.3.1.2. Usando "ifconfig" e "route" (obsoleto)</A
></H4
><P
>Esta não é uma maneira muito recomendada de se criar um túnel porque ele é um pouco estranho. Não há qualquer problema se voce adicionar somente um, mas se voce for configurar mais de um, voce não poderá desfazer os primeiros túneis criados e deixar os últimos em funcionamento.</P
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 up

# /sbin/ifconfig sit0 tunnel &#60;ipv4addressofforeigntunnel1&#62;
# /sbin/ifconfig sit1 up
# /sbin/route -A inet6 add &#60;prefixtoroute1&#62; dev sit1

# /sbin/ifconfig sit0 tunnel &#60;ipv4addressofforeigntunnel2&#62;
# /sbin/ifconfig sit2 up
# /sbin/route -A inet6 add &#60;prefixtoroute2&#62; dev sit2

# /sbin/ifconfig sit0 tunnel &#60;ipv4addressofforeigntunnel3&#62;
# /sbin/ifconfig sit3 up
# /sbin/route -A inet6 add &#60;prefixtoroute3&#62; dev sit3</PRE
></FONT
></TD
></TR
></TABLE
><P
>Importante: NÃO USE ISSO, porque esta configuração habilita implicitamente um “tunelamento automático” de qualquer lugar na internet, e isto é um risco, então não o utilize.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1257"
>9.3.1.3. Usando somente "route"</A
></H4
><P
>Também é possível configurar túneis no modo Non Broadcast Multiple Access (NBMA), pois é uma maneira fácil de adicionar muitos túneis de uma vez. Mas nenhum dos túneis pode ser numerado (o que não é uma característica).</P
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 up

# /sbin/route -A inet6 add &#60;prefixtoroute1&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel1&#62; dev sit0
# /sbin/route -A inet6 add &#60;prefixtoroute2&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel2&#62; dev sit0
# /sbin/route -A inet6 add &#60;prefixtoroute3&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel3&#62; dev sit0</PRE
></FONT
></TD
></TR
></TABLE
><P
>Importante: NÃO USE ISSO, porque esta configuração habilita implicitamente um “tunelamento automático” de qualquer lugar na internet, e isto é um risco, então não o utilize.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1263"
>9.3.2. Removendo os túneis ponto a ponto</A
></H3
><P
>Nem sempre é necessário fazer isso manualmente, mas pode ser usado em scripts para uma limpeza ou restart de uma configuração IPv6.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1266"
>9.3.2.1. Usando "ip"</A
></H4
><P
>Uso para remover um dispositivo túnel:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel del &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del &#60;prefixtoroute1&#62; dev sit1
# /sbin/ip link set sit1 down
# /sbin/ip tunnel del sit1

# /sbin/ip -6 route del &#60;prefixtoroute2&#62; dev sit2
# /sbin/ip link set sit2 down
# /sbin/ip tunnel del sit2

# /sbin/ip -6 route del &#60;prefixtoroute3&#62; dev sit3
# /sbin/ip link set sit3 down
# /sbin/ip tunnel del sit3</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1272"
>9.3.2.2. Usando "ifconfig" e "route" (não é mais usado por ser estranho)</A
></H4
><P
>Não somente a criação é estranha, como também o shutdown... voce tem que remover os tuneis na ordem inversa em que eles foram criados.</P
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del &#60;prefixtoroute3&#62; dev sit3
# /sbin/ifconfig sit3 down

# /sbin/route -A inet6 del &#60;prefixtoroute2&#62; dev sit2
# /sbin/ifconfig sit2 down

# /sbin/route -A inet6 add &#60;prefixtoroute1&#62; dev sit1
# /sbin/ifconfig sit1 down

# /sbin/ifconfig sit0 down&#13;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1277"
>9.3.2.3. Usando "route"</A
></H4
><P
>Isto é como remover rotas normais em IPv6.</P
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del &#60;prefixtoroute1&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel1&#62; dev sit0
# /sbin/route -A inet6 del &#60;prefixtoroute2&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel2&#62; dev sit0
# /sbin/route -A inet6 del &#60;prefixtoroute3&#62; gw
¬ ::&#60;ipv4addressofforeigntunnel3&#62; dev sit0

# /sbin/ifconfig sit0 down</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1282"
>9.3.3. Tuneis ponto a ponto numerados</A
></H3
><P
>Às vezes é necessário configurar túneis ponto a ponto com endereços IPv6 como em IPv4. Isto somente é possível utilizando o primeiro (ifconfig+route - obsoleto) e o terceiro (ip+route) modo de configuração. Em tais casos, voce pode adicionar os endereços IPv6 na interface de túnel conforme é mostrado na configuração de uma interface. </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONFIGURING-IPV6TO4-TUNNELS"
>9.4. Configuração de túneis 6to4</A
></H2
><P
>Preste atenção pois o suporte aos túneis 6to4 atualmente não está implementado completamente no kernel vanilla da série 2.2.x (veja <A
HREF="#SYSTEMCHECK-KERNEL"
>systemcheck/kernel</A
> para mais detalhes). Veja também que o tamanho do prefixo para um endereço 6to4 é 16, uma vez que do ponto de vista da rede, todos os outros hosts habilitados para 6to4 estão na mesma camada 2.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1289"
>9.4.1. Adição de um túnel 6to4</A
></H3
><P
>Antes de tudo, voce precisa calcular o seu prefixo 6to4 usando o seu endereço público IPv4 (se seu host não tem este endereço, é possível utilizar um NAT no router de borda em alguns casos especiais):</P
><P
>Assumindo que o seu endereço IPv4 seja este </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>1.2.3.4</PRE
></FONT
></TD
></TR
></TABLE
><P
>o prefixo 6to4 gerado será este</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2002:0102:0304::</PRE
></FONT
></TD
></TR
></TABLE
><P
>Gateways locais 6to4 deveriam (mas não é uma regra fixa, pois voce pode escolher um sufixo arbitrário, se voce preferir) sempre assinalar o sufixo "::1", desta forma seu endereço local 6to4 será este</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2002:0102:0304::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Por exemplo, use a seguinte automação:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ipv4="1.2.3.4"; printf "2002:%02x%02x:%02x%02x::1" `echo $ipv4 | tr "." " "`</PRE
></FONT
></TD
></TR
></TABLE
><P
>Atualmente existem duas maneiras possíveis de configurar um túnel 6to4.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1301"
>9.4.1.1. Usando "ip" e um dispositivo de túnel dedicado</A
></H4
><P
>Esta é a maneira recomendada (um TTL deve ser especificado, pois o valor default é 0).</P
><P
>Criando um dispositivo de túnel</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel add tun6to4 mode sit ttl &#60;ttldefault&#62; remote any local
¬ &#60;localipv4address&#62; </PRE
></FONT
></TD
></TR
></TABLE
><P
>Ativando a interface</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip link set dev tun6to4 up </PRE
></FONT
></TD
></TR
></TABLE
><P
>Adicionando o endereço local 6to4 na interface (nota: o tamanho do prefixo - /16 - é importante!)</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr add &#60;local6to4address&#62;/16 dev tun6to4 </PRE
></FONT
></TD
></TR
></TABLE
><P
>Adicionando uma rota default para a rede global IPv6 usando o endereço anycast IPv4 todos-6to4-router</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add 2000::/3 via ::192.88.99.1 dev tun6to4 metric 1</PRE
></FONT
></TD
></TR
></TABLE
><P
>É sabido que algumas versões do comando "ip" (exemplo SuSE Linux 9.0) não suportam endereços IPv6 no formato compatível IPv4 para seus gateways, e neste caso o endereço IPv6 relativo a ele deve ser usado:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add 2000::/3 via 2002:c058:6301::1 dev tun6to4 metric 1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1314"
>9.4.1.2. Usando "ifconfig" e "route" e um dispositivo de túnel genérico "sit0" (obsoleto)</A
></H4
><P
>Este método está obsoleto porque o uso de um túnel genérico sit0 não permite especificar filtros pelo dispositivo.</P
><P
>Ativando a interface genérica sit0</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 up </PRE
></FONT
></TD
></TR
></TABLE
><P
>Adicionando um endereço 6to4 na interface</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 add &#60;local6to4address&#62;/16</PRE
></FONT
></TD
></TR
></TABLE
><P
>Adicionando uma rota default para a rede global IPv6 usando o endereço anycast IPv4 todos-6to4-router</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 add 2000::/3 gw ::192.88.99.1 dev sit0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1323"
>9.4.2. Removendo um túnel 6to4</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1325"
>9.4.2.1. Usando "ip" e um dispositivo de túnel dedicado</A
></H4
><P
>Remova todas as rotas que utilizam este dispositivo</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route flush dev tun6to4</PRE
></FONT
></TD
></TR
></TABLE
><P
>Desligue a interface</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip link set dev tun6to4 down</PRE
></FONT
></TD
></TR
></TABLE
><P
>Remova o dispositivo criado</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel del tun6to4 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1333"
>9.4.2.2. Usando "ifconfig" e "route" e o dispositivo genérico de túnel "sit0" (obsoleto)</A
></H4
><P
>Remova as rotas default que usam esta interface</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/route -A inet6 del 2000::/3 gw ::192.88.99.1 dev sit0</PRE
></FONT
></TD
></TR
></TABLE
><P
>Remova o endereço local 6to4 desta interface</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 del &#60;local6to4address&#62;/16</PRE
></FONT
></TD
></TR
></TABLE
><P
>Desligue o dispositivo genérico de túnel (cuidado com isto, pois ela ainda pode estar em uso...)</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ifconfig sit0 down </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-CONFIGURING-IPV4-IN-IPV6-TUNNELS"
></A
>Chapter 10. Configurando túneis IPv4-in-IPv6</H1
><P
>A <A
HREF="http://www.faqs.org/rfcs/rfc2473.html"
TARGET="_top"
>RFC 2473 / Generic Packet Tunneling in IPv6 Specification</A
> especifica o mecanismo para tunelar diferentes tipos de pacotes em IPv6 incluindo IPv4.</P
><P
>NOTAE: O suporte para túneis IPv4-in-IPv6 está disponível somente a partir da versão de kernel 2.6.22.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1346"
>10.1. Mostrando os túneis existentes</A
></H2
><P
>Uso:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel show [&#60;device&#62;]</PRE
></FONT
></TD
></TR
></TABLE
><P
>Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel show mode any
ip6tnl0: ipv6/ipv6 remote :: local :: encaplimit 0 hoplimit 0 tclass 0x00
¬ flowlabel 0x00000 (flowinfo 0x00000000)
ip6tnl1: ip/ipv6 remote fd00:0:0:2::a local fd00:0:0:2::1 dev eth1 encaplimit 4
¬ hoplimit 64 tclass 0x00 flowlabel 0x00000 (flowinfo 0x00000000)</PRE
></FONT
></TD
></TR
></TABLE
><P
>NOTA: Se voce não incluir "mode any", somente os túneis IPv6-in-IPv6 serão mostrados.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1353"
>10.2. Configuração de túnel ponto a ponto</A
></H2
><P
>Uso para criar um dispositivo de túnel 4over6 </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip tunnel add &#60;device&#62; mode ip4ip6 remote &#60;ipv6addressofforeigntunnel&#62;
¬ local &#60;ipv6addresslocal&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel add ip6tnl1 mode ip4ip6 remote
¬ &#60;ipv6addressofforeigntunnel1&#62; local &#60;ipv6addresslocal&#62;
# /sbin/ip link set dev ip6tnl1 up 
# /sbin/ip -6 route add &#60;prefixtoroute1&#62; dev ip6tnl1 metric 1

# /sbin/ip -6 tunnel add ip6tnl2 mode ip4ip6 remote
¬ &#60;ipv6addressofforeigntunnel2&#62; local &#60;ipv6addresslocal&#62;
# /sbin/ip link set dev ip6tnl2 up
# /sbin/ip -6 route add &#60;prefixtoroute2&#62; dev ip6tnl2 metric 1

# /sbin/ip -6 tunnel add ip6tnl3 mode ip4ip6 remote
¬ &#60;ipv6addressofforeigntunnel3&#62; local &#60;ipv6addresslocal&#62;
# /sbin/ip link set dev ip6tnl3 up
# /sbin/ip -6 route add &#60;prefixtoroute3&#62; dev ip6tnl3 metric 1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1359"
>10.3. Removendo túneis ponto a ponto</A
></H2
><P
>Uso ara remover um dispositivo de túnel:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 tunnel del &#60;device&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Uso (exemplo genérico para 3 túneis):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route del &#60;prefixtoroute1&#62; dev ip6tnl1
# /sbin/ip link set ip6tnl1 down
# /sbin/ip -6 tunnel del ip6tnl1

# /sbin/ip -6 route del &#60;prefixtoroute2&#62; dev ip6tnl2
# /sbin/ip link set ip6tnl2 down
# /sbin/ip -6 tunnel del ip6tnl2

# /sbin/ip -6 route del &#60;prefixtoroute3&#62; dev ip6tnl3
# /sbin/ip link set ip6tnl3 down
# /sbin/ip -6 tunnel del ip6tnl3 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-KERNEL-SETTINGS"
></A
>Chapter 11. Configuraçoes de Kernel nos arquivos do /proc</H1
><P
>Nota: a fonte desta seção é em sua maioria o arquivo "ip-sysctl.txt", o qual está incluído no diretório "Documentation/networking" do código fonte do kernel usado. Crédito para Pekka Savola pela manutençao da parte IPv6 neste arquivo. Além disso, muito do que está escrito abaixo é um Copy &#38; Paste deste arquivo mencionado.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1368"
>11.1. Como acessar os arquivos do /proc</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1370"
>11.1.1. Usando "cat" e "echo"</A
></H3
><P
>Usar os comandos "cat" e "echo" é a maneira mais simples de acessar os arquivos deste diretório, mas alguns pontos devem ser observados:</P
><P
></P
><UL
><LI
><P
>O sistema de arquivos /proc deve estar habilitado no kernel , ou seja, a seguinte chave deve estar configurada</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>CONFIG_PROC_FS=y</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>O sistema de arquivos já deve estar montado, o que pode ser testado como comando</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># mount | grep "type proc"
none on /proc type proc (rw)</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Voce pode ler e também escrever (geralmente como root) nos arquivos contidos aqui (/proc)</P
></LI
></UL
><P
>Normalmente, somente as entradas localizadas em /proc/sys/* podem ser alteradas, as demais são somentepara leitura e para obtenção de informações.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1385"
>11.1.1.1. Obtendo um valor</A
></H4
><P
>O valor de uma entrada pode ser obtido com o comando "cat":</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cat /proc/sys/net/ipv6/conf/all/forwarding
0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1389"
>11.1.1.2. Definindo um valor</A
></H4
><P
>Um novo valor pode ser definido (se a entrada aceitar a escrita) através do comando "echo":</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># echo "1" &#62;/proc/sys/net/ipv6/conf/all/forwarding</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1393"
>11.1.2. Usando "sysctl"</A
></H3
><P
>O uso do programa "syysctl" para acessar as chaves do kernel é uma maneira moderna utilizada hoje em dia. Voce também pode usar se o sistema de arquivos /proc não estiver montado. Mas voce só terá acesso às entradas /proc/sys/*!</P
><P
>O programa "sysctl" está incluído no pacote "procps" (em sistemas Red Hat Linux).</P
><P
></P
><UL
><LI
><P
>A interface do sysctl deve estar habilitada no kernel, então a seguinte chave deve estar habilitada</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>CONFIG_SYSCTL=y</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1401"
>11.1.2.1. Obtendo um valor</A
></H4
><P
>O valor de uma entrada pode ser obtida da seguinte maneira:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># sysctl net.ipv6.conf.all.forwarding
net.ipv6.conf.all.forwarding = 0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1405"
>11.1.2.2. Definindo um valor</A
></H4
><P
>Um novo valor pode ser definido (se a entrada aceitar a escrita):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># sysctl -w net.ipv6.conf.all.forwarding=1
net.ipv6.conf.all.forwarding = 1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Nota: Não use espaços entre o sinal = para definir os valores. Se forem possíveis diversos valores, coloque-os entre aspas</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># sysctl -w net.ipv4.ip_local_port_range="32768 61000"
net.ipv4.ip_local_port_range = 32768 61000</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1411"
>11.1.2.3. Adicionais</A
></H4
><P
>Nota: Existem versões em campo que mostram "/" ao invés de "."</P
><P
>Para mais detalhes, de uma olhada na manpage do sysctl.</P
><P
>Dica: para achar mais rapidamente as definiçoes, use a opçao "-a" (mostra todas as entradas) junto com o comando "grep".</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1416"
>11.1.3. Valores encontrados nas entradas /proc</A
></H3
><P
>Existem vários formatos vistos no sistema de arquivos /proc:</P
><P
></P
><UL
><LI
><P
>BOOLEANO: simplesmente um "0" (falso) ou um "1" (verdadeiro)</P
></LI
><LI
><P
>INTEIRO: um valor inteiro, também pode ser sem sinal</P
></LI
><LI
><P
>linhas mais sofisticadas com muitos valores: às vezes uma linha de cabeçalho também é mostrada, senão, uma olhada no código fonte do kernel pode ser necessário para entender o significado dos valores apresentados...</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROC-SYS-NET-IPV6."
>11.2. Entradas em /proc/sys/net/ipv6/</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1428"
>11.2.1. conf/default/*</A
></H3
><P
>Muda as configurações específicas da interface.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1431"
>11.2.2. conf/all/*</A
></H3
><P
>Muda todas as configurações esoecíficas da interface.</P
><P
>Exceção: "conf/all/forwarding" tem um significado diferente aqui</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1435"
>11.2.2.1. conf/all/forwarding</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: BOOLEANO</P
></LI
></UL
><P
>Isto habilita o encaminhamento de pacotes IPv6 entre todas as interfaces.</P
><P
>Em IPv6 voce não pode controlar o envio de pacotes por dispositivo. este encaminhamento deve ser feito através de regras do IPv6-netfilter (controlado com ip6tables) e especificando os dispositivos de entrada e saída (veja <A
HREF="#FIREWALLING-NETFILTER6."
>Firewalling/Netfilter6</A
> para mais detalhes). Isto é diferente no IPv4, onde é possível controlar o encaminhamento por dispositivo (a decisão é feita na interface onde o pacote entra).</P
><P
>Isto também define todas as interfaces do host e/ou router para o valor especificado. Veja os detalhes abaixo. Esta definição refere-se ao encaminhamento global.</P
><P
>Se este valor é 0, nenhum pacote IPv6 é encaminhado, os pacotes nunca deixarão outra interface, seja ela física ou lógica, como os túneis.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1445"
>11.2.3. conf/interface/*</A
></H3
><P
>Muda configurações especiais por interface.</P
><P
>O comportamento funcional de certos ajustes é diferente, dependendo se o encaminhamento local está habilitado ou não.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1449"
>11.2.3.1. accept_ra</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: BOOLEAN</P
></LI
><LI
><P
>Ajuste default: habilitado se o encaminhamento local está desabilitado, e desabilitado se o encaminhamento local está habilitado.</P
></LI
></UL
><P
>Aceita Router Advertisements, e configura automaticamente esta interface com os dados recebidos.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1457"
>11.2.3.2. accept_redirects</A
></H4
><P
></P
><UL
><LI
><P
>Tipi: BOOLEAN</P
></LI
><LI
><P
>Ajuste default: habilitado se o encaminhamento local está desabilitado, e desabilitado se o encaminhamento local está habilitado.</P
></LI
></UL
><P
>Aceita os Redirects enviados por um router IPv6.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1465"
>11.2.3.3. autoconf</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: BOOLEAN</P
></LI
><LI
><P
>Ajuste default: habilitado se o accept_ra_pinfo está babilitado, e desabilitado se o accept_ra_pinfo estiver desabilitado.</P
></LI
></UL
><P
>Os endereços e prefixos usados na configuração automática proveem de anúncios dos routers.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1473"
>11.2.3.4. dad_transmits</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 1</P
></LI
></UL
><P
>Quantidade de probes de detecção de endereços duplicados enviados.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1481"
>11.2.3.5. forwarding</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: BOOLEAN</P
></LI
><LI
><P
>Default: FALSE se o encaminhamento global estiver desabilitado (default), caso contrário TRUE</P
></LI
></UL
><P
>Comportamento Host/Router específico.</P
><P
>Nota: É recomendado ter a mesma configuração em todas as interfaces; cenários diferentes são bem incomuns.</P
><P
></P
><UL
><LI
><P
>Valor FALSE: Por default, o comportamento do Host é assumido. Isto significa:</P
></LI
></UL
><P
></P
><OL
TYPE="1"
><LI
><P
>O flag IsRouter não está definido em aúncios de vizinhança.</P
></LI
><LI
><P
>Solicitaçoes Router são enviados quando necessário.</P
></LI
><LI
><P
>Se accept_ra é TRUE (default), aceita anúncios router (e fazem auti configuração).</P
></LI
><LI
><P
>Se accept_redirects é TRUE (default), aceita Redirects.</P
></LI
></OL
><P
></P
><UL
><LI
><P
>Valor TRUE: se o encaminhamento local está habilitado, o comportamento Router é assumido. Isto significa que o contrário da lista acima pode acontecer:</P
></LI
></UL
><P
></P
><OL
TYPE="1"
><LI
><P
>O flag IsRouter é definido nos anúncios de vizinhança.</P
></LI
><LI
><P
>Solicitaçoes Router não são enviadas.</P
></LI
><LI
><P
>Anúncios Router são ignorados.</P
></LI
><LI
><P
>Redirects são ignorados.</P
></LI
></OL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1514"
>11.2.3.6. hop_limit</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 64</P
></LI
></UL
><P
>Hop Limit default para definir.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1522"
>11.2.3.7. mtu</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 1280 (mínimo necessário no IPv6)</P
></LI
></UL
><P
>Default Maximum Transfer Unit</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1530"
>11.2.3.8. router_solicitation_delay</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 1</P
></LI
></UL
><P
>Número de segundos a esperar após a interface ser ativada antes de enviar solicitaçoes Router.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1538"
>11.2.3.9. router_solicitation_interval</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 4</P
></LI
></UL
><P
>Número de segundos a esperar entre solicitaçoes Router. </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1546"
>11.2.3.10. router_solicitations</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 3</P
></LI
></UL
><P
>Número de solicitaçoes Router a enviar até assumir que não há um router presente.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1554"
>11.2.4. neigh/default/*</A
></H3
><P
>Muda as definiçoes default para detecçao de vizinhos e alguns valores globais e de limites:</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1557"
>11.2.4.1. gc_thresh1</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 128</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1565"
>11.2.4.2. gc_thresh2</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 512</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1573"
>11.2.4.3. gc_thresh3</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 1024</P
></LI
></UL
><P
>Parametro para o tamanho da tabela de vizinhança.</P
><P
>Aumente este valor se voce tem muitas interfaces e os routers começam a apresentar problemas misteriosos de funcionamento e falhas. Ou se uma mensagem dessas aparecer <A
HREF="http://www.zebra.org/"
TARGET="_top"
>Zebra (routing daemon)</A
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ZEBRA: netlink-listen error: No buffer space available, type=RTM_NEWROUTE(24),
¬ seq=426, pid=0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1584"
>11.2.4.4. gc_interval</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 30</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1592"
>11.2.5. neigh/interface/*</A
></H3
><P
>Muda ajustes especiais por interface para detecção de vizinhos.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1595"
>11.2.5.1. anycast_delay</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 100</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1603"
>11.2.5.2. gc_stale_time</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 60</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1611"
>11.2.5.3. proxy_qlen</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 64</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1619"
>11.2.5.4. unres_qlen</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 3</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1627"
>11.2.5.5. app_solicit</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 0</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1635"
>11.2.5.6. locktime</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 0</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1643"
>11.2.5.7. retrans_time</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 100</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1651"
>11.2.5.8. base_reachable_time</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 30</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1659"
>11.2.5.9. mcast_solicit</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 3</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1667"
>11.2.5.10. ucast_solicit</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 3</P
></LI
></UL
><P
>Precisa ser preenchido</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1675"
>11.2.5.11. delay_first_probe_time</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 5</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1683"
>11.2.5.12. proxy_delay</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 80</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1691"
>11.2.6. route/*</A
></H3
><P
>Ajustes globais para roteamento.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1694"
>11.2.6.1. flush</A
></H4
><P
>Removido nas novas versões de kernel - Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1697"
>11.2.6.2. gc_interval</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 30</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1705"
>11.2.6.3. gc_thresh</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 1024</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1713"
>11.2.6.4. mtu_expires</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 600</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1721"
>11.2.6.5. gc_elasticity</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 0</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1729"
>11.2.6.6. gc_min_interval</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 5</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1737"
>11.2.6.7. gc_timeout</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 60</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1745"
>11.2.6.8. min_adv_mss</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 12</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1753"
>11.2.6.9. max_size</A
></H4
><P
></P
><UL
><LI
><P
>Tipo: INTEGER</P
></LI
><LI
><P
>Default: 4096</P
></LI
></UL
><P
>Precisa ser preenchido.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROC-SYS-NET-IPV4."
>11.3. Entradas relacionadas a IPv6 em /proc/sys/net/ipv4/</A
></H2
><P
>Neste momento (e será até que o IPv6 seja completamente convertido para um módulo independente do kernel) algumas chaves para IPv6 são usadas aqui.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1764"
>11.3.1. ip_*</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1766"
>11.3.1.1. ip_local_port_range</A
></H4
><P
>Esta definição também é usada para o IPv6.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1769"
>11.3.2. tcp_*</A
></H3
><P
>Esta definição também é usada para o IPv6.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1772"
>11.3.3. icmp_*</A
></H3
><P
>Esta definição não é usada para o IPv6. Para habilitar o limite ICMPv6 (o que é muito recomendado) regras netfilter-v6 devem ser usadas.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1775"
>11.3.4. others</A
></H3
><P
>Desconhecido, mas provavelmente não usado pelo IPv6.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROC-NET"
>11.4. Entradas em /proc/net relacionadas com IPv6</A
></H2
><P
>No /proc/net existem diversas variáveis disponíveis, somente para leitura, Não é possível obter informaçoes através do "sysctl", então utilize "cat".</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1781"
>11.4.1. if_inet6</A
></H3
><P
></P
><UL
><LI
><P
>Tipo: Uma linha por endereço contendo vários valores</P
></LI
></UL
><P
>Aqui todos os endereços IPv6 cpnfigurados são mostrados em um formato especial. O exemplo mostra somente a interface de loopback. O significado é mostrado abaixo (veja "net/ipv6/addrconf.c" para mais informações).</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cat /proc/net/if_inet6
00000000000000000000000000000001 01 80 10 80 lo
+------------------------------+ ++ ++ ++ ++ ++
|                                |  |  |  |  |
1                                2  3  4  5  6</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><OL
TYPE="1"
><LI
><P
>Endereço IPv6 mostrado em hexadecimal (32 caracteres) sem os dois pontos ":" como separadores</P
></LI
><LI
><P
>Número do dispositivo netlink (índice da interface) em hexadecimal (veja “ip addr” , também)</P
></LI
><LI
><P
>tamanho do prefixo, em hexadecimal</P
></LI
><LI
><P
>Valor do escopo (veja o fonte do kernel " include/net/ipv6.h" e "net/ipv6/addrconf.c" para mais informações)</P
></LI
><LI
><P
>Flags da interface (veja "include/linux/rtnetlink.h" e"net/ipv6/addrconf.c" para mais informações)</P
></LI
><LI
><P
>Nome do disppositivo</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1801"
>11.4.2. ipv6_route</A
></H3
><P
></P
><UL
><LI
><P
>Tipo: Uma linha por rota contém várias valores</P
></LI
></UL
><P
>Aqui toda a configuração de rotas em IPv6 é mostrada em um formato especialt. O exemplo mostra informações somente para a interface de loopback O significado é mostrado abaixo (veja "net/ipv6/route.c" para mais informações).</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cat /proc/net/ipv6_route
00000000000000000000000000000000 00 00000000000000000000000000000000 00
+------------------------------+ ++ +------------------------------+ ++
|                                |  |                                |
1                                2  3                                4

¬ 00000000000000000000000000000000 ffffffff 00000001 00000001 00200200 lo
¬ +------------------------------+ +------+ +------+ +------+ +------+ ++
¬ |                                |        |        |        |        |
¬ 5                                6        7        8        9        10</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><OL
TYPE="1"
><LI
><P
>Rede de destino IPv6 mostrada em hexadecimal (32 caracteres) som dois pontos ":" como separador</P
></LI
><LI
><P
>Tamanho do prefixo de destino, em hexadecimal</P
></LI
><LI
><P
>Rede de origem IPv6 mostrada em hexadecimal (32 caracteres) som dois pontos ":" como separador</P
></LI
><LI
><P
>Tamanho do prefixo de origem, em hexadecimal</P
></LI
><LI
><P
>Próximo salto IPv6 mostrado em hexadecimal (32 caracteres) som dois pontos ":" como separador</P
></LI
><LI
><P
>Métrica em hexadecimal</P
></LI
><LI
><P
>Contador de referencia</P
></LI
><LI
><P
>Contadoer de uso</P
></LI
><LI
><P
>Flags</P
></LI
><LI
><P
>Nome do dispositivo</P
></LI
></OL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1829"
>11.4.3. sockstat6</A
></H3
><P
></P
><UL
><LI
><P
>Tipo: Uma linha por protocolo, com descrição e valor</P
></LI
></UL
><P
>Estatísticas sobre o uso de sockets IPv6. Exemplo:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cat /proc/net/sockstat6
TCP6: inuse 7 
UDP6: inuse 2 
RAW6: inuse 1 
FRAG6: inuse 0 memory 0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1836"
>11.4.4. tcp6</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1839"
>11.4.5. udp6</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1842"
>11.4.6. igmp6</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1845"
>11.4.7. raw6</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1848"
>11.4.8. ip6_flowlabel</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1851"
>11.4.9. rt6_stats</A
></H3
><P
>Precisa ser preenchido.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1854"
>11.4.10. snmp6</A
></H3
><P
></P
><UL
><LI
><P
>Tipo: Uma linha por descrição SNMP e valor</P
></LI
></UL
><P
>Estatísticas SNMP podem ser obtidas via um servidor SNMP e suas MIB's relacionadas, através um software de gerencia de rede.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1860"
>11.4.11. ip6_tables_names</A
></H3
><P
>Tabelas netfilter6 disponíveis</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NETLINK"
></A
>Chapter 12. Netlink-Interface to kernel</H1
><P
>To be filled...I have no experience with that...</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="RESOLVER"
></A
>Chapter 13. Address Resolver</H1
><P
>Name to IPv4 or IPv6 address resolving is usually done using a libc resolver library. There are some issues known using the function <EM
>getaddrinfo</EM
>.</P
><P
>More info can be found at <A
HREF="http://www.bieringer.de/linux/IPv6/getaddrinfo/"
TARGET="_top"
>Linux &#38; IPv6: getaddrinfo and search domains - Research</A
> and <A
HREF="http://people.redhat.com/drepper/linux-rfc3484.html"
TARGET="_top"
>RFC 3484 on Linux</A
>.</P
><P
>More to be filled later...</P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="NETWORK-DEBUGGING"
></A
>Chapter 14. Network debugging</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN1876"
>14.1. Server socket binding</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN1878"
>14.1.1. Using “netstat” for server socket binding check</A
></H3
><P
>It's always interesting which server sockets are currently active on a node. Using “netstat” is a short way to get such information: </P
><P
>Used options: -nlptu</P
><P
>Example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># netstat -nlptu
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State      
¬ PID/Program name
tcp        0      0 0.0.0.0:32768           0.0.0.0:*               LISTEN     
¬ 1258/rpc.statd
tcp        0      0 0.0.0.0:32769           0.0.0.0:*               LISTEN     
¬ 1502/rpc.mountd
tcp        0      0 0.0.0.0:515             0.0.0.0:*               LISTEN     
¬ 22433/lpd Waiting
tcp        0      0 1.2.3.1:139             0.0.0.0:*               LISTEN     
¬ 1746/smbd
tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN     
¬ 1230/portmap
tcp        0      0 0.0.0.0:6000            0.0.0.0:*               LISTEN     
¬ 3551/X
tcp        0      0 1.2.3.1:8081            0.0.0.0:*               LISTEN     
¬ 18735/junkbuster
tcp        0      0 1.2.3.1:3128            0.0.0.0:*               LISTEN     
¬ 18822/(squid)
tcp        0      0 127.0.0.1:953           0.0.0.0:*               LISTEN     
¬ 30734/named
tcp        0      0 ::ffff:1.2.3.1:993      :::*                    LISTEN     
¬ 6742/xinetd-ipv6
tcp        0      0 :::13                   :::*                    LISTEN     
¬ 6742/xinetd-ipv6
tcp        0      0 ::ffff:1.2.3.1:143      :::*                    LISTEN     
¬ 6742/xinetd-ipv6
tcp        0      0 :::53                   :::*                    LISTEN     
¬ 30734/named
tcp        0      0 :::22                   :::*                    LISTEN     
¬ 1410/sshd
tcp        0      0 :::6010                 :::*                    LISTEN     
¬ 13237/sshd
udp        0      0 0.0.0.0:32768           0.0.0.0:*                          
¬ 1258/rpc.statd
udp        0      0 0.0.0.0:2049            0.0.0.0:*                          
¬ -
udp        0      0 0.0.0.0:32770           0.0.0.0:*                          
¬ 1502/rpc.mountd
udp        0      0 0.0.0.0:32771           0.0.0.0:*                          
¬ -
udp        0      0 1.2.3.1:137             0.0.0.0:*                          
¬ 1751/nmbd
udp        0      0 0.0.0.0:137             0.0.0.0:*                          
¬ 1751/nmbd
udp        0      0 1.2.3.1:138             0.0.0.0:*                          
¬ 1751/nmbd
udp        0      0 0.0.0.0:138             0.0.0.0:*                          
¬ 1751/nmbd
udp        0      0 0.0.0.0:33044           0.0.0.0:*                          
¬ 30734/named
udp        0      0 1.2.3.1:53              0.0.0.0:*                          
¬ 30734/named
udp        0      0 127.0.0.1:53            0.0.0.0:*                          
¬ 30734/named
udp        0      0 0.0.0.0:67              0.0.0.0:*                          
¬ 1530/dhcpd
udp        0      0 0.0.0.0:67              0.0.0.0:*                          
¬ 1530/dhcpd
udp        0      0 0.0.0.0:32858           0.0.0.0:*                          
¬ 18822/(squid)
udp        0      0 0.0.0.0:4827            0.0.0.0:*                          
¬ 18822/(squid)
udp        0      0 0.0.0.0:111             0.0.0.0:*                          
¬ 1230/portmap
udp        0      0 :::53                   :::*                               
¬ 30734/named</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="EXAMPLES-TCPDUMP"
>14.2. Examples for tcpdump packet dumps</A
></H2
><P
>Here some examples of captured packets are shown, perhaps useful for your own debugging...</P
><P
>...more coming next...</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1888"
>14.2.1. Router discovery</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1890"
>14.2.1.1. Router advertisement</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>15:43:49.484751 fe80::212:34ff:fe12:3450 &#62; ff02::1: icmp6: router
¬ advertisement(chlim=64, router_ltime=30, reachable_time=0,
¬ retrans_time=0)(prefix info: AR valid_ltime=30, preffered_ltime=20,
¬ prefix=2002:0102:0304:1::/64)(prefix info: LAR valid_ltime=2592000,
¬ preffered_ltime=604800, prefix=2001:0db8:0:1::/64)(src lladdr:
¬ 0:12:34:12:34:50) (len 88, hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
><P
>Router with link-local address “fe80::212:34ff:fe12:3450” send an advertisement to the all-node-on-link multicast address “ff02::1” containing two prefixes “2002:0102:0304:1::/64” (lifetime 30 s) and “2001:0db8:0:1::/64” (lifetime 2592000 s) including its own layer 2 MAC address “0:12:34:12:34:50”.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1894"
>14.2.1.2. Router solicitation</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>15:44:21.152646 fe80::212:34ff:fe12:3456 &#62; ff02::2: icmp6: router solicitation
¬ (src lladdr: 0:12:34:12:34:56) (len 16, hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
><P
>Node with link-local address “fe80::212:34ff:fe12:3456” and layer 2 MAC address “0:12:34:12:34:56” is looking for a router on-link, therefore sending this solicitation to the all-router-on-link multicast address “ff02::2”.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1898"
>14.2.2. Neighbor discovery</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1900"
>14.2.2.1. Neighbor discovery solicitation for duplicate address detection</A
></H4
><P
>Following packets are sent by a node with layer 2 MAC address “0:12:34:12:34:56” during autoconfiguration to check whether a potential address is already used by another node on the link sending this to the solicited-node link-local multicast address.</P
><P
></P
><UL
><LI
><P
>Node wants to configure its link-local address “fe80::212:34ff:fe12:3456”, checks for duplicate now</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>15:44:17.712338 :: &#62; ff02::1:ff12:3456: icmp6: neighbor sol: who has
¬ fe80::212:34ff:fe12:3456(src lladdr: 0:12:34:12:34:56) (len 32, hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Node wants to configure its global address “2002:0102:0304:1:212:34ff:fe12:3456” (after receiving advertisement shown above), checks for duplicate now</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>15:44:21.905596 :: &#62; ff02::1:ff12:3456: icmp6: neighbor sol: who has
¬ 2002:0102:0304:1:212:34ff:fe12:3456(src lladdr: 0:12:34:12:34:56) (len 32,
¬ hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Node wants to configure its global address “2001:0db8:0:1:212:34ff:fe12:3456” (after receiving advertisement shown above), checks for duplicate now</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>15:44:22.304028 :: &#62; ff02::1:ff12:3456: icmp6: neighbor sol: who has
¬ 2001:0db8:0:1:212:34ff:fe12:3456(src lladdr: 0:12:34:12:34:56) (len 32, hlim
¬ 255)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1915"
>14.2.2.2. Neighbor discovery solicitation for looking for host or gateway</A
></H4
><P
></P
><UL
><LI
><P
>Node wants to send packages to “2001:0db8:0:1::10” but has no layer 2 MAC address to send packet, so send solicitation now</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>13:07:47.664538 2002:0102:0304:1:2e0:18ff:fe90:9205 &#62; ff02::1:ff00:10: icmp6:
¬ neighbor sol: who has 2001:0db8:0:1::10(src lladdr: 0:e0:18:90:92:5) (len 32,
¬ hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Node looks for “fe80::10” now</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>13:11:20.870070 fe80::2e0:18ff:fe90:9205 &#62; ff02::1:ff00:10: icmp6: neighbor
¬ sol: who has fe80::10(src lladdr: 0:e0:18:90:92:5) (len 32, hlim 255)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-SUPPORT-PERSISTENT-CONFIGURATION"
></A
>Chapter 15. Support for persistent IPv6 configuration in Linux distributions</H1
><P
>Some Linux distribution contain already support of a persistent IPv6 configuration using existing or new configuration and script files and some hook in the IPv4 script files.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1928"
>15.1. Red Hat Linux and “clones”</A
></H2
><P
>Since starting writing the <A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6 &#38; Linux - HowTo</A
> it was my intention to enable a persistent IPv6 configuration which catch most of the wished cases like host-only, router-only, dual-homed-host, router with second stub network, normal tunnels, 6to4 tunnels, and so on. Nowadays there exists a set of configuration and script files which do the job very well (never heard about real problems, but I don't know how many use the set). Because this configuration and script files are extended from time to time, they got their own homepage: <A
HREF="http://www.deepspace6.net/projects/initscripts-ipv6.html"
TARGET="_top"
>initscripts-ipv6 homepage</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/projects/initscripts-ipv6.html"
TARGET="_top"
>Mirror</A
>). Because I began my IPv6 experience using a Red Hat Linux 5.0 clone, my IPv6 development systems are mostly Red Hat Linux based now, it's kind a logic that the scripts are developed for this kind of distribution (so called <EM
>historic issue</EM
>). Also it was very easy to extend some configuration files, create new ones and create some simple hook for calling IPv6 setup during IPv4 setup.</P
><P
>Fortunately, in Red Hat Linux since 7.1 a snapshot of my IPv6 scripts is included, this was and is still further on assisted by Pekka Savola.</P
><P
>Mandrake since version 8.0 also includes an IPv6-enabled initscript package, but a minor bug still prevents usage (“ifconfig” misses “inet6” before “add”).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1937"
>15.1.1. Test for IPv6 support of network configuration scripts</A
></H3
><P
>You can test, whether your Linux distribution contain support for persistent IPv6 configuration using my set. Following script library should exist:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/etc/sysconfig/network-scripts/network-functions-ipv6</PRE
></FONT
></TD
></TR
></TABLE
><P
>Auto-magically test:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># test -f /etc/sysconfig/network-scripts/network-functions-ipv6 &#38;&#38; echo "Main
¬ IPv6 script library exists"</PRE
></FONT
></TD
></TR
></TABLE
><P
>The version of the library is important if you miss some features. You can get it executing following (or easier look at the top of the file):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># source /etc/sysconfig/network-scripts/network-functions-ipv6 &#38;&#38;
¬ getversion_ipv6_functions 
20011124</PRE
></FONT
></TD
></TR
></TABLE
><P
>In shown example, the used version is 20011124. Check this against latest information on <A
HREF="http://www.deepspace6.net/projects/initscripts-ipv6.html"
TARGET="_top"
>initscripts-ipv6 homepage</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/projects/initscripts-ipv6.html"
TARGET="_top"
>Mirror</A
>) to see what has been changed. You will find there also a change-log.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1948"
>15.1.2. Short hint for enabling IPv6 on current RHL 7.1, 7.2, 7.3, ...</A
></H3
><P
></P
><UL
><LI
><P
>Check whether running system has already IPv6 module loaded</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># modprobe -c | grep net-pf-10
alias net-pf-10 off</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>If result is “off”, then enable IPv6 networking by editing /etc/sysconfig/network, add following new line</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>NETWORKING_IPV6=yes</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Reboot or restart networking using</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># service network restart</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Now IPv6 module should be loaded</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># modprobe -c | grep ipv6
alias net-pf-10 ipv6</PRE
></FONT
></TD
></TR
></TABLE
><P
>If your system is on a link which provides router advertisement, autoconfiguration will be done automatically. For more information which settings are supported see /usr/share/doc/initscripts-$version/sysconfig.txt.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1967"
>15.2. SuSE Linux</A
></H2
><P
>In newer 7.x versions there is a really rudimentary support available, see /etc/rc.config for details.</P
><P
>Because of the really different configuration and script file structure it is hard (or impossible) to use the set for Red Hat Linux and clones with this distribution.
In versions 8.x they completly change their configuration setup. </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1971"
>15.2.1. SuSE Linux 7.3</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.feyrer.de/IPv6/SuSE73-IPv6+6to4-setup.html"
TARGET="_top"
>How to setup 6to4 IPv6 with SuSE 7.3</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1977"
>15.2.2. SuSE Linux 8.0</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1979"
>15.2.2.1. IPv6 address configuration</A
></H4
><P
>Edit file /etc/sysconfig/network/ifcfg-&#60;Interface-Name&#62; and setup following value</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>IP6ADDR="&#60;ipv6-address&#62;/&#60;prefix&#62;"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1983"
>15.2.2.2. Additional information</A
></H4
><P
>See file /usr/share/doc/packages/sysconfig/README</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN1986"
>15.2.3. SuSE Linux 8.1</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN1988"
>15.2.3.1. IPv6 address configuration</A
></H4
><P
>Edit file /etc/sysconfig/network/ifcfg-&#60;Interface-Name&#62; and setup following value</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>IPADDR="&#60;ipv6-address&#62;/&#60;prefix&#62;"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN1992"
>15.2.3.2. Additional information</A
></H4
><P
>See file /usr/share/doc/packages/sysconfig/Network </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONFIGURATION-DEBIAN-LINUX"
>15.3. Debian Linux</A
></H2
><P
>Following information was contributed by Stephane Bortzmeyer &#60;bortzmeyer at nic dot fr&#62;</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Be sure that IPv6 is loaded, either because it is compiled into the kernel or because the module is loaded. For the latest, three solutions, adding it to /etc/modules, using the pre-up trick shown later or using kmod (not detailed here).</P
></LI
><LI
><P
>Configure your interface. Here we assume eth0 and address (2001:0db8:1234:5::1:1). Edit /etc/network/interfaces:</P
></LI
></OL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>iface eth0 inet6 static
        pre-up modprobe ipv6
        address 2001:0db8:1234:5::1:1
        # To suppress completely autoconfiguration:
        # up echo 0 &#62; /proc/sys/net/ipv6/conf/all/autoconf
        netmask 64
        # The router is autoconfigured and has no fixed address.
        # It is magically
        # found. (/proc/sys/net/ipv6/conf/all/accept_ra). Otherwise:
        #gateway 2001:0db8:1234:5::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>And you reboot or you just</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ifup --force eth0</PRE
></FONT
></TD
></TR
></TABLE
><P
>and you have your static address. </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2007"
>15.3.1. Further information</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://ipv6.debian.net/"
TARGET="_top"
>IPv6 with Debian Linux</A
></P
></LI
><LI
><P
>Jean-Marc V. Liotier's <A
HREF="http://www.ruwenzori.net/ipv6/Jims_LAN_IPv6_global_connectivity_howto.html"
TARGET="_top"
>HOWTO for Freenet6 &#38; Debian Users</A
> (announced 24.12.2002 on <A
HREF="#INFORMATION-MAILLISTS"
>mailinglist</A
> users@ipv6.org )</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-AUTOCONFIGURATION"
></A
>Chapter 16. Auto-configuration</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2019"
>16.1. Stateless auto-configuration</A
></H2
><P
>Is supported and seen on the assigned link-local address after an IPv6-enabled interface is up.</P
><P
>Example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 addr show dev eth0 scope link
2: eth0: &#60;BROADCAST,MULTICAST,UP&#62; mtu 1500 qlen1000
    inet6 fe80::211:d8ff:fe6b:f0f5/64 scope link
       valid_lft forever preferred_lft forever </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2024"
>16.2. Stateful auto-configuration using Router Advertisement Daemon (radvd)</A
></H2
><P
>to be filled. See <A
HREF="#HINTS-DAEMONS-RADVD"
>radvd daemon autoconfiguration</A
> below.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2028"
>16.3. Dynamic Host Configuration Protocol v6 (DHCPv6)</A
></H2
><P
>After a long time discussing issues, finally <A
HREF="http://www.faqs.org/rfcs/rfc3315.html"
TARGET="_top"
>RFC 3315 / Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</A
> was finished. At time updating this part (10/2005) currently two implementations are available:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://klub.com.pl/dhcpv6/"
TARGET="_top"
>Dibbler</A
> by Tomasz Mrugalski &#60;thomson at klub dot com dot pl&#62; (<A
HREF="#HINTS-DAEMONS-DIBBLER"
>Hints for configuration</A
>)</P
></LI
><LI
><P
><A
HREF="http://dhcpv6.sourceforge.net/"
TARGET="_top"
>DHCPv6 on Sourceforge</A
> (<A
HREF="#HINTS-DAEMONS-DHCPV6."
>Hints for configuration</A
>)</P
></LI
><LI
><P
><A
HREF="http://www.isc.org/software/dhcp"
TARGET="_top"
>ISC DHCP</A
> (<A
HREF="#HINTS-DAEMONS-ISC-DHCP"
>Hints for configuration</A
>)</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-MOBILITY"
></A
>Chapter 17. Mobility</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2047"
>17.1. Common information</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2049"
>17.1.1. Node Mobility</A
></H3
><P
>Support for IPv6 mobility can be enabled in Linux by installing the MIPL2 implementation found at: <A
HREF="http://www.mobile-ipv6.org/"
TARGET="_top"
>http://www.mobile-ipv6.org/</A
></P
><P
>This implementation is compliant with RFC 3775. It is composed of a kernel patch and a mobility daemon called mip6d. Version 2.0.1 applies on Linux kernel 2.6.15.</P
><P
>Installation and setup are described in the <A
HREF="http://tldp.org/HOWTO/Mobile-IPv6-HOWTO/"
TARGET="_top"
>Linux Mobile IPv6 HOWTO</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2056"
>17.1.2. Network Mobility</A
></H3
><P
>There also exists an implementation of network mobility for Linux, it is called NEPL and is based on MIPL. It can also be downloaded from: <A
HREF="http://www.mobile-ipv6.org/"
TARGET="_top"
>http://www.mobile-ipv6.org/</A
>.</P
><P
>The HOWTO document describing setup and configuration is available at: <A
HREF="http://www.nautilus6.org/doc/nepl-howto/"
TARGET="_top"
>http://www.nautilus6.org/doc/nepl-howto/</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2062"
>17.1.3. Links</A
></H3
><P
></P
><UL
><LI
><P
>Mobile IPv6 for Linux (MIPL) project: <A
HREF="http://www.mobile-ipv6.org/"
TARGET="_top"
>http://www.mobile-ipv6.org/</A
></P
></LI
><LI
><P
>Nautilus6 working group: <A
HREF="http://nautilus6.org/"
TARGET="_top"
>http://nautilus6.org/</A
></P
></LI
><LI
><P
>Fast Handovers for Mobile IPv6 for Linux project: <A
HREF="http://www.fmipv6.org/"
TARGET="_top"
>http://www.fmipv6.org/</A
></P
></LI
><LI
><P
>USAGI-patched Mobile IPv6 for Linux (UMIP):<A
HREF="http://umip.linux-ipv6.org/"
TARGET="_top"
>http://umip.linux-ipv6.org/</A
></P
></LI
><LI
><P
>Deploying IPsec/IKE-protected MIPv6 under Linux:<A
HREF="http://natisbad.org/MIPv6/"
TARGET="_top"
>http://natisbad.org/MIPv6/</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3775.html"
TARGET="_top"
>RFC 3775 / Mobility Support in IPv6</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3776.html"
TARGET="_top"
>RFC 3776 / Using IPsec to Protect Mobile IPv6 Signaling Between Mobile Nodes and Home Agents</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3963.html"
TARGET="_top"
>RFC 3963 / Network Mobility (NEMO)</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc4068.html"
TARGET="_top"
>RFC 4068 / Fast Handovers for Mobile IPv6</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc4423.html"
TARGET="_top"
>RFC 4423 / Host Identity Protocol (HIP) Architecture</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc5201.html"
TARGET="_top"
>RFC 5201 / Host Identity Protocol</A
></P
></LI
><LI
><P
>HIP implementations: <A
HREF="http://infrahip.hiit.fi/"
TARGET="_top"
>http://infrahip.hiit.fi/</A
>, <A
HREF="http://hip4inter.net/"
TARGET="_top"
>http://hip4inter.net/</A
>, <A
HREF="http://www.openhip.org/"
TARGET="_top"
>http://www.openhip.org/</A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-FIREWALLING-SECURITY"
></A
>Chapter 18. Firewalling</H1
><P
>IPv6 firewalling is important, especially if using IPv6 on internal networks with global IPv6 addresses. Because unlike at IPv4 networks where in common internal hosts are protected automatically using private IPv4 addresses like <A
HREF="http://www.faqs.org/rfcs/rfc1918.html"
TARGET="_top"
>RFC 1918 / Address Allocation for Private Internets</A
> or Automatic Private IP Addressing (APIPA)<A
HREF="http://www.google.com/search?q=apipa+microsoft"
TARGET="_top"
>Google search for Microsoft + APIPA</A
>, in IPv6 normally global addresses are used and someone with IPv6 connectivity can reach all internal IPv6 enabled nodes.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FIREWALLING-NETFILTER6."
>18.1. Firewalling using netfilter6</A
></H2
><P
>Native IPv6 firewalling is only supported in kernel versions 2.4+. In older 2.2- you can only filter IPv6-in-IPv4 by protocol 41. </P
><P
>Attention: no warranty that described rules or examples can really protect your system! </P
><P
>Audit your ruleset after installation, see <A
HREF="#IPV6-SECURITY-AUDITING"
>Section 19.3</A
> for more.</P
><P
>Since kernel version 2.6.20 IPv6 connection tracking is fully working (and does not break IPv4 NAT anymore like versions before)</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2115"
>18.1.1. More information</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.netfilter.org/"
TARGET="_top"
>Netfilter project</A
></P
></LI
><LI
><P
><A
HREF="https://lists.netfilter.org/mailman/listinfo/netfilter"
TARGET="_top"
>maillist archive of netfilter users</A
></P
></LI
><LI
><P
><A
HREF="https://lists.netfilter.org/mailman/listinfo/netfilter-devel"
TARGET="_top"
>maillist archive of netfilter developers</A
></P
></LI
><LI
><P
><A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-kernel.html#netfilter6 "
TARGET="_top"
>Unofficial status informations</A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2130"
>18.2. Preparation</A
></H2
><P
>This step is only needed if distributed kernel and netfilter doesn't fit your requirements and new features are available but still not built-in.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2133"
>18.2.1. Get sources</A
></H3
><P
>Get the latest kernel source: <A
HREF="http://www.kernel.org/"
TARGET="_top"
>http://www.kernel.org/</A
></P
><P
>Get the latest iptables package: </P
><P
></P
><UL
><LI
><P
>Source tarball (for kernel patches): <A
HREF="http://www.netfilter.org/"
TARGET="_top"
>http://www.netfilter.org/</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2142"
>18.2.2. Extract sources</A
></H3
><P
>Change to source directory: </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cd /path/to/src </PRE
></FONT
></TD
></TR
></TABLE
><P
>Unpack and rename kernel sources </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tar z|jxf kernel-version.tar.gz|bz2 
# mv linux linux-version-iptables-version+IPv6 </PRE
></FONT
></TD
></TR
></TABLE
><P
>Unpack iptables sources </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tar z|jxf iptables-version.tar.gz|bz2 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2150"
>18.2.3. Apply latest iptables/IPv6-related patches to kernel source</A
></H3
><P
>Change to iptables directory </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cd iptables-version </PRE
></FONT
></TD
></TR
></TABLE
><P
>Apply pending patches </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># make pending-patches KERNEL_DIR=/path/to/src/linux-version-iptables-version/ </PRE
></FONT
></TD
></TR
></TABLE
><P
>Apply additional IPv6 related patches (still not in the vanilla kernel included) </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># make patch-o-matic KERNEL_DIR=/path/to/src/linux-version-iptables-version/ </PRE
></FONT
></TD
></TR
></TABLE
><P
>Say yes at following options (iptables-1.2.2) </P
><P
></P
><UL
><LI
><P
>ah-esp.patch </P
></LI
><LI
><P
>masq-dynaddr.patch (only needed for systems with dynamic IP assigned WAN connections like PPP or PPPoE) </P
></LI
><LI
><P
>ipv6-agr.patch.ipv6 </P
></LI
><LI
><P
>ipv6-ports.patch.ipv6 </P
></LI
><LI
><P
>LOG.patch.ipv6 </P
></LI
><LI
><P
>REJECT.patch.ipv6 </P
></LI
></UL
><P
>Check IPv6 extensions </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># make print-extensions 
Extensions found: IPv6:owner IPv6:limit IPv6:mac IPv6:multiport</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2174"
>18.2.4. Configure, build and install new kernel</A
></H3
><P
>Change to kernel sources </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># cd /path/to/src/linux-version-iptables-version/ </PRE
></FONT
></TD
></TR
></TABLE
><P
>Edit Makefile </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>- EXTRAVERSION = 
+ EXTRAVERSION = -iptables-version+IPv6-try </PRE
></FONT
></TD
></TR
></TABLE
><P
>Run configure, enable IPv6 related </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>            Code maturity level options 
                  Prompt for development and/or incomplete code/drivers : yes 
            Networking options 
                  Network packet filtering: yes 
                  The IPv6 protocol: module 
                       IPv6: Netfilter Configuration 
                             IP6 tables support: module 
                             All new options like following: 
                                   limit match support: module 
                                   MAC address match support: module 
                                   Multiple port match support: module 
                                   Owner match support: module 
                                   netfilter MARK match support: module 
                                   Aggregated address check: module 
                                   Packet filtering: module 
                                        REJECT target support: module 
                                        LOG target support: module 
                                   Packet mangling: module 
                                   MARK target support: module </PRE
></FONT
></TD
></TR
></TABLE
><P
>Configure other related to your system, too </P
><P
>Compilation and installing: see the kernel section here and other HOWTOs </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2184"
>18.2.5. Rebuild and install binaries of iptables</A
></H3
><P
>Make sure, that upper kernel source tree is also available at /usr/src/linux/ </P
><P
>Rename older directory </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># mv /usr/src/linux /usr/src/linux.old </PRE
></FONT
></TD
></TR
></TABLE
><P
>Create a new softlink </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ln -s /path/to/src/linux-version-iptables-version /usr/src/linux </PRE
></FONT
></TD
></TR
></TABLE
><P
>Rebuild SRPMS </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># rpm --rebuild /path/to/SRPMS/iptables-version-release.src.rpm </PRE
></FONT
></TD
></TR
></TABLE
><P
>Install new iptables packages (iptables + iptables-ipv6) </P
><P
></P
><UL
><LI
><P
>On RH 7.1 systems, normally, already an older version is installed, therefore use "freshen" </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># rpm -Fhv /path/to/RPMS/cpu/iptables*-version-release.cpu.rpm </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>If not already installed, use "install" </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># rpm -ihv /path/to/RPMS/cpu/iptables*-version-release.cpu.rpm </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>On RH 6.2 systems, normally, no kernel 2.4.x is installed, therefore the requirements don't fit. Use "--nodeps" to install it </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># rpm -ihv --nodeps /path/to/RPMS/cpu/iptables*-version-release.cpu.rpm </PRE
></FONT
></TD
></TR
></TABLE
><P
>Perhaps it's necessary to create a softlink for iptables libraries where iptables looks for them </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ln -s /lib/iptables/ /usr/lib/iptables </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2208"
>18.3. Usage</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2210"
>18.3.1. Check for support</A
></H3
><P
>Load module, if so compiled </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># modprobe ip6_tables </PRE
></FONT
></TD
></TR
></TABLE
><P
>Check for capability </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># [ ! -f /proc/net/ip6_tables_names ] &#38;&#38; echo "Current kernel doesn't support
¬ 'ip6tables' firewalling (IPv6)!" </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2216"
>18.3.2. Learn how to use ip6tables</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2218"
>18.3.2.1. List all IPv6 netfilter entries</A
></H4
><P
></P
><UL
><LI
><P
>Short </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -L </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Extended </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -n -v --line-numbers -L </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2228"
>18.3.2.2. List specified filter</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -n -v --line-numbers -L INPUT </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2231"
>18.3.2.3. Insert a log rule at the input filter with options</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables --table filter --append INPUT  -j LOG --log-prefix "INPUT:"
¬ --log-level 7 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2234"
>18.3.2.4. Insert a drop rule at the input filter</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables --table filter --append INPUT  -j DROP </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2237"
>18.3.2.5. Delete a rule by number</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables --table filter --delete INPUT 1 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2240"
>18.3.2.6. Enable connection tracking</A
></H4
><P
>Since kernel version 2.6.20 IPv6 connection tracking is well supported and should be used instead of using stateless filter rules.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2244"
>18.3.2.7. Allow ICMPv6</A
></H4
><P
>Using older kernels (unpatched kernel 2.4.5 and iptables-1.2.2) no type can be specified</P
><P
></P
><UL
><LI
><P
>Accept incoming ICMPv6 through tunnels </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A INPUT -i sit+ -p icmpv6 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Allow outgoing ICMPv6 through tunnels </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A OUTPUT -o sit+ -p icmpv6 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
>Newer kernels allow specifying of ICMPv6 types:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A INPUT -p icmpv6 --icmpv6-type echo-request -j ACCEPT</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2257"
>18.3.2.8. Rate-limiting</A
></H4
><P
>Because it can happen (author already saw it to times) that an ICMPv6 storm will raise up, you should use available rate limiting for at least ICMPv6 ruleset. In addition logging rules should also get rate limiting to prevent DoS attacks against syslog and storage of log file partition. An example for a rate limited ICMPv6 looks like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A INPUT --protocol icmpv6 --icmpv6-type echo-request
¬ -j ACCEPT --match limit --limit 30/minute</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2261"
>18.3.2.9. Allow incoming SSH</A
></H4
><P
>Here an example is shown for a ruleset which allows incoming SSH connection from a specified IPv6 address </P
><P
></P
><UL
><LI
><P
>Allow incoming SSH from 2001:0db8:100::1/128 </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A INPUT -i sit+ -p tcp -s 2001:0db8:100::1/128 --sport 512:65535
¬ --dport 22 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Allow response packets (no longer needed if connection tracking is used!) </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A OUTPUT -o sit+ -p tcp -d 2001:0db8:100::1/128 --dport 512:65535
¬ --sport 22 ! --syn -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2272"
>18.3.2.10. Enable tunneled IPv6-in-IPv4</A
></H4
><P
>To accept tunneled IPv6-in-IPv4 packets, you have to insert rules in your IPv4 firewall setup relating to such packets, for example </P
><P
></P
><UL
><LI
><P
>Accept incoming IPv6-in-IPv4 on interface ppp0 </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iptables -A INPUT -i ppp0 -p ipv6 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Allow outgoing IPv6-in-IPv4 to interface ppp0 </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iptables -A OUTPUT -o ppp0 -p ipv6 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
>If you have only a static tunnel, you can specify the IPv4 addresses, too, like </P
><P
></P
><UL
><LI
><P
>Accept incoming IPv6-in-IPv4 on interface ppp0 from tunnel endpoint 192.0.2.2</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iptables -A INPUT -i ppp0 -p ipv6 -s 192.0.2.2 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Allow outgoing IPv6-in-IPv4 to interface ppp0 to tunnel endpoint 1.2.3.4 </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iptables -A OUTPUT -o ppp0 -p ipv6 -d 192.0.2.2 -j ACCEPT </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2292"
>18.3.2.11. Protection against incoming TCP connection requests</A
></H4
><P
>VERY RECOMMENDED! For security issues you should really insert a rule which blocks incoming TCP connection requests. Adapt "-i" option, if other interface names are in use! </P
><P
></P
><UL
><LI
><P
>Block incoming TCP connection requests to this host </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -I INPUT -i sit+ -p tcp --syn -j DROP </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Block incoming TCP connection requests to hosts behind this router </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -I FORWARD -i sit+ -p tcp --syn -j DROP </PRE
></FONT
></TD
></TR
></TABLE
><P
>Perhaps the rules have to be placed below others, but that is work you have to think about it. Best way is to create a script and execute rules in a specified way. </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2304"
>18.3.2.12. Protection against incoming UDP connection requests</A
></H4
><P
>ALSO RECOMMENDED! Like mentioned on my firewall information it's possible to control the ports on outgoing UDP/TCP sessions. So if all of your local IPv6 systems are using local ports e.g. from 32768 to 60999 you are able to filter UDP connections also (until connection tracking works) like: </P
><P
></P
><UL
><LI
><P
>Block incoming UDP packets which cannot be responses of outgoing requests of this host </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -I INPUT -i sit+ -p udp ! --dport 32768:60999 -j DROP </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Block incoming UDP packets which cannot be responses of forwarded requests of hosts behind this router </P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -I FORWARD -i sit+ -p udp ! --dport 32768:60999 -j DROP </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2315"
>18.3.3. Examples</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2317"
>18.3.3.1. Simple example for Fedora</A
></H4
><P
>Following lines show a simple firewall configuration for Fedora 6 (since kernel version 2.6.20). It was modfied from the default one (generated by system-config-firewall) for supporting connection tracking and return the proper ICMPv6 code for rejects. Incoming SSH (port 22) connections are allowed.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>File: /etc/sysconfig/ip6tables

*filter :INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:RH-Firewall-1-INPUT - [0:0]
-A INPUT -j RH-Firewall-1-INPUT
-A FORWARD -j RH-Firewall-1-INPUT
-A RH-Firewall-1-INPUT -i lo -j ACCEPT
-A RH-Firewall-1-INPUT -p icmpv6 -j ACCEPT
-A RH-Firewall-1-INPUT -p 50 -j ACCEPT
-A RH-Firewall-1-INPUT -p 51 -j ACCEPT
-A RH-Firewall-1-INPUT -p udp --dport 5353 -d ff02::fb -j ACCEPT
-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT 
-A RH-Firewall-1-INPUT -p tcp -m tcp --dport 631 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -p tcp --dport 22 -j ACCEPT
-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp6-adm-prohibited
COMMIT </PRE
></FONT
></TD
></TR
></TABLE
><P
>For completeness also the IPv4 configuration is shown here:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>File: /etc/sysconfig/iptables

*filter :INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:RH-Firewall-1-INPUT - [0:0]
-A INPUT -j RH-Firewall-1-INPUT
-A FORWARD -j RH-Firewall-1-INPUT
-A RH-Firewall-1-INPUT -i lo -j ACCEPT
-A RH-Firewall-1-INPUT -p icmp --icmp-type any -j ACCEPT
-A RH-Firewall-1-INPUT -p 50 -j ACCEPT
-A RH-Firewall-1-INPUT -p 51 -j ACCEPT
-A RH-Firewall-1-INPUT -p udp --dport 5353 -d 224.0.0.251 -j ACCEPT
-A RH-Firewall-1-INPUT -p udp -m udp --dport 631 -j ACCEPT
-A RH-Firewall-1-INPUT -p tcp -m tcp --dport 631 -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
-A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT
-A RH-Firewall-1-INPUT -j REJECT --reject-with icmp-host-prohibited
COMMIT </PRE
></FONT
></TD
></TR
></TABLE
><P
>Usage:</P
><P
></P
><UL
><LI
><P
>Create/modify the configuration files</P
></LI
><LI
><P
>Activate IPv4 &#38; IPv6 firewalling</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># service iptables start
# service ip6tables start</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Enable automatic start after reboot</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># chkconfig iptables on
# chkconfig ip6tables on</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2334"
>18.3.3.2. Sophisticated example</A
></H4
><P
>Following lines show a more sophisticated but still stateless filter setup as an example. Happy netfilter6 ruleset creation.... </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -n -v -L 
Chain INPUT (policy DROP 0 packets, 0 bytes) 
 pkts bytes target     prot opt in     out     source               destination
    0     0 extIN      all      sit+   *       ::/0                 ::/0 
    4   384 intIN      all      eth0   *       ::/0                 ::/0 
    0     0 ACCEPT     all      *      *       ::1/128              ::1/128 
    0     0 ACCEPT     all      lo     *       ::/0                 ::/0 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `INPUT-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain FORWARD (policy DROP 0 packets, 0 bytes) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 int2ext    all      eth0   sit+    ::/0                 ::/0 
    0     0 ext2int    all      sit+   eth0    ::/0                 ::/0 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `FORWARD-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain OUTPUT (policy DROP 0 packets, 0 bytes) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 extOUT     all      *      sit+    ::/0                 ::/0 
    4   384 intOUT     all      *      eth0    ::/0                 ::/0 
    0     0 ACCEPT     all      *      *       ::1/128              ::1/128 
    0     0 ACCEPT     all      *      lo      ::/0                 ::/0 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `OUTPUT-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain ext2int (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     icmpv6    *      *       ::/0                 ::/0 
    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0       
¬        tcp spts:1:65535 dpts:1024:65535 flags:!0x16/0x02 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `ext2int-default:' 
    0     0 DROP       tcp      *      *       ::/0                 ::/0 
    0     0 DROP       udp      *      *       ::/0                 ::/0 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain extIN (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     tcp      *      *       3ffe:400:100::1/128  ::/0       
¬        tcp spts:512:65535 dpt:22 
    0     0 ACCEPT     tcp      *      *       3ffe:400:100::2/128  ::/0       
¬        tcp spts:512:65535 dpt:22 
    0     0 ACCEPT     icmpv6    *      *       ::/0                 ::/0 
    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0       
¬        tcp spts:1:65535 dpts:1024:65535 flags:!0x16/0x02 
    0     0 ACCEPT     udp      *      *       ::/0                 ::/0       
¬        udp spts:1:65535 dpts:1024:65535 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        limit: avg 5/min burst 5 LOG flags 0 level 7 prefix `extIN-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain extOUT (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     tcp      *      *       ::/0                
¬ 2001:0db8:100::1/128tcp spt:22 dpts:512:65535 flags:!0x16/0x02 
    0     0 ACCEPT     tcp      *      *       ::/0                
¬ 2001:0db8:100::2/128tcp spt:22 dpts:512:65535 flags:!0x16/0x02 
    0     0 ACCEPT     icmpv6    *      *       ::/0                 ::/0 
    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0       
¬        tcp spts:1024:65535 dpts:1:65535 
    0     0 ACCEPT     udp      *      *       ::/0                 ::/0       
¬        udp spts:1024:65535 dpts:1:65535 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `extOUT-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain int2ext (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     icmpv6    *      *       ::/0                 ::/0 
    0     0 ACCEPT     tcp      *      *       ::/0                 ::/0       
¬        tcp spts:1024:65535 dpts:1:65535 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `int2ext:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `int2ext-default:' 
    0     0 DROP       tcp      *      *       ::/0                 ::/0 
    0     0 DROP       udp      *      *       ::/0                 ::/0 
    0     0 DROP       all      *      *       ::/0                 ::/0 
 
Chain intIN (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     all      *      *       ::/0                
¬ fe80::/ffc0:: 
    4   384 ACCEPT     all      *      *       ::/0                 ff02::/16 
 
Chain intOUT (1 references) 
 pkts bytes target     prot opt in     out     source               destination
¬ 
    0     0 ACCEPT     all      *      *       ::/0                
¬ fe80::/ffc0:: 
    4   384 ACCEPT     all      *      *       ::/0                 ff02::/16 
    0     0 LOG        all      *      *       ::/0                 ::/0       
¬        LOG flags 0 level 7 prefix `intOUT-default:' 
    0     0 DROP       all      *      *       ::/0                 ::/0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-SECURITY"
></A
>Chapter 19. Security</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN2340"
>19.1. Node security</A
></H2
><P
>It's very recommended to apply all available patches and disable all not necessary services. Also bind services to the needed IPv4/IPv6 addresses only and install local firewalling.</P
><P
>More to be filled...</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2344"
>19.2. Access limitations</A
></H2
><P
>Many services uses the tcp_wrapper library for access control. Below is described the <A
HREF="#HINTS-DAEMONS-TCPWRAPPER"
>use of tcp_wrapper</A
>.</P
><P
>More to be filled...</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="IPV6-SECURITY-AUDITING"
>19.3. IPv6 security auditing</A
></H2
><P
>Currently there are no comfortable tools out which are able to check a system over network for IPv6 security issues. Neither <A
HREF="http://www.nessus.org/"
TARGET="_top"
>Nessus</A
> nor any commercial security scanner is as far as I know able to scan IPv6 addresses.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2353"
>19.3.1. Legal issues</A
></H3
><P
>ATTENTION: always take care that you only scan your own systems or after receiving a written order, otherwise legal issues are able to come up to you.
CHECK destination IPv6 addresses TWICE before starting a scan.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2356"
>19.3.2. Security auditing using IPv6-enabled netcat</A
></H3
><P
>With the IPv6-enabled netcat (see <A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-apps.html#security-auditing"
TARGET="_top"
>IPv6+Linux-status-apps/security-auditing</A
> for more) you can run a portscan by wrapping a script around which run through a port range, grab banners and so on. Usage example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># nc6 ::1 daytime
13 JUL 2002 11:22:22 CEST</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2361"
>19.3.3. Security auditing using IPv6-enabled nmap</A
></H3
><P
><A
HREF="http://www.insecure.org/nmap/"
TARGET="_top"
>NMap</A
>, one of the best portscaner around the world, supports IPv6 since version 3.10ALPHA1. Usage example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># nmap -6 -sT ::1
Starting nmap V. 3.10ALPHA3 ( www.insecure.org/nmap/ ) 
Interesting ports on localhost6 (::1): 
(The 1600 ports scanned but not shown below are in state: closed) 
Port       State       Service 
22/tcp     open        ssh 
53/tcp     open        domain 
515/tcp    open        printer 
2401/tcp   open        cvspserver
Nmap run completed -- 1 IP address (1 host up) scanned in 0.525 seconds</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2366"
>19.3.4. Security auditing using IPv6-enabled strobe</A
></H3
><P
>Strobe is a (compared to NMap) more a low budget portscanner, but there is an IPv6-enabling patch available (see <A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-apps.html#security-auditing"
TARGET="_top"
>IPv6+Linux-status-apps/security-auditing</A
> for more). Usage example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ./strobe ::1 strobe 1.05 (c) 1995-1999 Julian Assange &#60;proff@iq.org&#62;.
::1 2401 unassigned unknown
::1 22 ssh Secure Shell - RSA encrypted rsh 
::1 515 printer spooler (lpd)
::1 6010 unassigned unknown 
::1 53 domain Domain Name Server</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note: strobe isn't really developed further on, the shown version number isn't the right one.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2372"
>19.3.5. Audit results</A
></H3
><P
>If the result of an audit mismatch your IPv6 security policy, use IPv6 firewalling to close the holes, e.g. using netfilter6 (see <A
HREF="#FIREWALLING-NETFILTER6."
>Firewalling/Netfilter6</A
> for more).</P
><P
>Info: More detailed information concerning IPv6 Security can be found here: </P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/v6ops.html"
TARGET="_top"
>IETF drafts - IPv6 Operations (v6ops)</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3964.html"
TARGET="_top"
>RFC 3964 / Security Considerations for 6to4</A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-ENCRYPTION-AUTHENTICATION"
></A
>Chapter 20. Encryption and Authentication</H1
><P
>Unlike in IPv4, encryption and authentication is a mandatory feature of IPv6. Those features are normally implemented using IPsec (which can be also used by IPv4).</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2387"
>20.1. Modes of using encryption and authentication</A
></H2
><P
>Two modes of encryption and authentication of a connection are possible:</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2390"
>20.1.1. Transport mode</A
></H3
><P
>Transport mode is a real end-to-end connection mode. Here, only the payload (usually ICMP, TCP or UDP) is encrypted with their particular header, while the IP header is not encrypted (but usually included in authentication).</P
><P
>Using AES-128 for encryption and SHA1 for authentication, this mode decreases the MTU by 42 octets.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2394"
>20.1.2. Tunnel mode</A
></H3
><P
>Tunnel mode can be used either for end-to-end or for gateway-to-gateway connection modes. Here, the complete IP packet is being encrypted and gets a new IP header prepended, all together constituing a new IP packet (this mechanism is also known as "encapsulation")</P
><P
>This mode usually decreases the MTU by 40 octets from the MTU of transport mode. I.e. using AES-128 for encryption and SHA1 for authentication 82 octets less than the normal MTU.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2398"
>20.2. Support in kernel (ESP and AH)</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2400"
>20.2.1. Support in vanilla Linux kernel 2.4.x</A
></H3
><P
>At the time of writing missing in vanilla up to 2.4.28. There was an issue about keeping the Linux kernel source free of export/import-control-laws regarding encryption code. This is also one case why <A
HREF="http://www.freeswan.org/"
TARGET="_top"
>FreeS/WAN project</A
> wasn't included in vanilla source. Perhaps a backport from 2.6.x will be done in the future.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2404"
>20.2.2. Support in vanilla Linux kernel 2.6.x</A
></H3
><P
>Current versions (as time of writing 2.6.9 and upper) support native IPsec for IPv4 and IPv6.</P
><P
>Implementation was helped by the USAGI project.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2408"
>20.3. Automatic key exchange (IKE)</A
></H2
><P
>IPsec requires a key exchange of a secret. This is mostly done automatically by so called IKE daemons. They also handle the authentication of the peers, either by a common known secret (so called “pre-shared secret”) or by RSA keys (which can also be used from X.509 certificates).</P
><P
>Currently, two different IKE daemons are available for Linux, which totally differ in configuration and usage.</P
><P
>I prefer “pluto” from the *S/WAN implementation because of the easier and one-config-only setup.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2413"
>20.3.1. IKE daemon “racoon”</A
></H3
><P
>The IKE daemon “racoon” is taken from the KAME project and ported to Linux. Modern Linux distributions contain this daemon in the package “ipsec-tools”. Two executables are required for a proper IPsec setup. Take a look on <A
HREF="http://lartc.org/howto/lartc.ipsec.html"
TARGET="_top"
>Linux Advanced Routing &#38; Traffic Control HOWTO / IPSEC</A
>, too.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2417"
>20.3.1.1. Manipulation of the IPsec SA/SP database with the tool “setkey”</A
></H4
><P
>“setkey” is important to define the security policy (SP) for the kernel.</P
><P
>File: /etc/racoon/setkey.sh</P
><P
></P
><UL
><LI
><P
>Example for an end-to-end encrypted connection in transport mode</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>#!/sbin/setkey -f
flush;
spdflush;
spdadd 2001:db8:1:1::1 2001:db8:2:2::2 any -P out ipsec esp/transport//require;
spdadd 2001:db8:2:2::2 2001:db8:1:1::1 any -P in  ipsec esp/transport//require;&#13;</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
><UL
><LI
><P
>Example for a end-to-end encrypted connection in tunnel mode</P
></LI
></UL
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>#!/sbin/setkey -f
flush;
spdflush;
spdadd 2001:db8:1:1::1 2001:db8:2:2::2 any -P out ipsec
¬ esp/tunnel/2001:db8:1:1::1-2001:db8:2:2::2/require;
spdadd 2001:db8:2:2::2 2001:db8:1:1::1 any -P in  ipsec
¬ esp/tunnel/2001:db8:2:2::2-2001:db8:1:1::1/require;</PRE
></FONT
></TD
></TR
></TABLE
><P
>For the other peer, you have to replace “in” with “out”.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2430"
>20.3.1.2. Configuration of the IKE daemon “racoon”</A
></H4
><P
>“racoon” requires a configuration file for proper execution. It includes the related settings to the security policy, which should be set up previously using “setkey”.</P
><P
>File: /etc/racoon/racoon.conf</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># Racoon IKE daemon configuration file.
# See 'man racoon.conf' for a description of the format and entries.
path include "/etc/racoon";
path pre_shared_key "/etc/racoon/psk.txt";

listen
{
        isakmp 2001:db8:1:1::1;
}

remote 2001:db8:2:2::2
{
        exchange_mode main;
        lifetime time 24 hour;
        proposal
        {
                encryption_algorithm 3des;
                hash_algorithm md5;
                authentication_method pre_shared_key;
                dh_group 2;
        }
}

# gateway-to-gateway
sainfo address 2001:db8:1:1::1 any address 2001:db8:2:2::2 any
{
        lifetime time 1 hour;
        encryption_algorithm 3des;
        authentication_algorithm hmac_md5;
        compression_algorithm deflate;
}

sainfo address 2001:db8:2:2::2 any address 2001:db8:1:1::1 any
{
        lifetime time 1 hour;
        encryption_algorithm 3des;
        authentication_algorithm hmac_md5;
        compression_algorithm deflate;
} </PRE
></FONT
></TD
></TR
></TABLE
><P
>Also set up the pre-shared secret:</P
><P
>File: /etc/racoon/psk.txt</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># file for pre-shared keys used for IKE authentication
# format is: 'identifier' 'key'

2001:db8:2:2::2 verysecret </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2438"
>20.3.1.3. Running IPsec with IKE daemon “racoon”</A
></H4
><P
>At least the daemon needs to be started. For the first time, use debug and foreground mode. The following example shows a successful IKE phase 1 (ISAKMP-SA) and 2 (IPsec-SA) negotiation:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># racoon -F -v -f /etc/racoon/racoon.conf
Foreground mode. 
2005-01-01 20:30:15: INFO: @(#)ipsec-tools 0.3.3
¬ (http://ipsec-tools.sourceforge.net)
2005-01-01 20:30:15: INFO: @(#)This product linked
¬ OpenSSL 0.9.7a Feb 19 2003 (http://www.openssl.org/)
2005-01-01 20:30:15: INFO: 2001:db8:1:1::1[500] used as isakmp port (fd=7)
2005-01-01 20:31:06: INFO: IPsec-SA request for 2001:db8:2:2::2
¬ queued due to no phase1 found.
2005-01-01 20:31:06: INFO: initiate new phase 1 negotiation:
¬ 2001:db8:1:1::1[500]&#60;=&#62;2001:db8:2:2::2[500]
2005-01-01 20:31:06: INFO: begin Identity Protection mode.
2005-01-01 20:31:09: INFO: ISAKMP-SA established
¬ 2001:db8:1:1::1[500]-2001:db8:2:2::2[500] spi:da3d3693289c9698:ac039a402b2db401
2005-01-01 20:31:09: INFO: initiate new phase 2 negotiation:
¬ 2001:6f8:900:94::2[0]&#60;=&#62;2001:db8:2:2::2[0]
2005-01-01 20:31:10: INFO: IPsec-SA established:
¬ ESP/Tunnel 2001:db8:2:2::2-&#62;2001:db8:1:1::1 spi=253935531(0xf22bfab) 
2005-01-01 20:31:10: INFO: IPsec-SA established:
¬ ESP/Tunnel 2001:db8:1:1::1-&#62;2001:db8:2:2::2 spi=175002564(0xa6e53c4) </PRE
></FONT
></TD
></TR
></TABLE
><P
>Each direction got its own IPsec-SA (like defined in the IPsec standard). With “tcpdump” on the related interface, you will see as result of an IPv6 ping:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>20:35:55.305707 2001:db8:1:1::1 &#62; 2001:db8:2:2::2: ESP(spi=0x0a6e53c4,seq=0x3)
20:35:55.537522 2001:db8:2:2::2 &#62; 2001:db8:1:1::1: ESP(spi=0x0f22bfab,seq=0x3)</PRE
></FONT
></TD
></TR
></TABLE
><P
>As expected, the negotiated SPIs are being used here.</P
><P
>And using “setkey”, current active parameters are shown:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># setkey -D
2001:db8:1:1::1 2001:db8:2:2::2
        esp mode=tunnel spi=175002564(0x0a6e53c4) reqid=0(0x00000000)
        E: 3des-cbc  bd26bc45 aea0d249 ef9c6b89 7056080f 5d9fa49c 924e2edd
        A: hmac-md5  60c2c505 517dd8b7 c9609128 a5efc2db
        seq=0x00000000 replay=4 flags=0x00000000 state=mature
        created: Jan  1 20:31:10 2005   current: Jan  1 20:40:47 2005
        diff: 577(s)    hard: 3600(s)   soft: 2880(s)
        last: Jan  1 20:35:05 2005      hard: 0(s)      soft: 0(s)
        current: 540(bytes)     hard: 0(bytes)  soft: 0(bytes)
        allocated: 3    hard: 0 soft: 0
        sadb_seq=1 pid=22358 refcnt=0
2001:db8:2:2::2 2001:db8:1:1::1
        esp mode=tunnel spi=253935531(0x0f22bfab) reqid=0(0x00000000)
        E: 3des-cbc  c1ddba65 83debd62 3f6683c1 20e747ac 933d203f 4777a7ce
        A: hmac-md5  3f957db9 9adddc8c 44e5739d 3f53ca0e
        seq=0x00000000 replay=4 flags=0x00000000 state=mature
        created: Jan  1 20:31:10 2005   current: Jan  1 20:40:47 2005
        diff: 577(s)    hard: 3600(s)   soft: 2880(s)
        last: Jan  1 20:35:05 2005      hard: 0(s)      soft: 0(s)
        current: 312(bytes)     hard: 0(bytes)  soft: 0(bytes)
        allocated: 3    hard: 0 soft: 0
        sadb_seq=0 pid=22358 refcnt=0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2447"
>20.3.2. IKE daemon “pluto”</A
></H3
><P
>The IKE daemon “pluto” is included in distributions of the *S/WAN projects. *S/WAN project starts at the beginning as <A
HREF="http://www.freeswan.org/"
TARGET="_top"
>FreeS/WAN</A
>. Unfortunately, the FreeS/WAN project stopped further development in 2004. Because of the slow pace of development in the past, two spin-offs started: <A
HREF="http://www.strongswan.org/"
TARGET="_top"
>strongSwan</A
> and <A
HREF="http://www.openswan.org/"
TARGET="_top"
>Openswan</A
>. Today, readily installable packages are available for at least Openswan (included in Fedora Core 3).</P
><P
>A major difference to “racoon”, only one configuration file is required. Also, an initscript exists for automatic setup after booting.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2454"
>20.3.2.1. Configuration of the IKE daemon “pluto”</A
></H4
><P
>The configuration is very similar to the IPv4 one, only one important option is necessary.</P
><P
>File: /etc/ipsec.conf</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /etc/ipsec.conf - Openswan IPsec configuration file
#
# Manual:     ipsec.conf.5
version 2.0     # conforms to second version of ipsec.conf specification

# basic configuration
config setup
        # Debug-logging controls:  "none" for (almost) none, "all" for lots.
        # klipsdebug=none
        # plutodebug="control parsing"

#Disable Opportunistic Encryption
include /etc/ipsec.d/examples/no_oe.conf

conn ipv6-p1-p2
        connaddrfamily=ipv6       # Important for IPv6!
        left=2001:db8:1:1::1
        right=2001:db8:2:2::2
        authby=secret
        esp=aes128-sha1
        ike=aes128-sha-modp1024
        type=transport
        #type=tunnel
        compress=no
        #compress=yes
        auto=add
        #auto=start&#13;</PRE
></FONT
></TD
></TR
></TABLE
><P
>Don't forget to define the pre-shared secret here also.</P
><P
>File: /etc/ipsec.secrets</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>2001:db8:1:1::1 2001:db8:2:2::2 : PSK      "verysecret"</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2462"
>20.3.2.2. Running IPsec with IKE daemon “pluto”</A
></H4
><P
>If installation of Openswan was successfully, an initscript should exist for starting IPsec, simply run (on each peer):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /etc/rc.d/init.d/ipsec start</PRE
></FONT
></TD
></TR
></TABLE
><P
>Afterwards, start this connection on one peer. If you saw the line “IPsec SA established”, all worked fine.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ipsec auto --up ipv6-peer1-peer2
104 "ipv6-p1-p2" #1: STATE_MAIN_I1: initiate
106 "ipv6-p1-p2" #1: STATE_MAIN_I2: sent MI2, expecting MR2
108 "ipv6-p1-p2" #1: STATE_MAIN_I3: sent MI3, expecting MR3
004 "ipv6-p1-p2" #1: STATE_MAIN_I4: ISAKMP SA established
112 "ipv6-p1-p2" #2: STATE_QUICK_I1: initiate
004 "ipv6-p1-p2" #2: STATE_QUICK_I2: sent QI2,
¬ IPsec SA established {ESP=&#62;0xa98b7710 &#60;0xa51e1f22} </PRE
></FONT
></TD
></TR
></TABLE
><P
>Because *S/WAN and setkey/racoon do use the same IPsec implementation in Linux 2.6.x kernel, “setkey” can be used here too to show current active parameters:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># setkey -D
2001:db8:1:1::1 2001:db8:2:2::2
        esp mode=transport spi=2844489488(0xa98b7710) reqid=16385(0x00004001)
        E: aes-cbc  082ee274 2744bae5 7451da37 1162b483
        A: hmac-sha1  b7803753 757417da 477b1c1a 64070455 ab79082c
        seq=0x00000000 replay=64 flags=0x00000000 state=mature
        created: Jan  1 21:16:32 2005   current: Jan  1 21:22:20 2005
        diff: 348(s)    hard: 0(s)      soft: 0(s)
        last:                           hard: 0(s)      soft: 0(s)
        current: 0(bytes)       hard: 0(bytes)  soft: 0(bytes)
        allocated: 0    hard: 0 soft: 0
        sadb_seq=1 pid=23825 refcnt=0
2001:db8:2:2::2 2001:db8:1:1::1
        esp mode=transport spi=2770214690(0xa51e1f22) reqid=16385(0x00004001)
        E: aes-cbc  6f59cc30 8d856056 65e07b76 552cac18
        A: hmac-sha1  c7c7d82b abfca8b1 5440021f e0c3b335 975b508b
        seq=0x00000000 replay=64 flags=0x00000000 state=mature
        created: Jan  1 21:16:31 2005   current: Jan  1 21:22:20 2005
        diff: 349(s)    hard: 0(s)      soft: 0(s)
        last:                           hard: 0(s)      soft: 0(s)
        current: 0(bytes)       hard: 0(bytes)  soft: 0(bytes)
        allocated: 0    hard: 0 soft: 0
        sadb_seq=0 pid=23825 refcnt=0 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2470"
>20.4. Additional informations:</A
></H2
><P
>On Linux Kernel 2.6.x you can get the policy and status of IPsec also using “ip”:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip xfrm policy
...

# ip xfrm state
...</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-QOS"
></A
>Chapter 21. Quality of Service (QoS)</H1
><P
>IPv6 supports QoS with use of Flow Labels and Traffic Classes.</P
><P
>Additional infos:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3697.html"
TARGET="_top"
>RFC 3697 / IPv6 Flow Label Specification</A
></P
></LI
></UL
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2482"
>21.1. General</A
></H2
><P
>Proper working QoS is only possible on the outgoing interface of a router or host, where the bottleneck begins. Everything else is a hickup and not subject to work as expected or has a successful result.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>--------------&#62;-------
           Queue 1    \
           ---&#62;---     ----&#62;---------&#62;---------&#62;---------------
Big pipe   Queue 2      Queue 1 / Queue 2 / Queue 3   Thin Pipe
           ---&#62;----    ----&#62;---------&#62;---------&#62;---------------
           Queue 3    /
--------------&#62;-------</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN2486"
>21.2. Linux QoS using “tc”</A
></H2
><P
>Linux is using “tc” from the “iproute2” package to configure traffic shaping, generally described in the <A
HREF="http://lartc.org/"
TARGET="_top"
>Linux Advanced Routing &#38; Traffic Control HOWTO</A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2490"
>21.2.1. Example for a constant bitrate queuing</A
></H3
><P
>With the “cbq” scheduler, pipes with constant bit rates can be defined.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2493"
>21.2.1.1. Root qdisc definition</A
></H4
><P
>Define root qdisc with a bandwidth of 1000 MBit/s on eth1</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc qdisc add dev eth1 root handle 1: cbq avpkt 1000 bandwidth 1000Mbit</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2497"
>21.2.1.2. QoS class definition</A
></H4
><P
>Define a class 1:1 with 1 MBit/s</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc class add dev eth1 parent 1: classid 1:1 cbq rate   1Mbit allot 1500 bounded </PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a class 1:2 with 50 MBit/s</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc class add dev eth1 parent 1: classid 1:2 cbq rate  50Mbit allot 1500 bounded</PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a class 1:3 with 10 MBit/s</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc class add dev eth1 parent 1: classid 1:3 cbq rate  10Mbit allot 1500 bounded</PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a class 1:4 with 200 kBit/s</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc class add dev eth1 parent 1: classid 1:4 cbq rate 200kbit allot 1500 bounded</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2507"
>21.2.1.3. QoS filter definition</A
></H4
><P
>Define a filter for IPv4 (<EM
>protocol ip</EM
>), TCP (<EM
>match ip protocol 6 0xff</EM
>) destination port 5001 (<EM
>match ip dport 5001 0xffff</EM
>) using class 1:2 from above</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc filter add dev eth1 parent 1: protocol ip   u32 match ip  protocol 6 0xff match ip dport 5001 0xffff flowid 1:1</PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a filter for IPv6 (<EM
>protocol ip</EM
>), TCP (<EM
>match ip6 protocol 6 0xff</EM
>) destination port 5001 using class 1:2 from above</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc filter add dev eth1 parent 1: protocol ipv6 u32 match ip6 protocol 6 0xff match ip6 dport 5001 0xffff flowid 1:2</PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a filter for IPv6 for packets having flow label 12345 (<EM
>match ip6 flowlabel 12345 0x3ffff</EM
>) using class 1:3 from above</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc filter add dev eth1 parent 1: protocol ipv6 u32 match ip6 flowlabel 12345 0x3ffff flowid 1:3 </PRE
></FONT
></TD
></TR
></TABLE
><P
>Define a filter for IPv6 for packets having Linux iptables mark 32 (<EM
>handle 32 fw</EM
>) specified using class 1:4 from above</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># tc filter add dev eth1 parent 1: protocol ipv6 handle 32 fw flowid 1:4</PRE
></FONT
></TD
></TR
></TABLE
><P
>The last filter definition requires an entry in the ip6tables to mark a packet</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip6tables -A POSTROUTING -t mangle -p tcp --dport 5003 -j MARK --set-mark 32 </PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2526"
>21.2.1.4. Testing filter definitions using iperf</A
></H4
><P
>Start on server side each one one separate console:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iperf -V -s -p 5001
# iperf -V -s -p 5002
# iperf -V -s -p 5003</PRE
></FONT
></TD
></TR
></TABLE
><P
>Start on client side and compare results:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># iperf -V -c SERVER-IPv4 -p 5001    (expected:      1 MBit/s)
# iperf -V -c SERVER-IPv6 -p 5001    (expected:     50 MBit/s)
# iperf -V -c SERVER-IPv4 -p 5002    (expected:  &#62;&#62; 50 MBit/s &#38;&#38; &#60;= 1000 MBit/s)
# iperf -V -c SERVER-IPv6 -p 5002    (expected:  &#62;&#62; 50 MBit/s &#38;&#38; &#60;= 1000 MBit/s)
# iperf -V -c SERVER-IPv4 -p 5003    (expected:  &#62;&#62; 50 MBit/s &#38;&#38; &#60;= 1000 MBit/s)
# iperf -V -c SERVER-IPv6 -p 5003    (expected:    200 kBit/s)</PRE
></FONT
></TD
></TR
></TABLE
><P
>The rate result should be as defined in the classes (see above), the results on port 5002 should be very similar independend from used IP version.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-HINTS-DAEMONS"
></A
>Chapter 22. Hints for IPv6-enabled daemons</H1
><P
>Here some hints are shown for IPv6-enabled daemons.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-BIND"
>22.1. Berkeley Internet Name Domain (BIND) daemon “named”</A
></H2
><P
>IPv6 is supported since version 9. Always use newest available version. At least version 9.1.3 must be used, older versions can contain remote exploitable security holes.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2539"
>22.1.1. Listening on IPv6 addresses</A
></H3
><P
>Note: unlike in IPv4 current versions doesn't allow to bind a server socket to dedicated IPv6 addresses, so only <EM
>any</EM
> or <EM
>none</EM
> are valid. Because this can be a security issue, check the Access Control List (ACL) section below, too!</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2544"
>22.1.1.1. Enable BIND named for listening on IPv6 address</A
></H4
><P
>To enable IPv6 for listening, following options are requested to change</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>options {
        # sure other options here, too
        listen-on-v6 { any; };
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>This should result after restart in e.g.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># netstat -lnptu |grep "named\W*$" 
tcp 0 0 :::53         :::*      LISTEN 1234/named
¬ # incoming TCP requests
udp 0 0 1.2.3.4:53    0.0.0.0:*        1234/named
¬ # incoming UDP requests to IPv4 1.2.3.4
udp 0 0 127.0.0.1:53  0.0.0.0:*        1234/named
¬ # incoming UDP requests to IPv4 localhost
udp 0 0 0.0.0.0:32868 0.0.0.0:*        1234/named
¬ # dynamic chosen port for outgoing queries
udp 0 0 :::53         :::*             1234/named
¬ # incoming UDP request to any IPv6</PRE
></FONT
></TD
></TR
></TABLE
><P
>And a simple test looks like</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># dig localhost @::1</PRE
></FONT
></TD
></TR
></TABLE
><P
>and should show you a result.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2553"
>22.1.1.2. Disable BIND named for listening on IPv6 address</A
></H4
><P
>To disable IPv6 for listening, following options are requested to change</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>options {
        # sure other options here, too
        listen-on-v6 { none; };
};</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2557"
>22.1.2. IPv6 enabled Access Control Lists (ACL)</A
></H3
><P
>IPv6 enabled ACLs are possible and should be used whenever it's possible. An example looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>acl internal-net { 
        127.0.0.1; 
        1.2.3.0/24;  
        2001:0db8:100::/56; 
        ::1/128; 
        ::ffff:1.2.3.4/128; 
};
acl ns-internal-net { 
        1.2.3.4;  
        1.2.3.5;  
        2001:0db8:100::4/128; 
        2001:0db8:100::5/128; 
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>This ACLs can be used e.g. for queries of clients and transfer zones to secondary name-servers. This prevents also your caching name-server to be used from outside using IPv6.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>options {
        # sure other options here, too
        listen-on-v6 { none; };
        allow-query { internal-net; }; 
        allow-transfer { ns-internal-net; }; 
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>It's also possible to set the <EM
>allow-query </EM
>and <EM
>allow-transfer</EM
> option for most of single zone definitions, too.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2566"
>22.1.3. Sending queries with dedicated IPv6 address</A
></H3
><P
>This option is not required, but perhaps needed:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>query-source-v6 address &#60;ipv6address|*&#62; port &#60;port|*&#62;;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2570"
>22.1.4. Per zone defined dedicated IPv6 addresses</A
></H3
><P
>It's also possible to define per zone some IPv6 addresses.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2573"
>22.1.4.1. Transfer source address</A
></H4
><P
>Transfer source address is used for outgoing zone transfers:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>transfer-source-v6 &#60;ipv6addr|*&#62; [port port];</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2577"
>22.1.4.2. Notify source address</A
></H4
><P
>Notify source address is used for outgoing notify messages:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>notify-source-v6 &#60;ipv6addr|*&#62; [port port];</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2581"
>22.1.5. IPv6 DNS zone files examples</A
></H3
><P
>Some information can be also found at <A
HREF="http://www.isi.edu/~bmanning/v6DNS.html"
TARGET="_top"
>IPv6 DNS Setup Information (article)</A
>. Perhaps also helpful is the <A
HREF="http://tools.fpsn.net/ipv6-inaddr/"
TARGET="_top"
>IPv6 Reverse DNS zone builder for BIND 8/9 (webtool)</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2586"
>22.1.6. Serving IPv6 related DNS data</A
></H3
><P
>For IPv6 new types and root zones for reverse lookups are defined:</P
><P
></P
><UL
><LI
><P
>AAAA and reverse IP6.INT: specified in <A
HREF="http://www.faqs.org/rfcs/rfc1886.html"
TARGET="_top"
>RFC 1886 / DNS Extensions to support IP version 6</A
>, usable since BIND version 4.9.6</P
></LI
><LI
><P
>A6, DNAME (DEPRECATED NOW!) and reverse IP6.ARPA: specified in <A
HREF="http://www.faqs.org/rfcs/rfc2874.html"
TARGET="_top"
>RFC 2874 / DNS Extensions to Support IPv6 Address Aggregation and Renumbering</A
>, usable since BIND 9, but see also an information about the current state at <A
HREF="http://www.ietf.org/ids.by.wg/dnsext.html"
TARGET="_top"
>Domain Name System Extension (dnsext)</A
></P
></LI
></UL
><P
>Perhaps filled later more content, for the meantime take a look at given RFCs and</P
><P
></P
><UL
><LI
><P
>AAAA and reverse IP6.INT: <A
HREF="http://www.isi.edu/~bmanning/v6DNS.html"
TARGET="_top"
>IPv6 DNS Setup Information</A
></P
></LI
><LI
><P
>A6, DNAME (DEPRECATED NOW!) and reverse IP6.ARPA: take a look into chapter 4 and 6 of the BIND 9 Administrator Reference Manual (ARM) distributed with the bind-package or get this here: <A
HREF="http://www.isc.org/sw/bind/arm93/"
TARGET="_top"
>BIND manual version 9.3</A
></P
></LI
></UL
><P
>Because IP6.INT is deprecated (but still in use), a DNS server which will support IPv6 information has to serve both reverse zones.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2606"
>22.1.6.1. Current best practice</A
></H4
><P
>Because there are some troubles around using the new formats, current best practice is:</P
><P
>Forward lookup support:</P
><P
></P
><UL
><LI
><P
>AAAA</P
></LI
></UL
><P
>Reverse lookup support:</P
><P
></P
><UL
><LI
><P
>Reverse nibble format for zone ip6.int (FOR BACKWARD COMPATIBILITY)</P
></LI
><LI
><P
>Reverse nibble format for zone ip6.arpa (RECOMMENDED)</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2619"
>22.1.7. Checking IPv6-enabled connect</A
></H3
><P
>To check, whether BIND named is listening on an IPv6 socket and serving data see following examples.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2622"
>22.1.7.1. IPv6 connect, but denied by ACL</A
></H4
><P
>Specifying a dedicated server for the query, an IPv6 connect can be forced:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ host -t aaaa www.6bone.net 2001:0db8:200:f101::1 
Using domain server: 
Name: 2001:0db8:200:f101::1 
Address: 2001:0db8:200:f101::1#53 
Aliases:

Host www.6bone.net. not found: 5(REFUSED)</PRE
></FONT
></TD
></TR
></TABLE
><P
>Related log entry looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jan 3 12:43:32 gate named[12347]: client
¬ 2001:0db8:200:f101:212:34ff:fe12:3456#32770: 
 query denied</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you see such entries in the log, check whether requests from this client should be allowed and perhaps review your ACL configuration.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2629"
>22.1.7.2. Successful IPv6 connect</A
></H4
><P
>A successful IPv6 connect looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ host -t aaaa www.6bone.net 2001:0db8:200:f101::1 
Using domain server: 
Name: 2001:0db8:200:f101::1 
Address: 2001:0db8:200:f101::1#53 
Aliases:

www.6bone.net. is an alias for 6bone.net. 
6bone.net. has AAAA address 3ffe:b00:c18:1::10</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-XINETD"
>22.2. Internet super daemon (xinetd)</A
></H2
><P
>IPv6 is supported since <A
HREF="http://www.xinetd.org/"
TARGET="_top"
>xinetd</A
> version around 1.8.9. Always use newest available version. At least version 2.3.3 must be used, older versions can contain remote exploitable security holes.</P
><P
>Some Linux distribution contain an extra package for the IPv6 enabled xinetd, some others start the IPv6-enabled xinetd if following variable is set: NETWORKING_IPV6="yes", mostly done by /etc/sysconfig/network (only valid for Red Hat like distributions). In newer releases, one binary supports IPv4 and IPv6.</P
><P
>If you enable a built-in service like e.g. daytime by modifying the configuration file in /etc/xinetd.d/daytime like</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># diff -u /etc/xinetd.d/daytime.orig /etc/xinetd.d/daytime 
--- /etc/xinetd.d/daytime.orig Sun Dec 16 19:00:14 2001 
+++ /etc/xinetd.d/daytime Sun Dec 16 19:00:22 2001 
@@ -10,5 +10,5 @@ 
        protocol = tcp 
        user = root 
        wait = no 
-       disable = yes 
+       disable = no 
 }</PRE
></FONT
></TD
></TR
></TABLE
><P
>After restarting the xinetd you should get a positive result like:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># netstat -lnptu -A inet6 |grep "xinetd*" 
tcp 0 0 ::ffff:192.168.1.1:993  :::*  LISTEN  12345/xinetd-ipv6 
tcp 0 0 :::13                   :::*  LISTEN  12345/xinetd-ipv6 &#60;- service
¬ daytime/tcp
tcp 0 0 ::ffff:192.168.1.1:143  :::*  LISTEN  12345/xinetd-ipv6</PRE
></FONT
></TD
></TR
></TABLE
><P
>Shown example also displays an IMAP and IMAP-SSL IPv4-only listening xinetd.</P
><P
>Note: earlier versions had a problem that an IPv4-only xinetd won't start on an IPv6-enabled node and also the IPv6-enabled xinetd won't start on an IPv4-only node. This is known to be fixed in later versions, at least version 2.3.11.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-APACHE2."
>22.3. Webserver Apache2 (httpd2)</A
></H2
><P
>Apache web server supports IPv6 native by maintainers since 2.0.14. Available patches for the older 1.3.x series are not current and shouldn't be used in public environment, but available at <A
HREF="ftp://ftp.kame.net/pub/kame/misc/"
TARGET="_top"
>KAME / Misc</A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2648"
>22.3.1. Listening on IPv6 addresses</A
></H3
><P
>Note: virtual hosts on IPv6 addresses are broken in versions until 2.0.28 (a patch is available for 2.0.28). But always try latest available version first because earlier versions had some security issues.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2651"
>22.3.1.1. Virtual host listen on an IPv6 address only</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Listen [2001:0db8:100::1]:80
&#60;VirtualHost [2001:0db8:100::1]:80&#62;
        ServerName ipv6only.yourdomain.yourtopleveldomain
        # ...sure more config lines
&#60;/VirtualHost&#62;</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2654"
>22.3.1.2. Virtual host listen on an IPv6 and on an IPv4 address</A
></H4
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Listen [2001:0db8:100::2]:80 
Listen 1.2.3.4:80
&#60;VirtualHost [2001:0db8:100::2]:80 1.2.3.4:80&#62;
        ServerName ipv6andipv4.yourdomain.yourtopleveldomain
        # ...sure more config lines
&#60;/VirtualHost&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>This should result after restart in e.g.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># netstat -lnptu |grep "httpd2\W*$" 
tcp 0 0 1.2.3.4:80          0.0.0.0:* LISTEN 12345/httpd2 
tcp 0 0 2001:0db8:100::1:80 :::*      LISTEN 12345/httpd2 
tcp 0 0 2001:0db8:100::2:80 :::*      LISTEN 12345/httpd2</PRE
></FONT
></TD
></TR
></TABLE
><P
>For simple tests use the telnet example already shown.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2660"
>22.3.1.3. Additional notes</A
></H4
><P
></P
><UL
><LI
><P
>Apache2 supports a method called “sendfile” to speedup serving data. Some NIC drivers also support offline checksumming. In some cases, this can lead to connection problems and invalid TCP checksums. In this cases, disable “sendfile” either by recompiling using configure option “--without-sendfile” or by using the "EnableSendfile off" directive in configuration file.</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-RADVD"
>22.4. Router Advertisement Daemon (radvd)</A
></H2
><P
>The router advertisement daemon is very useful on a LAN, if clients should be auto-configured. The daemon itself should run on the Linux default IPv6 gateway router (it's not required that this is also the default IPv4 gateway, so pay attention who on your LAN is sending router advertisements). </P
><P
>You can specify some information and flags which should be contained in the advertisement. Common used are</P
><P
></P
><UL
><LI
><P
>Prefix (needed)</P
></LI
><LI
><P
>Lifetime of the prefix</P
></LI
><LI
><P
>Frequency of sending advertisements (optional)</P
></LI
></UL
><P
>After a proper configuration, the daemon sends advertisements through specified interfaces and clients are hopefully receive them and auto-magically configure addresses with received prefix and the default route.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2677"
>22.4.1. Configuring radvd</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2679"
>22.4.1.1. Simple configuration</A
></H4
><P
>Radvd's config file is normally /etc/radvd.conf. An simple example looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>interface eth0 { 
        AdvSendAdvert on;
        MinRtrAdvInterval 3; 
        MaxRtrAdvInterval 10;
        prefix 2001:0db8:0100:f101::/64 { 
                AdvOnLink on; 
                AdvAutonomous on; 
                AdvRouterAddr on; 
        };
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>This results on client side in</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ip -6 addr show eth0 
3: eth0: &#60;BROADCAST,MULTICAST,UP&#62; mtu 1500 qdisc pfifo_fast qlen 100 
    inet6 2001:0db8:100:f101:2e0:12ff:fe34:1234/64 scope global dynamic 
       valid_lft 2591992sec preferred_lft 604792sec 
    inet6 fe80::2e0:12ff:fe34:1234/10 scope link</PRE
></FONT
></TD
></TR
></TABLE
><P
>Because no lifetime was defined, a very high value was used.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2686"
>22.4.1.2. Special 6to4 configuration</A
></H4
><P
>Version since 0.6.2pl3 support the automatic (re)-generation of the prefix depending on an IPv4 address of a specified interface. This can be used to distribute advertisements in a LAN after the 6to4 tunneling has changed. Mostly used behind a dynamic dial-on-demand Linux router. Because of the sure shorter lifetime of such prefix (after each dial-up, another prefix is valid), the lifetime configured to minimal values:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>interface eth0 { 
        AdvSendAdvert on;
        MinRtrAdvInterval 3; 
        MaxRtrAdvInterval 10;
        prefix 0:0:0:f101::/64 { 
                AdvOnLink off; 
                AdvAutonomous on; 
                AdvRouterAddr on; 
                Base6to4Interface ppp0;
                AdvPreferredLifetime 20; 
                AdvValidLifetime 30;
        };
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>This results on client side in (assuming, ppp0 has currently 1.2.3.4 as local IPv4 address):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 addr show eth0 
3: eth0: &#60;BROADCAST,MULTICAST,UP&#62; mtu 1500 qdisc pfifo_fast qlen 100 
   inet6 2002:0102:0304:f101:2e0:12ff:fe34:1234/64 scope global dynamic 
      valid_lft 22sec preferred_lft 12sec
   inet6 fe80::2e0:12ff:fe34:1234/10 scope link</PRE
></FONT
></TD
></TR
></TABLE
><P
>Because a small lifetime was defined, such prefix will be thrown away quickly, if no related advertisement was received.</P
><P
>Additional note: if you do not used special 6to4 support in initscripts, you have to setup a special route on the internal interface on the router, otherwise you will get some backrouting problems. for the example showh here:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /sbin/ip -6 route add 2002:0102:0304:f101::/64 dev eth0 metric 1</PRE
></FONT
></TD
></TR
></TABLE
><P
>This route needs to be replaced every time the prefix changes, which is the case after a new IPv4 address was assigned to the dial-up interface.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2696"
>22.4.2. Debugging</A
></H3
><P
>A program called “radvdump” can help you looking into sent or received advertisements. Simple to use:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># radvdump 
Router advertisement from fe80::280:c8ff:feb9:cef9 (hoplimit 255) 
        AdvCurHopLimit: 64 
        AdvManagedFlag: off 
        AdvOtherConfigFlag: off 
        AdvHomeAgentFlag: off 
        AdvReachableTime: 0 
        AdvRetransTimer: 0 
        Prefix 2002:0102:0304:f101::/64 
                AdvValidLifetime: 30 
                AdvPreferredLifetime: 20 
                AdvOnLink: off 
                AdvAutonomous: on 
                AdvRouterAddr: on 
        Prefix 2001:0db8:100:f101::/64 
                AdvValidLifetime: 2592000 
                AdvPreferredLifetime: 604800 
                AdvOnLink: on 
                AdvAutonomous: on 
                AdvRouterAddr: on 
        AdvSourceLLAddress: 00 80 12 34 56 78</PRE
></FONT
></TD
></TR
></TABLE
><P
>Output shows you each advertisement package in readable format. You should see your configured values here again, if not, perhaps it's not your radvd which sends the advertisement...look for another router on the link (and take the LLAddress, which is the MAC address for tracing).</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-DHCPV6."
>22.5. Dynamic Host Configuration v6 Server (dhcp6s)</A
></H2
><P
>DHCPv6 can be used for stateful configurations. The daemon itself need not necessary run on the Linux default IPv6 gateway router. </P
><P
>You can specify more information than by using radvd. The are most similar to IPv4 DHCP server.</P
><P
>After a proper configuration, the daemon reacts on received ICMPv6 multicast packets sent by a client to address ff02::1:2</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2706"
>22.5.1. Configuration of the DHCPv6 server (dhcp6s)</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2708"
>22.5.1.1. Simple configuration</A
></H4
><P
>dhcp6s's config file is normally /etc/dhcp6s.conf. An simple example looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>interface eth0 {
        server-preference 255;
        renew-time 60;
        rebind-time 90;
        prefer-life-time 130;
        valid-life-time 200;
        allow rapid-commit;
        option dns_servers 2001:db8:0:f101::1 sub.domain.example;
        link AAA {
                range 2001:db8:0:f101::1000 to 2001:db8:0:f101::ffff/64;
                prefix 2001:db8:0:f101::/64;
        };
};</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2712"
>22.5.2. Configuration of the DHCPv6 client (dhcp6c)</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2714"
>22.5.2.1. Simple configuration</A
></H4
><P
>dhcp6c's config file is normally /etc/dhcp6c.conf. An simple example looks like following:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>interface eth0 {
        send rapid-commit;
        request domain-name-servers;
}; </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2718"
>22.5.3. Usage</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2720"
>22.5.3.1. dhcpv6_server</A
></H4
><P
>Start server, e.g.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># service dhcp6s start</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2724"
>22.5.3.2. dhcpv6_client</A
></H4
><P
>Start client in foreground, e.g.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># dhcp6c -f eth0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2728"
>22.5.4. Debugging</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2730"
>22.5.4.1. dhcpv6_server</A
></H4
><P
>The server has one foreground and two debug toggles (both should be used for debugging), here is an example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># dhcp6s -d -D -f eth0</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2734"
>22.5.4.2. dhcpv6_client</A
></H4
><P
>As general debugging for test whether the IPv6 DHCP server is reable on the link use an IPv6 ping to the DHCP multicast address:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># ping6 -I eth0 ff02::1:2</PRE
></FONT
></TD
></TR
></TABLE
><P
>The client has one foreground and two debug toggles, here is an example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># dhcp6c -d -f eth0
Oct/03/2005 17:18:16 dhcpv6 doesn't support hardware type 776 
Oct/03/2005 17:18:16 doesn't support sit0 address family 0 
Oct/03/2005 17:18:16 netlink_recv_rtgenmsg error 
Oct/03/2005 17:18:16 netlink_recv_rtgenmsg error 
Oct/03/2005 17:18:17 status code for this address is: success 
Oct/03/2005 17:18:17 status code: success 
Oct/03/2005 17:18:17 netlink_recv_rtgenmsg error 
Oct/03/2005 17:18:17 netlink_recv_rtgenmsg error 
Oct/03/2005 17:18:17 assigned address 2001:db8:0:f101::1002 prefix len is not
¬ in any RAs prefix length using 64 bit instead 
Oct/03/2005 17:18:17 renew time 60, rebind time 9</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the netlink error messages have no impact.</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-ISC-DHCP"
>22.6. ISC Dynamic Host Configuration Server (dhcpd)</A
></H2
><P
>ISC DHCP supports IPv6 since version 4.x.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2744"
>22.6.1. Configuration of the ISC DHCP server for IPv6 (dhcpd)</A
></H3
><P
>Note that currently, the ISC DHCP server can only serve IPv4 or IPv6, means you have to start the daemon twice (for IPv6 with option “-6”) to support both protocols.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2747"
>22.6.1.1. Simple configuration</A
></H4
><P
>Create a dedicated configuration file /etc/dhcp/dhcpd6.conf for the IPv6 part of the dhcpd. Note, that the router requires to have a interface configured with an IPv6 address out of the defined subnet.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>default-lease-time 600;
max-lease-time 7200; 
log-facility local7; 
subnet6 2001:db8:0:1::/64 {
        # Range for clients
        range6 2001:db8:0:1::129 2001:db8:0:1::254;
        # Additional options
        option dhcp6.name-servers fec0:0:0:1::1;
        option dhcp6.domain-search "domain.example";
        # Prefix range for delegation to sub-routers
        prefix6 2001:db8:0:100:: 2001:db8:0:f00:: /56;
        # Example for a fixed host address
        host specialclient {
    		host-identifier option dhcp6.client-id 00:01:00:01:4a:1f:ba:e3:60:b9:1f:01:23:45;
        	fixed-address6 2001:db8:0:1::127;
    	} 
} </PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the “dhcp.client-id” no longer belongs to a MAC address, an unique ID is used instead! “dhcp6c” (see above) uses the file /var/lib/dhcpv6/dhcp6c_duid (would be created during first start, if not existing) as unique identity. It's a 14 byte long identifier, starting with a 2 byte length information (usually “0x000e”):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># hexdump -e '"%07.7_ax " 1/2 "%04x" " " 14/1 "%02x:" "\n"' /var/lib/dhcpv6/dhcp6c_duid 0000000 000e 00:01:00:01:4a:1f:ba:e3:60:b9:1f:01:23:45:</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2753"
>22.6.2. Usage</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2755"
>22.6.2.1. dhcpd</A
></H4
><P
>Start server in foreground:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># /usr/sbin/dhcpd -6 -f -cf /etc/dhcp/dhcpd.conf eth1 
Internet Systems Consortium DHCP Server 4.1.0 
Copyright 2004-2008 Internet Systems Consortium. 
All rights reserved. 
For info, please visit http://www.isc.org/sw/dhcp/ 
Not searching LDAP since ldap-server, ldap-port and ldap-base-dn were not specified in the config file 
Wrote 0 leases to leases file. 
Bound to *:547 
Listening on Socket/5/eth1/2001:db8:0:1::/64 
Sending on   Socket/5/eth1/2001:db8:0:1::/64</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-DIBBLER"
>22.7. DHCP Server Dibbler</A
></H2
><P
>Dibbler is also a DHCP server</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2762"
>22.7.1. Configuration of the Dibbler DHCP server for IPv6</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2764"
>22.7.1.1. Simple configuration</A
></H4
><P
>Create a dedicated configuration file /etc/dibbler/server.conf . Note, that the router requires to have a interface configured with an IPv6 address out of the defined subnet.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>log-level 8 
log-mode short 
preference 0 
iface "eth1" {
 // also ranges can be defines, instead of exact values  t1 1800-2000  t2 2700-3000
  prefered-lifetime 3600
  valid-lifetime 7200
  class {
    pool 2001:6f8:12d8:1::/64
  }
  option dns-server fec0:0:0:1::1
  option domain domain.example
} </PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2768"
>22.7.2. Usage</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN2770"
>22.7.2.1. dibbler-server</A
></H4
><P
>Start server in foreground:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
># dibbler-server run 
| Dibbler - a portable DHCPv6, version 0.7.3 (SERVER, Linux port) 
| Authors : Tomasz Mrugalski&#60;thomson(at)klub.com.pl&#62;,Marek Senderski&#60;msend(at)o2.pl&#62; 
| Licence : GNU GPL v2 only. Developed at Gdansk University of Technology. 
| Homepage: http://klub.com.pl/dhcpv6/ 
2009.05.28 10:18:48 Server Notice    My pid (1789) is stored in /var/lib/dibbler/server.pid 
2009.05.28 10:18:48 Server Notice    Detected iface eth0/3, MAC=54:52:00:01:23:45. 
2009.05.28 10:18:48 Server Notice    Detected iface eth1/2, MAC=54:52:00:67:89:ab. 
2009.05.28 10:18:48 Server Notice    Detected iface lo/1, MAC=00:00:00:00:00:00. 
2009.05.28 10:18:48 Server Debug     Skipping database loading. 
2009.05.28 10:18:48 Server Debug     Cache:server-cache.xml file: parsing started, expecting 0 entries. 
2009.05.28 10:18:48 Server Notice    Parsing /etc/dibbler/server.conf config file... 
18:48 Server Debug     Setting 0 generic option(s). 
18:48 Server Debug     0 per-client configurations (exceptions) added. 
18:48 Server Debug     Parsing /etc/dibbler/server.conf done. 
18:48 Server Info      0 client class(es) defined. 
18:48 Server Debug     1 interface(s) specified in /etc/dibbler/server.conf 
18:48 Server Info      Mapping allow, deny list to class 0:0 allow/deny entries in total. 
18:48 Server Info      Interface eth1/2 configuration has been loaded. 
18:48 Server Notice    Running in stateful mode. 
18:48 Server Info      My DUID is 00:01:00:01:11:aa:6d:a7:54:52:00:67:89:ab. 
18:48 Server Notice    Creating multicast (ff02::1:2) socket on eth1/2 (eth1/2) interface. 
18:48 Server Debug     Cache: size set to 1048576 bytes, 1 cache entry size is 87 bytes, so maximum 12052 address-client pair(s) may be cached. 
18:48 Server Notice    Accepting connections. Next event in 4294967295 second(s).</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-TCPWRAPPER"
>22.8. tcp_wrapper</A
></H2
><P
>tcp_wrapper is a library which can help you to protect service against misuse.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2777"
>22.8.1. Filtering capabilities</A
></H3
><P
>You can use tcp_wrapper for</P
><P
></P
><UL
><LI
><P
>Filtering against source addresses (IPv4 or IPv6)</P
></LI
><LI
><P
>Filtering against users (requires a running ident daemon on the client)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2785"
>22.8.2. Which program uses tcp_wrapper</A
></H3
><P
>Following are known:</P
><P
></P
><UL
><LI
><P
>Each service which is called by xinetd (if xinetd is compiled using tcp_wrapper library)</P
></LI
><LI
><P
>sshd (if compiled using tcp_wrapper)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2793"
>22.8.3. Usage</A
></H3
><P
>tcp_wrapper is controlled by two files name /etc/hosts.allow and /etc/hosts.deny. For more information see</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ man hosts.allow</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2797"
>22.8.3.1. Example for /etc/hosts.allow</A
></H4
><P
>In this file, each service which should be positive filtered (means connects are accepted) need a line.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>sshd:           1.2.3. [2001:0db8:100:200::]/64
daytime-stream: 1.2.3. [2001:0db8:100:200::]/64</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note: there are broken implementations around, which uses following broken IPv6 network description: [2001:0db8:100:200::/64]. Hopefully, such versions will be fixed soon.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2802"
>22.8.3.2. Example for /etc/hosts.deny</A
></H4
><P
>This file contains all negative filter entries and should normally deny the rest using</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ALL: ALL</PRE
></FONT
></TD
></TR
></TABLE
><P
>If this node is a more sensible one you can replace the standard line above with this one, but this can cause a DoS attack (load of mailer and spool directory), if too many connects were made in short time. Perhaps a logwatch is better for such issues.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ALL: ALL: spawn (echo "Attempt from %h %a to %d at `date`" 
 | tee -a /var/log/tcp.deny.log | mail root@localhost)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2808"
>22.8.4. Logging</A
></H3
><P
>Depending on the entry in the syslog daemon configuration file /etc/syslog.conf the tcp_wrapper logs normally into /var/log/secure.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2811"
>22.8.4.1. Refused connection</A
></H4
><P
>A refused connection via IPv4 to an xinetd covered daytime service produces a line like following example</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jan 2 20:40:44 gate xinetd-ipv6[12346]: FAIL: daytime-stream libwrap
¬ from=::ffff:1.2.3.4
Jan 2 20:32:06 gate xinetd-ipv6[12346]: FAIL: daytime-stream libwrap 
 from=2001:0db8:100:200::212:34ff:fe12:3456</PRE
></FONT
></TD
></TR
></TABLE
><P
>A refused connection via IPv4 to an dual-listen sshd produces a line like following example</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jan 2 20:24:17 gate sshd[12345]: refused connect from ::ffff:1.2.3.4
¬ (::ffff:1.2.3.4)
Jan 2 20:39:33 gate sshd[12345]: refused connect 
 from 2001:0db8:100:200::212:34ff:fe12:3456
¬ (2001:0db8:100:200::212:34ff:fe12:3456)</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2817"
>22.8.4.2. Permitted connection</A
></H4
><P
>A permitted connection via IPv4 to an xinetd covered daytime service produces a line like following example</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jan 2 20:37:50 gate xinetd-ipv6[12346]: START: daytime-stream pid=0
¬ from=::ffff:1.2.3.4 
Jan 2 20:37:56 gate xinetd-ipv6[12346]: START: daytime-stream pid=0 
 from=2001:0db8:100:200::212:34ff:fe12:3456</PRE
></FONT
></TD
></TR
></TABLE
><P
>A permitted connection via IPv4 to an dual-listen sshd produces a line like following example</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Jan 2 20:43:10 gate sshd[21975]: Accepted password for user from ::ffff:1.2.3.4
¬ port 33381 ssh2
Jan 2 20:42:19 gate sshd[12345]: Accepted password for user 
 from 2001:0db8:100:200::212:34ff:fe12:3456 port 33380 ssh2</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-VSFTPD"
>22.9. vsftpd</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2825"
>22.9.1. Listening on IPv6 addresses</A
></H3
><P
>Edit the configuration file, ususally /etc/vsftpd/vsftpd.conf, and adjust the listen option like</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>listen_ipv6=yes</PRE
></FONT
></TD
></TR
></TABLE
><P
>That's all.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-PROFTPD"
>22.10. proftpd</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN2832"
>22.10.1. Listening on IPv6 addresses</A
></H3
><P
>Edit the configuration file, ususally /etc/proftpd.conf, but take care, not 100% logical in virtual host setup</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>&#60;VirtualHost 192.0.2.1&#62;
        ...
        Bind 2001:0DB8::1
        ...
&#60;/VirtualHost&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>That's all.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="HINTS-DAEMONS-OTHERS"
>22.11. Other daemons</A
></H2
><P
>Nowadays it's mostly simple, look for either a command line option or a configuration value to enable IPv6 listening. See manual page of the daemon or check related FAQs. It can happen that you can bind a daemon only to the IPv6-“any”-address (::) and not to bind to a dedicated IPv6 address, because the lack of support (depends on that what the programmer has implemented so far...).</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-PROGRAMMING"
></A
>Chapter 23. Programming</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="CHAPTER-SECTION-USING-API"
>23.1. Programming using C-API</A
></H2
><P
>Related RFCs:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3493.html"
TARGET="_top"
>RFC 3493 / Basic Socket Interface Extensions for IPv6</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3542.html"
TARGET="_top"
>RFC 3542 / Advanced Sockets Application Program Interface (API) for IPv6</A
></P
></LI
></UL
><P
>Following contents of this section is contributed by John Wenker, Sr. Software Engineer Performance Technologies San Diego, CA USA <A
HREF="http://www.pt.com/"
TARGET="_top"
>http://www.pt.com/</A
>.</P
><P
></P
><P
>This section describes how to write IPv6 client-server applications under the Linux operating system. First thing's first, and credit must be given where it is due. The information contained in this section is derived from Chapters 2 through 4 of IPv6 Network Programming by Jun-ichiro itojun Hagino (ISBN 1-55558-318-0). The reader is encouraged to consult that book for more detailed information. It describes how to convert IPv4 applications to be IPv6 compatible in a protocol-independent way, and describes some of the common problems encountered during the conversion along with suggested solutions. At the time of this writing, this is the only book of which the author is aware that specifically addresses how to program IPv6 applications [since writing this section, the author has also become aware of the Porting applications to IPv6 HowTo by Eva M. Castro at <A
HREF="http://jungla.dit.upm.es/~ecastro/IPv6-web/ipv6.html"
TARGET="_top"
>http://jungla.dit.upm.es/~ecastro/IPv6-web/ipv6.html</A
>]. Unfortunately, of the almost 360 pages in the book, maybe 60 are actually useful (the chapters mentioned). Nevertheless, without the guidance of that book, the author would have been unable to perform his job duties or compose this HowTo. While most (but certainly not all) of the information in the Hagino book is available via the Linux 'man' pages, application programmers will save a significant amount of time and frustration by reading the indicated chapters of the book rather than searching through the 'man' pages and online documentation.</P
><P
>Other than the Hagino book, any other information presented in this HowTo was obtained through trial and error. Some items or explanations may not be entirely “correct” in the grand IPv6 scheme, but seem to work in practical application.</P
><P
>The discussion that follows assumes the reader is already experienced with the traditional TCP/IP socket API. For more information on traditional socket programming, the Internetworking with TCP/IP series of textbooks by Comer &#38; Stevens is hard to beat, specifically Volume III: Client-Server Programming and Applications, Linux/POSIX Sockets Version (ISBN 0-13-032071-4). This HowTo also assumes that the reader has had at least a bare basic introduction to IPv6 and in particular the addressing scheme for network addresses (see Section 2.3).</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2859"
>23.1.1. Address Structures</A
></H3
><P
>This section provides a brief overview of the structures provided in the socket API to represent network addresses (or more specifically transport endpoints) when using the Internet protocols in a client-server application.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2862"
>23.1.1.1. IPv4 sockaddr_in</A
></H4
><P
>In IPv4, network addresses are 32 bits long and define a network node. Addresses are written in dotted decimal notation, such as 192.0.2.1, where each number represents eight bits of the address. Such an IPv4 address is represented by the struct sockaddr_in data type, which is defined in &#60;netinet/in.h&#62;.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct sockaddr_in
{
   sa_family_t    sin_family;
   in_port_t      sin_port;
   struct in_addr sin_addr;
   /* Plus some padding for alignment */
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>The sin_family component indicates the address family. For IPv4 addresses, this is always set to AF_INET. The sin_addr field contains the 32-bit network address (in network byte order). Finally, the sin_port component represents the transport layer port number (in network byte order). Readers should already be familiar with this structure, as this is the standard IPv4 address structure.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2867"
>23.1.1.2. IPv6 sockaddr_in6</A
></H4
><P
>The biggest feature of IPv6 is its increased address space. Instead of 32-bit network addresses, IPv6 allots 128 bits to an address. Addresses are written in colon-hex notation of the form fe80::2c0:8cff:fe01:2345, where each hex number separated by colons represents 16 bits of the address. Two consecutive colons indicate a string of consecutive zeros for brevity, and at most only one double-colon may appear in the address. IPv6 addresses are represented by the struct sockaddr_in6 data type, also defined in &#60;netinet/in.h&#62;.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct sockaddr_in6
{
   sa_family_t     sin6_family;
   in_port_t       sin6_port;
   uint32_t        sin6_flowinfo;
   struct in6_addr sin6_addr;
   uint32_t        sin6_scope_id;
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>The sin6_family, sin6_port, and sin6_addr components of the structure have the same meaning as the corresponding fields in the sockaddr_in structure. However, the sin6_family member is set to AF_INET6 for IPv6 addresses, and the sin6_addr field holds a 128-bit address instead of only 32 bits.</P
><P
>The sin6_flowinfo field is used for flow control, but is not yet standardized and can be ignored.</P
><P
>The sin6_scope_id field has an odd use, and it seems (at least to this naïve author) that the IPv6 designers took a huge step backwards when devising this. Apparently, 128-bit IPv6 network addresses are not unique. For example, it is possible to have two hosts, on separate networks, with the same link-local address (see Figure 1). In order to pass information to a specific host, more than just the network address is required; the scope identifier must also be specified. In Linux, the network interface name is used for the scope identifier (e.g. “eth0”) [be warned that the scope identifier is implementation dependent!]. Use the ifconfig(1M) command to display a list of active network interfaces.</P
><P
>A colon-hex network address can be augmented with the scope identifier to produce a "scoped address”. The percent sign ('%') is used to delimit the network address from the scope identifier. For example, fe80::1%eth0 is a scoped IPv6 address where fe80::1 represents the 128-bit network address and eth0 is the network interface (i.e. the scope identifier). Thus, if a host resides on two networks, such as Host B in example below, the user now has to know which path to take in order to get to a particular host. In Figure 1, Host B addresses Host A using the scoped address fe80::1%eth0, while Host C is addressed with fe80::1%eth1.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Host A (fe80::1) ---- eth0 ---- Host B ---- eth1 ---- Host C (fe80::1)</PRE
></FONT
></TD
></TR
></TABLE
><P
>Getting back to the sockaddr_in6 structure, its sin6_scope_id field contains the index of the network interface on which a host may be found. Server applications will have this field set automatically by the socket API when they accept a connection or receive a datagram. For client applications, if a scoped address is passed as the node parameter to getaddrinfo(3) (described later in this HowTo), then the sin6_scope_id field will be filled in correctly by the system upon return from the function; if a scoped address is not supplied, then the sin6_scope_id field must be explicitly set by the client software prior to attempting to communicate with the remote server. The if_nametoindex(3) function is used to translate a network interface name into its corresponding index. It is declared in &#60;net/if.h&#62;.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2877"
>23.1.1.3. Generic Addresses</A
></H4
><P
>As any programmer familiar with the traditional TCP/IP socket API knows, several socket functions deal with "generic" pointers. For example, a pointer to a generic struct sockaddr data type is passed as a parameter to some socket functions (such as connect(2) or bind(2)) rather than a pointer to a specific address type. Be careful... the sockaddr_in6 structure is larger than the generic sockaddr structure! Thus, if your program receives a generic address whose actual type is unknown (e.g. it could be an IPv4 address structure or an IPv6 address structure), you must supply sufficient storage to hold the entire address. The struct sockaddr_storage data type is defined in &#60;bits/socket.h&#62; for this purpose [do not #include this file directly within an application; use &#60;sys/socket.h&#62; as usual, and &#60;bits/socket.h&#62; will be implicitly included].</P
><P
>For example, consider the recvfrom(2) system call, which is used to receive a message from a remote peer. Its function prototype is:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ssize_t recvfrom( int              s,
                  void            *buf,
                  size_t           len,
                  int              flags,
                  struct sockaddr *from,
                  socklen_t       *fromlen );</PRE
></FONT
></TD
></TR
></TABLE
><P
>The from parameter points to a generic sockaddr structure. If data can be received from an IPv6 peer on the socket referenced by s, then from should point to a data type of struct sockaddr_storage, as in the following dummy example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/*
** Read a message from a remote peer, and return a buffer pointer to
** the caller.
**
** 's' is the file descriptor for the socket.
*/
char *rcvMsg( int s )
{
   static char             bfr[ 1025 ];  /* Where the msg is stored. */
   ssize_t                 count;
   struct sockaddr_storage ss;           /* Where the peer adr goes. */
   socklen_t               sslen;
   sslen = sizeof( ss );
   count = recvfrom( s,
                     bfr,
                     sizeof( bfr ) - 1,
                     0,
                     (struct sockaddr*) &#38;ss,
                     &#38;sslen );
   bfr[ count ] = '\0';   /* Null-terminates the message. */
   return bfr;
}  /* End rcvMsg() */</PRE
></FONT
></TD
></TR
></TABLE
><P
>As seen in the above example, ss (a struct sockaddr_storage data object) is used to receive the peer address information, but it's address is typecast to a generic struct sockaddr* pointer in the call to recvfrom(2). </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2885"
>23.1.2. Lookup Functions</A
></H3
><P
>Traditionally, hostname and service name resolution were performed by functions such as gethostbyname(3) and getservbyname(3). These traditional lookup functions are still available, but they are not forward compatible to IPv6. Instead, the IPv6 socket API provides new lookup functions that consolidate the functionality of several traditional functions. These new lookup functions are also backward compatible with IPv4, so a programmer can use the same translation algorithm in an application for both the IPv4 and IPv6 protocols. This is an important feature, because obviously a global IPv6 infrastructure isn't going to be put in place overnight. Thus, during the transition period from IPv4 to IPv6, client-server applications should be designed with the flexibility to handle both protocols simultaneously. The example programs at the end of this chapter do just that.</P
><P
>The primary lookup function in the new socket API is getaddrinfo(3). Its prototype is as follows. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int getaddrinfo( const char             *node,
                 const char             *service,
                 const struct addrinfo  *hints,
                 struct addrinfo       **res );</PRE
></FONT
></TD
></TR
></TABLE
><P
>The node parameter is a pointer to the hostname or IP address being translated. The referenced string can be a hostname, IPv4 dotted decimal address, or IPv6 colon-hex address (possibly scoped). The service parameter is a pointer to the transport layer's service name or port number. It can be specified as a name found in /etc/services or a decimal number. getaddrinfo(3) resolves the host/service combination and returns a list of address records; a pointer to the list is placed in the location pointed at by res. For example, suppose a host can be identified by both an IPv4 and IPv6 address, and that the indicated service has both a TCP entry and UDP entry in /etc/services. In such a scenario, it is not inconceivable that four address records are returned; one for TCP/IPv6, one for UDP/IPv6, one for TCP/IPv4, and one for UDP/IPv4.</P
><P
>The definition for struct addrinfo is found in &#60;netdb.h&#62; (as is the declaration for getaddrinfo(3) and the other functions described in this section). The structure has the following format:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>struct addrinfo
{
   int              ai_flags;
   int              ai_family;
   int              ai_socktype;
   int              ai_protocol;
   socklen_t        ai_addrlen;
   struct sockaddr *ai_addr;
   char            *ai_canonname;
   struct addrinfo *ai_next;
};</PRE
></FONT
></TD
></TR
></TABLE
><P
>Consult the 'man' page for getaddrinfo(3) for detailed information about the various fields; this HowTo only describes a subset of them, and only to the extent necessary for normal IPv6 programming.</P
><P
>The ai_family, ai_socktype, and ai_protocol fields have the exact same meaning as the parameters to the socket(2) system call. The ai_family field indicates the protocol family (not the address family) associated with the record, and will be PF_INET6 for IPv6 or PF_INET for IPv4. The ai_socktype parameter indicates the type of socket to which the record corresponds; SOCK_STREAM for a reliable connection-oriented byte-stream or SOCK_DGRAM for connectionless communication. The ai_protocol field specifies the underlying transport protocol for the record.</P
><P
>The ai_addr field points to a generic struct sockaddr object. Depending on the value in the ai_family field, it will point to either a struct sockaddr_in (PF_INET) or a struct sockaddr_in6 (PF_INET6). The ai_addrlen field contains the size of the object pointed at by the ai_addr field.</P
><P
>As mentioned, getaddrinfo(3) returns a list of address records. The ai_next field points to the next record in the list.</P
><P
>The hints parameter to getaddrinfo(3) is also of type struct addrinfo and acts as a filter for the address records returned in res. If hints is NULL, all matching records are returned; but if hints is non-NULL, the referenced structure gives "hints" to getaddrinfo(3) about which records to return. Only the ai_flags, ai_family, ai_socktype, and ai_protocol fields are significant in the hints structure, and all other fields should be set to zero.</P
><P
>Programs can use hints-&#62;ai_family to specify the protocol family. For example, if it is set to PF_INET6, then only IPv6 address records are returned. Likewise, setting hints-&#62;ai_family to PF_INET results in only IPv4 address records being returned. If an application wants both IPv4 and IPv6 records, the field should be set to PF_UNSPEC.</P
><P
>The hints-&#62;socktype field can be set to SOCK_STREAM to return only records that correspond to connection-oriented byte streams, SOCK_DGRAM to return only records corresponding to connectionless communication, or 0 to return both.</P
><P
>For the Internet protocols, there is only one protocol associated with connection-oriented sockets (TCP) and one protocol associated with connectionless sockets (UDP), so setting hints-&#62;ai_socktype to SOCK_STREAM or SOCK_DGRAM is the same as saying, "Give me only TCP records," or "Give me only UDP records," respectively. With that in mind, the hints-&#62;ai_protocol field isn't really that important with the Internet protocols, and pretty much mirrors the hints-&#62;ai_socktype field. Nevertheless, hints-&#62;ai_protocol can be set to IPPROTO_TCP to return only TCP records, IPPROTO_UDP to return only UDP records, or 0 for both.</P
><P
>The node or service parameter to gethostbyname(3) can be NULL, but not both. If node is NULL, then the ai_flags field of the hints parameter specifies how the network address in a returned record is set (i.e. the sin_addr or sin6_addr field of the object pointed at by the ai_addr component in a returned record). If the AI_PASSIVE flag is set in hints, then the returned network addresses are left unresolved (all zeros). This is how server applications would use getaddrinfo(3). If the flag is not set, then the address is set to the local loopback address (::1 for IPv6 or 127.0.0.1 for IPv4). This is one way a client application can specify that the target server is running on the same machine as the client. If the service parameter is NULL, the port number in the returned address records remains unresolved.</P
><P
>The getaddrinfo(3) function returns zero on success, or an error code. In the case of an error, the gai_strerror(3) function is used to obtain a character pointer to an error message corresponding to the error code, just like strerror(3) does in the standard 'C' library.</P
><P
>Once the address list is no longer needed, it must be freed by the application. This is done with the freeaddrinfo(3) function.</P
><P
>The last function that will be mentioned in this section is getnameinfo(3). This function is the inverse of getaddrinfo(3); it is used to create a string representation of the hostname and service from a generic struct sockaddr data object. It has the following prototype. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>int getnameinfo( const struct sockaddr *sa,
                 socklen_t              salen,
                 char                  *host,
                 size_t                 hostlen,
                 char                  *serv,
                 size_t                 servlen,
                 int                    flags );</PRE
></FONT
></TD
></TR
></TABLE
><P
>The sa parameter points to the address structure in question, and salen contains its size. The host parameter points to a buffer where the null-terminated hostname string is placed, and the hostlen parameter is the size of that buffer. If there is no hostname that corresponds to the address, then the network address (dotted decimal or colon-hex) is placed in host. Likewise, the serv parameter points to a buffer where the null-terminated service name string (or port number) is placed, and the servlen parameter is the size of that buffer. The flags parameter modifies the function's behavior; in particular, the NI_NUMERICHOST flag indicates that the converted hostname should always be formatted in numeric form (i.e. dotted decimal or colon-hex), and the NI_NUMERICSERV flag indicates that the converted service should always be in numeric form (i.e. the port number).</P
><P
>The symbols NI_MAXHOST and NI_MAXSERV are available to applications and represent the maximum size of any converted hostname or service name, respectively. Use these when declaring output buffers for getnameinfo(3).</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2908"
>23.1.3. Quirks Encountered</A
></H3
><P
>Before jumping into the programming examples, there are several quirks in IPv6 of which the reader should be aware. The more significant ones (in addition to the non-uniqueness of IPv6 network addresses already discussed) are described in the paragraphs below. </P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2911"
>23.1.3.1. IPv4 Mapped Addresses</A
></H4
><P
>For security reasons that this author won't pretend to understand, "IPv4 mapped addresses" should not be allowed in IPv6-capable server applications. To put it in terms that everyone can understand, this simply means that a server should not accept IPv4 traffic on an IPv6 socket (an otherwise legal operation). An IPv4 mapped address is a mixed-format address of the form:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>::ffff:192.0.2.1</PRE
></FONT
></TD
></TR
></TABLE
><P
>where the first portion is in IPv6 colon-hex format and the last portion is in IPv4 dotted decimal notation. The dotted decimal IPv4 address is the actual network address, but it is being mapped into an IPv6 compatible format.</P
><P
>To prevent IPv4 mapped addresses from being accepted on an IPv6 socket, server applications must explicitly set the IPV6_V6ONLY socket option on all IPv6 sockets created [the Hagino book implies that this is only a concern with server applications. However, it has been observed during testing that if a client application uses an IPv4 mapped address to specify the target server, and the target server has IPv4 mapped addresses disabled, the connection still completes regardless. On the server side, the connection endpoint is an IPv4 socket as desired; but on the client side, the connection endpoint is an IPv6 socket. Setting the IPV6_V6ONLY socket option on the client side as well as the server side prevents any connection from being established at all.]. There's only one problem. Apparently, IPV6_V6ONLY isn't defined on all systems [or at least it wasn't in 2005 when the Hagino book was written]. The server example at the end of this chapter provides a method for handling this problem.</P
><P
>If IPv4 traffic cannot be handled on IPv6 sockets, then that implies that server applications must open both an IPv4 and IPv6 socket for a particular network service if it wants to handle requests from either protocol. This goes back to the flexibility issue mentioned earlier. If getaddrinfo(3) returns multiple address records, then server applications should traverse the list and open a passive socket for each address provided. </P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2918"
>23.1.3.2. Cannot Specify the Scope Identifier in /etc/hosts</A
></H4
><P
>It is possible to assign a hostname to an IPv6 network address in /etc/hosts. For example, the following is an excerpt from the /etc/hosts file on the author's development system. </P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>        ::1                        localhost
        127.0.0.1                  localhost
        fe80::2c0:8cff:fe01:2345   pt141
        192.0.2.1                  pt141</PRE
></FONT
></TD
></TR
></TABLE
><P
>The "localhost" and "pt141" hostnames can be translated to either an IPv4 or IPv6 network address. So, for example, if "pt141" is passed as the node parameter to getaddrinfo(3), the function returns both an IPv4 and IPv6 address record for the host (assuming the behavior hasn't been modified by the hints parameter). Unfortunately, a scoped address cannot be used in /etc/hosts. Doing so results in getaddrinfo(3) returning only the IPv4 record.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2923"
>23.1.3.3. Client &#38; Server Residing on the Same Machine</A
></H4
><P
>Suppose a machine has the IPv4 address 192.0.2.1. A client application running on that machine can connect to a server application on the same machine by using either the local loopback address (127.0.0.1) or the network address (192.0.2.1) as the target server. Much to this author's surprise (and dismay), it turns out that an IPv6 client application cannot connect to a server application on the same machine if it uses the network address of that machine as the target; it must use the local loopback address (::1). </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN2926"
>23.1.4. Putting It All Together (A Client-Server Programming Example)</A
></H3
><P
>Now it's time to put everything discussed thus far together into a sample client-server application. The remainder of this section is devoted to a remote time-of-day application (the 'daytime' Internet service) [I noticed that Ms. Castro used a 'daytime' example in her <EM
>Porting applications to IPv6 HowTo</EM
>. For the record, the source code presented here is original, developed from scratch, and any similarity between it and any other publicly available 'daytime' example is purely coincidental.]. The source code presented in this section was developed and tested on a RedHat Linux release using the 2.6 kernel (2.6.9 to be specific). Readers may use the source code freely, so long as proper credit is attributed; but of course the standard disclaimer must be given first: </P
><A
NAME="AEN2930"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Although the sample source code is believed to be free of errors, the author makes no guarantees as to its reliability, especially considering that some error paths were intentionally omitted for brevity. Use it at your own risk!</P
></BLOCKQUOTE
><P
>When you get right down to it, there really aren't that many differences between IPv4 and IPv6 applications. The trick is to code IPv6 applications in a protocol-independent manner, such that they can handle both IPv4 and IPv6 simultaneously and transparently. This sample application does just that. The only protocol-dependent code in the example occurs when printing network addresses in verbose mode; but only after the ai_family field in the addrinfo structure has been checked, so the programs know exactly what type of address they're handling at the time.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2933"
>23.1.4.1. 'Daytime' Server Code</A
></H4
><P
>The server code is found in file tod6d.c (time-of-day IPv6 daemon). Once built, the server may be started using the following command syntax (assuming tod6d is the executable file):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tod6d [-v] [service]</PRE
></FONT
></TD
></TR
></TABLE
><P
>ARGUMENTS: </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>service</DT
><DD
><P
>The service (or well-known port) on which to listen. Default is "daytime".</P
></DD
></DL
></DIV
><P
>OPTIONS:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-v</DT
><DD
><P
>Turn on verbose mode.</P
></DD
></DL
></DIV
><P
>The server handles both TCP and UDP requests on the network. The server source code contained in tod6d.c follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/******************************************************************************
* File: tod6d.c
* Description: Contains source code for an IPv6-capable 'daytime' server.
* Author: John Wenker, Sr. Software Engineer,
*         Performance Technologies, San Diego, USA
******************************************************************************/
/*
** System header files.
*/
#include &#60;errno.h&#62;        /* errno declaration &#38; error codes.            */
#include &#60;netdb.h&#62;        /* getaddrinfo(3) et al.                       */
#include &#60;netinet/in.h&#62;   /* sockaddr_in &#38; sockaddr_in6 definition.      */
#include &#60;stdio.h&#62;        /* printf(3) et al.                            */
#include &#60;stdlib.h&#62;       /* exit(2).                                    */
#include &#60;string.h&#62;       /* String manipulation &#38; memory functions.     */
#include &#60;sys/poll.h&#62;     /* poll(2) and related definitions.            */
#include &#60;sys/socket.h&#62;   /* Socket functions (socket(2), bind(2), etc). */
#include &#60;time.h&#62;         /* time(2) &#38; ctime(3).                         */
#include &#60;unistd.h&#62;       /* getopt(3), read(2), etc.                    */
/*
** Constants.
*/
#define DFLT_SERVICE "daytime"   /* Default service name.                    */
#define INVALID_DESC -1          /* Invalid file descriptor.                 */
#define MAXCONNQLEN  3           /* Max nbr of connection requests to queue. */
#define MAXTCPSCKTS  2           /* One TCP socket for IPv4 &#38; one for IPv6.  */
#define MAXUDPSCKTS  2           /* One UDP socket for IPv4 &#38; one for IPv6.  */
#define VALIDOPTS    "v"         /* Valid command options.                   */
/*
** Simple boolean type definition.
*/
typedef enum { false = 0, true } boolean;
/*
** Prototypes for internal helper functions.
*/
static int  openSckt( const char *service,
                      const char *protocol,
                      int         desc[ ],
                      size_t     *descSize );
static void tod( int    tSckt[ ],
                 size_t tScktSize,
                 int    uSckt[ ],
                 size_t uScktSize );
/*
** Global (within this file only) data objects.
*/
static char        hostBfr[ NI_MAXHOST ];   /* For use w/getnameinfo(3).    */
static const char *pgmName;                 /* Program name w/o dir prefix. */
static char        servBfr[ NI_MAXSERV ];   /* For use w/getnameinfo(3).    */
static boolean     verbose = false;         /* Verbose mode indication.     */
/*
** Usage macro for command syntax violations.
*/
#define USAGE                                       \
        {                                           \
           fprintf( stderr,                         \
                    "Usage: %s [-v] [service]\n",   \
                    pgmName );                      \
           exit( 127 );                             \
        }  /* End USAGE macro. */
/*
** Macro to terminate the program if a system call error occurs.  The system
** call must be one of the usual type that returns -1 on error.  This macro is
** a modified version of a macro authored by Dr. V. Vinge, SDSU Dept. of
** Computer Science (retired)... best professor I ever had.  I hear he writes
** great science fiction in addition to robust code, too.
*/
#define CHK(expr)                                                   \
        do                                                          \
        {                                                           \
           if ( (expr) == -1 )                                      \
           {                                                        \
              fprintf( stderr,                                      \
                       "%s (line %d): System call ERROR - %s.\n",   \
                       pgmName,                                     \
                       __LINE__,                                    \
                       strerror( errno ) );                         \
              exit( 1 );                                            \
           }   /* End IF system call failed. */                     \
        } while ( false )
/******************************************************************************
* Function: main
*
* Description:
*    Set up a time-of-day server and handle network requests.  This server
*    handles both TCP and UDP requests.
*
* Parameters:
*    The usual argc and argv parameters to a main() function.
*
* Return Value:
*    This is a daemon program and never returns.  However, in the degenerate
*    case where no sockets are created, the function returns zero.
******************************************************************************/
int main( int   argc,
          char *argv[ ] )
{
   int         opt;
   const char *service   = DFLT_SERVICE;
   int         tSckt[ MAXTCPSCKTS ];     /* Array of TCP socket descriptors. */
   size_t      tScktSize = MAXTCPSCKTS;  /* Size of uSckt (# of elements).   */
   int         uSckt[ MAXUDPSCKTS ];     /* Array of UDP socket descriptors. */
   size_t      uScktSize = MAXUDPSCKTS;  /* Size of uSckt (# of elements).   */
   /*
   ** Set the program name (w/o directory prefix).
   */
   pgmName = strrchr( argv[ 0 ], '/' );
   pgmName = pgmName == NULL  ?  argv[ 0 ]  :  pgmName + 1;
   /*
   ** Process command options.
   */
   opterr = 0;   /* Turns off "invalid option" error messages. */
   while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) &#62;= 0 )
   {
      switch ( opt )
      {
         case 'v':   /* Verbose mode. */
         {
            verbose = true;
            break;
         }
         default:
         {
            USAGE;
         }
      }  /* End SWITCH on command option. */
   }  /* End WHILE processing options. */
   /*
   ** Process command line arguments.
   */
   switch ( argc - optind )
   {
      case 0:  break;
      case 1:  service = argv[ optind ]; break;
      default: USAGE;
   }  /* End SWITCH on number of command line arguments. */
   /*
   ** Open both a TCP and UDP socket, for both IPv4 &#38; IPv6, on which to receive
   ** service requests.
   */
   if ( ( openSckt( service, "tcp", tSckt, &#38;tScktSize ) &#60; 0 ) ||
        ( openSckt( service, "udp", uSckt, &#38;uScktSize ) &#60; 0 ) )
   {
      exit( 1 );
   }
   /*
   ** Run the time-of-day server.
   */
   if ( ( tScktSize &#62; 0 ) || ( uScktSize &#62; 0 ) )
   {
      tod( tSckt,         /* tod() never returns. */
           tScktSize,
           uSckt,
           uScktSize );
   }
   /*
   ** Since tod() never returns, execution only gets here if no sockets were
   ** created.
   */
   if ( verbose )
   {
      fprintf( stderr,
               "%s: No sockets opened... terminating.\n",
               pgmName );
   }
   return 0;
}  /* End main() */
/******************************************************************************
* Function: openSckt
*
* Description:
*    Open passive (server) sockets for the indicated inet service &#38; protocol.
*    Notice in the last sentence that "sockets" is plural.  During the interim
*    transition period while everyone is switching over to IPv6, the server
*    application has to open two sockets on which to listen for connections...
*    one for IPv4 traffic and one for IPv6 traffic.
*
* Parameters:
*    service  - Pointer to a character string representing the well-known port
*               on which to listen (can be a service name or a decimal number).
*    protocol - Pointer to a character string representing the transport layer
*               protocol (only "tcp" or "udp" are valid).
*    desc     - Pointer to an array into which the socket descriptors are
*               placed when opened.
*    descSize - This is a value-result parameter.  On input, it contains the
*               max number of descriptors that can be put into 'desc' (i.e. the
*               number of elements in the array).  Upon return, it will contain
*               the number of descriptors actually opened.  Any unused slots in
*               'desc' are set to INVALID_DESC.
*
* Return Value:
*    0 on success, -1 on error.
******************************************************************************/
static int openSckt( const char *service,
                     const char *protocol,
                     int         desc[ ],
                     size_t     *descSize )
{
   struct addrinfo *ai;
   int              aiErr;
   struct addrinfo *aiHead;
   struct addrinfo  hints    = { .ai_flags  = AI_PASSIVE,    /* Server mode. 
¬ */
                                 .ai_family = PF_UNSPEC };   /* IPv4 or IPv6.
¬ */
   size_t           maxDescs = *descSize;
   /*
   ** Initialize output parameters.  When the loop completes, *descSize is 0.
   */
   while ( *descSize &#62; 0 )
   {
      desc[ --( *descSize ) ] = INVALID_DESC;
   }
   /*
   ** Check which protocol is selected (only TCP and UDP are valid).
   */
   if ( strcmp( protocol, "tcp" ) == 0 )        /* TCP protocol.     */
   {
      hints.ai_socktype = SOCK_STREAM;
      hints.ai_protocol = IPPROTO_TCP;
   }
   else if ( strcmp( protocol, "udp" ) == 0 )   /* UDP protocol.     */
   {
      hints.ai_socktype = SOCK_DGRAM;
      hints.ai_protocol = IPPROTO_UDP;
   }
   else                                         /* Invalid protocol. */
   {
      fprintf( stderr,
               "%s (line %d): ERROR - Unknown transport "
               "layer protocol \"%s\".\n",
               pgmName,
               __LINE__,
               protocol );
      return -1;
   }
   /*
   ** Look up the service's well-known port number.  Notice that NULL is being
   ** passed for the 'node' parameter, and that the AI_PASSIVE flag is set in
   ** 'hints'.  Thus, the program is requesting passive address information.
   ** The network address is initialized to :: (all zeros) for IPv6 records, or
   ** 0.0.0.0 for IPv4 records.
   */
   if ( ( aiErr = getaddrinfo( NULL,
                               service,
                               &#38;hints,
                               &#38;aiHead ) ) != 0 )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               gai_strerror( aiErr ) );
      return -1;
   }
   /*
   ** For each of the address records returned, attempt to set up a passive
   ** socket.
   */
   for ( ai = aiHead;
         ( ai != NULL ) &#38;&#38; ( *descSize &#60; maxDescs );
         ai = ai-&#62;ai_next )
   {
      if ( verbose )
      {
         /*
         ** Display the current address info.   Start with the protocol-
         ** independent fields first.
         */
         fprintf( stderr,
                  "Setting up a passive socket based on the "
                  "following address info:\n"
                  "   ai_flags     = 0x%02X\n"
                  "   ai_family    = %d (PF_INET = %d, PF_INET6 = %d)\n"
                  "   ai_socktype  = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                  "   ai_protocol  = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                  "   ai_addrlen   = %d (sockaddr_in = %d, "
                  "sockaddr_in6 = %d)\n",
                  ai-&#62;ai_flags,
                  ai-&#62;ai_family,
                  PF_INET,
                  PF_INET6,
                  ai-&#62;ai_socktype,
                  SOCK_STREAM,
                  SOCK_DGRAM,
                  ai-&#62;ai_protocol,
                  IPPROTO_TCP,
                  IPPROTO_UDP,
                  ai-&#62;ai_addrlen,
                  sizeof( struct sockaddr_in ),
                  sizeof( struct sockaddr_in6 ) );
         /*
         ** Now display the protocol-specific formatted socket address.  Note
         ** that the program is requesting that getnameinfo(3) convert the
         ** host &#38; service into numeric strings.
         */
         getnameinfo( ai-&#62;ai_addr,
                      ai-&#62;ai_addrlen,
                      hostBfr,
                      sizeof( hostBfr ),
                      servBfr,
                      sizeof( servBfr ),
                      NI_NUMERICHOST | NI_NUMERICSERV );
         switch ( ai-&#62;ai_family )
         {
            case PF_INET:   /* IPv4 address record. */
            {
               struct sockaddr_in *p = (struct sockaddr_in*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin_addr:     %s\n"
                        "                  sin_port:     %s\n",
                        p-&#62;sin_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr );
               break;
            }  /* End CASE of IPv4. */
            case PF_INET6:   /* IPv6 address record. */
            {
               struct sockaddr_in6 *p = (struct sockaddr_in6*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin6_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin6_addr:     %s\n"
                        "                  sin6_port:     %s\n"
                        "                  sin6_flowinfo: %d\n"
                        "                  sin6_scope_id: %d\n",
                        p-&#62;sin6_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr,
                        p-&#62;sin6_flowinfo,
                        p-&#62;sin6_scope_id );
               break;
            }  /* End CASE of IPv6. */
            default:   /* Can never get here, but just for completeness. */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                        pgmName,
                        __LINE__,
                        ai-&#62;ai_family );
               freeaddrinfo( aiHead );
               return -1;
            }  /* End DEFAULT case (unknown protocol family). */
         }  /* End SWITCH on protocol family. */
      }  /* End IF verbose mode. */
      /*
      ** Create a socket using the info in the addrinfo structure.
      */
      CHK( desc[ *descSize ] = socket( ai-&#62;ai_family,
                                       ai-&#62;ai_socktype,
                                       ai-&#62;ai_protocol ) );
      /*
      ** Here is the code that prevents "IPv4 mapped addresses", as discussed
      ** in Section 22.1.3.1.  If an IPv6 socket was just created, then set the
      ** IPV6_V6ONLY socket option.
      */
      if ( ai-&#62;ai_family == PF_INET6 )
      {
#if defined( IPV6_V6ONLY )
         /*
         ** Disable IPv4 mapped addresses.
         */
         int v6Only = 1;
         CHK( setsockopt( desc[ *descSize ],
                          IPPROTO_IPV6,
                          IPV6_V6ONLY,
                          &#38;v6Only,
                          sizeof( v6Only ) ) );
#else
         /*
         ** IPV6_V6ONLY is not defined, so the socket option can't be set and
         ** thus IPv4 mapped addresses can't be disabled.  Print a warning
         ** message and close the socket.  Design note: If the
         ** #if...#else...#endif construct were removed, then this program
         ** would not compile (because IPV6_V6ONLY isn't defined).  That's an
         ** acceptable approach; IPv4 mapped addresses are certainly disabled
         ** if the program can't build!  However, since this program is also
         ** designed to work for IPv4 sockets as well as IPv6, I decided to
         ** allow the program to compile when IPV6_V6ONLY is not defined, and
         ** turn it into a run-time warning rather than a compile-time error.
         ** IPv4 mapped addresses are still disabled because _all_ IPv6 traffic
         ** is disabled (all IPv6 sockets are closed here), but at least this
         ** way the server can still service IPv4 network traffic.
         */
         fprintf( stderr,
                  "%s (line %d): WARNING - Cannot set IPV6_V6ONLY socket "
                  "option.  Closing IPv6 %s socket.\n",
                  pgmName,
                  __LINE__,
                  ai-&#62;ai_protocol == IPPROTO_TCP  ?  "TCP"  :  "UDP" );
         CHK( close( desc[ *descSize ] ) );
         continue;   /* Go to top of FOR loop w/o updating *descSize! */
#endif /* IPV6_V6ONLY */
      }  /* End IF this is an IPv6 socket. */
      /*
      ** Bind the socket.  Again, the info from the addrinfo structure is used.
      */
      CHK( bind( desc[ *descSize ],
                 ai-&#62;ai_addr,
                 ai-&#62;ai_addrlen ) );
      /*
      ** If this is a TCP socket, put the socket into passive listening mode
      ** (listen is only valid on connection-oriented sockets).
      */
      if ( ai-&#62;ai_socktype == SOCK_STREAM )
      {
         CHK( listen( desc[ *descSize ],
                      MAXCONNQLEN ) );
      }
      /*
      ** Socket set up okay.  Bump index to next descriptor array element.
      */
      *descSize += 1;
   }  /* End FOR each address info structure returned. */
   /*
   ** Dummy check for unused address records.
   */
   if ( verbose &#38;&#38; ( ai != NULL ) )
   {
      fprintf( stderr,
               "%s (line %d): WARNING - Some address records were "
               "not processed due to insufficient array space.\n",
               pgmName,
               __LINE__ );
   }  /* End IF verbose and some address records remain unprocessed. */
   /*
   ** Clean up.
   */
   freeaddrinfo( aiHead );
   return 0;
}  /* End openSckt() */
/******************************************************************************
* Function: tod
*
* Description:
*    Listen on a set of sockets and send the current time-of-day to any
*    clients.  This function never returns.
*
* Parameters:
*    tSckt     - Array of TCP socket descriptors on which to listen.
*    tScktSize - Size of the tSckt array (nbr of elements).
*    uSckt     - Array of UDP socket descriptors on which to listen.
*    uScktSize - Size of the uSckt array (nbr of elements).
*
* Return Value: None.
******************************************************************************/
static void tod( int    tSckt[ ],
                 size_t tScktSize,
                 int    uSckt[ ],
                 size_t uScktSize )
{
   char                     bfr[ 256 ];
   ssize_t                  count;
   struct pollfd           *desc;
   size_t                   descSize = tScktSize + uScktSize;
   int                      idx;
   int                      newSckt;
   struct sockaddr         *sadr;
   socklen_t                sadrLen;
   struct sockaddr_storage  sockStor;
   int                      status;
   size_t                   timeLen;
   char                    *timeStr;
   time_t                   timeVal;
   ssize_t                  wBytes;
   /*
   ** Allocate memory for the poll(2) array.
   */
   desc = malloc( descSize * sizeof( struct pollfd ) );
   if ( desc == NULL )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               strerror( ENOMEM ) );
      exit( 1 );
   }
   /*
   ** Initialize the poll(2) array.
   */
   for ( idx = 0;     idx &#60; descSize;     idx++ )
   {
      desc[ idx ].fd      = idx &#60; tScktSize  ?  tSckt[ idx ]
                                             :  uSckt[ idx - tScktSize ];
      desc[ idx ].events  = POLLIN;
      desc[ idx ].revents = 0;
   }
   /*
   ** Main time-of-day server loop.  Handles both TCP &#38; UDP requests.  This is
   ** an interative server, and all requests are handled directly within the
   ** main loop.
   */
   while ( true )   /* Do forever. */
   {
      /*
      ** Wait for activity on one of the sockets.  The DO..WHILE construct is
      ** used to restart the system call in the event the process is
      ** interrupted by a signal.
      */
      do
      {
         status = poll( desc,
                        descSize,
                        -1 /* Wait indefinitely for input. */ );
      } while ( ( status &#60; 0 ) &#38;&#38; ( errno == EINTR ) );
      CHK( status );   /* Check for a bona fide system call error. */
      /*
      ** Get the current time.
      */
      timeVal = time( NULL );
      timeStr = ctime( &#38;timeVal );
      timeLen = strlen( timeStr );
      /*
      ** Indicate that there is new network activity.
      */
      if ( verbose )
      {
         char *s = malloc( timeLen+1 );
         strcpy( s, timeStr );
         s[ timeLen-1 ] = '\0';   /* Overwrite '\n' in date string. */
         fprintf( stderr,
                  "%s: New network activity on %s.\n",
                  pgmName,
                  s );
         free( s );
      }  /* End IF verbose. */
      /*
      ** Process sockets with input available.
      */
      for ( idx = 0;     idx &#60; descSize;     idx++ )
      {
         switch ( desc[ idx ].revents )
         {
            case 0:        /* No activity on this socket; try the next. */
               continue;
            case POLLIN:   /* Network activity.  Go process it.         */
               break;
            default:       /* Invalid poll events.                      */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Invalid poll event (0x%02X).\n",
                        pgmName,
                        __LINE__,
                        desc[ idx ].revents );
               exit( 1 );
            }
         }  /* End SWITCH on returned poll events. */
         /*
         ** Determine if this is a TCP request or UDP request.
         */
         if ( idx &#60; tScktSize )
         {
            /*
            ** TCP connection requested.  Accept it.  Notice the use of
            ** the sockaddr_storage data type.
            */
            sadrLen = sizeof( sockStor );
            sadr    = (struct sockaddr*) &#38;sockStor;
            CHK( newSckt = accept( desc[ idx ].fd,
                                   sadr,
                                   &#38;sadrLen ) );
            CHK( shutdown( newSckt,       /* Server never recv's anything. */
                           SHUT_RD ) );
            if ( verbose )
            {
               /*
               ** Display the socket address of the remote client.  Begin with
               ** the address-independent fields.
               */
               fprintf( stderr,
                        "Sockaddr info for new TCP client:\n"
                        "   sa_family = %d (AF_INET = %d, AF_INET6 = %d)\n"
                        "   addr len  = %d (sockaddr_in = %d, "
                        "sockaddr_in6 = %d)\n",
                        sadr-&#62;sa_family,
                        AF_INET,
                        AF_INET6,
                        sadrLen,
                        sizeof( struct sockaddr_in ),
                        sizeof( struct sockaddr_in6 ) );
               /*
               ** Display the address-specific fields.
               */
               getnameinfo( sadr,
                            sadrLen,
                            hostBfr,
                            sizeof( hostBfr ),
                            servBfr,
                            sizeof( servBfr ),
                            NI_NUMERICHOST | NI_NUMERICSERV );
               /*
               ** Notice that we're switching on an address family now, not a
               ** protocol family.
               */
               switch ( sadr-&#62;sa_family )
               {
                  case AF_INET:   /* IPv4 address. */
                  {
                     struct sockaddr_in *p = (struct sockaddr_in*) sadr;
                     fprintf( stderr,
                              "   sin_addr  = sin_family: %d\n"
                              "               sin_addr:   %s\n"
                              "               sin_port:   %s\n",
                              p-&#62;sin_family,
                              hostBfr,
                              servBfr );
                     break;
                  }  /* End CASE of IPv4. */
                  case AF_INET6:   /* IPv6 address. */
                  {
                     struct sockaddr_in6 *p = (struct sockaddr_in6*) sadr;
                     fprintf( stderr,
                              "   sin6_addr = sin6_family:   %d\n"
                              "               sin6_addr:     %s\n"
                              "               sin6_port:     %s\n"
                              "               sin6_flowinfo: %d\n"
                              "               sin6_scope_id: %d\n",
                              p-&#62;sin6_family,
                              hostBfr,
                              servBfr,
                              p-&#62;sin6_flowinfo,
                              p-&#62;sin6_scope_id );
                     break;
                  }  /* End CASE of IPv6. */
                  default:   /* Can never get here, but for completeness. */
                  {
                     fprintf( stderr,
                              "%s (line %d): ERROR - Unknown address "
                              "family (%d).\n",
                              pgmName,
                              __LINE__,
                              sadr-&#62;sa_family );
                     break;
                  }  /* End DEFAULT case (unknown address family). */
               }  /* End SWITCH on address family. */
            }  /* End IF verbose mode. */
            /*
            ** Send the TOD to the client.
            */
            wBytes = timeLen;
            while ( wBytes &#62; 0 )
            {
               do
               {
                  count = write( newSckt,
                                 timeStr,
                                 wBytes );
               } while ( ( count &#60; 0 ) &#38;&#38; ( errno == EINTR ) );
               CHK( count );   /* Check for a bona fide error. */
               wBytes -= count;
            }  /* End WHILE there is data to send. */
            CHK( close( newSckt ) );
         }  /* End IF this was a TCP connection request. */
         else
         {
            /*
            ** This is a UDP socket, and a datagram is available.  The funny
            ** thing about UDP requests is that this server doesn't require any
            ** client input; but it can't send the TOD unless it knows a client
            ** wants the data, and the only way that can occur with UDP is if
            ** the server receives a datagram from the client.  Thus, the
            ** server must receive _something_, but the content of the datagram
            ** is irrelevant.  Read in the datagram.  Again note the use of
            ** sockaddr_storage to receive the address.
            */
            sadrLen = sizeof( sockStor );
            sadr    = (struct sockaddr*) &#38;sockStor;
            CHK( count = recvfrom( desc[ idx ].fd,
                                   bfr,
                                   sizeof( bfr ),
                                   0,
                                   sadr,
                                   &#38;sadrLen ) );
            /*
            ** Display whatever was received on stdout.
            */
            if ( verbose )
            {
               ssize_t rBytes = count;
               fprintf( stderr,
                        "%s: UDP datagram received (%d bytes).\n",
                        pgmName,
                        count );
               while ( count &#62; 0 )
               {
                  fputc( bfr[ rBytes - count-- ],
                         stdout );
               }
               if ( bfr[ rBytes-1 ] != '\n' )
                  fputc( '\n', stdout );   /* Newline also flushes stdout. */
               /*
               ** Display the socket address of the remote client.  Address-
               ** independent fields first.
               */
               fprintf( stderr,
                        "Remote client's sockaddr info:\n"
                        "   sa_family = %d (AF_INET = %d, AF_INET6 = %d)\n"
                        "   addr len  = %d (sockaddr_in = %d, "
                        "sockaddr_in6 = %d)\n",
                        sadr-&#62;sa_family,
                        AF_INET,
                        AF_INET6,
                        sadrLen,
                        sizeof( struct sockaddr_in ),
                        sizeof( struct sockaddr_in6 ) );
               /*
               ** Display the address-specific information.
               */
               getnameinfo( sadr,
                            sadrLen,
                            hostBfr,
                            sizeof( hostBfr ),
                            servBfr,
                            sizeof( servBfr ),
                            NI_NUMERICHOST | NI_NUMERICSERV );
               switch ( sadr-&#62;sa_family )
               {
                  case AF_INET:   /* IPv4 address. */
                  {
                     struct sockaddr_in *p = (struct sockaddr_in*) sadr;
                     fprintf( stderr,
                              "   sin_addr  = sin_family: %d\n"
                              "               sin_addr:   %s\n"
                              "               sin_port:   %s\n",
                              p-&#62;sin_family,
                              hostBfr,
                              servBfr );
                     break;
                  }  /* End CASE of IPv4 address. */
                  case AF_INET6:   /* IPv6 address. */
                  {
                     struct sockaddr_in6 *p = (struct sockaddr_in6*) sadr;
                     fprintf( stderr,
                              "   sin6_addr = sin6_family:   %d\n"
                              "               sin6_addr:     %s\n"
                              "               sin6_port:     %s\n"
                              "               sin6_flowinfo: %d\n"
                              "               sin6_scope_id: %d\n",
                              p-&#62;sin6_family,
                              hostBfr,
                              servBfr,
                              p-&#62;sin6_flowinfo,
                              p-&#62;sin6_scope_id );
                     break;
                  }  /* End CASE of IPv6 address. */
                  default:   /* Can never get here, but for completeness. */
                  {
                     fprintf( stderr,
                              "%s (line %d): ERROR - Unknown address "
                              "family (%d).\n",
                              pgmName,
                              __LINE__,
                              sadr-&#62;sa_family );
                     break;
                  }  /* End DEFAULT case (unknown address family). */
               }  /* End SWITCH on address family. */
            }  /* End IF verbose mode. */
            /*
            ** Send the time-of-day to the client.
            */
            wBytes = timeLen;
            while ( wBytes &#62; 0 )
            {
               do
               {
                  count = sendto( desc[ idx ].fd,
                                  timeStr,
                                  wBytes,
                                  0,
                                  sadr,        /* Address &#38; address length   */
                                  sadrLen );   /*    received in recvfrom(). */
               } while ( ( count &#60; 0 ) &#38;&#38; ( errno == EINTR ) );
               CHK( count );   /* Check for a bona fide error. */
               wBytes -= count;
            }  /* End WHILE there is data to send. */
         }  /* End ELSE a UDP datagram is available. */
         desc[ idx ].revents = 0;   /* Clear the returned poll events. */
      }  /* End FOR each socket descriptor. */
   }  /* End WHILE forever. */
}  /* End tod() */</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2951"
>23.1.4.2. 'Daytime' TCP Client Code</A
></H4
><P
>The TCP client code is found in file tod6tc.c (time-of-day IPv6 TCP client). Once built, the TCP client may be started using the following command syntax (assuming tod6tc is the executable file):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tod6tc [-v] [-s scope_id] [host [service]]</PRE
></FONT
></TD
></TR
></TABLE
><P
>ARGUMENTS:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>host</DT
><DD
><P
>The hostname or IP address (dotted decimal or colon-hex) of the remote host providing the service. Default is "localhost".</P
></DD
><DT
>service</DT
><DD
><P
>The TCP service (or well-known port number) to which a connection attempt is made. Default is "daytime".</P
></DD
></DL
></DIV
><P
>OPTIONS:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-s</DT
><DD
><P
>This option is only meaningful for IPv6 addresses, and is used to set the scope identifier (i.e. the network interface on which to establish the connection). Default is "eth0". If host is a scoped address, this option is ignored.</P
></DD
><DT
>-v</DT
><DD
><P
>Turn on verbose mode.</P
></DD
></DL
></DIV
><P
>The TCP client source code contained in tod6tc.c follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/******************************************************************************
* File: tod6tc.c
* Description: Contains source code for an IPv6-capable 'daytime' TCP client.
* Author: John Wenker, Sr. Software Engineer
*         Performance Technologies, San Diego, USA
******************************************************************************/
/*
** System header files.
*/
#include &#60;errno.h&#62;        /* errno declaration and error codes.             */
#include &#60;net/if.h&#62;       /* if_nametoindex(3).                             */
#include &#60;netdb.h&#62;        /* getaddrinfo(3) and associated definitions.     */
#include &#60;netinet/in.h&#62;   /* sockaddr_in and sockaddr_in6 definitions.      */
#include &#60;stdio.h&#62;        /* printf(3) et al.                               */
#include &#60;stdlib.h&#62;       /* exit(2).                                       */
#include &#60;string.h&#62;       /* String manipulation and memory functions.      */
#include &#60;sys/socket.h&#62;   /* Socket functions (socket(2), connect(2), etc). */
#include &#60;unistd.h&#62;       /* getopt(3), read(2), etc.                       */
/*
** Constants &#38; macros.
*/
#define DFLT_HOST      "localhost"   /* Default server name.              */
#define DFLT_SCOPE_ID  "eth0"        /* Default scope identifier.         */
#define DFLT_SERVICE   "daytime"     /* Default service name.             */
#define INVALID_DESC   -1            /* Invalid file (socket) descriptor. */
#define MAXBFRSIZE     256           /* Max bfr sz to read remote TOD.    */
#define VALIDOPTS      "s:v"         /* Valid command options.            */
/*
** Type definitions (for convenience).
*/
typedef enum { false = 0, true } boolean;
typedef struct sockaddr_in       sockaddr_in_t;
typedef struct sockaddr_in6      sockaddr_in6_t;
/*
** Prototypes for internal helper functions.
*/
static int  openSckt( const char   *host,
                      const char   *service,
                      unsigned int  scopeId );
static void tod( int sckt );
/*
** Global (within this file only) data objects.
*/
static const char *pgmName;           /* Program name (w/o directory). */
static boolean     verbose = false;   /* Verbose mode.                 */
/*
** Usage macro.
*/
#define USAGE                                                            \
        {                                                                \
           fprintf( stderr,                                              \
                    "Usage: %s [-v] [-s scope_id] [host [service]]\n",   \
                    pgmName );                                           \
           exit( 127 );                                                  \
        }  /* End USAGE macro. */
/*
** This "macro" (even though it's really a function) is loosely based on the
** CHK() macro by Dr. V. Vinge (see server code).  The status parameter is
** a boolean expression indicating the return code from one of the usual system
** calls that returns -1 on error.  If a system call error occurred, an alert
** is written to stderr.  It returns a boolean value indicating success/failure
** of the system call.
**
** Example: if ( !SYSCALL( "write",
**                         count = write( fd, bfr, size ) ) )
**          {
**             // Error processing... but SYSCALL() will have already taken
**             // care of dumping an error alert to stderr.
**          }
*/
static __inline boolean SYSCALL( const char *syscallName,
                                 int         lineNbr,
                                 int         status )
{
   if ( ( status == -1 ) &#38;&#38; verbose )
   {
      fprintf( stderr,
               "%s (line %d): System call failed ('%s') - %s.\n",
               pgmName,
               lineNbr,
               syscallName,
               strerror( errno ) );
   }
   return status != -1;   /* True if the system call was successful. */
}  /* End SYSCALL() */
/******************************************************************************
* Function: main
*
* Description:
*    Connect to a remote time-of-day service and write the remote host's TOD to
*    stdout.
*
* Parameters:
*    The usual argc &#38; argv parameters to a main() program.
*
* Return Value:
*    This function always returns zero.
******************************************************************************/
int main( int   argc,
          char *argv[ ] )
{
   const char   *host     = DFLT_HOST;
   int           opt;
   int           sckt;
   unsigned int  scopeId  = if_nametoindex( DFLT_SCOPE_ID );
   const char   *service  = DFLT_SERVICE;
   /*
   ** Determine the program name (w/o directory prefix).
   */
   pgmName = (const char*) strrchr( argv[ 0 ], '/' );
   pgmName = pgmName == NULL  ?  argv[ 0 ]  :  pgmName+1;
   /*
   ** Process command line options.
   */
   opterr = 0;   /* Turns off "invalid option" error messages. */
   while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) != -1 )
   {
      switch ( opt )
      {
         case 's':   /* Scope identifier (IPv6 kluge). */
         {
            scopeId = if_nametoindex( optarg );
            if ( scopeId == 0 )
            {
               fprintf( stderr,
                        "%s: Unknown network interface (%s).\n",
                        pgmName,
                        optarg );
               USAGE;
            }
            break;
         }
         case 'v':   /* Verbose mode. */
         {
            verbose = true;
            break;
         }
         default:
         {
            USAGE;
         }
      }  /* End SWITCH on command option. */
   } /* End WHILE processing command options. */
   /*
   ** Process command arguments.  At the end of the above loop, optind is the
   ** index of the first NON-option argv element.
   */
   switch ( argc - optind )
   {
      case 2:   /* Both host &#38; service are specified on the command line. */
      {
          service = argv[ optind + 1 ];
          /***** Fall through *****/
      }
      case 1:   /* Host is specified on the command line. */
      {
          host = argv[ optind ];
          /***** Fall through *****/
      }
      case 0:   /* Use default host &#38; service. */
      {
          break;
      }
      default:
      {
         USAGE;
      }
   }  /* End SWITCH on number of command arguments. */
   /*
   ** Open a connection to the indicated host/service.
   **
   ** Note that if all three of the following conditions are met, then the
   ** scope identifier remains unresolved at this point.
   **    1) The default network interface is unknown for some reason.
   **    2) The -s option was not used on the command line.
   **    3) An IPv6 "scoped address" was not specified for the hostname on the
   **       command line.
   ** If the above three conditions are met, then only an IPv4 socket can be
   ** opened (connect(2) fails without the scope ID properly set for IPv6
   ** sockets).
   */
   if ( ( sckt = openSckt( host,
                           service,
                           scopeId ) ) == INVALID_DESC )
   {
      fprintf( stderr,
               "%s: Sorry... a connection could not be established.\n",
               pgmName );
      exit( 1 );
   }
   /*
   ** Get the remote time-of-day.
   */
   tod( sckt );
   /*
   ** Close the connection and terminate.
   */
   (void) SYSCALL( "close",
                   __LINE__,
                   close( sckt ) );
   return 0;
}  /* End main() */
/******************************************************************************
* Function: openSckt
*
* Description:
*    Sets up a TCP connection to a remote server.  Getaddrinfo(3) is used to
*    perform lookup functions and can return multiple address records (i.e. a
*    list of 'struct addrinfo' records).  This function traverses the list and
*    tries to establish a connection to the remote server.  The function ends
*    when either a connection has been established or all records in the list
*    have been processed.
*
* Parameters:
*    host    - A pointer to a character string representing the hostname or IP
*              address (IPv4 or IPv6) of the remote server.
*    service - A pointer to a character string representing the service name or
*              well-known port number.
*    scopeId - For IPv6 sockets only.  This is the index corresponding to the
*              network interface on which to set up the connection.  This
*              parameter is ignored for IPv4 sockets or when an IPv6 "scoped
*              address" is specified in 'host' (i.e. where the colon-hex
*              network address is augmented with the scope ID).
*
* Return Value:
*    Returns the socket descriptor for the connection, or INVALID_DESC if all
*    address records have been processed and a connection could not be
*    established.
******************************************************************************/
static int openSckt( const char   *host,
                     const char   *service,
                     unsigned int  scopeId )
{
   struct addrinfo *ai;
   int              aiErr;
   struct addrinfo *aiHead;
   struct addrinfo  hints;
   sockaddr_in6_t  *pSadrIn6;
   int              sckt;
   /*
   ** Initialize the 'hints' structure for getaddrinfo(3).
   **
   ** Notice that the 'ai_family' field is set to PF_UNSPEC, indicating to
   ** return both IPv4 and IPv6 address records for the host/service.  Most of
   ** the time, the user isn't going to care whether an IPv4 connection or an
   ** IPv6 connection is established; the user simply wants to exchange data
   ** with the remote host and doesn't care how it's done.  Sometimes, however,
   ** the user might want to explicitly specify the type of underlying socket.
   ** It is left as an exercise for the motivated reader to add a command line
   ** option allowing the user to specify the IP protocol, and then process the
   ** list of addresses accordingly (it's not that difficult).
   */
   memset( &#38;hints, 0, sizeof( hints ) );
   hints.ai_family   = PF_UNSPEC;     /* IPv4 or IPv6 records (don't care). */
   hints.ai_socktype = SOCK_STREAM;   /* Connection-oriented byte stream.   */
   hints.ai_protocol = IPPROTO_TCP;   /* TCP transport layer protocol only. */
   /*
   ** Look up the host/service information.
   */
   if ( ( aiErr = getaddrinfo( host,
                               service,
                               &#38;hints,
                               &#38;aiHead ) ) != 0 )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               gai_strerror( aiErr ) );
      return INVALID_DESC;
   }
   /*
   ** Go through the list and try to open a connection.  Continue until either
   ** a connection is established or the entire list is exhausted.
   */
   for ( ai = aiHead,   sckt = INVALID_DESC;
         ( ai != NULL ) &#38;&#38; ( sckt == INVALID_DESC );
         ai = ai-&#62;ai_next )
   {
      /*
      ** IPv6 kluge.  Make sure the scope ID is set.
      */
      if ( ai-&#62;ai_family == PF_INET6 )
      {
         pSadrIn6 = (sockaddr_in6_t*) ai-&#62;ai_addr;
         if ( pSadrIn6-&#62;sin6_scope_id == 0 )
         {
            pSadrIn6-&#62;sin6_scope_id = scopeId;
         }  /* End IF the scope ID wasn't set. */
      }  /* End IPv6 kluge. */
      /*
      ** Display the address info for the remote host.
      */
      if ( verbose )
      {
         /*
         ** Temporary character string buffers for host &#38; service.
         */
         char hostBfr[ NI_MAXHOST ];
         char servBfr[ NI_MAXSERV ];
         /*
         ** Display the address information just fetched.  Start with the
         ** common (protocol-independent) stuff first.
         */
         fprintf( stderr,
                  "Address info:\n"
                  "   ai_flags     = 0x%02X\n"
                  "   ai_family    = %d (PF_INET = %d, PF_INET6 = %d)\n"
                  "   ai_socktype  = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                  "   ai_protocol  = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                  "   ai_addrlen   = %d (sockaddr_in = %d, "
                  "sockaddr_in6 = %d)\n",
                  ai-&#62;ai_flags,
                  ai-&#62;ai_family,
                  PF_INET,
                  PF_INET6,
                  ai-&#62;ai_socktype,
                  SOCK_STREAM,
                  SOCK_DGRAM,
                  ai-&#62;ai_protocol,
                  IPPROTO_TCP,
                  IPPROTO_UDP,
                  ai-&#62;ai_addrlen,
                  sizeof( struct sockaddr_in ),
                  sizeof( struct sockaddr_in6 ) );
         /*
         ** Display the protocol-specific formatted address.
         */
         getnameinfo( ai-&#62;ai_addr,
                      ai-&#62;ai_addrlen,
                      hostBfr,
                      sizeof( hostBfr ),
                      servBfr,
                      sizeof( servBfr ),
                      NI_NUMERICHOST | NI_NUMERICSERV );
         switch ( ai-&#62;ai_family )
         {
            case PF_INET:   /* IPv4 address record. */
            {
               sockaddr_in_t *pSadrIn = (sockaddr_in_t*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin_family: %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin_addr:   %s\n"
                        "                  sin_port:   %s\n",
                        pSadrIn-&#62;sin_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr );
               break;
            }  /* End CASE of IPv4 record. */
            case PF_INET6:   /* IPv6 address record. */
            {
               pSadrIn6 = (sockaddr_in6_t*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin6_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin6_addr:     %s\n"
                        "                  sin6_port:     %s\n"
                        "                  sin6_flowinfo: %d\n"
                        "                  sin6_scope_id: %d\n",
                        pSadrIn6-&#62;sin6_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr,
                        pSadrIn6-&#62;sin6_flowinfo,
                        pSadrIn6-&#62;sin6_scope_id );
               break;
            }  /* End CASE of IPv6 record. */
            default:   /* Can never get here, but just for completeness. */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                        pgmName,
                        __LINE__,
                        ai-&#62;ai_family );
               break;
            }  /* End DEFAULT case (unknown protocol family). */
         }  /* End SWITCH on protocol family. */
      }  /* End IF verbose mode. */
      /*
      ** Create a socket.
      */
      if ( !SYSCALL( "socket",
                     __LINE__,
                     sckt = socket( ai-&#62;ai_family,
                                    ai-&#62;ai_socktype,
                                    ai-&#62;ai_protocol ) ) )
      {
         sckt = INVALID_DESC;
         continue;   /* Try the next address record in the list. */
      }
      /*
      ** Connect to the remote host.
      */
      if ( !SYSCALL( "connect",
                     __LINE__,
                     connect( sckt,
                              ai-&#62;ai_addr,
                              ai-&#62;ai_addrlen ) ) )
      {
         (void) close( sckt );   /* Could use SYSCALL() again here, but why? */
         sckt = INVALID_DESC;
         continue;   /* Try the next address record in the list. */
      }
   }  /* End FOR each address record returned by getaddrinfo(3). */
   /*
   ** Clean up &#38; return.
   */
   freeaddrinfo( aiHead );
   return sckt;
}  /* End openSckt() */
/******************************************************************************
* Function: tod
*
* Description:
*    Receive the time-of-day from the remote server and write it to stdout.
*
* Parameters:
*    sckt - The socket descriptor for the connection.
*
* Return Value: None.
******************************************************************************/
static void tod( int sckt )
{
   char bfr[ MAXBFRSIZE+1 ];
   int  inBytes;
   /*
   ** The client never sends anything, so shut down the write side of the
   ** connection.
   */
   if ( !SYSCALL( "shutdown",
                  __LINE__,
                  shutdown( sckt, SHUT_WR ) ) )
   {
      return;
   }
   /*
   ** Read the time-of-day from the remote host.
   */
   do
   {
      if ( !SYSCALL( "read",
                     __LINE__,
                     inBytes = read( sckt,
                                     bfr,
                                     MAXBFRSIZE ) ) )
      {
         return;
      }
      bfr[ inBytes ] = '\0';   /* Null-terminate the received string. */
      fputs( bfr, stdout );    /* Null string if EOF (inBytes == 0).  */
   } while ( inBytes &#62; 0 );
   fflush( stdout );
}  /* End tod() */</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN2977"
>23.1.4.3. 'Daytime' UDP Client Code</A
></H4
><P
>The UDP client code is found in file tod6uc.c (time-of-day IPv6 UDP client). It is almost an exact duplicate of the TCP client (and in fact was derived from it), but is included in this HowTo for completeness. Once built, the UDP client may be started using the following command syntax (assuming tod6uc is the executable file):</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tod6uc [-v] [-s scope_id] [host [service]]</PRE
></FONT
></TD
></TR
></TABLE
><P
>ARGUMENTS:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>host</DT
><DD
><P
>The hostname or IP address (dotted decimal or colon-hex) of the remote host providing the service. Default is "localhost".</P
></DD
><DT
>service</DT
><DD
><P
>The UDP service (or well-known port number) to which datagrams are sent. Default is "daytime".</P
></DD
></DL
></DIV
><P
>OPTIONS:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>-s</DT
><DD
><P
>This option is only meaningful for IPv6 addresses, and is used to set the scope identifier (i.e. the network interface on which to exchange datagrams). Default is "eth0". If host is a scoped address, this option is ignored.</P
></DD
><DT
>-v</DT
><DD
><P
>Turn on verbose mode.</P
></DD
></DL
></DIV
><P
>The UDP client source code contained in tod6uc.c follows:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>/******************************************************************************
* File: tod6uc.c
* Description: Contains source code for an IPv6-capable 'daytime' UDP client.
* Author: John Wenker, Sr. Software Engineer
*         Performance Technologies, San Diego, USA
******************************************************************************/
/*
** System header files.
*/
#include &#60;errno.h&#62;        /* errno declaration and error codes.             */
#include &#60;net/if.h&#62;       /* if_nametoindex(3).                             */
#include &#60;netdb.h&#62;        /* getaddrinfo(3) and associated definitions.     */
#include &#60;netinet/in.h&#62;   /* sockaddr_in and sockaddr_in6 definitions.      */
#include &#60;stdio.h&#62;        /* printf(3) et al.                               */
#include &#60;stdlib.h&#62;       /* exit(2).                                       */
#include &#60;string.h&#62;       /* String manipulation and memory functions.      */
#include &#60;sys/socket.h&#62;   /* Socket functions (socket(2), connect(2), etc). */
#include &#60;unistd.h&#62;       /* getopt(3), recvfrom(2), sendto(2), etc.        */
/*
** Constants &#38; macros.
*/
#define DFLT_HOST      "localhost"   /* Default server name.              */
#define DFLT_SCOPE_ID  "eth0"        /* Default scope identifier.         */
#define DFLT_SERVICE   "daytime"     /* Default service name.             */
#define INVALID_DESC   -1            /* Invalid file (socket) descriptor. */
#define MAXBFRSIZE     256           /* Max bfr sz to read remote TOD.    */
#define VALIDOPTS      "s:v"         /* Valid command options.            */
/*
** Type definitions (for convenience).
*/
typedef enum { false = 0, true } boolean;
typedef struct sockaddr_in       sockaddr_in_t;
typedef struct sockaddr_in6      sockaddr_in6_t;
/*
** Prototypes for internal helper functions.
*/
static int  openSckt( const char   *host,
                      const char   *service,
                      unsigned int  scopeId );
static void tod( int sckt );
/*
** Global (within this file only) data objects.
*/
static const char *pgmName;           /* Program name (w/o directory). */
static boolean     verbose = false;   /* Verbose mode.                 */
/*
** Usage macro.
*/
#define USAGE                                                            \
        {                                                                \
           fprintf( stderr,                                              \
                    "Usage: %s [-v] [-s scope_id] [host [service]]\n",   \
                    pgmName );                                           \
           exit( 127 );                                                  \
        }  /* End USAGE macro. */
/*
** This "macro" (even though it's really a function) is loosely based on the
** CHK() macro by Dr. V. Vinge (see server code).  The status parameter is
** a boolean expression indicating the return code from one of the usual system
** calls that returns -1 on error.  If a system call error occurred, an alert
** is written to stderr.  It returns a boolean value indicating success/failure
** of the system call.
**
** Example: if ( !SYSCALL( "write",
**                         count = write( fd, bfr, size ) ) )
**          {
**             // Error processing... but SYSCALL() will have already taken
**             // care of dumping an error alert to stderr.
**          }
*/
static __inline boolean SYSCALL( const char *syscallName,
                                 int         lineNbr,
                                 int         status )
{
   if ( ( status == -1 ) &#38;&#38; verbose )
   {
      fprintf( stderr,
               "%s (line %d): System call failed ('%s') - %s.\n",
               pgmName,
               lineNbr,
               syscallName,
               strerror( errno ) );
   }
   return status != -1;   /* True if the system call was successful. */
}  /* End SYSCALL() */
/******************************************************************************
* Function: main
*
* Description:
*    Connect to a remote time-of-day service and write the remote host's TOD to
*    stdout.
*
* Parameters:
*    The usual argc &#38; argv parameters to a main() program.
*
* Return Value:
*    This function always returns zero.
******************************************************************************/
int main( int   argc,
          char *argv[ ] )
{
   const char   *host     = DFLT_HOST;
   int           opt;
   int           sckt;
   unsigned int  scopeId  = if_nametoindex( DFLT_SCOPE_ID );
   const char   *service  = DFLT_SERVICE;
   /*
   ** Determine the program name (w/o directory prefix).
   */
   pgmName = (const char*) strrchr( argv[ 0 ], '/' );
   pgmName = pgmName == NULL  ?  argv[ 0 ]  :  pgmName+1;
   /*
   ** Process command line options.
   */
   opterr = 0;   /* Turns off "invalid option" error messages. */
   while ( ( opt = getopt( argc, argv, VALIDOPTS ) ) != -1 )
   {
      switch ( opt )
      {
         case 's':   /* Scope identifier (IPv6 kluge). */
         {
            scopeId = if_nametoindex( optarg );
            if ( scopeId == 0 )
            {
               fprintf( stderr,
                        "%s: Unknown network interface (%s).\n",
                        pgmName,
                        optarg );
               USAGE;
            }
            break;
         }
         case 'v':   /* Verbose mode. */
         {
            verbose = true;
            break;
         }
         default:
         {
            USAGE;
         }
      }  /* End SWITCH on command option. */
   } /* End WHILE processing command options. */
   /*
   ** Process command arguments.  At the end of the above loop, optind is the
   ** index of the first NON-option argv element.
   */
   switch ( argc - optind )
   {
      case 2:   /* Both host &#38; service are specified on the command line. */
      {
          service = argv[ optind + 1 ];
          /***** Fall through *****/
      }
      case 1:   /* Host is specified on the command line. */
      {
          host = argv[ optind ];
          /***** Fall through *****/
      }
      case 0:   /* Use default host &#38; service. */
      {
          break;
      }
      default:
      {
         USAGE;
      }
   }  /* End SWITCH on number of command arguments. */
   /*
   ** Open a connection to the indicated host/service.
   **
   ** Note that if all three of the following conditions are met, then the
   ** scope identifier remains unresolved at this point.
   **    1) The default network interface is unknown for some reason.
   **    2) The -s option was not used on the command line.
   **    3) An IPv6 "scoped address" was not specified for the hostname on the
   **       command line.
   ** If the above three conditions are met, then only an IPv4 socket can be
   ** opened (connect(2) fails without the scope ID properly set for IPv6
   ** sockets).
   */
   if ( ( sckt = openSckt( host,
                           service,
                           scopeId ) ) == INVALID_DESC )
   {
      fprintf( stderr,
               "%s: Sorry... a connectionless socket could "
               "not be set up.\n",
               pgmName );
      exit( 1 );
   }
   /*
   ** Get the remote time-of-day.
   */
   tod( sckt );
   /*
   ** Close the connection and terminate.
   */
   (void) SYSCALL( "close",
                   __LINE__,
                   close( sckt ) );
   return 0;
}  /* End main() */
/******************************************************************************
* Function: openSckt
*
* Description:
*    Sets up a UDP socket to a remote server.  Getaddrinfo(3) is used to
*    perform lookup functions and can return multiple address records (i.e. a
*    list of 'struct addrinfo' records).  This function traverses the list and
*    tries to establish a connection to the remote server.  The function ends
*    when either a connection has been established or all records in the list
*    have been processed.
*
* Parameters:
*    host    - A pointer to a character string representing the hostname or IP
*              address (IPv4 or IPv6) of the remote server.
*    service - A pointer to a character string representing the service name or
*              well-known port number.
*    scopeId - For IPv6 sockets only.  This is the index corresponding to the
*              network interface on which to exchange datagrams.  This
*              parameter is ignored for IPv4 sockets or when an IPv6 "scoped
*              address" is specified in 'host' (i.e. where the colon-hex
*              network address is augmented with the scope ID).
*
* Return Value:
*    Returns the socket descriptor for the connection, or INVALID_DESC if all
*    address records have been processed and a socket could not be initialized.
******************************************************************************/
static int openSckt( const char   *host,
                     const char   *service,
                     unsigned int  scopeId )
{
   struct addrinfo *ai;
   int              aiErr;
   struct addrinfo *aiHead;
   struct addrinfo  hints;
   sockaddr_in6_t  *pSadrIn6;
   int              sckt;
   /*
   ** Initialize the 'hints' structure for getaddrinfo(3).
   **
   ** Notice that the 'ai_family' field is set to PF_UNSPEC, indicating to
   ** return both IPv4 and IPv6 address records for the host/service.  Most of
   ** the time, the user isn't going to care whether an IPv4 connection or an
   ** IPv6 connection is established; the user simply wants to exchange data
   ** with the remote host and doesn't care how it's done.  Sometimes, however,
   ** the user might want to explicitly specify the type of underlying socket.
   ** It is left as an exercise for the motivated reader to add a command line
   ** option allowing the user to specify the IP protocol, and then process the
   ** list of addresses accordingly (it's not that difficult).
   */
   memset( &#38;hints, 0, sizeof( hints ) );
   hints.ai_family   = PF_UNSPEC;     /* IPv4 or IPv6 records (don't care). */
   hints.ai_socktype = SOCK_DGRAM;    /* Connectionless communication.      */
   hints.ai_protocol = IPPROTO_UDP;   /* UDP transport layer protocol only. */
   /*
   ** Look up the host/service information.
   */
   if ( ( aiErr = getaddrinfo( host,
                               service,
                               &#38;hints,
                               &#38;aiHead ) ) != 0 )
   {
      fprintf( stderr,
               "%s (line %d): ERROR - %s.\n",
               pgmName,
               __LINE__,
               gai_strerror( aiErr ) );
      return INVALID_DESC;
   }
   /*
   ** Go through the list and try to open a connection.  Continue until either
   ** a connection is established or the entire list is exhausted.
   */
   for ( ai = aiHead,   sckt = INVALID_DESC;
         ( ai != NULL ) &#38;&#38; ( sckt == INVALID_DESC );
         ai = ai-&#62;ai_next )
   {
      /*
      ** IPv6 kluge.  Make sure the scope ID is set.
      */
      if ( ai-&#62;ai_family == PF_INET6 )
      {
         pSadrIn6 = (sockaddr_in6_t*) ai-&#62;ai_addr;
         if ( pSadrIn6-&#62;sin6_scope_id == 0 )
         {
            pSadrIn6-&#62;sin6_scope_id = scopeId;
         }  /* End IF the scope ID wasn't set. */
      }  /* End IPv6 kluge. */
      /*
      ** Display the address info for the remote host.
      */
      if ( verbose )
      {
         /*
         ** Temporary character string buffers for host &#38; service.
         */
         char hostBfr[ NI_MAXHOST ];
         char servBfr[ NI_MAXSERV ];
         /*
         ** Display the address information just fetched.  Start with the
         ** common (protocol-independent) stuff first.
         */
         fprintf( stderr,
                  "Address info:\n"
                  "   ai_flags     = 0x%02X\n"
                  "   ai_family    = %d (PF_INET = %d, PF_INET6 = %d)\n"
                  "   ai_socktype  = %d (SOCK_STREAM = %d, SOCK_DGRAM = %d)\n"
                  "   ai_protocol  = %d (IPPROTO_TCP = %d, IPPROTO_UDP = %d)\n"
                  "   ai_addrlen   = %d (sockaddr_in = %d, "
                  "sockaddr_in6 = %d)\n",
                  ai-&#62;ai_flags,
                  ai-&#62;ai_family,
                  PF_INET,
                  PF_INET6,
                  ai-&#62;ai_socktype,
                  SOCK_STREAM,
                  SOCK_DGRAM,
                  ai-&#62;ai_protocol,
                  IPPROTO_TCP,
                  IPPROTO_UDP,
                  ai-&#62;ai_addrlen,
                  sizeof( struct sockaddr_in ),
                  sizeof( struct sockaddr_in6 ) );
         /*
         ** Display the protocol-specific formatted address.
         */
         getnameinfo( ai-&#62;ai_addr,
                      ai-&#62;ai_addrlen,
                      hostBfr,
                      sizeof( hostBfr ),
                      servBfr,
                      sizeof( servBfr ),
                      NI_NUMERICHOST | NI_NUMERICSERV );
         switch ( ai-&#62;ai_family )
         {
            case PF_INET:   /* IPv4 address record. */
            {
               sockaddr_in_t *pSadrIn = (sockaddr_in_t*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin_family: %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin_addr:   %s\n"
                        "                  sin_port:   %s\n",
                        pSadrIn-&#62;sin_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr );
               break;
            }  /* End CASE of IPv4 record. */
            case PF_INET6:   /* IPv6 address record. */
            {
               pSadrIn6 = (sockaddr_in6_t*) ai-&#62;ai_addr;
               fprintf( stderr,
                        "   ai_addr      = sin6_family:   %d (AF_INET = %d, "
                        "AF_INET6 = %d)\n"
                        "                  sin6_addr:     %s\n"
                        "                  sin6_port:     %s\n"
                        "                  sin6_flowinfo: %d\n"
                        "                  sin6_scope_id: %d\n",
                        pSadrIn6-&#62;sin6_family,
                        AF_INET,
                        AF_INET6,
                        hostBfr,
                        servBfr,
                        pSadrIn6-&#62;sin6_flowinfo,
                        pSadrIn6-&#62;sin6_scope_id );
               break;
            }  /* End CASE of IPv6 record. */
            default:   /* Can never get here, but just for completeness. */
            {
               fprintf( stderr,
                        "%s (line %d): ERROR - Unknown protocol family (%d).\n",
                        pgmName,
                        __LINE__,
                        ai-&#62;ai_family );
               break;
            }  /* End DEFAULT case (unknown protocol family). */
         }  /* End SWITCH on protocol family. */
      }  /* End IF verbose mode. */
      /*
      ** Create a socket.
      */
      if ( !SYSCALL( "socket",
                     __LINE__,
                     sckt = socket( ai-&#62;ai_family,
                                    ai-&#62;ai_socktype,
                                    ai-&#62;ai_protocol ) ) )
      {
         sckt = INVALID_DESC;
         continue;   /* Try the next address record in the list. */
      }
      /*
      ** Set the target destination for the remote host on this socket.  That
      ** is, this socket only communicates with the specified host.
      */
      if ( !SYSCALL( "connect",
                     __LINE__,
                     connect( sckt,
                              ai-&#62;ai_addr,
                              ai-&#62;ai_addrlen ) ) )
      {
         (void) close( sckt );   /* Could use SYSCALL() again here, but why? */
         sckt = INVALID_DESC;
         continue;   /* Try the next address record in the list. */
      }
   }  /* End FOR each address record returned by getaddrinfo(3). */
   /*
   ** Clean up &#38; return.
   */
   freeaddrinfo( aiHead );
   return sckt;
}  /* End openSckt() */
/******************************************************************************
* Function: tod
*
* Description:
*    Receive the time-of-day from the remote server and write it to stdout.
*
* Parameters:
*    sckt - The socket descriptor for the connection.
*
* Return Value: None.
******************************************************************************/
static void tod( int sckt )
{
   char bfr[ MAXBFRSIZE+1 ];
   int  inBytes;
   /*
   ** Send a datagram to the server to wake it up.  The content isn't
   ** important, but something must be sent to let it know we want the TOD.
   */
   if ( !SYSCALL( "write",
                  __LINE__,
                  write( sckt, "Are you there?", 14 ) ) )
   {
      return;
   }
   /*
   ** Read the time-of-day from the remote host.
   */
   if ( !SYSCALL( "read",
                  __LINE__,
                  inBytes = read( sckt,
                                  bfr,
                                  MAXBFRSIZE ) ) )
   {
      return;
   }
   bfr[ inBytes ] = '\0';   /* Null-terminate the received string. */
   fputs( bfr, stdout );    /* Null string if EOF (inBytes == 0).  */
   fflush( stdout );
}  /* End tod() */</PRE
></FONT
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3003"
>23.2. Other programming languages</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3005"
>23.2.1. JAVA</A
></H3
><P
>Sun Java versions since 1.4 are IPv6 enabled, see e.g. <A
HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/net/Inet6Address.html"
TARGET="_top"
>Inet6Address (1.5/5.0)</A
> class. Hints are available in the <EM
>Networking IPv6 User Guide for JDK/JRE</EM
> <A
HREF="http://java.sun.com/j2se/1.4.2/docs/guide/net/ipv6_guide/index.html"
TARGET="_top"
>1.4</A
> and <A
HREF="http://java.sun.com/j2se/1.5.0/docs/guide/net/ipv6_guide/index.html"
TARGET="_top"
>1.5 (5.0)</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3012"
>23.2.2. Perl</A
></H3
><P
>As of May 2007 it's not known that the Perl core itself already supports IPv6. It can be added by using following modules:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://search.cpan.org/~umemoto/Socket6/"
TARGET="_top"
>Socket6</A
></P
></LI
></UL
><P
>Anyway, some other modules exist for/with IPv6 support (e.g. Net::IP), search for “IPv6” on <A
HREF="http://search.cpan.org/"
TARGET="_top"
>http://search.cpan.org/</A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-INTEROPERABILITY"
></A
>Chapter 24. Interoperability</H1
><P
>The <A
HREF="http://www.tahi.org/"
TARGET="_top"
>TAHI Project</A
> checks the interoperability of different operating systems regarding the implementation of IPv6 features. Linux kernel already got the <A
HREF="http://www.linux-ipv6.org/v6ready/"
TARGET="_top"
>IPv6 Ready Logo Phase 1</A
>. </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="CHAPTER-INFORMATION"
></A
>Chapter 25. Further information and URLs</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="INFORMATION-BOOKS"
>25.1. Paper printed books, articles, online reviews (mixed)</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3030"
>25.1.1. Printed Books (English)</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN3032"
>25.1.1.1. Cisco</A
></H4
><P
></P
><UL
><LI
><P
>Cisco Self-Study: Implementing IPv6 Networks (IPV6) by Regis Desmeules. Cisco Press; ISBN 1587050862; 500 pages; 1st edition (April 11, 2003).
Note: This item will be published on April 11, 2003.</P
></LI
><LI
><P
>Configuring IPv6 with Cisco IOS by Sam Brown, Sam Browne, Neal Chen, Robbie Harrell, Edgar, Jr. Parenti (Editor), Eric Knipp (Editor), Paul Fong (Editor)362 pages; Syngress Media Inc; ISBN 1928994849; (July 12, 2002).</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3039"
>25.1.1.2. General</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.benedikt-stockebrand.de/books_e.html#ipv6-in-practice"
TARGET="_top"
>IPv6 in Practice: A Unixer's Guide to the Next Generation Internet</A
> von Benedikt Stockebrand, November 2006; ISBN 3-540-24524-3</P
></LI
><LI
><P
><A
HREF="http://www.sunny.ch/publications/f_ipv6.htm"
TARGET="_top"
>IPv6 Essentials</A
> by Silvia Hagen, 2nd Edition, May 2006; ISBN 0-5961-0058-2
<A
HREF="http://www.oreilly.com/catalog/ipv6ess/"
TARGET="_top"
>ToC, Index, Sample Chapter etc.</A
>; <A
HREF="http://press.oreilly.com/ipv6ess.html"
TARGET="_top"
>O'Reilly Pressrelease</A
></P
></LI
><LI
><P
>IPv6: The New Internet Protocol. By Christian Huitema; Published by Prentice-Hall; ISBN 0138505055. 
Description: This book, written by Christian Huitema - a member of the InternetArchitecture Board, gives an excellent description of IPv6, how it differs from IPv4, and the hows and whys of it's development. 
Source: <A
HREF="http://www.cs.uu.nl/wais/html/na-dir/internet/tcp-ip/resource-list.html"
TARGET="_top"
>http://www.cs.uu.nl/wais/html/na-dir/internet/tcp-ip/resource-list.html</A
></P
></LI
><LI
><P
><A
HREF="http://www.epinions.com/book_mu-3402412/display_~full_specs"
TARGET="_top"
>IPv6 Networks</A
> by Niles, Kitty; (ISBN 0070248079); 550 pages; Date Published 05/01/1998.</P
></LI
><LI
><P
>Implementing IPV6. Supporting the Next Generation Internet Protocols by P. E. Miller, Mark A. Miller; Publisher: John Wiley &#38; Sons; ISBN 0764545892; 2nd edition (March 15, 2000); 402 pages.</P
></LI
><LI
><P
>Big Book of Ipv6 Addressing Rfcs by Peter H. Salus (Compiler), Morgan Kaufmann Publishers, April 2000, 450 pages ISBN 0126167702. </P
></LI
><LI
><P
><A
HREF="http://www.epinions.com/book_mu-3922588/display_~full_specs"
TARGET="_top"
>Understanding IPV6</A
> by Davies, Joseph; ISBN 0735612455; Date Published 05/01/2001; Number of Pages: 350.</P
></LI
><LI
><P
>Migrating to IPv6 - IPv6 in Practice by Marc Blanchet Publisher: John Wiley &#38; Sons; ISBN 0471498920; 1st edition (November 2002); 368 pages.</P
></LI
><LI
><P
>Ipv6 Network Programming by Jun-ichiro Hagino; ISBN 1555583180</P
></LI
><LI
><P
><A
HREF="http://www.nwfusion.com/news/2000/1023ipv6.html"
TARGET="_top"
>Wireless boosting IPv6</A
> by Carolyn Duffy Marsan, 10/23/2000.</P
></LI
><LI
><P
><A
HREF="http://www.oreillynet.com/search/index.ncsp?sp-q=IPv6"
TARGET="_top"
>O'reilly Network search for keyword IPv6</A
> results in 29 hits (28. January 2002)</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3073"
>25.1.2. Articles, eBooks, Online Reviews (mixed)</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.onlamp.com/pub/a/onlamp/2001/06/01/ipv6_tutorial.html"
TARGET="_top"
>Getting Connected with 6to4</A
> by Huber Feyrer, 06/01/2001</P
></LI
><LI
><P
>Transient Addressing for Related Processes: Improved Firewalling by Using IPv6 and Multiple Addresses per Host; written by Peter M. Gleiz, Steven M. Bellovin (<A
HREF="http://www.securiteinfo.com/ebooks/pdf/tarp.pdf"
TARGET="_top"
>PC-PDF-Version</A
>; <A
HREF="http://www.securiteinfo.com/ebooks/palm/tarp.pdf"
TARGET="_top"
>Palm-PDF-Version</A
>; <A
HREF="http://www.securiteinfo.com/ebooks/pdb/tarp.pdb"
TARGET="_top"
>PDB-Version</A
>)</P
></LI
><LI
><P
><A
HREF="http://www.ip6.com/index.html"
TARGET="_top"
>Internetworking IPv6 with Cisco Routers</A
> by Silvano Gai, McGrawHill Italia, 1997. The 13 chapters and appendix A-D are downloadable as PDF-documents.</P
></LI
><LI
><P
><A
HREF="http://www.csc.fi/~psavola/residential.html"
TARGET="_top"
>Migration and Co-existence of IPv4 and IPv6 in Residential Networks</A
> by Pekka Savola, CSC/FUNET, 2002</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INFORMATION-SCIENCEPUBLICATION"
>25.1.3. Science Publications (abstracts, bibliographies, online resources)</A
></H3
><P
>See also: <A
HREF="http://liinwww.ira.uka.de/mpsbib?query=ipv6&#38;maxnum=200"
TARGET="_top"
>liinwww.ira.uka.de/ipv6</A
> or <A
HREF="http://www.google.com/scholar?q=ipv6"
TARGET="_top"
>Google / Scholar / IPv6</A
></P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.ac.uk/gtpv6/workplan.html"
TARGET="_top"
>GEANT IPv6 Workplan</A
></P
></LI
><LI
><P
><A
HREF="http://www.ipv6.ac.uk/bermuda2/"
TARGET="_top"
>IPv6 Trials on UK Academic Networks: Bermuda Project Aug.2002</A
>: Participants - Getting connected - Project deliverables - Network topology - Address assignments - Wireless IPv6 access - IPv6 migration - Project presentations - Internet 2 - Other IPv6 projects - IPv6 fora and standards Bermuda 2...</P
></LI
><LI
><P
><A
HREF="http://www.ipv6.ac.uk/"
TARGET="_top"
>http://www.ipv6.ac.uk/</A
></P
></LI
><LI
><P
><A
HREF="http://www.ipv6.ecs.soton.ac.uk/"
TARGET="_top"
>IPv6 at the University of Southampton</A
></P
></LI
><LI
><P
>Microsoft Research IPv6 Implementation (MSRIPv6): <A
HREF="http://www.research.microsoft.com/msripv6/"
TARGET="_top"
>MSRIPv6 Configuring 6to4 - Connectivity with MSR IPv6 - Our 6Bone Node... </A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3111"
>25.1.4. Others</A
></H3
><P
>See following URL for more: <A
HREF="http://www.switch.ch/lan/ipv6/references.html"
TARGET="_top"
>SWITCH IPv6 Pilot / References</A
></P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-CONFERENCES"
>25.2. Conferences, Meetings, Summits</A
></H2
><P
>Something missing? Suggestions are welcome!</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3118"
>25.2.1. 2004</A
></H3
><P
></P
><UL
><LI
><P
>1st Global IPv6 Summit in Sao Paul, Brazil</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-ONLINEINFORMATION"
>25.3. Online information</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="INFORMATION-JOINIPV6."
>25.3.1. Join the IPv6 backbone</A
></H3
><P
>More to be filled later...suggestions are welcome!</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-GLOBALREGISTRIES"
>25.3.1.1. Global registries</A
></H4
><P
>See regional registries.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-MAJORREGIONREGISTRIES"
>25.3.1.2. Major regional registries</A
></H4
><P
></P
><UL
><LI
><P
>America: <A
HREF="http://www.arin.net/"
TARGET="_top"
>ARIN</A
>, <A
HREF="http://www.arin.net/registration/ipv6/index.html"
TARGET="_top"
>ARIN / registration page</A
>, <A
HREF="http://www.arin.net/registration/ipv6/index.html"
TARGET="_top"
>ARIN / IPv6 guidelines</A
></P
></LI
><LI
><P
>EMEA: <A
HREF="http://www.ripe.net/"
TARGET="_top"
>Ripe NCC</A
>, <A
HREF="http://www.ripe.net/ripencc/mem-services/registration/"
TARGET="_top"
>Ripe NCC / registration page</A
>, <A
HREF="http://www.ripe.net/ripencc/mem-services/registration/ipv6/"
TARGET="_top"
>Ripe NCC / IPv6 registration</A
></P
></LI
><LI
><P
>Asia/Pacific: <A
HREF="http://www.apnic.net/"
TARGET="_top"
>APNIC</A
>, <A
HREF="http://www.apnic.net/services/ipv6_guide.html"
TARGET="_top"
>APNIC / IPv6 ressource guide</A
></P
></LI
><LI
><P
>Latin America and Caribbea: <A
HREF="http://lacnic.org/"
TARGET="_top"
>LACNIC</A
>, <A
HREF="http://lacnic.net/en/bt-IPv6.html"
TARGET="_top"
>IPv6 Registration Services</A
>, <A
HREF="http://lacnic.net/en/chapter-4-en.pdf"
TARGET="_top"
>IPv6 Allocation Policy</A
></P
></LI
><LI
><P
>Africa: <A
HREF="http://www.afrinic.org/"
TARGET="_top"
>AfriNIC</A
></P
></LI
></UL
><P
>Also a list of major (prefix length 32) allocations per local registry is available here: <A
HREF="http://www.ripe.net/ripencc/mem-services/registration/ipv6/ipv6allocs.html"
TARGET="_top"
>Ripe NCC / IPv6 allocations</A
>.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-JOINIPV6-TUNNELBROKERS"
>25.3.1.3. Tunnel brokers</A
></H4
><P
>Note: A list of available Tunnel broker can be found in the section <A
HREF="#INFORMATION-TUNNELBROKER"
>Tunnel broker</A
> below. </P
><P
></P
><UL
><LI
><P
>Former IPng. Tunnelbroker and IPv6 resources, now migrated to the <A
HREF="http://www.sixxs.net/main/"
TARGET="_top"
>SixXs System</A
>.</P
></LI
><LI
><P
>Eckes' <A
HREF="http://sites.inka.de/lina/linux/ipv6.html"
TARGET="_top"
>IPv6-with-Linux</A
> Page.</P
></LI
><LI
><P
>tunnelc - a perl based tunnel client script:
freshmeat.net: <A
HREF="http://freshmeat.net/projects/tunnelc"
TARGET="_top"
>Project details for tunnel client</A
>
SourceForge: <A
HREF="http://sourceforge.net/projects/tunnelc"
TARGET="_top"
>Project Info - tunnelc</A
> (also <A
HREF="http://tunnelc.sourceforge.net/"
TARGET="_top"
>here</A
>)</P
></LI
><LI
><P
>Linux Advanced Routing &#38; Traffic Control HOWTO, <A
HREF="http://howtos.linuxbroker.com/howtoreader.shtml?file=Adv-Routing-HOWTO.html#LARTC.TUNNEL-IPV6.ADDRESSING"
TARGET="_top"
>Chapter 6: IPv6 tunneling with Cisco and/or 6bone</A
>.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-JOINIPV6-6TO4-TUNNELING"
>25.3.1.4. 6to4</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.kfu.com/~nsayer/6to4/"
TARGET="_top"
>NSayer's 6to4 information</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/rfcs/rfc3068.html"
TARGET="_top"
>RFC 3068 / An Anycast Prefix for 6to4 Relay Routers</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-JOINIPV6-ISATAP-TUNNELING"
>25.3.1.5. ISATAP</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.join.uni-muenster.de/Dokumente/Howtos/Howto_ISATAP.php?lang=en"
TARGET="_top"
>ISATAP (Intra-Site Automatic Tunnel Access Protocol) Information</A
> by <A
HREF="http://www.join.uni-muenster.de/"
TARGET="_top"
>JOIN</A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3193"
>25.3.2. Latest news and URLs to other documents</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.estoile.com/links/ipv6"
TARGET="_top"
>Lot of URLs to others documents</A
> by Anil Edathara</P
></LI
><LI
><P
><A
HREF="http://www.go6.net/"
TARGET="_top"
>go6 - The IPv6 Portal</A
>: an IPv6 online portal with a wiki-based IPv6 knowledge center, an IPv6 discussion forum, an up-to-date collection of IPv6 Events and News, free IPv6 access and services, IPv6 software applications, and much more</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3202"
>25.3.3. Protocol references</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN3204"
>25.3.3.1. IPv6-related Request For Comments (RFCs)</A
></H4
><P
>Publishing the list of IPv6-related RFCs is beyond the scope of this document, but given URLs will lead you to such lists:</P
><P
></P
><UL
><LI
><P
>List sorted by <A
HREF="http://playground.sun.com/pub/ipng/html/specs/standards.html"
TARGET="_top"
>IPng Standardization Status</A
> or <A
HREF="http://playground.sun.com/pub/ipng/html/specs/specifications.html"
TARGET="_top"
>IPng Current Specifications</A
> by Robert Hinden</P
></LI
><LI
><P
><A
HREF="http://www.ipv6.org/specs.html"
TARGET="_top"
>IPv6 Related Specifications</A
> on IPv6.org</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3215"
>25.3.3.2. Current drafts of working groups</A
></H4
><P
>Current (also) IPv6-related drafts can be found here:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/ipv6.html"
TARGET="_top"
>IP Version 6 (ipv6)</A
></P
></LI
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/ngtrans.html"
TARGET="_top"
>Next Generation Transition (ngtrans)</A
></P
></LI
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/dhc.html"
TARGET="_top"
>Dynamic Host Configuration (dhc)</A
></P
></LI
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/dnsext.html"
TARGET="_top"
>Domain Name System Extension (dnsext)</A
></P
></LI
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/v6ops.html"
TARGET="_top"
>IPv6 Operations (v6ops)</A
></P
></LI
><LI
><P
><A
HREF="http://www.ietf.org/ids.by.wg/mobileip.html"
TARGET="_top"
>Mobile IP (mobileip)</A
></P
></LI
><LI
><P
><A
HREF="http://playground.sun.com/pub/ipng/html/ipng-main.html"
TARGET="_top"
>Get any information about IPv6, from overviews, through RFCs &#38; drafts, to implementations</A
> (including availability of stacks on various platforms &#38; source code for IPv6 stacks) </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3240"
>25.3.3.3. Others</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.switch.ch/lan/ipv6/references.html"
TARGET="_top"
>SWITCH IPv6 Pilot / References</A
>, big list of IPv6 references maintained by Simon Leinen</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3246"
>25.3.4. More information</A
></H3
><P
><A
HREF="http://www.deepspace6.net/sections/links.html"
TARGET="_top"
>DeepSpace6 / more interesting links</A
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3250"
>25.3.4.1. Linux related</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.deepspace6.net/"
TARGET="_top"
>DeepSpace6 / (Not only) Linux IPv6 Portal</A
> - Italy (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/"
TARGET="_top"
>Mirror</A
>)</P
></LI
><LI
><P
><A
HREF="http://www.bieringer.de/linux/IPv6/"
TARGET="_top"
>IPv6-HowTo for Linux by Peter Bieringer</A
> - Germany, and his <A
HREF="ftp://ftp.bieringer.de/pub/linux/IPv6/"
TARGET="_top"
>Bieringer / IPv6 - software archive</A
></P
></LI
><LI
><P
><A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status.html"
TARGET="_top"
>Linux+IPv6 status by Peter Bieringer</A
> - Germany (going obsolete)</P
></LI
><LI
><P
><A
HREF="http://www.deepspace6.net/docs/ipv6_status_page_apps.html"
TARGET="_top"
>DeepSpace6 / IPv6 Status Page</A
> - Italy (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/docs/ipv6_status_page_apps.html"
TARGET="_top"
>Mirror</A
>) (will superseed upper one)</P
></LI
><LI
><P
><A
HREF="http://www.linux-ipv6.org/"
TARGET="_top"
>USAGI project</A
> - Japan, and their <A
HREF="ftp://ftp.linux-ipv6.org/pub/"
TARGET="_top"
>USAGI project - software archive</A
></P
></LI
><LI
><P
><A
HREF="http://www.tldp.org/HOWTO/OLSR-IPv6-HOWTO/"
TARGET="_top"
>Linux Optimized Link State Routing Protocol (OLSR) IPv6 HOWTO</A
></P
></LI
><LI
><P
><A
HREF="http://inl.info.ucl.ac.be/LinShim6/"
TARGET="_top"
>LinShim6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3278"
>25.3.4.2. Linux related per distribution</A
></H4
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>PLD</DT
><DD
><P
><A
HREF="http://www.pld-linux.org/"
TARGET="_top"
>PLD Linux Distribution</A
> (“market leader” in containing IPv6 enabled packages)</P
></DD
><DT
>Red Hat</DT
><DD
><P
><A
HREF="http://www.redhat.com/"
TARGET="_top"
>Red Hat Enterprise Linux</A
>, <A
HREF="http://www.netcore.fi/pekkas/linux/ipv6/"
TARGET="_top"
> Pekka Savola's IPv6 packages</A
></P
></DD
><DT
>Fedora</DT
><DD
><P
><A
HREF="http://www.fedora.redhat.com/"
TARGET="_top"
>Fedora Core Linux</A
></P
></DD
><DT
>Debian</DT
><DD
><P
><A
HREF="http://www.debian.org/"
TARGET="_top"
>Debian Linux</A
>, <A
HREF="http://ipv6.debian.net/"
TARGET="_top"
>IPv6 with Debian Linux</A
></P
></DD
><DT
>Novell/SuSE</DT
><DD
><P
><A
HREF="http://www.novell.com/linux/suse/"
TARGET="_top"
>Novell/SuSE Linux</A
></P
></DD
><DT
>Mandriva</DT
><DD
><P
><A
HREF="http://www.mandriva.com/"
TARGET="_top"
>Mandriva</A
></P
></DD
></DL
></DIV
><P
>For more see the <A
HREF="http://www.bieringer.de/linux/IPv6/status/IPv6+Linux-status-distributions.html"
TARGET="_top"
>IPv6+Linux Status Distributions</A
> page.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3315"
>25.3.4.3. General</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.org/"
TARGET="_top"
>IPv6.org</A
></P
></LI
><LI
><P
><A
HREF="http://www.6bone.net/"
TARGET="_top"
>6bone</A
></P
></LI
><LI
><P
><A
HREF="http://www.v6.wide.ad.jp/"
TARGET="_top"
>WIDE project</A
> - Japan</P
></LI
><LI
><P
><A
HREF="http://www.switch.ch/lan/ipv6/"
TARGET="_top"
>SWITCH IPv6 Pilot</A
> - Switzerland</P
></LI
><LI
><P
><A
HREF="http://www.feyrer.de/IPv6/"
TARGET="_top"
>IPv6 Corner of Hubert Feyrer</A
> - Germany</P
></LI
><LI
><P
><A
HREF="http://www.ipv6forum.com/"
TARGET="_top"
>IPv6 Forum</A
> - a world-wide consortium of leading Internet vendors, Research &#38; Education Networks...</P
></LI
><LI
><P
><A
HREF="http://playground.sun.com/pub/ipng/html/ipng-main.html"
TARGET="_top"
>Playground.sun.com / IPv6 Info Page</A
> - maintained by Robert Hinden, Nokia. Get any information about IPv6, from overviews, through RFCs &#38; drafts, to implementations (including availability of stacks on various platforms &#38; source code for IPv6 stacks).</P
></LI
><LI
><P
><A
HREF="http://www.6init.com/"
TARGET="_top"
>6INIT</A
> - IPv6 Internet Initiative - an EU Fifth Framework Project under the IST Programme.</P
></LI
><LI
><P
><A
HREF="http://www.ipv6-taskforce.org/"
TARGET="_top"
>IPv6 Task Force (European Union)</A
></P
></LI
><LI
><P
><A
HREF="http://www.6init.org/"
TARGET="_top"
>6init</A
> - IPv6 INternet IniTiative </P
></LI
><LI
><P
><A
HREF="http://www.usenix.org/publications/library/proceedings/ana97/summaries/deering.html"
TARGET="_top"
>IPv6: The New Version of the Internet Protocol</A
>, by Steve Deering.</P
></LI
><LI
><P
><A
HREF="http://www.garykessler.net/library/ipv6_exp.html"
TARGET="_top"
>IPv6: The Next Generation Internet Protocol</A
>, by Gary C. Kessler. </P
></LI
><LI
><P
><A
HREF="http://www.3com.com/nsc/ipv6.html"
TARGET="_top"
>IPv6: Next Generation Internet Protocol</A
> - 3Com</P
></LI
><LI
><P
><A
HREF="http://www.internet2.org/"
TARGET="_top"
>internet || site</A
> and <A
HREF="http://ipv6.internet2.edu/"
TARGET="_top"
>internet2 Working Group</A
></P
></LI
><LI
><P
>NetworkWorldFusion: Search / Doc Finder: <A
HREF="http://search.nwfusion.com/query.html?qt=IPv6&#38;qp=&#38;ch=cn&#38;"
TARGET="_top"
>searched for IPv6</A
> (102 documents found 22.12.2002)</P
></LI
><LI
><P
><A
HREF="http://www.theregister.co.uk/"
TARGET="_top"
>The Register</A
> (Search for IPv6 will result in 30 documents, 22.12.2002)</P
></LI
><LI
><P
><A
HREF="http://zdnet.search.com/search?cat=279&#38;q=IPv6"
TARGET="_top"
>ZDNet Search for IPv6</A
></P
></LI
><LI
><P
><A
HREF="http://whatis.techtarget.com/wsearchResults/1,290214,sid9,00.html?query=IPv6"
TARGET="_top"
>TechTarget Search for IPv6</A
></P
></LI
><LI
><P
><A
HREF="http://www.faqs.org/faqs/internet/tcp-ip/resource-list/index.html"
TARGET="_top"
>IPv6 &#38; TCP Resources List</A
></P
></LI
></UL
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-MARKETRESEARCH"
>25.3.4.4. Market Research</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.seminarinformation.com/wconnect/wc.dll?sis~details0~307~TSN"
TARGET="_top"
>A Tale of Two Wireless Technology Trends: Processor Development Outsourcing and IPv6</A
>Yankee Group - 4/1/2002 - 12 Pages - ID: YANL768881</P
></LI
><LI
><P
><A
HREF="http://www.marketresearch.com/product/display.asp?SID=88602378-241489274-186851952&#38;ProductID=803907"
TARGET="_top"
>The World Atlas of the Internet: Americas</A
>; IDATE - 2/1/2002 - 242 PAges - ID: IDT803907. Countries covered: Central America, North America, South America; List: Price: $ 3,500.00; excerpt: Panorama of Internet access markets across the globe. Market assessment and forecasts up to 2006 for 34 countries: market structure: main ISPs and market shares; number of subscribers, of ISPs.</P
></LI
><LI
><P
>Early Interest Rising for IPv6 by IDC (Author); List Price:   $1,500.00; Edition: e-book (Acrobat Reader); Publisher: IDC; ISBN B000065T8E; (March 1, 2002) </P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-PATENTS"
>25.3.4.5. Patents</A
></H4
><P
></P
><UL
><LI
><P
>Delphion Research: <A
HREF="http://www.delphion.com/research/"
TARGET="_top"
>Patent Search Page</A
>. Basic (free) registration needed. Examples found 21.12.2002 searching for IPv6:
<A
HREF="http://www.delphion.com/details?pn=US06118784__"
TARGET="_top"
>Communicating method between IPv4 terminal and IPv6 terminal and IPv4-IPv6 converting apparatus</A
>
<A
HREF="http://www.delphion.com/details?pn=US06038233__"
TARGET="_top"
>Translator for IP networks, network system using the translator, and IP network coupling method therefor</A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3396"
>25.3.5. By countries</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN3398"
>25.3.5.1. Europe</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ist-ipv6.org/"
TARGET="_top"
>www.ist-ipv6.org</A
>: IST IPv6 Cluster, European IPv6 Research and Development Projects</P
></LI
><LI
><P
><A
HREF="http://www.euro6ix.org/"
TARGET="_top"
>Euro6IX</A
>: European IPv6 Internet Exchanges Backbone</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3407"
>25.3.5.2. Austria</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ikn.tuwien.ac.at/~ipv6/"
TARGET="_top"
>IPv6@IKNnet and MIPv6 Research Group</A
>: TU Vienna, Austria (IPv6: project, publications, diploma / doctor thesis, Conference Proceedings etc.)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3413"
>25.3.5.3. Australia</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://oversteer.bl.echidna.id.au/IPv6/"
TARGET="_top"
>Carl's Australian IPv6 Pages</A
> (old content)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3419"
>25.3.5.4. Belgium</A
></H4
><P
>Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3422"
>25.3.5.5. Brasil</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6dobrasil.com.br/"
TARGET="_top"
>IPv6 do Brasil</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3428"
>25.3.5.6. China</A
></H4
><P
>Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3431"
>25.3.5.7. Czech</A
></H4
><P
>Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3434"
>25.3.5.8. Germany</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="https://www.xing.com/net/ipv6/"
TARGET="_top"
>Xing / IPv6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3440"
>25.3.5.9. France</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.renater.fr/Projets/IPv6/index.htm"
TARGET="_top"
>Renater</A
>: Renater IPv6 Project Page</P
></LI
><LI
><P
><A
HREF="http://www.inria.fr/recherche/equipes/ipv6.fr.html"
TARGET="_top"
>IPv6 - RSVP - ATM at INRIA</A
></P
></LI
><LI
><P
><A
HREF="http://www.netbsd.org/fr/Documentation/network/ipv6/"
TARGET="_top"
>NetBSD IPv6 Documentation</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3452"
>25.3.5.10. Italy</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://project6.ferrara.linux.it/"
TARGET="_top"
>Project6</A
>: IPv6 networking with Linux</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3458"
>25.3.5.11. Japan</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.rtpro.yamaha.co.jp/RT/ipv6/"
TARGET="_top"
>Yamaha IPv6</A
> (sorry, all in japanese native ...)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3464"
>25.3.5.12. Korea</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.krv6.net/"
TARGET="_top"
>ETRI</A
>: Electronics and Telecommunications Research Institut</P
></LI
><LI
><P
><A
HREF="http://www.ipv6.or.kr/english/index.new.htm"
TARGET="_top"
>IPv6 Forum Korea</A
>: Korean IPv6 Deployment Project</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3473"
>25.3.5.13. Mexico</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.unam.mx/"
TARGET="_top"
>IPv6 Mexico</A
> (spain &#38; english version): IPv6 Project Hompeage of The National Autonomous University of Mexico (UNAM)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3479"
>25.3.5.14. Netherland</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.surfnet.nl/"
TARGET="_top"
>SURFnet</A
>: SURFnet IPv6 Backbone</P
></LI
><LI
><P
><A
HREF="http://www.stack.nl/"
TARGET="_top"
>STACK</A
>, <A
HREF="http://www.stack.nl/ipv6/"
TARGET="_top"
>STACK (IPv6)</A
>: Students' computer association of the Eindhoven University of Technology, Netherland</P
></LI
><LI
><P
><A
HREF="http://www.ipng.nl/"
TARGET="_top"
>IPng.nl</A
>: collaboration between WiseGuys and Intouch</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3492"
>25.3.5.15. Portugal</A
></H4
><P
>Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3495"
>25.3.5.16. Russia</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.ru/"
TARGET="_top"
>IPv6 Forum for Russia</A
>: Yaroslavl State University Internet Center</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3501"
>25.3.5.17. Switzerland</A
></H4
><P
>Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3504"
>25.3.5.18. United Kingdom</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.bt.com/ipv6/"
TARGET="_top"
>British Telecom IPv6 Home</A
>: BT's ISP IPv6 Trial, UK's first IPv6 Internet Exchange etc.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3510"
>25.3.6. By operating systems</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN3512"
>25.3.6.1. *BSD</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.kame.net/"
TARGET="_top"
>KAME project</A
> (*BSD)</P
></LI
><LI
><P
><A
HREF="http://www.netbsd.org/Documentation/network/ipv6/"
TARGET="_top"
>NetBSD's IPv6 Networking FAQ</A
></P
></LI
><LI
><P
><A
HREF="http://www.freebsd.org/ports/ipv6.html"
TARGET="_top"
>FreeBSD Ports: Ipv6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3524"
>25.3.6.2. Cisco IOS</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.cisco.com/warp/public/732/Tech/ipv6/"
TARGET="_top"
>Cisco IOS IPv6 Entry Page</A
></P
></LI
><LI
><P
><A
HREF="http://www.cisco.com/univercd/cc/td/doc/product/software/ios122/122newft/122t/122t2/ipv6/ftipv6c.htm"
TARGET="_top"
>IPv6 for Cisco IOS Software</A
>, File 2 of 3: Aug 2002 -- Table of Contents: IPv6 for Cisco IOS Software; Configuring Documentation Specifics; Enabling IPv6 Routing and Configuring; IPv6 Addressing; Enabling IPv6 Processing Globally.</P
></LI
><LI
><P
>Cisco Internet Networking Handbook, <A
HREF="http://www.cisco.com/univercd/cc/td/doc/cisintwk/ito_doc/ipv6.htm"
TARGET="_top"
>Chapter IPv6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3536"
>25.3.6.3. HPUX</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.faqs.org/faqs/hp/hpux-faq/index.html"
TARGET="_top"
>comp.sys.hp.hpux FAQ</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3542"
>25.3.6.4. IBM</A
></H4
><P
></P
><UL
><LI
><P
>Now that IBM's announced the availability of z/OS V1.4, <A
HREF="http://search390.techtarget.com/ateQuestionNResponse/0,289625,sid10_cid486367_tax292523,00.html"
TARGET="_top"
>what's new in this release?</A
> This question was posed on 15 August 2002</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3548"
>25.3.6.5. Microsoft</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.microsoft.com/windows2000/technologies/communications/ipv6/default.asp"
TARGET="_top"
>Microsoft Windows 2000 IPv6</A
> </P
></LI
><LI
><P
><A
HREF="http://www.research.microsoft.com/msripv6"
TARGET="_top"
>MSRIPv6</A
> - Microsoft Research Network - IPv6 Homepage </P
></LI
><LI
><P
><A
HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;306203"
TARGET="_top"
>Internet Connection Firewall Does Not Block Internet Protocol Version 6 Traffic</A
> (6.11.2001)</P
></LI
><LI
><P
><A
HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;289892"
TARGET="_top"
>Internet Protocol Numbers</A
> (8.10.2002)</P
></LI
><LI
><P
><A
HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;273826"
TARGET="_top"
>IPv6 Technology Preview Refresh</A
> (16.10.2002)</P
></LI
><LI
><P
><A
HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;325449"
TARGET="_top"
>HOW TO: Install and Configure IP Version 6 in Windows .NET Enterprise Server</A
> (26.10.2002)</P
></LI
><LI
><P
><A
HREF="http://support.microsoft.com/default.aspx?scid=kb;en-us;329984"
TARGET="_top"
>Windows .NET Server 6to4 Router Service Quits When You Advertise a 2002 Address on the Public Interface</A
> (28.10.2002)</P
></LI
><LI
><P
><A
HREF="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wcetcpip/htm/cmconIPv6exe.asp"
TARGET="_top"
>msdn - Microsoft Windows CE .NET - IPv6 commands</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3575"
>25.3.6.6. Solaris</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.sun.com/software/solaris/"
TARGET="_top"
>Sun Microsystems Solaris</A
></P
></LI
><LI
><P
><A
HREF="http://www.cs.uu.nl/wais/html/na-dir/Solaris2/FAQ.html"
TARGET="_top"
>Solaris 2 Frequently Asked Questions (FAQ) 1.73</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3584"
>25.3.6.7. Sumitoma</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://playground.sun.com/pub/ipng/html/ipng-implementations.html#Sumitomo"
TARGET="_top"
>Sumitomo Electric has implemented IPv6 on Suminet 3700 family routers</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3590"
>25.3.6.8. ZebOS</A
></H4
><P
></P
><UL
><LI
><P
>IpInfusion's <A
HREF="http://www.ipinfusion.com/products/server/products_server.html"
TARGET="_top"
>ZebOS Server Routing Software</A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INFORMATION-IPV6ANDSECURITY"
>25.3.7. IPv6 Security</A
></H3
><P
></P
><UL
><LI
><P
>Internet Security Systems: Security Center, <A
HREF="http://www.iss.net/security_center/search.php?type=3&#38;type=3&#38;pattern=IPv6"
TARGET="_top"
>X-Force Database Search</A
> (21.12.2002 - 6 topics found relating to IPv6)</P
></LI
><LI
><P
><A
HREF="http://csrc.nist.gov/ipsec/"
TARGET="_top"
>NIST IPsec Project</A
> ( National Institute of Standards and Technology, NIST)</P
></LI
><LI
><P
><A
HREF="http://www.infosecuritymag.com/index.shtml"
TARGET="_top"
>Information Security</A
></P
></LI
><LI
><P
><A
HREF="http://neworder.box.sk/search.php3?srch=IPv6"
TARGET="_top"
>NewOrder.box.sk (search for IPv6)</A
> (Articles, exploits, files database etc.) </P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3611"
>25.3.8. Application lists</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.deepspace6.net/docs/ipv6_status_page_apps.html"
TARGET="_top"
>DeepSpace6 / IPv6 Status Page</A
> (<A
HREF="http://mirrors.bieringer.de/www.deepspace6.net/docs/ipv6_status_page_apps.html"
TARGET="_top"
>Mirror</A
>)</P
></LI
><LI
><P
><A
HREF="http://www.ipv6.org/v6-apps.html"
TARGET="_top"
>IPv6.org / IPv6 enabled applications</A
></P
></LI
><LI
><P
><A
HREF="http://freshmeat.net/search/?q=IPv6"
TARGET="_top"
>Freshmeat / IPv6 search</A
>, currently (14 Dec 2002) 62 projects</P
></LI
><LI
><P
><A
HREF="http://www.ipv6forum.com/modules.php?op=modload&#38;name=Web_Links&#38;file=index"
TARGET="_top"
>IPv6 Forum / Web Links</A
></P
></LI
></UL
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3627"
>25.3.8.1. Analyzer tools</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.wireshark.org/"
TARGET="_top"
>Wireshark</A
> (former known as <EM
>Ethereal</EM
>) is a free network protocol analyzer for Unix and Windows</P
></LI
><LI
><P
><A
HREF="http://www.ip6.com/us/analyzer.htm"
TARGET="_top"
>Radcom RC100-WL</A
> - Download Radcom RC100-WL protocol analyzer version 3.20</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3637"
>25.3.8.2. IPv6 Products</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.6wind.com/"
TARGET="_top"
>6wind</A
> - solutions for IPv4/IPv6 Router, QoS, Multicast, Mobility, Security/VPN/Firewall. </P
></LI
><LI
><P
><A
HREF="http://www.fefe.de/dns/"
TARGET="_top"
>Fefe's patches for IPv6 with djbdns</A
>Aug 2002 -- What is djbdns and why does it need IPv6? djbdns is a full blown DNS server which outperforms BIND in nearly all respects.</P
></LI
><LI
><P
><A
HREF="http://www.ipinfusion.com/products/server/products_server.html"
TARGET="_top"
>ZebOS Server Routing Suite </A
></P
></LI
><LI
><P
><A
HREF="http://download.com.com/3000-2165-10153543.html?tag=lst-0-21"
TARGET="_top"
>SPA Mail Server 2.21 </A
></P
></LI
><LI
><P
><A
HREF="http://download.com.com/3000-2165-8202652.html?tag=lst-0-2"
TARGET="_top"
>Inframail (Advantage Server Edition) 6.0 </A
></P
></LI
><LI
><P
><A
HREF="http://download.com.com/3000-2377-10149393.html?tag=lst-0-1"
TARGET="_top"
>HTTrack Website Copier</A
></P
></LI
><LI
><P
><A
HREF="http://download.com.com/3000-2085-10132748.html?tag=lst-0-1"
TARGET="_top"
>CommView 5.0</A
></P
></LI
><LI
><P
><A
HREF="http://download.com.com/3000-2104-10149750.html?tag=lst-0-1"
TARGET="_top"
>Posadis 0.50.6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-SNMP"
>25.3.8.3. SNMP</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.cs.uu.nl/wais/html/na-dir/snmp-faq/part1.html"
TARGET="_top"
>comp.protocpols.snmp SNMP FAQ Part 1 of 2</A
></P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN3670"
>25.4. IPv6 Infrastructure</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3672"
>25.4.1. Statistics</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.space.net/~gert/RIPE/"
TARGET="_top"
>IPv6 routing table history</A
> created by Gert Döring, <A
HREF="http://www.space.net/"
TARGET="_top"
>Space.Net</A
></P
></LI
><LI
><P
><A
HREF="http://6bone.informatik.uni-leipzig.de/ipv6/stats/stats.php3"
TARGET="_top"
>Official 6bone Webserver list Statisic</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN3682"
>25.4.2. Internet Exchanges</A
></H3
><P
>Another list of IPv6 Internet Exchanges can be found here: <A
HREF="http://www.euro-ix.net/isp/choosing/search/matrix.php"
TARGET="_top"
>IPv6 status of IXPs in Europe</A
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-ESTONIA"
>25.4.2.1. Estonia</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://tix.estpak.ee/"
TARGET="_top"
>TIX</A
> (tallinn interneti exchange with ipv6 support)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-EUROPE"
>25.4.2.2. Europe</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.euro6ix.net/"
TARGET="_top"
>Euro6IX</A
>, European IPv6 Internet Exchange Backbone</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-FRANCE"
>25.4.2.3. France</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.fnix6.net/"
TARGET="_top"
>French National Internet  Exchange IPv6</A
> (since 1.11.2002 active). 
FNIX6 provides a free and reliable high speed FastEthernet interconnection between ISP located in TeleCity Paris.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-GERMANY"
>25.4.2.4. Germany</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.inxs.de/"
TARGET="_top"
>INXS</A
>: (Cable &#38; Wireless) Munich and Hamburg</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-JAPAN"
>25.4.2.5. Japan</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.wide.ad.jp/nspixp6/"
TARGET="_top"
>NSPIXP-6</A
>: IPv6-based Internet Exchange in Tokyo</P
></LI
><LI
><P
><A
HREF="http://www.jpix.co.jp/"
TARGET="_top"
>JPIX</A
>, Tokyo</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-KOREA"
>25.4.2.6. Korea</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ngix.ne.kr/"
TARGET="_top"
>6NGIX</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-NETHERLANDS"
>25.4.2.7. Netherlands</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ams-ix.net/"
TARGET="_top"
>AMS-IX</A
>: Amsterdam Internet Exchange</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-UK"
>25.4.2.8. UK</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.uk6x.com/"
TARGET="_top"
>UK6X</A
>: London</P
></LI
><LI
><P
><A
HREF="http://www.xchangepoint.net/"
TARGET="_top"
>XchangePoint</A
>: London</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-IPV6EXCHANGES-USA"
>25.4.2.9. USA</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.6tap.net/"
TARGET="_top"
>6TAP</A
>: Chicago. Supports peerings around the globe.</P
></LI
><LI
><P
><A
HREF="http://www.paix.net/"
TARGET="_top"
>PAIX</A
>: Palo Alto</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INFORMATION-TUNNELBROKER"
>25.4.3. Tunnel broker</A
></H3
><P
>See also: <A
HREF="http://www.deepspace6.net/docs/tunnelbrokers.html"
TARGET="_top"
>http://www.deepspace6.net/docs/tunnelbrokers.html</A
></P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-BELGIUM"
>25.4.3.1. Belgium</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-CANADA"
>25.4.3.2. Canada</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.freenet6.net/"
TARGET="_top"
>Freenet6</A
> - /48 Delegation, Canada
<A
HREF="http://www.linuxjournal.com/article.php?sid=5963&#38;mode=thread&#38;order=0"
TARGET="_top"
>Getting IPv6 Using Freenet6 on Debian</A
>
<A
HREF="http://www.viagenie.qc.ca/en/index.shtml"
TARGET="_top"
>Freenet6 creater</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-CHINA"
>25.4.3.3. China</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-ESTONIA"
>25.4.3.4. Estonia</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://tunnelbroker.ipv6.estpak.ee/?tunnel&#38;PHPSESSID=aa2184190cc2cc6d3a6f6ddd01ae3635"
TARGET="_top"
>Estpak</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-GERMANY"
>25.4.3.5. Germany</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://6bone.informatik.uni-leipzig.de/"
TARGET="_top"
>6bone Knoten Leipzig</A
>
<A
HREF="http://www.mail-archive.com/ipv6@uni-muenster.de/msg00056.html"
TARGET="_top"
>Info bez. Hackangriff (2001)</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-ITALY"
>25.4.3.6. Italy</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.comv6.com/"
TARGET="_top"
>Comv6</A
></P
></LI
><LI
><P
><A
HREF="http://www.bersafe.it/"
TARGET="_top"
>Bersafe</A
> (Italian language)</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-JAPAN"
>25.4.3.7. Japan</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-MALAYSIA"
>25.4.3.8. Malaysia</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-NETHERLANDS"
>25.4.3.9. Netherlands</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipng.nl/"
TARGET="_top"
>IPng Netherland</A
> - Intouch, SurfNet, AMS-IX, UUNet, Cistron, RIPE NCC and AT&#38;T are connected at the AMS-IX. It is possible (there are requirements...) to get an static tunnel.</P
></LI
><LI
><P
><A
HREF="http://www.ipv6.surfnet.nl/"
TARGET="_top"
>SURFnet Customers</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-NORWAY"
>25.4.3.10. Norway</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.uninett.no/testnett/index.en.html"
TARGET="_top"
>UNINETT</A
> - Pilot IPv6 Service (for Customers): tunnelbroker &#38; address allocation 
<A
HREF="http://www.guruz.de/Uninett-Autoupdate-HOWTO"
TARGET="_top"
>Uninett-Autoupdate-HOWTO</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-SPAIN"
>25.4.3.11. Spain</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://tb.consulintel.euro6ix.org/"
TARGET="_top"
>Consulintel</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-SWITZERLAND"
>25.4.3.12. Switzerland</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-UK"
>25.4.3.13. UK</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.nttv6.net/"
TARGET="_top"
>NTT</A
>, United Kingdom - IPv6 Trial. IPv4 Tunnel and native IPv6 leased Line connections. POPs are located in London, UK Dusseldorf, Germany New Jersey, USA (East Coast) Cupertino, USA (West Coast) Tokyo, Japan</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-USA"
>25.4.3.14. USA</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.es.net/hypertext/welcome/pr/ipv6.html"
TARGET="_top"
>ESnet</A
>, USA - Energy Sciences Network: Tunnel Registry &#38; Address Delegation for directly connected ESnet sites and ESnet collaborators.</P
></LI
><LI
><P
><A
HREF="http://ipv6tb.he.net/"
TARGET="_top"
>Hurricane Electric</A
>, US backbone; 
<A
HREF="http://tunnelbroker.net/"
TARGET="_top"
>Hurrican Electric Tunnelbroker</A
> (also available under <A
HREF="http://tunnelbroker.com/"
TARGET="_top"
>http://tunnelbroker.com/</A
>)
Press Release: <A
HREF="http://www.he.net/releases/release6.html"
TARGET="_top"
>Hurricane Electric Upgrades IPv6 Tunnel Broker</A
>
<A
HREF="http://ipv6.he.net/tunnelbroker-update.php"
TARGET="_top"
>Tunnel Broker Endpoint Autoupdate</A
>, Perl Script</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-SINGAPORE"
>25.4.3.15. Singapore</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-TUNNELBROKER-MORE"
>25.4.3.16. More Tunnel brokers...</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.kfu.com/~nsayer/6to4/"
TARGET="_top"
>Public 6to4 relay routers</A
> (MS IIE boycott!)</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INFORMATION-INFRASTRUCTURE-NATIVEIPV6SERVICE"
>25.4.4. Native IPv6 Services</A
></H3
><P
>Note: These services are mostly only available with a valid IPv6 connection!</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-NATIVEIPV6NNTP"
>25.4.4.1. Net News (NNTP)</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-NATIVEIPV6GAMESERVER"
>25.4.4.2. Game Server</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.viagenie.qc.ca/en/ipv6/quake2/ipv6-quake2.shtml"
TARGET="_top"
>Quake2</A
> over IPv6</P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-NATIVEIPV6IRCSERVER"
>25.4.4.3. IRC Server</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN3863"
>25.4.4.4. Radio Stations, Music Streams</A
></H4
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="INFORMATION-NATIVEIPV6WEBSERVER"
>25.4.4.5. Webserver</A
></H4
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ipv6.bieringer.de/"
TARGET="_top"
>Peter Bieringer's Home of Linux IPv6 HOWTO </A
></P
></LI
></UL
><P
>Something missing? Suggestions are welcome!</P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-MAILLISTS"
>25.5. Maillists</A
></H2
><P
>Lists of maillists are available at:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.deepspace6.net/sections/lists.html"
TARGET="_top"
>DeepSpace6 / Mailling Lists</A
></P
></LI
></UL
><P
>Major Mailinglists are listed in following table:</P
><DIV
CLASS="INFORMALTABLE"
><P
></P
><A
NAME="AEN3881"
></A
><TABLE
BORDER="1"
RULES="all"
CLASS="CALSTABLE"
><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col0"><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col1"><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col2"><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col3"><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col4"><COL
WIDTH="1*"
ALIGN="CENTER"
TITLE="col5"><TBODY
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Focus</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Request e-mail address</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>What to subscribe</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Maillist e-mail address</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Language</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Access through WWW</TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Linux kernel networking including IPv6</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>majordomo (at) vger.kernel.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>netdev</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>netdev (at) vger.kernel.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://vger.kernel.org/vger-lists.html#netdev"
TARGET="_top"
>Info</A
>, <A
HREF="http://www.spinics.net/lists/netdev/"
TARGET="_top"
>Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Mobile IP(v6) for Linux</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Web-based, see URL</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>mipl</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>mipl (at) mobile-ipv6.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://www.mobile-ipv6.org/cgi-bin/mailman/listinfo"
TARGET="_top"
>Info</A
>, <A
HREF="http://www.mobile-ipv6.org/pipermail/mipl/"
TARGET="_top"
>Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Linux IPv6 users using USAGI extension</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>usagi-users-ctl (at) linux-ipv6.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>&nbsp;</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>usagi-users (at) linux-ipv6.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://www.linux-ipv6.org/ml/index.html#usagi-users"
TARGET="_top"
>Info / Search</A
>, <A
HREF="http://www.linux-ipv6.org/ml/usagi-users/"
TARGET="_top"
>Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>IPv6 on Debian Linux</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>&nbsp;</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>&nbsp;</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>debian-ipv6 (at) lists.debian.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://lists.debian.org/debian-ipv6/"
TARGET="_top"
>Info/Subscription/Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>6bone</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>majordomo (at) isi.edu</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>6bone</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>6bone (at) isi.edu</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://www.6bone.net/6bone_email.html"
TARGET="_top"
>Info</A
>, <A
HREF="http://mailman.isi.edu/pipermail/6bone/"
TARGET="_top"
>Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>IPv6 users in general</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>majordomo (at) ipv6.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>users</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>users (at) ipv6.org</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://www.ipv6.org/mailing-lists.html"
TARGET="_top"
>Info</A
>, <A
HREF="http://www.mail-archive.com/users@ipv6.org/"
TARGET="_top"
>Archive</A
></TD
></TR
><TR
><TD
ALIGN="CENTER"
VALIGN="TOP"
>Bugtracking of Internet applications (1)</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>bugtraq-subscribe (at) securityfocus.com</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>&nbsp;</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>bugtraq (at) securityfocus.com (2)</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
>English</TD
><TD
ALIGN="CENTER"
VALIGN="TOP"
><A
HREF="http://online.securityfocus.com/popups/forums/bugtraq/intro.shtml"
TARGET="_top"
>Info</A
>, <A
HREF="http://online.securityfocus.com/archive/1"
TARGET="_top"
>Archive</A
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>(1) very recommended if you provide server applications.</P
><P
>(2) list is moderated.</P
><P
>Something missing? Suggestions are welcome!</P
><P
>Following other maillinglists &#38; newsgroups are available via web:</P
><P
></P
><UL
><LI
><P
><A
HREF="http://groups.yahoo.com/group/student-ipv6"
TARGET="_top"
>student-ipv6 (India)</A
>
Description: This is the group for the Student Awareness group of IPv6 in India</P
></LI
><LI
><P
><A
HREF="http://groups.yahoo.com/group/sun-ipv6-users"
TARGET="_top"
>sun-ipv6-users</A
>
Description: Please report problems/suggestions regarding SUN Microsystems IPng implementation</P
></LI
><LI
><P
><A
HREF="http://groups.yahoo.com/group/IPv6-BITS"
TARGET="_top"
>IPv6-BITS</A
>
Description: This List will co-ordinate the working of Project Vertebrae.</P
></LI
><LI
><P
><A
HREF="http://groups.yahoo.com/group/linux-bangalore-ipv6"
TARGET="_top"
>linux-bangalore-ipv6</A
>
Description: The IPv6 deployment list of the Bangalore Linux User Group</P
></LI
><LI
><P
><A
HREF="http://groups.yahoo.com/group/packet-switching"
TARGET="_top"
>packet-switching</A
>
Description: This mailing list provides a forum for discussion of packet switching theory, technology, implementation and application in any relevant aspect including without limitation LAPB, X.25, SDLC, P802.1d, LLC, IP, IPv6, IPX, DECNET, APPLETALK, FR, PPP, IP Telephony, LAN PBX systems, management protocols like SNMP, e-mail, network transparent window systems, protocol implementation, protocol verification, conformance testing and tools used in maintaining or developing packet switching systems.</P
></LI
><LI
><P
>de.comm.protocols.tcp-ip
Description: Umstellung auf IPv6
Source: <A
HREF="http://www.faqs.org/faqs/de-newsgroups/chartas/index.html"
TARGET="_top"
>Chartas der Newsgruppen in de.*</A
></P
></LI
><LI
><P
>Google Group: <A
HREF="http://groups.google.com/groups?hl=en&#38;lr=&#38;ie=UTF-8&#38;oe=UTF8&#38;safe=off&#38;group=comp.protocols.tcp-ip"
TARGET="_top"
>comp.protocols.tcp-ip</A
></P
></LI
><LI
><P
>Google Group: <A
HREF="http://groups.google.com/groups?hl=en&#38;lr=&#38;ie=UTF-8&#38;oe=UTF8&#38;safe=off&#38;group=linux.debian.maint.ipv6"
TARGET="_top"
>linux.debian.maint.ipv6</A
></P
></LI
><LI
><P
>Google Group: <A
HREF="http://groups.google.com/groups?hl=en&#38;lr=&#38;ie=UTF-8&#38;oe=UTF8&#38;safe=off&#38;group=microsoft.public.platformsdk.networking.ipv6"
TARGET="_top"
>microsoft.public.platformsdk.networking.ipv6</A
></P
></LI
><LI
><P
>Google Group: <A
HREF="http://groups.google.com/groups?hl=en&#38;lr=&#38;ie=UTF-8&#38;oe=UTF8&#38;safe=off&#38;group=fa.openbsd.ipv6"
TARGET="_top"
>fa.openbsd.ipv6</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-ONLINETESTTOOLS"
>25.6. Online tools</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN3996"
>25.6.1. Testing tools</A
></H3
><P
></P
><UL
><LI
><P
>ping, traceroute, tracepath, 6bone registry, DNS: <A
HREF="http://www.join.uni-muenster.de/lab/testtools.html"
TARGET="_top"
>JOIN / Testtools</A
> (German language only, but should be no problem for non German speakers)</P
></LI
><LI
><P
>traceroute6, whois: <A
HREF="http://www.ipng.nl/"
TARGET="_top"
>IPng.nl</A
></P
></LI
><LI
><P
>AAAA Lookup Checker <A
HREF="http://www.cnri.dit.ie/cgi-bin/check_aaaa.pl"
TARGET="_top"
>http://www.cnri.dit.ie/cgi-bin/check_aaaa.pl</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4008"
>25.6.2. Information retrievement</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.ripe.net/ripencc/mem-services/registration/ipv6/ipv6allocs.html"
TARGET="_top"
>List of worldwide all IPv6-aggregated IP-Blocks</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4014"
>25.6.3. IPv6 Looking Glasses</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.v6.dren.net/lg/"
TARGET="_top"
>DRENv6 Looking Glass</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4020"
>25.6.4. Helper applications</A
></H3
><P
></P
><UL
><LI
><P
><A
HREF="http://www.tdoi.org/prefcalc.php"
TARGET="_top"
>IPv6 Prefix Calculator</A
> by <A
HREF="http://www.tdoi.org/"
TARGET="_top"
>TDOI</A
></P
></LI
><LI
><P
><A
HREF="http://www.maths.tcd.ie/cgi-bin/check_dns.pl"
TARGET="_top"
>DNS record checker</A
></P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-TRAININGSANDSEMINARS"
>25.7. Trainings, Seminars</A
></H2
><P
></P
><UL
><LI
><P
><A
HREF="http://www.e-trainonline.com/html/ciw_internetworking_profession.html#IPv6"
TARGET="_top"
>CIW Internetworking Professional Training CBT CD</A
></P
></LI
><LI
><P
><A
HREF="http://www.trainingpages.com/x/category,kw-1628,.html"
TARGET="_top"
>Training Pages</A
>, U.K. - Search for IPv6 (13 Courses, 2006-08-21)</P
></LI
><LI
><P
><A
HREF="http://www.erion.co.uk/ipv6.html"
TARGET="_top"
>Erion IPv6 Training</A
>, UK</P
></LI
></UL
><P
>Something missing? Suggestions are welcome!</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INFORMATION-ONLINEDISCOVERY"
>25.8. 'The Online Discovery' ...</A
></H2
><P
>IPv6: Addressing The Needs Of the Future by Yankee Group (Author) 
List Price:   $595.00
Edition: e-book (Acrobat Reader)
Pages: 3 (three)
Publisher: MarketResearch.com; ISBN B00006334Y; (November 1, 2001) </P
><P
>;-) The number of copies would be interesting...</P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN4047"
></A
>Chapter 26. Revision history / Credits / The End</H1
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="REVISION-HISTORY"
>26.1. Revision history</A
></H2
><P
>Versions x.y are published on the Internet.</P
><P
>Versions x.y.z are work-in-progress and published as LyX and SGML file on CVS. Because Deep Space 6 mirrors these SGML files and generate independend from TLDP public versions, this versions will show up there and also on its mirrors.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4053"
>26.1.1. Releases 0.x</A
></H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>0.65</DT
><DD
><P
>2010-04-20/PB: extend QoS section with examples</P
></DD
><DT
>0.65</DT
><DD
><P
>2009-12-13/PB: minor fixes</P
></DD
><DT
>0.64</DT
><DD
><P
>2009-06-11/PB: extend DHCP server examples (ISC DHCP, Dibbler)</P
></DD
><DT
>0.63</DT
><DD
><P
>2009-02-14/PB: Fix FSF address, major update on 4in6 tunnels, add new section for address resolving, add some URLs, remove broken URLs</P
></DD
><DT
>0.62</DT
><DD
><P
>2008-11-09/PB: Adjust URL to Turkish howto, add some HIP related URLs, remove broken URLs</P
></DD
><DT
>0.61.1</DT
><DD
><P
>2007-11-11/PB: fix broken description of shortcut BIND</P
></DD
><DT
>0.61</DT
><DD
><P
>2007-10-06/PB: fix broken URLs to TLDP-CVS, minor URL update.</P
></DD
><DT
>0.60.2</DT
><DD
><P
>2007-10-03/PB: fix description of sysctl/autoconf (credits to Francois-Xavier Le Bail)</P
></DD
><DT
>0.60.1</DT
><DD
><P
>2007-06-16/PB: speling fixes (credits to Larry W. Burton)</P
></DD
><DT
>0.60</DT
><DD
><P
>2007-05-29/PB: import major contribution to Programming using C-API written by John Wenker, minor fixes</P
></DD
><DT
>0.52</DT
><DD
><P
>2007-05-23/PB: update firewalling chapter, improve document for proper SGML validation, minor bugfixes</P
></DD
><DT
>0.51</DT
><DD
><P
>2006-11-08/PB: remove broken URLs, add a new book (credits to Bryan Vukich)</P
></DD
><DT
>0.50.2</DT
><DD
><P
>2006-10-25/PB: fix typo in dhcp6 section (credits to Michele Ferritto)</P
></DD
><DT
>0.50.1</DT
><DD
><P
>2006-09-23/PB: add some URLs</P
></DD
><DT
>0.50</DT
><DD
><P
>2006-08-24/PB: check RFC URLs, fix URL to Chinese translation, finalize for publishing</P
></DD
><DT
>0.49.5</DT
><DD
><P
>2006-08-23/PB: fix/remove broken URLs</P
></DD
><DT
>0.49.4</DT
><DD
><P
>2006-08-21/PB: some review, update and enhancement of the content, replace old 6bone example addresses with the current defined ones.</P
></DD
><DT
>0.49.3</DT
><DD
><P
>2006-08-20/PB: fix bug in maillist entries, 'mobility' is now a separate chapter</P
></DD
><DT
>0.49.2</DT
><DD
><P
>2006-08-20/PB: update and cleanup of maillist entries</P
></DD
><DT
>0.49.1</DT
><DD
><P
>2006-06-13/PB: major update of mobility section (contributed by Benjamin Thery)</P
></DD
><DT
>0.49</DT
><DD
><P
>2005-10-03/PB: add configuration hints for DHCPv6, major broken URL cleanup (credits to Necdet Yucel)</P
></DD
><DT
>0.48.1</DT
><DD
><P
>2005-01-15/PB: minor fixes</P
></DD
><DT
>0.48</DT
><DD
><P
>2005-01-11/PB: grammar check and minor review of IPv6 IPsec section</P
></DD
><DT
>0.47.1</DT
><DD
><P
>2005-01-01/PB: add information and examples about IPv6 IPsec, add some URLs</P
></DD
><DT
>0.47</DT
><DD
><P
>2004-08-30/PB: add some notes about proftpd, vsftpd and other daemons, add some URLs, minor fixes, update status of Spanish translation</P
></DD
><DT
>0.46.4</DT
><DD
><P
>2004-07-19/PB: minor fixes</P
></DD
><DT
>0.46.3</DT
><DD
><P
>2004-06-23/PB: add note about started Greek translation, replace Taiwanese with Chinese for related translation</P
></DD
><DT
>0.46.2</DT
><DD
><P
>2004-05-22/PB: minor fixes</P
></DD
><DT
>0.46.1</DT
><DD
><P
>2004-04-18/PB: minor fixes</P
></DD
><DT
>0.46</DT
><DD
><P
>2004-03-04/PB: announce Italian translation, add information about DHCPv6, minor updates</P
></DD
><DT
>0.45.1</DT
><DD
><P
>2004-01-12/PB: add note about the official example address space</P
></DD
><DT
>0.45</DT
><DD
><P
>2004-01-11/PB: minor fixes, add/fix some URLs, some extensions</P
></DD
><DT
>0.44.2</DT
><DD
><P
>2003-10-30/PB: fix some copy&#38;paste text bugs</P
></DD
><DT
>0.44.1</DT
><DD
><P
>2003-10-19/PB: add note about start of Italian translation</P
></DD
><DT
>0.44</DT
><DD
><P
>2003-08-15/PB: fix URLs, add hint on tcp_wrappers (about broken notation in some versions) and Apache2</P
></DD
><DT
>0.43.4</DT
><DD
><P
>2003-07-26/PB: fix URL, add archive URL for maillist users at ipv6.org, add some ds6 URLs</P
></DD
><DT
>0.43.3</DT
><DD
><P
>2003-06-19/PB: fix typos</P
></DD
><DT
>0.43.2</DT
><DD
><P
>2003-06-11/PB: fix URL</P
></DD
><DT
>0.43.1</DT
><DD
><P
>2003-06-07/PB: fix some URLs, fix credits, add some notes at IPsec</P
></DD
><DT
>0.43</DT
><DD
><P
>2003-06-05/PB: add some notes about configuration in SuSE Linux, add URL of French translation</P
></DD
><DT
>0.42</DT
><DD
><P
>2003-05-09/PB: minor fixes, announce French translation</P
></DD
><DT
>0.41.4</DT
><DD
><P
>2003-05-02/PB: Remove a broken URL, update some others.</P
></DD
><DT
>0.41.3</DT
><DD
><P
>2003-04-23/PB: Minor fixes, remove a broken URL, fix URL to Taiwanese translation</P
></DD
><DT
>0.41.2</DT
><DD
><P
>2003-04-13/PB: Fix some typos, add a note about a French translation is in progress</P
></DD
><DT
>0.41.1</DT
><DD
><P
>2003-03-31/PB: Remove a broken URL, fix another</P
></DD
><DT
>0.41</DT
><DD
><P
>2003-03-22/PB: Add URL of German translation</P
></DD
><DT
>0.40.2</DT
><DD
><P
>2003-02-27/PB: Fix a misaddressed URL</P
></DD
><DT
>0.40.1</DT
><DD
><P
>2003-02-12/PB: Add Debian-Linux-Configuration, add a minor note on translations</P
></DD
><DT
>0.40</DT
><DD
><P
>2003-02-10/PB: Announcing available German version</P
></DD
><DT
>0.39.2</DT
><DD
><P
>2003-02-10/GK: Minor syntax and spelling fixes</P
></DD
><DT
>0.39.1</DT
><DD
><P
>2003-01-09/PB: fix an URL (draft adopted to an RFC)</P
></DD
><DT
>0.39</DT
><DD
><P
>2003-01-13/PB: fix a bug (forgotten 'link” on “ip link set” (credits to Yaniv Kaul)</P
></DD
><DT
>0.38.1</DT
><DD
><P
>2003-01-09/PB: a minor fix</P
></DD
><DT
>0.38</DT
><DD
><P
>2003-01-06/PB: minor fixes</P
></DD
><DT
>0.37.1</DT
><DD
><P
>2003-01-05/PB: minor updates</P
></DD
><DT
>0.37</DT
><DD
><P
>2002-12-31/GK: 270 new links added (searched in 1232 SearchEngines) in existing and 53 new (sub)sections</P
></DD
><DT
>0.36.1</DT
><DD
><P
>2002-12-20/PB: Minor fixes</P
></DD
><DT
>0.36</DT
><DD
><P
>2002-12-16/PB: Check of and fix broken links (credits to Georg Käfer), some spelling fixes</P
></DD
><DT
>0.35</DT
><DD
><P
>2002-12-11/PB: Some fixes and extensions</P
></DD
><DT
>0.34.1</DT
><DD
><P
>2002-11-25/PB: Some fixes (e.g. broken linuxdoc URLs)</P
></DD
><DT
>0.34</DT
><DD
><P
>2002-11-19/PB: Add information about German translation (work in progress), some fixes, create a small shortcut explanation list, extend “used terms” and add two German books</P
></DD
><DT
>0.33</DT
><DD
><P
>2002-11-18/PB: Fix broken RFC-URLs, add parameter ttl on 6to4 tunnel setup example</P
></DD
><DT
>0.32</DT
><DD
><P
>2002-11-03/PB: Add information about Taiwanese translation</P
></DD
><DT
>0.31.1</DT
><DD
><P
>2002-10-06/PB: Add another maillist</P
></DD
><DT
>0.31</DT
><DD
><P
>2002-09-29/PB: Extend information in proc-filesystem entries</P
></DD
><DT
>0.30</DT
><DD
><P
>2002-09-27/PB: Add some maillists</P
></DD
><DT
>0.29</DT
><DD
><P
>2002-09-18/PB: Update statement about nmap (triggered by Fyodor)</P
></DD
><DT
>0.28.1</DT
><DD
><P
>2002-09-16/PB: Add note about ping6 to multicast addresses, add some labels</P
></DD
><DT
>0.28</DT
><DD
><P
>2002-08-17/PB: Fix broken LDP/CVS links, add info about Polish translation, add URL of the IPv6 Address Oracle</P
></DD
><DT
>0.27</DT
><DD
><P
>2002-08-10/PB: Some minor updates</P
></DD
><DT
>0.26.2</DT
><DD
><P
>2002-07-15/PB: Add information neighbor discovery, split of firewalling (got some updates) and security into extra chapters</P
></DD
><DT
>0.26.1</DT
><DD
><P
>2002-07-13/PB: Update nmap/IPv6 information</P
></DD
><DT
>0.26</DT
><DD
><P
>2002-07-13/PB: Fill /proc-filesystem chapter, update DNS information about depricated A6/DNAME, change P-t-P tunnel setup to use of “ip” only</P
></DD
><DT
>0.25.2</DT
><DD
><P
>2002-07-11/PB: Minor spelling fixes</P
></DD
><DT
>0.25.1</DT
><DD
><P
>2002-06-23/PB: Minor spelling and other fixes</P
></DD
><DT
>0.25</DT
><DD
><P
>2002-05-16/PB: Cosmetic fix for 2^128, thanks to José Abílio Oliveira Matos for help with LyX</P
></DD
><DT
>0.24</DT
><DD
><P
>2002-05-02/PB: Add entries in URL list, minor spelling fixes</P
></DD
><DT
>0.23</DT
><DD
><P
>2002-03-27/PB: Add entries in URL list and at maillists, add a label and minor information about IPv6 on RHL</P
></DD
><DT
>0.22</DT
><DD
><P
>2002-03-04/PB: Add info about 6to4 support in kernel series 2.2.x and add an entry in URL list and at maillists</P
></DD
><DT
>0.21</DT
><DD
><P
>2002-02-26/PB: Migrate next grammar checks submitted by John Ronan </P
></DD
><DT
>0.20.4</DT
><DD
><P
>2002-02-21/PB: Migrate more grammar checks submitted by John Ronan, add some additional hints at DNS section </P
></DD
><DT
>0.20.3</DT
><DD
><P
>2002-02-12/PB: Migrate a minor grammar check patch submitted by John Ronan</P
></DD
><DT
>0.20.2</DT
><DD
><P
>2002-02-05/PB: Add mipl to maillist table</P
></DD
><DT
>0.20.1</DT
><DD
><P
>2002-01-31/PB: Add a hint how to generate 6to4 addresses</P
></DD
><DT
>0.20</DT
><DD
><P
>2002-01-30/PB: Add a hint about default route problem, some minor updates</P
></DD
><DT
>0.19.2</DT
><DD
><P
>2002-01-29/PB: Add many new URLs</P
></DD
><DT
>0.19.1</DT
><DD
><P
>2002-01-27/PB: Add some forgotten URLs</P
></DD
><DT
>0.19</DT
><DD
><P
>2002-01-25/PB: Add two German books, fix quote entinities in exported SGML code</P
></DD
><DT
>0.18.2</DT
><DD
><P
>2002-01-23/PB: Add a FAQ on the program chapter</P
></DD
><DT
>0.18.1</DT
><DD
><P
>2002-01-23/PB: Move “the end” to the end, add USAGI to maillists</P
></DD
><DT
>0.18</DT
><DD
><P
>2002-01-22/PB: Fix bugs in explanation of multicast address types</P
></DD
><DT
>0.17.2</DT
><DD
><P
>2002-01-22/PB: Cosmetic fix double existing text in history (at 0.16), move all credits to the end of the document</P
></DD
><DT
>0.17.1</DT
><DD
><P
>2002-01-20/PB: Add a reference, fix URL text in online-test-tools</P
></DD
><DT
>0.17</DT
><DD
><P
>2002-01-19/PB: Add some forgotten information and URLs about global IPv6 addresses</P
></DD
><DT
>0.16</DT
><DD
><P
>2002-01-19/PB: Minor fixes, remove “bold” and “emphasize” formats on code lines, fix “too long unwrapped code lines” using selfmade utility, extend list of URLs.</P
></DD
><DT
>0.15</DT
><DD
><P
>2002-01-15/PB: Fix bug in addresstype/anycast, move content related credits to end of document</P
></DD
><DT
>0.14</DT
><DD
><P
>2002-01-14/PB: Minor review at all, new chapter “debugging”, review “addresses”, spell checking, grammar checking (from beginning to 3.4.1) by Martin Krafft, add tcpdump examples, copy firewalling/netfilter6 from IPv6+Linux-HowTo, minor enhancements</P
></DD
><DT
>0.13</DT
><DD
><P
>2002-01-05/PB: Add example BIND9/host, move revision history to end of document, minor extensions</P
></DD
><DT
>0.12</DT
><DD
><P
>2002-01-03/PB: Merge review of David Ranch</P
></DD
><DT
>0.11</DT
><DD
><P
>2002-01-02/PB: Spell checking and merge review of Pekka Savola</P
></DD
><DT
>0.10</DT
><DD
><P
>2002-01-02/PB: First public release of chapter 1</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CREDITS"
>26.2. Credits</A
></H2
><P
>The quickest way to be added to this nice list is to send bug fixes, corrections, and/or updates to me ;-).</P
><P
>If you want to do a major review, you can use the native LyX file (see <A
HREF="#GENERAL-ORIGINAL-SOURCE"
>original source</A
>) and send diffs against it, because diffs against SGML don't help too much.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAJOR-CREDITS"
>26.2.1. Major credits</A
></H3
><P
></P
><UL
><LI
><P
>David Ranch &#60;dranch at trinnet dot net&#62;: For encouraging me to write this HOWTO, his editorial comments on the first few revisions, and his contributions to various IPv6 testing results on my IPv6 web site. Also for his major reviews and suggestions.</P
></LI
><LI
><P
>Pekka Savola &#60;pekkas at netcore dot fi&#62;: For major reviews, input and suggestions.</P
></LI
><LI
><P
>Martin F. Krafft &#60;madduck at madduck dot net&#62;: For grammar checks and general reviewing of the document.</P
></LI
><LI
><P
>John Ronan &#60;j0n at tssg dot wit dot ie&#62;: For grammar checks.</P
></LI
><LI
><P
>Georg Käfer &#60;gkaefer at gmx dot at&#62;: For detection of no proper PDF creation (fixed now by LDP maintainer Greg Ferguson), input for German books, big list of URLs, checking all URLs, many more suggestions, corrections and contributions, and the German translation</P
></LI
><LI
><P
>Michel Boucey &#60;mboucey at free dot fr&#62;: Finding typos and some broken URLs, contribute some suggestions and URLs, and the French translation</P
></LI
><LI
><P
>Michele Ferritto &#60;m dot ferritto at virgilio dot it&#62;: Finding bugs and the Italian translation</P
></LI
><LI
><P
>Daniel Roesen &#60;dr at cluenet dot de&#62;: For grammar checks</P
></LI
><LI
><P
>Benjamin Thery &#60;benjamin dot thery at bull dot net&#62;: For contribution of updated mobility section</P
></LI
><LI
><P
>John Wenker &#60;jjw at pt dot com&#62;: major contribution to Programming using C-API</P
></LI
><LI
><P
>Srivats P. &#60;Srivats dot P at conexant dot com&#62;: major contribution for 4in6 tunnels</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN4490"
>26.2.2. Other credits</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN4492"
>26.2.2.1. Document technique related</A
></H4
><P
>Writing a LDP HOWTO as a newbie (in LyX and exporting this to DocBook to conform to SGML) isn't as easy as some people say. There are some strange pitfalls... Nevertheless, thanks to:</P
><P
></P
><UL
><LI
><P
>Authors of the <A
HREF="http://www.tldp.org/LDP/LDP-Author-Guide/"
TARGET="_top"
>LDP Author Guide</A
></P
></LI
><LI
><P
>B. Guillon: For his <A
HREF="http://perso.libertysurf.fr/bgu/doc/db4lyx/"
TARGET="_top"
>DocBook with LyX HOWTO</A
></P
></LI
></UL
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="CONTENT-RELATED-CREDITS"
>26.2.2.2. Content related credits</A
></H4
><P
>Credits for fixes and hints are listed here, will grow sure in the future</P
><P
></P
><UL
><LI
><P
>S .P. Meenakshi &#60;meena at cs dot iitm dot ernet dot in&#62;: For a hint using a “send mail” shell program on tcp_wrapper/hosts.deny</P
></LI
><LI
><P
>Frank Dinies &#60;FrankDinies at web dot de&#62;: For a bugfix on IPv6 address explanation</P
></LI
><LI
><P
>John Freed &#60;jfreed at linux-mag dot com&#62;: For finding a bug in IPv6 multicast address explanation</P
></LI
><LI
><P
>Craig Rodrigues &#60;crodrigu at bbn dot com&#62;: For suggestion about RHL IPv6 setup</P
></LI
><LI
><P
>Fyodor &#60;fyodor at insecure dot org&#62;: Note me about outdated nmap information</P
></LI
><LI
><P
>Mauro Tortonesi &#60;mauro at deepspace6 dot net&#62;: For some suggestions</P
></LI
><LI
><P
>Tom Goodale &#60;goodale at aei-potsdam dot mpg dot de&#62;: For some suggestions</P
></LI
><LI
><P
>Martin Luemkemann &#60;mluemkem at techfak dot uni-bielefeld dot de&#62;: For a suggestion</P
></LI
><LI
><P
>Jean-Marc V. Liotier &#60;jim at jipo dot com&#62;: Finding a bug</P
></LI
><LI
><P
>Yaniv Kaul &#60;ykaul at checkpoint dot com&#62;: Finding a bug</P
></LI
><LI
><P
>Arnout Engelen &#60;arnouten at bzzt dot net&#62;: For sending note about a draft was adopted to RFC now</P
></LI
><LI
><P
>Stephane Bortzmeyer &#60;bortzmeyer at nic dot fr&#62;: Contributing persistent configuration on Debian</P
></LI
><LI
><P
>lithis von saturnsys &#60;lithis at saturnsys dot com&#62;: Reporting a misaddressed URL</P
></LI
><LI
><P
>Guy Hulbert &#60;gwhulbert at rogers dot com&#62;: Send a note that RFC1924 is probably an April fool's joke</P
></LI
><LI
><P
>Tero Pelander &#60;tpeland at tkukoulu dot fi&#62;: Reporting a broken URL</P
></LI
><LI
><P
>Walter Jontofsohn &#60;wjontof at gmx dot de&#62;: Hints for SuSE Linux 8.0/8.1</P
></LI
><LI
><P
>Benjamin Hofstetter &#60;benjamin dot hofstetter at netlabs dot org&#62;: Reporting a mispointing URL</P
></LI
><LI
><P
>J.P. Larocque &#60;piranha at ely dot ath dot cx&#62;: Reporting archive URL for maillist users at ipv6 dot org</P
></LI
><LI
><P
>Jorrit Kronjee &#60;jorrit at wafel dot org&#62;: Reporting broken URLs</P
></LI
><LI
><P
>Colm MacCarthaigh &#60;colm dot maccarthaigh at heanet dot ie&#62;: Hint for sendfile issue on Apache2</P
></LI
><LI
><P
>Tiago Camilo &#60;tandre at ipg dot pt&#62;: Contribute some URLs about Mobile IPv6</P
></LI
><LI
><P
>Harald Geiger: Reporting a bug in how described the bit counting of the universal/global bit</P
></LI
><LI
><P
>Bjoern Jacke &#60;bjoern at j3e dot de&#62;: Triggered me to fix some outdated information on xinetd</P
></LI
><LI
><P
>Christoph Egger &#60;cegger at chrrr dot com&#62;: Sending note about “ip” has problems with IPv4-compatible addresses on SuSE Linux 9.0 and trigger to add a hint on 6to4-radvd example</P
></LI
><LI
><P
>David Lee Haw Ling &#60;hawling at singnet dot com dot sg&#62;: Sending information about a tunnel broker</P
></LI
><LI
><P
>Michael H. Warfield &#60;mhw at iss dot net&#62;: Sending note about suffix for 6to4 routers</P
></LI
><LI
><P
>Tomasz Mrugalski &#60;thomson at klub dot com dot pl&#62;: Sending updates for DHCPv6 section</P
></LI
><LI
><P
>Jan Minar &#60;jjminar at fastmail dot fm&#62;: Reporting minor bugs</P
></LI
><LI
><P
>Kalin KOZHUHAROV &#60;kalin at tar dot bz&#62;: Fixing a not so well explanation</P
></LI
><LI
><P
>Roel van Dijk &#60;rdvdijk at planet dot nl&#62;: Reporting broken URLs</P
></LI
><LI
><P
>Catalin Muresan &#60;catalin dot muresan at astral dot ro&#62;: Reporting minor bugs</P
></LI
><LI
><P
>Dennis van Dok &#60;dvandok at quicknet dot nl&#62;: Reporting minor bugs</P
></LI
><LI
><P
>Necdet Yucel &#60;nyucel at comu dot edu dot tr&#62;: Reporting broken URLs</P
></LI
><LI
><P
>Bryan Vukich: Reporting a broken URL</P
></LI
><LI
><P
>Daniele Masini: reporting a broken iptables example</P
></LI
><LI
><P
>Yao Zhao: reporting a bug in IPv6 route remove description</P
></LI
><LI
><P
>Aaron Kunde: reporting a broken URL and a content related bug</P
></LI
><LI
><P
>Larry W. Burton: speling fixes</P
></LI
><LI
><P
>Justin Pryzby: reporting broken shortcut description of BIND</P
></LI
></UL
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN4584"
>26.3. The End</A
></H2
><P
>Thanks for reading. Hope it helps!</P
><P
>If you have any questions, subscribe to proper <A
HREF="#INFORMATION-MAILLISTS"
>maillist</A
> and describe your problem providing as much as information as possible.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>