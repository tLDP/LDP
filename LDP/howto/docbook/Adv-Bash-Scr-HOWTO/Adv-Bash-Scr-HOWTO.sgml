<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!--
Uncomment line below to generate index.
-->
<!--
<!ENTITY indice SYSTEM "indice.sgml">
-->
<!ENTITY ex1 SYSTEM "ex1.sh">
<!ENTITY ex2 SYSTEM "ex2.sh">
<!ENTITY ex3 SYSTEM "ex3.sh">
<!ENTITY ex4 SYSTEM "ex4.sh">
<!ENTITY ex5 SYSTEM "ex5.sh">
<!ENTITY ex6 SYSTEM "ex6.sh">
<!ENTITY ex7 SYSTEM "ex7.sh">
<!ENTITY ex8 SYSTEM "ex8.sh">
<!ENTITY ex9 SYSTEM "ex9.sh">
<!ENTITY ex10 SYSTEM "ex10.sh">
<!ENTITY ex11 SYSTEM "ex11.sh">
<!ENTITY ex12 SYSTEM "ex12.sh">
<!ENTITY ex13 SYSTEM "ex13.sh">
<!ENTITY ex14 SYSTEM "ex14.sh">
<!ENTITY ex15 SYSTEM "ex15.sh">
<!ENTITY ex16 SYSTEM "ex16.sh">
<!ENTITY ex17 SYSTEM "ex17.sh">
<!ENTITY ex18 SYSTEM "ex18.sh">
<!ENTITY ex19 SYSTEM "ex19.sh">
<!ENTITY ex20 SYSTEM "ex20.sh">
<!ENTITY ex21 SYSTEM "ex21.sh">
<!ENTITY ex22 SYSTEM "ex22.sh">
<!ENTITY ex23 SYSTEM "ex23.sh">
<!ENTITY ex24 SYSTEM "ex24.sh">
<!ENTITY ex25 SYSTEM "ex25.sh">
<!ENTITY ex26 SYSTEM "ex26.sh">
<!ENTITY ex27 SYSTEM "ex27.sh">
<!ENTITY ex28 SYSTEM "ex28.sh">
<!ENTITY ex29 SYSTEM "ex29.sh">
<!ENTITY ex30 SYSTEM "ex30.sh">
<!ENTITY ex31 SYSTEM "ex31.sh">
<!ENTITY ex32 SYSTEM "ex32.sh">
<!ENTITY ex33 SYSTEM "ex33.sh">
<!ENTITY ex34 SYSTEM "ex34.sh">
<!ENTITY ex35 SYSTEM "ex35.sh">
<!ENTITY ex36 SYSTEM "ex36.sh">
<!ENTITY ex37 SYSTEM "ex37.sh">
<!ENTITY ex38 SYSTEM "ex38.sh">
<!ENTITY ex38bis SYSTEM "data-file">
<!ENTITY ex39 SYSTEM "ex39.sh">
<!ENTITY ex40 SYSTEM "ex40.sh">
<!ENTITY ex41 SYSTEM "ex41.sh">
<!ENTITY ex42 SYSTEM "ex42.sh">
<!ENTITY ex43 SYSTEM "ex43.sh">
<!ENTITY ex44 SYSTEM "ex44.sh">
<!ENTITY ex45 SYSTEM "ex45.sh">
<!ENTITY ex46 SYSTEM "ex46.sh">
<!ENTITY ex47 SYSTEM "ex47.sh">
<!ENTITY ex48 SYSTEM "ex48.sh">
<!ENTITY ex49 SYSTEM "ex49.sh">
<!ENTITY ex50 SYSTEM "ex50.sh">
<!ENTITY ex51 SYSTEM "ex51.sh">
<!ENTITY ex52 SYSTEM "ex52.sh">
<!ENTITY ex53 SYSTEM "ex53.sh">
<!ENTITY ex54 SYSTEM "ex54.sh">
<!ENTITY ex55 SYSTEM "ex55.sh">
<!ENTITY ex56 SYSTEM "ex56.sh">
<!ENTITY ex57 SYSTEM "ex57.sh">
<!ENTITY ex58 SYSTEM "ex58.sh">
<!ENTITY ex59 SYSTEM "ex59.sh">
<!ENTITY ex60 SYSTEM "ex60.sh">
<!ENTITY ex61 SYSTEM "ex61.sh">
<!ENTITY ex62 SYSTEM "ex62.sh">
<!ENTITY ex63 SYSTEM "ex63.sh">
<!ENTITY ex64 SYSTEM "ex64.sh">
<!ENTITY ex65 SYSTEM "ex65.sh">
<!ENTITY ex66 SYSTEM "ex66.sh">
<!ENTITY ex67 SYSTEM "ex67.sh">
<!ENTITY ex68 SYSTEM "ex68.sh">
<!ENTITY ex69 SYSTEM "ex69.sh">
<!ENTITY ex70 SYSTEM "ex70.sh">
<!ENTITY ex71 SYSTEM "ex71.sh">
<!ENTITY ex72 SYSTEM "ex72.sh">
<!ENTITY ex73 SYSTEM "ex73.sh">
<!ENTITY ex74 SYSTEM "ex74.sh">
<!ENTITY ex75 SYSTEM "ex75.sh">
<!ENTITY ex76 SYSTEM "ex76.sh">
<!ENTITY ex77 SYSTEM "ex77.sh">
<!ENTITY ex78 SYSTEM "ex78.sh">
<!ENTITY ex79 SYSTEM "ex79.sh">
]>
<!-- 
<article>
  <artheader>
    <title>Advanced Bash-Scripting HOWTO</title>
    <subtitle>A guide to shell scripting, using Bash</subtitle>
    <author>
      <firstname>Mendel</firstname>
      <surname>Cooper</surname>
      <affiliation>
	<address><email>thegrendel@theriver.com</email></address>
      </affiliation>
    </author>
    <pubdate>v0.1, 14 June 2000</pubdate>
    <abstract><para>This document is both a tutorial and a reference to shell
	scripting. It is essentially a synopsis of a complete book on the
	subject.</para>
    </abstract>
  </artheader>
  -->
<book>
  <bookinfo>
    <title>Advanced Bash-Scripting HOWTO</title>
    <subtitle>A guide to shell scripting, using Bash</subtitle>
    <author>
      <firstname>Mendel</firstname>
      <surname>Cooper</surname>
      <affiliation>
	<address><email>thegrendel@theriver.com</email></address>
      </affiliation>
    </author>
    <pubdate>v0.1, 14 June 2000</pubdate>
    <abstract>

      <para>v0.1, 14 June 2000</para>

      <para>This document is both a tutorial and a reference on shell
	scripting with Bash.  It assumes no previous knowledge of
	scripting or programming, but progresses rapidly toward an
	intermediate/advanced level of instruction.  The exercises and
	heavily-commented examples invite active reader participation.
	This is essentially a synopsis of a complete book on the
	subject.</para>

    </abstract>
  </bookinfo>
  <chapter id="why-shell">
    <title>Why Shell Programming?</title>
    
    <para>The shell is a command interpreter. It is the insulating layer between
      the operating system kernel and the user. Yet, it is also a fairly
      powerful programming language.  A shell program, called a 
      <firstterm>
	<indexterm>
	  <primary>script</primary>
	</indexterm>
	script
      </firstterm>,
      is an easy-to-use tool for building applications by <quote>gluing</quote> together
      system calls, tools, utilities, and compiled binaries.  Virtually the
      entire repertoire of UNIX commands, utilities, and tools is available for
      invocation by a shell script.  If that were not enough, internal shell
      commands, such as testing and loop constructs, give additional power
      and flexibility to scripts.  Shell scripts lend themselves exceptionally
      well to to administrative system tasks and other routine repetitive jobs
      not requiring the bells and whistles of a full-blown tightly structured
      programming language.</para>
    
    <para>A working knowledge of shell scripting is essential to everyone wishing
      to become reasonably adept at system administration, even if they do
      not anticipate ever having to actually write a script. Consider that as
      a Linux machine boots up, it executes the shell scripts in <filename>/etc/rc.d</filename>
      to restore the system configuration and set up services. A detailed
      understanding of these scripts is important for analyzing the behavior
      of a system, and possibly modifying it.</para>
    
    <para>Writing shell scripts is not hard to learn, since the scripts can be
      built in bite-sized sections and there is only a fairly small set of
      shell-specific operators and options to learn.  The syntax is simple
      and straightforward, similar to that of invoking and chaining together
      utilities at the command line, and there are only a few <quote>rules</quote> to learn.
      Most short scripts work right the first time, and debugging even the
      longer ones is straightforward.</para>
    
    <para>A shell script is a <quote>quick and dirty</quote> method of prototyping a complex
      application.  Getting even a limited subset of the functionality to
      work in a shell script, even if slowly, is often a useful first stage in
      project development. This way, the structure of the application can be
      tested and played with, and the major pitfalls found before proceeding
      to the final coding in C, C++, Java, or Perl.</para>
    
    <para>Shell scripting hearkens back to the classical UNIX philosophy of breaking
      complex projects into simpler subtasks, of chaining together components
      and utilities. Many consider this a better, or at least more esthetically
      pleasing approach to problem solving than using one of the new generation
      of high powered all-in-one languages, such as Perl, which attempt to be
      all things to all people, but at the cost of forcing you to alter your
      thinking processes to fit the tool.</para>
    
    <para>When not to use shell scripts
      
      <itemizedlist>
	<listitem>
	  <para>resource-intensive tasks, especially where speed is a factor</para>
	</listitem>
	<listitem>
	  <para>complex applications, where structured programming is a necessity</para>
	</listitem>
	<listitem>
	  <para>file handling (Bash is limited to serial file access, and that only
	    in a particularly clumsy and inefficient line-by-line fashion)</para>
	</listitem>
	<listitem>
	  <para>need to generate or manipulate graphics or GUIs</para>
	</listitem>
	<listitem>
	  <para>need direct access to system hardware</para>
	</listitem>
	<listitem>
	  <para>need port or socket I/O</para>
	</listitem>
	<listitem>
	  <para>need to use libraries or interface with legacy code</para>
	</listitem>
      </itemizedlist></para>
    
    <para>If any of the above applies, consider a more powerful scripting language,
      perhaps Perl, Tcl, Python, or even a high-level compiled language such
      as C, C++, or Java. Even then, prototyping the application as a shell
      script might still be a useful development step.</para>
    
    <para>We will be using Bash, an acronym for <quote>Born-Again Shell</quote> and a pun
      on Stephen Bourne's now classic Bourne Shell.  Bash has become the de
      facto standard for shell scripting on all flavors of UNIX. Most of the
      principles dealt with in this document apply equally well to scripting
      with other shells, such as the Korn Shell, from which Bash derives
      some of its features, and the C Shell and its variants.  (Note that C
      Shell programming is not recommended due to certain inherent problems,
      as pointed out in a <ulink
      url="http://www.etext.org/Quartz/computer/unix/csh.harmful.gz">news
      group posting</ulink> by Tom Christiansen in October of 1993).
      </para>
    
    <para>The following is a tutorial in shell scripting.  It relies heavily
      on examples to illustrate features of the shell.  As far as possible,
      the example scripts have been tested, and some of them may actually be
      useful in real life.  The reader should cut out and save the examples,
      assign them appropriate names, give them execute permission (<userinput>chmod u+x
	scriptname</userinput>), then run them to see what happens.  Note that some of the
      scripts below introduce features before they are explained, and this
      may require the reader to temporarily skip ahead for enlightenment.</para>
    
    <para>Unless otherwise noted, the author of this document wrote the example
      scripts that follow.</para>
  </chapter> <!-- Why Shell Programming? -->
  
  <chapter id="sha-bang">
    <title>Starting Off With a Sha-Bang</title>
    <para>In the simplest case, a script is nothing more than a list of system
      commands stored in a file. At the very least, this saves the effort of
      retyping that particular sequence of commands each time it is invoked.</para>
    
    <example id="ex1">
      <title><command>cleanup</command>: A script to clean up the log files in /var/log
      </title>
      <programlisting>&ex1;</programlisting>
    </example>
    
    <para>There is nothing unusual here, just a set of commands that could just
      as easily be invoked one by one from the command line on the console
      or in an xterm. The advantages of placing the commands in a script go
      beyond not having to retype them time and again. The script can easily
      be modified, customized, or generalized for a particular application.</para>
    
    <example id="ex2">
      <title><command>cleanup</command>
	An enhanced and generalized version of above script.</title>
      <programlisting>&ex2;</programlisting>
    </example>

    <para>Since you may not wish to wipe out the entire system log, this variant of
      the first script keeps the last section of the message log intact. You
      will constantly discover ways of refining previously written scripts
      for increased effectiveness.</para>
    
    <para>The 
      <firstterm><indexterm>
	  <primary>sha-bang</primary>
	</indexterm>
	sha-bang</firstterm> 
      (<token>
	<indexterm>
	  <primary>#!</primary>
	</indexterm>
	#!</token>) at the head of a script
      tells your system that this file 
      is a set of commands to be fed to the command interpreter indicated.
      The <token>#!</token> is actually a two byte 
      <quote>
	<indexterm>
	  <primary>magic number</primary>
	</indexterm>
	magic number</quote> that marks an executable
      shell script (<userinput>man magic</userinput> gives more info on this fascinating topic).
      It also gives the path to the program that the script invokes, whether
      this be the shell, a programming language, or a utility.  This enables the
      specific commands and directives embedded in the shell or program called.</para>
    
    <para><programlisting>#!/bin/sh
#!/bin/bash
#!/bin/awk
#!/usr/bin/perl
#!/bin/sed
#!/usr/bin/tcl</programlisting></para>

    <para>Each of the above script header lines calls a different command
      interpreter, be it <filename>/bin/sh</filename>, the default shell
      (<command>bash</command> in a Linux system) or otherwise.  Using
      <userinput>#!/bin/sh</userinput>, the default Bourne Shell in 
      most commercial variants of UNIX, makes the script portable to non-Linux
      machines, though you may have to sacrifice a few bash-specific features
      (the script will conform to the POSIX <command>sh</command> standard).</para>
    
    <para>Note that the path given at the <quote>sha-bang</quote> must be correct, otherwise
      an error message, usually <errorname>Command not found</errorname> will be the
      only result of running the script.</para>
    
    <para><token>#!</token> can be omitted if the script consists only of a set
      of generic system 
      commands, using no internal shell directives.  Example 2, above, requires
      the initial <token>#!</token>, since the variable assignment line, <userinput>lines=50</userinput>, uses a
      shell-specific construct.  Note that <userinput>#!/bin/sh</userinput> invokes the
      default shell interpreter, which defaults to <filename>/bin/bash</filename> on a
      Linux machine.</para>
    
    <sect1 id="invoking">
      <title>Invoking the script</title>
      <para>Having written the script, you can invoke it by <userinput>sh scriptname</userinput>,
	or alternately <userinput>bash scriptname</userinput>.  (Not recommended is using
	<userinput>sh &lt;scriptname</userinput>, since this effectively disables reading from input
	within the script.)  Much more convenient is to make the script itself
	directly executable by
	<variablelist>
	  <varlistentry>
	    <term>Either:</term>
	    <listitem>
	      <para><userinput>chmod 755 scriptname</userinput> (gives everyone execute permission)</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>or</term>
	    <listitem>
	      <para><userinput>chmod +x scriptname</userinput> (gives everyone execute permission)</para>
	      <para><userinput>chmod u+x scriptname</userinput> (gives only the
		script owner execute permission)</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </para>
      
      <para>In this case, you could try calling the script by <userinput>./scriptname</userinput>.</para>
      
      <para>As a final step, after testing and debugging, you would likely want
	to move it to <filename class="directory">/usr/local/bin</filename> (as
	root, of course), to make the script available to yourself and all other
	users as a system-wide executable.
	The script could then be invoked by simply typing <command>scriptname</command> <keycap>return</keycap>'
	from the command line.</para>
    </sect1> <!-- Invoking the script -->

    <sect1 id="wrapper">
      <title>Shell wrapper, self-executing script</title>
      
      <para>A 
	<command>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>script</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  sed</command> or 
	<command>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>script</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  awk</command> script would
	normally be invoked from the command line by a 
	<userinput>sed -e <replaceable>commands</replaceable></userinput> or 
	<userinput>awk -e	<replaceable>commands</replaceable></userinput>.
	Embedding such a script in a bash script permits calling it more simply,
	and makes it <quote>reusable</quote>. This also permits combining the
	functionality of <command>sed</command> and <command>awk</command>, for
	example piping the output of a set of <command>sed</command> commands to
	<command>awk</command>.  As a saved executable file, you can then
	repeatedly invoke it in its original form or modified, without retyping
	it on the command line.</para>

      <example id="ex3">
	<title><command>wrapper</command></title>
	<programlisting>&ex3;</programlisting>
      </example>
      
      <example id="ex4">
	<title>A slightly more complex script <command>wrapper</command></title>
	<programlisting>&ex4;</programlisting>
      </example>
      
      <formalpara><title>Exercise</title>
	<para>Write a shell script that performs a simple task.</para>
      </formalpara>
    </sect1> <!-- Shell wrapper, self-executing script -->
  </chapter> <!-- Starting Off With a Sha-Bang -->

  <chapter id="tutorial">
    <title>Tutorial / Reference</title>
    <blockquote>
      <attribution>Samuel Johnson</attribution>
      <para>Your (manu)script is both good and original, but the part that is good is not
	original and the part that is original is not good.</para>
    </blockquote>
    
    <sect1 id="exit-status">
      <title>exit and exit status</title>
      <para>The 
	<command>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  exit
	</command> 
	command may be used to terminate a script, as in a C program
	It may also return a value, which can be read by the shell.</para>

      <para>Every command returns an 
	<firstterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  exit status
	</firstterm> 
	(sometimes referred to as a 
	<firstterm>
	  <indexterm>
	    <primary>return status</primary>
	  </indexterm>
	  return status
	</firstterm>). A successful command returns a
	<errorcode>0</errorcode>, while an unsuccessful one returns a
	<errorcode>non-zero</errorcode> value that usually may be interpreted as
	an error code.</para>

      <para>Likewise, functions within a script and the script itself return an exit
	status. The last command executed in the function or script determines
	the exit status. Within a script, an 
	<userinput>exit <replaceable>nn</replaceable></userinput> command may be used to
	deliver an <errorcode>nn</errorcode> exit status to the shell 
	(<errorcode><replaceable>nn</replaceable></errorcode> must be a decimal number
	in the <errorcode>0</errorcode> - <errorcode>255</errorcode> range).</para>

      <para>
	<varname>
	  <indexterm>
	    <primary>$?</primary>	    
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>	    
	    <secondary>$?</secondary>	    
	  </indexterm>
	  $?</varname> reads the exit status of script or function</para>

      <example id="ex5">
	<title>exit / exit status</title>
	<programlisting>&ex5;</programlisting>
      </example>

    </sect1> <!-- exit and exit status -->

    <sect1 id="special-chars">
      <title>Special characters used in shell scripts</title>
      <variablelist>
	<varlistentry><term><token>#</token></term>
	  <indexterm>
	    <primary>#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>comment</primary>
	  </indexterm>	  
	  <listitem>
	    <formalpara><title>Comments</title>
	      <para>Lines beginning with a <token>#</token> (with the exception
		of <token>#!</token>) are comments.</para>
	    </formalpara>
	    
	    <para><programlisting># This line is a comment.</programlisting></para>

	    <para>Comments may also occur at the end of a command.</para>
	    
	    <para><programlisting>echo "A comment will follow." # Comment here.</programlisting></para>	    

	    <para>Comments may also follow white space at the beginning of a line.</para>
	    <para><programlisting># A tab precedes this comment.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>;</token></term>
	  <indexterm>
	    <primary>;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>;</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>separator</primary>
	  </indexterm>	  
	  
	  <listitem>
	    <formalpara><title>Command separator</title>
	      <para>Permits putting two or more commands on the same line</para>
	    </formalpara>

	    <para><programlisting>echo hello; echo there</programlisting></para>
	    
	    <para>Note that the <token>;</token> sometimes needs to be escaped (<token>\</token>).</para>
	    </listitem>
	</varlistentry>


	<varlistentry><term><token>.</token></term>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dot command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title><quote>dot</quote> command</title>
	      <para>Equivalent to <token>source</token>, explained further on</para>
	    </formalpara>
	  </listitem>
	</varlistentry>


	<varlistentry><term><token>:</token></term>
	  <indexterm>
	    <primary>:</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>:</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>null command</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>	  
	  <indexterm>
	    <primary>endless loop</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title>null command</title>
	      <para>Exit status <errorcode>0</errorcode>, alias for
	      <token>true</token>, see below</para>
	    </formalpara>

	    <para>Endless loop:</para>

	    <para><programlisting>
while :
do
   operation-1
   operation-2
   ...
   operation-n
done</programlisting>
	    </para>

	    <para>Placeholder in if/then test:</para>

	    <para><programlisting>
if condition
then :   # Do nothing and branch ahead
else
   take-some-action
fi</programlisting>
	    </para>

	    <para>Evaluate string of variables using
		<quote>parameter substitution</quote> (explained later on):</para>

	    <para><programlisting>: ${HOSTNAME?} ${USER?} ${MAIL?}</programlisting>
	    </para>
	    
	    <para>Prints error message if one or more of essential environmental
	      variables not set.</para>

	  </listitem>
	</varlistentry>

	<varlistentry><term><token>${}</token></term>
	  <indexterm>
	    <primary>${}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>${}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter substitution</primary>
	  </indexterm>	  

	  <listitem>
	    <formalpara><title>Parameter substitution</title>
	    <para></para></formalpara>
	    
	    <variablelist>
	      <varlistentry>
		<term><userinput>${parameter-default}</userinput></term>
		<listitem><para>If parameter not set, use default</para></listitem>
	      </varlistentry>
	      <varlistentry>
		<term><userinput>${parameter=default}</userinput></term>
		<listitem><para>If parameter not set, set it to default</para></listitem>
	      </varlistentry>
	      <varlistentry>
		<term><userinput>${parameter+otherwise}</userinput></term>
		<listitem><para>If parameter set, use 'otherwise", else use null string</para></listitem>
	      </varlistentry>
	      <varlistentry>
		<term><userinput>${parameter?err_msg}</userinput></term>
		<listitem><para>If parameter set, use it, else print err_msg</para></listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex6">
	      <title>Using param substitution and <token>:</token></title>
	      <programlisting>&ex6;</programlisting>
	    </example>
	    
	    <formalpara><title>Parameter substitution and/or expansion</title>
	      
	      <para>The following are the equivalent of <command>match</command> in
		<command>expr</command> string operations (see below).
		These are used mostly in parsing file path names.</para></formalpara>

	    <variablelist>
	      <varlistentry>
		<term><userinput>${var#pattern}</userinput></term>
		<term><userinput>${var##pattern}</userinput></term>
		<listitem><para>Strip off shortest/longest part of
		    <replaceable>pattern</replaceable> if it matches the front end of
		    <replaceable>variable</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var%pattern}</userinput></term>
		<term><userinput>${var%%pattern}</userinput></term>
		<listitem><para>Strip off shortest/longest part of
		    <replaceable>pattern</replaceable> if it matches the back end of 
		    <replaceable>variable</replaceable>.
		  </para></listitem>
	      </varlistentry>
	    </variablelist>
	    
	    <para>Version 2 of bash adds additional options.</para>
	    
	    <variablelist>
	      <varlistentry>
		<term><userinput>${var:pos}</userinput></term>
		<listitem><para>variable <replaceable>var</replaceable> expanded,
		    starting from offset <replaceable>pos</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var:pos:len}</userinput></term>
		<listitem><para>expansion to a max of <replaceable>len</replaceable>
		    characters of variable <replaceable>var</replaceable>, from offset
		    <replaceable>pos</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var/patt/replacement}</userinput></term>
		<listitem><para>first match of <replaceable>pattern</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>replacement</replaceable>.
		  </para></listitem>
	      </varlistentry>
	      
	      <varlistentry>
		<term><userinput>${var//patt/replacement}</userinput></term>
		<listitem><para>all matches of <replaceable>pattern</replaceable>,
		    within <replaceable>var</replaceable> replaced with
		    <replaceable>replacement</replaceable>.
		  </para></listitem>
	      </varlistentry>	
	    </variablelist>
	    
	    <example id="ex7">
	      <title>Using pattern matching to parse arbitrary strings</title>
	      <programlisting>&ex7;</programlisting>
	    </example>
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>()</token></term>
	  <listitem><formalpara><title>command group</title>
	      <para><programlisting>(a=hello; echo $a)</programlisting></para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>{}</token></term>
	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>block of code</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>block of code</title>
	      <para>This, in effect, creates an anonymous function.</para>
	    </formalpara>
	    
	    <para>The code block enclosed in braces may have I/O redirected to
	      and from it.</para>

	    <example id="ex8">
	      <title>Code blocks and I/O redirection</title>
	      <programlisting>&ex8;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/{}</token></term>
	  <listitem><formalpara><title>file pathname</title>
	      <para>Mostly used in 'find' constructs.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>></token> <token>>></token> <token><</token> <token>&</token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>redirection</title>
	      <para></para>
	    </formalpara>

	    <para><userinput>scriptname >filename</userinput> redirects the output of
	      <replaceable>scriptname</replaceable> to file
	      <replaceable>filename</replaceable>. If
	      <replaceable>filename</replaceable> already existed, it is 
	      overwritten.</para>

	    <para><userinput>command >&2</userinput> redirects output of
	    <replaceable>command</replaceable> to stderr.</para>

	    <para><userinput>scriptname >>filename</userinput> appends the output of 
	      <replaceable>scriptname</replaceable> to file
	      <replaceable>filename</replaceable>. If
	      <replaceable>filename</replaceable> already existed, the 
	      output of the script will be added at the end of the file.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><<</token></term>
	  <listitem><formalpara><title>redirection used in <quote>here document</quote></title>
	      <para>See below.</para>
	    </formalpara>
	    </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>pipe</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>pipe</title>
	      <para>Passes the output of previous command to next one, or to shell.</para>
	    </formalpara>

	    <para><programlisting>echo ls -l | sh</programlisting></para>

	    <para><programlisting>cat *.lst | sort | uniq</programlisting>
	      sorts the output of all the <filename>.lst</filename> files and
	      deletes duplicate lines.</para>
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>|</token></term>
	  <indexterm>
	    <primary>>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>force</secondary>
	  </indexterm>	  
	  <indexterm>
	    <primary>noclobber</primary>
	  </indexterm>	  

	  <listitem><formalpara><title>force redirection (even if
		<envar>noclobber</envar> environmental variable is in effect)</title>
	      <para>This will forcibly overwrite an existing file.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>redirection</primary>
	    <secondary>from/to stdin/stdout</secondary>
	  </indexterm>	  
	  <listitem><formalpara><title>redirection from/to stdin or stdout</title>
	      <para></para>
	    </formalpara>

	    <para><programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xvfp -)
# Move entire file tree from one directory to another
# [courtesy Alan Cox, a.cox@swansea.ac.uk]</programlisting></para>

	    <para><programlisting>bunzip2 linux-2.2.15.tar.bz2 | tar xvf -
# --uncompress tar file--    | --then pass it to "tar"--
# If "tar" has not been patched to handle "bunzip2",
# this needs to be done in two discrete steps, using a pipe.
# The purpose of the exercise is to unarchive "bzipped" kernel source.
</programlisting></para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>White space</term>
	  <listitem><formalpara><title>functions as a separator, separating commands or variables.</title>
	      <para>White space consists of either spaces, tabs, blank lines, or any
		combination thereof. In some contexts, such as variable assignment,
		white space is not permitted, and results in a syntax error.</para>
	    </formalpara>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Blank lines</term>
	  <listitem><para>Blank lines have no effect on the action of a script, and are therefore useful
	      for visually separating functional sections of the script.</para>
	    
	  </listitem>
	</varlistentry>

      </variablelist>

    </sect1> <!-- Special characters used in shell scripts -->

    <sect1 id="variables">
      <title>Variables</title>

      <variablelist>
	<varlistentry>
	  <term><token>$</token></term>
	  <indexterm>
	    <primary>$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>substitution</secondary>
	  </indexterm>

	  <listitem>
	    <formalpara><title>variable substitution</title>
	      <para><userinput>$variable</userinput> is a reference to the
		<emphasis>value</emphasis> of the variable.
		Variables will always begin with <token>$</token>, except when
		assigned (or at the head of a loop). Note that enclosing a
		referenced value in double quotes (<token>" "</token>) does not
		interfere with the variable substitution, but enclosing it in
		single quotes (<token>' '</token>) causes the variable name to
		be used literally, and no substitution will take place.</para>
	    </formalpara>

	    <para>Note that <userinput>$variable</userinput> is actually a
	      simplified alternate form of <userinput>${variable}</userinput>. In
	      complex cases where the <userinput>$variable</userinput> syntax causes
	      an error, the longer form may work.</para>

	    <example id="ex9">
	      <title>Variable substitution</title>
	      <programlisting>&ex9;</programlisting>
	    </example>

	    <para>Note that an uninitialized variable has a <quote>null</quote>
	      value (no assigned value at all).  Using a variable before
	      assigning a value to it will cause problems.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect1> <!-- Variables -->

    <sect1 id="quoting">
      <title>Quoting</title>
      <indexterm>
	<primary>"</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>"</secondary>
      </indexterm>
      <indexterm>
	<primary>'</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>'</secondary>
      </indexterm>
      <indexterm>
	<primary>quote</primary>
      </indexterm>
      <indexterm>
	<primary>\</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>\</secondary>
      </indexterm>
      <indexterm>
	<primary>escape</primary>
      </indexterm>
      <para>Quoting means just that, bracketing a string in quotes. This
	has the effect of protecting special characters in the string from
	reinterpretation or expansion by the shell or shell script. (A character
	is <quote>special</quote> if it has an interpretation other than its
	literal meaning, such as the <token>wild card</token> character,
      <token>*</token>.)</para>
      
      <para>When referencing a variable, it is generally advisable in enclose it in
	double quotes (<token>" "</token>). This preserves spaces and special
	characters within the variable name, but still allows referencing it,
	that is, replacing the variable with its value (see <xref linkend="ex9">, above).
	Enclosing the arguments to an <command>echo</command> statement in
	double quotes is usually a good practice.</para>

      <para>Single quotes (<token>' '</token>) operate similarly to double
	quotes, but do not permit referencing variables, since the special
	meaning of <token>$</token> is turned off. Special characters, such as
	<token>$</token> are not translated, but interpreted literally.
	Consider single quotes to be a stricter method of quoting than the
	double quotes.</para>

      <para><firstterm>Escaping</firstterm> is a method of quoting single
	characters. The <token>escape</token> (<token>\</token>) 
	preceding a character will either toggle on or turn off a special
	meaning for that character, depending on context.</para>

      <variablelist>

	<varlistentry><term><token>\n</token></term>
	  <indexterm>
	    <primary>\n</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\n</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>newline</primary>
	  </indexterm>
	  <listitem><para>means newline</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\r</token></term>
	  <indexterm>
	    <primary>\r</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\r</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>carriage return</primary>
	  </indexterm>
	  <listitem><para>means return</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\t</token></term>
	  <indexterm>
	    <primary>\t</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\t</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tabulation</primary>
	  </indexterm>
	  <listitem><para>means tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\v</token></term>
	  <indexterm>
	    <primary>\v</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\v</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>vertical tabulation</primary>
	  </indexterm>
	  <listitem><para><token>\v</token>means vertical tab</para>
	  </listitem>
	</varlistentry>

	<varlistentry><term><token>\b</token></term>
	  <indexterm>
	    <primary>\b</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\b</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>backspace</primary>
	  </indexterm>
	<listitem><para>means backspace</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\a</token></term>
	  <indexterm>
	    <primary>\a</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\a</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>alert</primary>
	  </indexterm>
	  <indexterm>
	    <primary>beep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>flash</primary>
	  </indexterm>
	<listitem><para>means <quote>alert</quote> (beep or flash)</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\0xx</token></term>
	  <indexterm>
	    <primary>\0xx</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\0xx</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>octal ASCII</primary>
	  </indexterm>
	  <listitem><para>translates to the octal ASCII
	      equivalent of <replaceable>0xx</replaceable></para>
	    <para><programlisting># Use the -e option with 'echo' to print these.
echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
echo -e "\042"   # Prints " (quote).</programlisting>
	  </para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\"</token></term>
	  <indexterm>
	    <primary>\"</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\"</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>quote</primary>
	  </indexterm>
	<listitem><para> gives the quote its literal meaning</para>
	</listitem>
	</varlistentry>

	<varlistentry><term><token>\$</token></term>
	  <indexterm>
	    <primary>\$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dollar</primary>
	  </indexterm>
	  <listitem><para>gives the dollar sign its literal meaning
	      (variable name following <token>\$</token> will not be
	      referenced)</para>
	    <para><programlisting>echo "\$variable01"  # results in $variable01</programlisting></para>
	  </listitem>
	  </varlistentry>
	</variablelist>

      <para>The <token>escape</token> also provides a means of writing a
	multi-line command. Normally, each separate line constitutes a different
	command, but an <token>escape</token> at the end of a line continues the
	command sequence onto the next line.</para>
      <para><programlisting>(cd /source/directory && tar cf - . ) | \
(cd /dest/directory && tar xvfp -)
# Repeating Alan Cox's directory tree copy command,
# but split into two lines for increased legibility.</programlisting>
	</para>

    </sect1> <!-- Quoting -->

    <sect1 id="tests">
      <title>Tests</title>
      <indexterm>
	<primary>if</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>if</secondary>
      </indexterm>
      <indexterm>
	<primary>then</primary>
      </indexterm>
      <indexterm>
	<primary>else if</primary>
      </indexterm>
      <indexterm>
	<primary>elif</primary>
      </indexterm>

      <para>The <token>if/then</token> construct tests whether a condition is
	true, and if so, executes one or more commands. Note that in this
	context, <literal>0</literal> (zero) will evaluate as true, as will
	Why?</para>

      <example id="ex10">
	<title>What is truth?</title>
	<programlisting>&ex10;</programlisting>
      </example>

      <formalpara><title>Exercise</title>
	<para>Explain the behavior of <xref linkend="ex10">, above.</para>
      </formalpara>
      
      <para><programlisting>if [ condition-true ]
then
   command 1
   command 2
   ...
else
   # Optional (may be left out if not needed).
   # Adds default code block executing if original condition
   # tests false.
   command 3
   command 4
   ...
fi</programlisting>
      </para>

      <para>Add a semicolon when 'if' and 'then' are on same line.</para>
      <para><programlisting>if [ -x filename ]; then</programlisting></para>

      <variablelist>
	<varlistentry>
	  <term><token>elif</token></term>
	  <listitem><para>  This is a contraction for <token>else if</token>.
	  The effect is to nest an inner <token>if/then</token> construction
	      within an outer one.</para>

	    <para><programlisting>if [ condition ]
then
   command
   command
   command
elif
# Same as else if
then
   command
   command
else
   default-command
fi</programlisting>
	      </para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>
      <indexterm>
	<primary>test</primary>
      </indexterm>
      <indexterm>
	<primary>test</primary>
	<secondary>test</secondary>
      </indexterm>
      <indexterm>
	<primary>[</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>[</secondary>
      </indexterm>
      <indexterm>
	<primary>]</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>]</secondary>
      </indexterm>
	
	The <userinput>test condition-true</userinput> construct is the exact
	equivalent of <userinput>if [condition-true ]</userinput>. The left bracket
	<token>[</token> is, in fact, an alias for <token>test</token>. (The
	closing right bracket <token>]</token> in a test should not therefore 
	be strictly necessary, however newer versions of bash detect it as a
	syntax error and complain.)</para>

      <example id="ex11">
	<title>Equivalence of <token>[ ]</token> and <token>test</token></title>
	<programlisting>&ex11;</programlisting>
      </example>
      
      <sect2>
	<title>File test operators</title>

	<variablelist>
	  <title>Returns true if...</title>
	  <varlistentry>
	    <term><token>-e</token></term>
	    <listitem><para>file exists.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-f</token></term>
	    <listitem><para>file is a regular file.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-s</token></term>
	    <listitem><para>file is not zero size.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-d</token></term>
	    <listitem><para>file is a directory.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-r</token></term>
	    <listitem><para>file is readable (has read permission).</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-w</token></term>
	    <listitem><para>file has write permission.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-x</token></term>
	    <listitem><para>file has execute permission.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-g</token></term>
	    <listitem><para>group-id flag set on file.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-u</token></term>
	    <listitem><para>user-id flag set on file.</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-O</token></term>
	    <listitem><para>you are owner of file</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-G</token></term>
	    <listitem><para>gid of file same as yours</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -nt f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is newer than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>f1 -ot f2</token></term>
	    <listitem><para>file <replaceable>f1</replaceable> is older than
		<replaceable>f2</replaceable></para></listitem>
	  </varlistentry>
	</variablelist>
	
	<para><token>!</token> <quote>not</quote>, reverses the sense of the
	  tests above (returns true if condition absent).</para>
	
	<example id="ex12">
	  <title>Tests, command chaining, redirection</title>
	  <programlisting>&ex12;</programlisting>
	</example>
      

      </sect2> <!-- File test operators -->

      <sect2>
	<title>Comparison operators (binary)</title>
	<variablelist>
	  <title>integer comparison</title>
	  <varlistentry>
	    <term><token>-eq</token></term>
	    <listitem><para>is equal to (<userinput>$a -eq $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-ne</token></term>
	    <listitem><para>is not equal to (<userinput>$a -ne $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-gt</token></term>
	    <listitem><para>is greater than (<userinput>$a -gt $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-ge</token></term>
	    <listitem><para>is greater than or equal to (<userinput>$a -ge $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-lt</token></term>
	    <listitem><para>is less than (<userinput>$a -lt $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-le</token></term>
	    <listitem><para>is less than or equal to (<userinput>$a -le $b</userinput>)</para></listitem>
	  </varlistentry>
	  
	</variablelist>
	
	<variablelist>
	  <title>string comparison</title>
	  <varlistentry>
	    <term><token>=</token></term>
	    <listitem><para>is equal to (<userinput>$a = $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>!=</token></term>
	    <listitem><para>is not equal to (<userinput>$a != $b</userinput>)</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-z</token></term>
	    <listitem><para>string is <quote>null</quote>, that is, has zero length</para></listitem>
	  </varlistentry>
	  <varlistentry>
	    <term><token>-n</token></term>
	    <listitem><para>string in not <quote>null</quote>. Note that this test
		does <emphasis>not</emphasis> work reliably (a bash bug?).  Use
		<userinput>! -z</userinput> instead.</para></listitem>
	    </varlistentry>
	</variablelist>
	
	<example id="ex13">
	  <title>arithmetic and string comparisons</title>
	  <programlisting>&ex13;</programlisting>
	</example>
      
	<example id="ex14">
	  <title><command>zmost</command></title>
	  <programlisting>&ex14;</programlisting>
	</example>
      
      </sect2> <!-- Comparison operators (binary) -->
    </sect1> <!-- Tests -->

    <sect1 id="operations">
      <title>Operations</title>

      <variablelist>
	<varlistentry>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>=</secondary>
	  </indexterm>
	  <term>=</term>
	  <listitem><para>All-purpose assignment operator, which works for both arithmetic and
    string assignments.</para>

	    <para>
	      <programlisting>var=27
category=minerals</programlisting>
	    </para>

	    <para>May also be used in a string comparison test.</para>

	    <para>
	      <programlisting>if [ $string1 = $string2 ]
then
   command
fi</programlisting>
	    </para>
    
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>The following are normally used in combination with
	<indexterm>
	  <primary>expr</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>expr</secondary>
	</indexterm>
	<indexterm>
	  <primary>let</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>let</secondary>
	</indexterm>

      <command>expr</command> or <command>let</command>.</para>

      <variablelist><title>arithmetic operators</title>
	<varlistentry>
	  <term><token>+</token></term>
	  <indexterm>
	    <primary>+</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>addition</primary>
	  </indexterm>
	  <indexterm>
	    <primary>plus</primary>
	  </indexterm>
	  <listitem><para>plus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-</token></term>
	  <indexterm>
	    <primary>-</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>substraction</primary>
	  </indexterm>
	  <indexterm>
	    <primary>minus</primary>
	  </indexterm>
	  <listitem><para>minus</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*</token></term>
	  <indexterm>
	    <primary>*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>multiplication</primary>
	  </indexterm>
	  <listitem><para>multiplication</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/</token></term>
	  <indexterm>
	    <primary>/</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>division</primary>
	  </indexterm>
	  <listitem><para>division</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>%</token></term>
	  <indexterm>
	    <primary>%</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>%</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>modulo</primary>
	  </indexterm>
	  <listitem><para>modulo, or mod</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>+=</token></term>
	  <indexterm>
	    <primary>+=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>+=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>plus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>plus-equal</quote> (increment variable by a constant)</para>
	    <para><userinput>`expr $var+=5`</userinput> results in
	      <varname>var</varname> being incremented by
	      <literal>5</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>-=</token></term>
	  <indexterm>
	    <primary>-=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>-=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>minus-equal</primary>
	  </indexterm>
	  <listitem><para><quote>minus-equal</quote> (decrement variable by a constant)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>*=</token></term>
	  <indexterm>
	    <primary>*=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>*=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>times-equal</primary>
	  </indexterm>
	  <listitem><para><quote>times-equal</quote> (multiply variable by a constant)</para>
	    <para><userinput>`expr $var*=4`</userinput> results in <varname>var</varname>
	    being multiplied by <literal>4</literal>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>/=</token></term>
	  <indexterm>
	    <primary>/=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>/=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>slash-equal</primary>
	  </indexterm>
	  <listitem><para><quote>slash-equal</quote> (divide variable by a constant)</para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <para>The bitwise logical operators seldom make an appearance in shell scripts.
	Their chief use seems to be manipulating and testing values read from
	ports or sockets. <quote>Bit flipping</quote> is more relevant to compiled languages,
	such as C and C++, which run fast enough to permit its use on the fly.</para>

      <variablelist>
	<varlistentry>
	  <term><token><<</token></term>
	  <indexterm>
	    <primary><<</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left shift</primary>
	  </indexterm>
	  <listitem><para>bitwise left shift (multiplies by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><<=</token></term>
	  <indexterm>
	    <primary><<=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><<=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>left-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>left-shift-equal</quote></para>
	    <para><userinput>let "var <<= 2"</userinput> results in <varname>var</varname>
	    left-shifted <literal>2</literal> bits (multiplied by <literal>4</literal>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>></token></term>
	  <indexterm>
	    <primary>>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right shift</primary>
	  </indexterm>
	  <listitem><para>bitwise right shift (divides by <literal>2</literal>
	      for each shift position)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>>=</token></term>
	  <indexterm>
	    <primary>>>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>>=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>right-shift-equal</primary>
	  </indexterm>
	  <listitem><para><quote>right-shift-equal</quote> (inverse of <token><<=</token>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&</token></term>
	  <indexterm>
	    <primary>&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>bitwise and</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&=</token></term>
	  <indexterm>
	    <primary>&=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>and-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise and-equal</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|</token></term>
	  <indexterm>
	    <primary>|</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>bitwise</secondary>
	  </indexterm>
	  <listitem><para>bitwise OR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>|=</token></term>
	  <indexterm>
	    <primary>|=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>|=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise OR-equal</quote></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>~</token></term>
	  <indexterm>
	    <primary>~</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>~</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>negate</primary>
	  </indexterm>
	  <listitem><para>bitwise negate</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!</token></term>
	  <indexterm>
	    <primary>!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>NOT</primary>
	  </indexterm>
	  <listitem><para>bitwise NOT</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^</token></term>
	  <indexterm>
	    <primary>^</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR</primary>
	  </indexterm>
	  <listitem><para>bitwise XOR</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>^=</token></term>
	  <indexterm>
	    <primary>^=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>^=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>XOR-equal</primary>
	  </indexterm>
	  <listitem><para><quote>bitwise XOR-equal</quote></para>
	  </listitem>
	</varlistentry>

      </variablelist>

      <variablelist><title>relational tests</title>
	<varlistentry>
	  <term><token><</token></term>
	  <indexterm>
	    <primary><</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less than</primary>
	  </indexterm>
	  <listitem><para>less than</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>></token></term>
	  <indexterm>
	    <primary>></primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>></secondary>
	  </indexterm>
	  <indexterm>
	    <primary>greater than</primary>
	  </indexterm>
	  <listitem><para>greater than</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><=</token></term>
	  <indexterm>
	    <primary><=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary><=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less than or equal to</primary>
	  </indexterm>
	  <listitem><para>less than or equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>=</token></term>
	  <indexterm>
	    <primary>>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>>=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>greater than or equal to</primary>
	  </indexterm>
	  <listitem><para>greater than or equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>==</token></term>
	  <indexterm>
	    <primary>==</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>==</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>equal to</primary>
	  </indexterm>
	  <listitem><para>equal to (test)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>!=</token></term>
	  <indexterm>
	    <primary>!=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>!=</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>not equal to</primary>
	  </indexterm>
	  <listitem><para>not equal to</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>&&</token></term>
	  <indexterm>
	    <primary>&&</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>&&</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>AND</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>and (logical)</para>
	    <para><programlisting>if [ $condition1 && $condition2 ]
# if both condition1 and condition2 hold true...</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>||</token></term>
	  <indexterm>
	    <primary>||</primary>
	  </indexterm>
	  <indexterm>
	    <primary>operation</primary>
	    <secondary>||</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>OR</primary>
	    <secondary>logical</secondary>
	  </indexterm>
	  <listitem><para>or  (logical)</para>
	    <para><programlisting>if [ $condition1 || $condition2 ]
# if both condition1 or condition2 hold true...</programlisting></para>
	  </listitem>
	</varlistentry>

      </variablelist>
    </sect1> <!-- Operations -->

    <sect1 id="variables2">
      <title>Variables Revisited</title>
      <variablelist>
	<varlistentry>
	  <term>Internal (builtin) variables</term>
	  <listitem><para>environmental variables affecting bash script behavior</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$IFS</varname></term>
	  <indexterm>
	    <primary>$IFS</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$IFS</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>input field separator</primary>
	  </indexterm>
	  <listitem><para>input field separator</para>
	    <para>This defaults to <token>white space</token>, but may be
	      changed, for example, to parse a comma-separated data file.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$HOME</varname></term>
	  <indexterm>
	    <primary>$HOME</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$HOME</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>home directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>home</secondary>
	  </indexterm>
	  <listitem><para>home directory of the user (usually <filename
	  class="directory">/home/username</filename>)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PATH</varname></term>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to binaries</primary>
	  </indexterm>
	  <listitem><para>path to binaries (usually 
	      <filename class="directory">/usr/bin/</filename>, 
	      <filename class="directory">/usr/X11R6/bin/</filename>, 
	      <filename class="directory">/usr/local/bin</filename>, etc.)</para>
	    <para>Note that the <quote>working directory</quote>, 
	      <filename class="directory">./</filename>, is usually omitted from
	      the <varname>$PATH</varname> as a security measure.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS1</varname></term>
	  <indexterm>
	    <primary>$PS1</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS1</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	  </indexterm>
	  <listitem><para>prompt</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PS2</varname></term>
	  <indexterm>
	    <primary>$PS2</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PS2</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>prompt</primary>
	    <secondary>secondary</secondary>
	  </indexterm>
	  <listitem><para>secondary prompt</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$PWD</varname></term>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>working directory</primary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>working directory (directory you are in at the time)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$EDITOR</varname></term>
	  <indexterm>
	    <primary>$EDITOR</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$EDITOR</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>editor</primary>
	  </indexterm>
	  <listitem><para>the default editor invoked by a script, usually
	      <command>vi</command> or <command>emacs</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH</varname></term>
	  <indexterm>
	    <primary>$BASH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>path to bash</primary>
	  </indexterm>
	  <listitem><para>the path to the <command>bash</command> binary itself,
	  usually <filename>/bin/bash</filename></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$BASH_ENV</varname></term>
	  <indexterm>
	    <primary>$BASH_ENV</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$BASH_ENV</secondary>
	  </indexterm>
	  <listitem><para>an environmental variable pointing to a bash startup
	      file to be read when a script is invoked</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><varname>$0</varname>, <varname>$1</varname>,
	  <varname>$2</varname>, etc.</term>
	  <indexterm>
	    <primary>$0</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$0</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem><para>positional parameters (passed from command line to script, passed to
	      a function, or <command>set</command> to a variable)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$#</varname></term>
	  <indexterm>
	    <primary>$#</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$#</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>number of</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>number of</tertiary>
	  </indexterm>
	  <listitem><para>number of command line arguments or positional parameters</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$$</varname></term>
	  <indexterm>
	    <primary>$$</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$$</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>of script</secondary>
	  </indexterm>
	  <listitem><para>process id of script, often used in scripts to construct temp file names</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$?</varname></term>
	  <indexterm>
	    <primary>$?</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$?</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>exit status</primary>
	  </indexterm>
	  <listitem><para>exit status of command, function, or the script itself</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$*</varname></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$*</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	    <tertiary>all</tertiary>
	  </indexterm>
	  <listitem><para>All of the positional parameters</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$@</varname></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$@</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>positional parameter</primary>
	    <secondary>all</secondary>
	  </indexterm>
	  <listitem><para>Same as <token>$*</token>, but each parameter is a
	      quoted string, that is, the parameters are passed on intact,
	      without interpretation or expansion</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$-</varname></term>
	  <indexterm>
	    <primary>$*</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$-</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>flags</primary>
	  </indexterm>
	  <listitem><para>Flags passed to script</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$!</varname></term>
	  <indexterm>
	    <primary>$!</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$!</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>PID</primary>
	    <secondary>of last job run in background</secondary>
	  </indexterm>
	  <listitem><para>PID of last job run in background</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>=</token></term>
	  <indexterm>
	    <primary>=</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>assignment</secondary>
	  </indexterm>
	  <listitem><para>variable assignment (<emphasis>no space before &
		after</emphasis>)</para>
	    <para>Do not confuse this with <token>==</token> and
	      <token>-eq</token>, which test, rather than assign!</para>

	<example id="ex15">
	  <title>Variable Assignment</title>
	  <programlisting>&ex15;</programlisting>
	</example>

	<example id="ex16">
	  <title>Variable Assignment, plain and fancy</title>
	  <programlisting>&ex16;</programlisting>
	</example>

	    <para>Variable assignment using the <token>$()</token> mechanism
	      (a newer method than using back quotes)</para>

	    <para><programlisting># From /etc/rc.d/rc.local
R=$(cat /etc/redhat-release)
arch=$(uname -m)</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>local variables</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>

	  <listitem><para>variables visible only within a code block or function
	      (see <xref linkend="functions">)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>environmental variables</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>environmental</secondary>
	  </indexterm>
	  <listitem><para>variables that affect the behavior of the shell and
	      user interface, such as the path and the prompt</para>
	    <para>If a script sets environmental variables, they need to be
	      <quote>exported</quote>, that is, reported to the environment
	      itself. This is the function of the <command>export</command> command.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><varname>$0</varname>, <varname>$1</varname>,
	  <varname>$2</varname>, <varname>$3</varname>, etc.</term> 
	  <indexterm>
	    <primary>parameter</primary>
	    <secondary>positional</secondary>
	  </indexterm>
	  <listitem><para>positional parameters ($0 is the name of the script
	      itself)</para>
	    
	    <example id="ex17">
	      <title>Positional Parameters</title>
	      <programlisting>&ex17;</programlisting>
	    </example>

	    <para>Some scripts can perform different operations, depending on
	      which name they are invoked by. For this to work, the script needs
	      to check <varname>$0</varname>, the name it was invoked by. There
	      also have to be symbolic links present to all the alternate names
	      of the same script.</para>

	    <example id="ex18">
	      <title><command>wh</command>, whois domain name lookup</title>
	      <programlisting>&ex18;</programlisting>
	    </example>

	    <para>
	      <indexterm>
		<primary>shift</primary>
	      </indexterm>
	      <indexterm>
		<primary>command</primary>
		<secondary>shift</secondary>
	      </indexterm>
	      The <command>shift</command> command reassigns the positional
	      parameters, in effect shifting them to the left one notch.</para>
	      
	    <para><varname>$1</varname> <--- <varname>$2</varname>, <varname>$2</varname> <--- <varname>$3</varname>, <varname>$3</varname> <--- <varname>$4</varname>, etc.</para>

	    <para>The old <varname>$1</varname> disappears, but
	      <varname>$0</varname> does not change. If you use a large number 
	      of positional parameters to a script, <command>shift</command>
	      lets you access those past <literal>10</literal>.</para>

	    <example id="ex19">
	      <title>Using <command>shift</command></title>
	      <programlisting>&ex19;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>
      </variablelist>

      <sect2>
	<indexterm>
	  <primary>declare</primary>
	</indexterm>
	<indexterm>
	  <primary>typeset</primary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>declare</secondary>
	</indexterm>
	<indexterm>
	  <primary>command</primary>
	  <secondary>typeset</secondary>
	</indexterm>
	<title>Typing variables: <command>declare</command> or <command>typeset</command></title>
	<para>The <command>declare</command> or <command>typeset</command>
	  keywords (they are exact synonyms) permit restricting the properties
	  of variables. This is a very weak form of the typing available in
	  certain programming languages. The <command>declare</command> command
	is not available in version 1 of <command>bash</command>.</para>

	<variablelist>
	  <varlistentry>
	    <term><token>-r</token> <replaceable>readonly</replaceable></term>
	    <listitem><para><programlisting>declare -r var1</programlisting></para>
	      <para>(<userinput>declare -r var1</userinput> works the same as
		<userinput>readonly var1</userinput>)</para>
	      <para>This is the rough equivalent of the C
		<command>const</command> type qualifier. An 
		attempt to change the value of a readonly variable fails with an 
		error message.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-i</token> <replaceable>integer</replaceable></term>
	    <listitem><para><programlisting>declare -i var2</programlisting></para>
	      <para>The script treats subsequent occurences of
		<varname>var2</varname> as an integer.
		Note that certain arithmetic operations are permitted for declared
		integer variables without the need for 
		<command>expr</command> or 
		<command>let</command>.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-a</token> <replaceable>array</replaceable></term>
	    <listitem><para><programlisting>declare -a indices</programlisting></para>
	      <para>The variable <varname>indices</varname> will be treated as
		an array.</para></listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><token>-f</token> <replaceable>functions</replaceable></term>
	    <listitem><para><programlisting>declare -f  # (no arguments)</programlisting></para>
	      <para>A <userinput>declare -f</userinput> line within a script causes
		a listing of all the functions contained in that script.</para></listitem>
	  </varlistentry>
	  
	  <varlistentry>
	    <term><token>-x</token> <replaceable>export</replaceable></term>
	      <listitem><para><programlisting>declare -x var3</programlisting></para>
	      <para>This declares a variable as available for exporting outside the
		environment of the script itself.</para></listitem>
	  </varlistentry>

	</variablelist>

	<example id="ex20">
	  <title>Using <command>declare</command> to type variables</title>
	  <programlisting>&ex20;</programlisting>
	</example>

      </sect2> <!-- Typing variables: declare or typeset -->

      <sect2>
	<indexterm>
	  <primary>$RANDOM</primary>
	</indexterm>
	<indexterm>
	  <primary>variable</primary>
	  <secondary>$RANDOM</secondary>
	</indexterm>
	<title>RANDOM: generate random integer</title>
	<example id="ex21">
	  <title>Generating random numbers</title>
	  <programlisting>&ex21;</programlisting>
	</example>
	
      </sect2> <!-- RANDOM: generate random integer -->
    </sect1> <!-- Variables -->

    <sect1 id="loops">
      <title>Loops</title>

      <variablelist>
	<varlistentry>
	  <term><command>for (in)</command></term>
	  <indexterm>
	    <primary>for</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>for</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the basic looping construct. It differs significantly
	      from its C counterpart.</para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="opt"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg rep=repeat choice=plain><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>Note that <replaceable>list</replaceable> may contain wild cards.</para>

	    <para>Note further that if <command>do</command> is on same line as
	      <command>for</command>, there needs to be a semicolon before list.</para>

	    <para><cmdsynopsis>
		<command>for</command>
		<arg choice="opt"><replaceable>arg</replaceable></arg>
		<arg choice="plain">in</arg>
		<arg choice="opt"><replaceable>list</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg><sbr>
	      </cmdsynopsis></para>

	    <example id="ex22">
	      <title>Simple <command>for</command> loops</title>
	      <programlisting>&ex22;</programlisting>
	    </example>

	    <para>Omitting the <userinput>in [list]</userinput> part of a
	      <command>for</command> loop causes the loop to operate on 
	      <token>$#</token>, the list of arguments given on the command line
	      to the script.</para>

	    <example id="ex23">
	      <title>Missing <userinput>in [list]</userinput> in a
		<command>for</command> loop</title>
	      <programlisting>&ex23;</programlisting>
	    </example>

	    <example id="ex24">
	      <title>Using <command>efax</command> in batch mode</title>
	      <programlisting>&ex24;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>while</command></term>
	  <indexterm>
	    <primary>while</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>while</secondary>
	  </indexterm>
	  <listitem>
	    <para>This construct tests for a condition at the top of a loop, and keeps
	      looping as long as that condition is true.</para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>As is the case with <token>for/in</token> loops, placing the
	      <command>do</command> on the same line as the condition test
	      requires a semicolon.</para>

	    <para><cmdsynopsis>
		<command>while</command>
		<arg choice="opt"><replaceable>condition</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>
	    
	    <para>Note that certain specialized <command>while</command> loops, as,
	      for example,  a <command>getopts</command> construct, deviate
	      somewhat from the standard template given here.</para>

	    <example id="ex25">
	      <title>Simple <command>while</command> loop</title>
	      <programlisting>&ex25;</programlisting>
	    </example>
	    
	    <example id="ex26">
	      <title>Another <command>while</command> loop</title>
	      <programlisting>&ex26;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <term><command>until</command></term>
	  <indexterm>
	    <primary>until</primary>
	  </indexterm>
	  <indexterm>
	    <primary>do</primary>
	  </indexterm>
	  <indexterm>
	    <primary>done</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>until</secondary>
	  </indexterm>

	  <listitem>
	    <para>This construct tests for a condition at the top of a loop, and keeps
	      looping as long as that condition is false (opposite of
	      <command>while</command> loop).</para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat"><replaceable>&nbsp;command</replaceable></arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>

	    <para>Note that an <command>until</command> loop tests for the
	      terminating condition at the top of the loop, differing from a
	      similar construct in some programming languages.</para>

	    <para>As is the case with <token>for/in</token> loops, placing the
	      <command>do</command> on the same line as the condition test
	      requires a semicolon.</para>

	    <para><cmdsynopsis>
		<command>until</command>
		<arg choice="opt"><replaceable>condition-is-true</replaceable></arg>
		<arg choice="plain">;</arg>
		<arg choice="plain">do</arg>
	      </cmdsynopsis></para>

	    <example id="ex27">
	      <title><command>until</command> loop</title>
	      <programlisting>&ex27;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>break</primary>
	  </indexterm>
	  <indexterm>
	    <primary>continue</primary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>break</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>continue</secondary>
	  </indexterm>
	  <term><command>break</command></term>
	  <term><command>continue</command></term>
	  <listitem>
	    <para>The <command>break</command> and <command>continue</command>
	      loop control commands correspond exactly to their counterparts in
	      other programming languages. The <command>break</command> command
	      terminates the loop (breaks out of it), while <command>continue</command>
	      causes a jump to the next iteration of the loop, skipping all the
	      remaining commands in that particular loop cycle.</para>

	    <example id="ex28">
	      <title>Effects of <command>break</command> and
		<command>continue</command> in a loop</title>
	      <programlisting>&ex28;</programlisting>
	    </example>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>case (in) / esac</command></term>
	  <indexterm>
	    <primary>case</primary>
	  </indexterm>
	  <indexterm>
	    <primary>in</primary>
	  </indexterm>
	  <indexterm>
	    <primary>esac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>switch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>;;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>

	  <listitem>
	    <para>The <command>case</command> construct is the shell equivalent
	      of <command>switch</command>  in C/C++.
	      It permits branching to one of a number of code blocks, depending
	      on condition tests. It serves as a kind of shorthand for multiple
	      <token>if/then/else</token> statements and is an appropriate tool
	      for creating menus.</para>

	    <para><cmdsynopsis>
		<command>case</command>
		<arg choice="plain">"$<replaceable>variable</replaceable>"</arg>
		<arg choice="plain">in</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition1</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">&nbsp;"$<replaceable>condition2</replaceable>" )</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;;;</arg><sbr><sbr>
		<arg choice="plain">esac</arg>
	      </cmdsynopsis></para>

	    <note><para>
	      <itemizedlist>
		<listitem><para>Quoting the variables is recommended.</para>
		</listitem>
		<listitem><para>Each test line ends with a left paren <token>)</token>.</para>
		</listitem>
		<listitem><para>Each condition block ends with a <emphasis>double</emphasis>
		    semicolon <token>;;</token>.</para>
		</listitem>
		<listitem><para>The entire <command>case</command> block terminates with an
	      <command>esac</command> (<wordasword>case</wordasword> spelled
		backwards).</para>
		  </listitem>
	      </itemizedlist>
	    </para></note>

	    <example id="ex29">
	      <title>Using <command>case</command></title>
	      <programlisting>&ex29;</programlisting>
	    </example>	    

	    <example id="ex30">
	      <title>Creating menus using <command>case</command></title>
	      <programlisting>&ex30;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>


	<varlistentry>
	  <term><command>select</command></term>
	  <indexterm>
	    <primary>select</primary>
	  </indexterm>
	  <indexterm>
	    <primary>menus</primary>
	  </indexterm>
	  <listitem>
	    <para>The <command>select</command> construct, adopted from the Korn
	      Shell, is yet another tool for building menus.</para>

	    <para><cmdsynopsis>
		<command>select</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg><sbr>
		<arg choice="plain">do</arg><sbr>
		<arg choice="plain" rep="repeat">&nbsp;<replaceable>command</replaceable></arg><sbr>
		<arg choice="plain">&nbsp;break</arg><sbr>
		<arg choice="plain">done</arg>
	      </cmdsynopsis></para>
	    
	    <para>This prompts the user to enter one of the choices presented in the
	      variable list.  Note that <command>select</command> uses the
	      <varname>PS3</varname> prompt (<prompt>#? </prompt>) by default, 
		but that this may be changed.</para>
	    
	    <example id="ex31">
	      <title>Creating menus using <command>select</command></title>
	      <programlisting>&ex31;</programlisting>
	    </example>	    

	    <para>If <userinput>in <replaceable>list</replaceable></userinput> is
	      omitted, then <command>select</command> uses the list of command
	      line arguments (<varname>$@</varname>) passed to the script or to
	      the function in which the <command>select</command> construct is
	      embedded. (Compare this to the behavior of a 
	      <cmdsynopsis>
		<command>for</command>
		<arg choice="plain"><replaceable>variable</replaceable></arg>
		<arg choice="opt">in <replaceable>list</replaceable></arg>
	      </cmdsynopsis>
	      construct with the 
	      <userinput>in <replaceable>list</replaceable></userinput>
	      omitted.)</para>

	    <example id="ex32">
	      <title>Creating menus using <command>select</command> in a function</title>
	      <programlisting>&ex32;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>
      </variablelist>
      
    </sect1> <!-- Loops -->

    <sect1 id="internal">
      <title>Internal Commands and Builtins</title>
      <indexterm>
	<primary>builtin</primary>
      </indexterm>

      <para>A <firstterm>builtin</firstterm> is a command contained in the bash tool
	set, literally built in.</para>
      
      <variablelist>
	<varlistentry>
	  <term><command>getopts</command></term>
	  <indexterm>
	    <primary>getopts</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>getopts</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTIND</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTIND</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$OPTARG</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$OPTARG</secondary>
	  </indexterm>
	  <listitem>
	    <para>This powerful tool parses command line arguments passed to the
	      script. This is the bash analog of the <command>getopt</command>
	      library function familiar to C programmers. It permits passing and
	      concatenating multiple flags<footnote><para>A flag is an argument
		  that acts as a signal, switching script behaviors on or
		  off.</para></footnote> and options to a script (for example
	      <userinput>scriptname -abc -e /usr/local</userinput>).</para>

	    <para>The <command>getopts</command> construct uses two implicit
	      variables. <varname>$OPTIND</varname> is the argument pointer
	      (<wordasword>OPTion INDex</wordasword>) and
	      <varname>$OPTARG</varname> (<wordasword>OPTion ARGumnet</wordasword>)
	      the (optional) argument attached to a flag. A colon following the flag
	      name in the declaration tags that flag as having an option.</para>

	    <para>A <command>getopts</command> construct usually comes packaged
	      in a <command>while</command> loop, which processes the flags and
	      options one at a time, then decrements the implicit
	      <varname>$OPTIND</varname> variable to step to the next.</para>

	    <note>
	      <para>
		<orderedlist>
		  <listitem><para>The arguments must be passed from the command line to the
		      script preceded by a minus (<option>-</option>) or a plus
		      (<option>+</option>), else <command>getopts</command> will 
		      not process them, and will, in fact, terminate option
		      processing at the first argument encountered lacking these
		      modifiers.</para>
		  </listitem>
		  <listitem><para>The <command>getopts</command> template
		      differs slightly from the standard <command>while</command>
		      loop, in that it lacks condition brackets.</para>
		  </listitem>
		  <listitem><para>The <command>getopts</command>
		      construct replaces the obsolete <command>getopt</command>
		      command.</para></listitem>
		</orderedlist>
	      </para>
	    </note>

	    <para><programlisting>
while getopts ":abcde:fg" Option
# Initial declaration.
# a, b, c, d, e, f, and g are the flags expected.
# The : after flag 'e' shows it will have an option passed with it.
do
  case $Option in
    a ) # Do something with variable 'a'.
    b ) # Do something with variable 'b'.
    ...
    e)  # Do something with 'e', and also with $OPTARG,
        # which is the associated argument passed with 'e'.
    ...
    g ) # Do something with variable 'g'.
  esac
done
shift $(($OPTIND - 1))
# Move argument pointer to next.

# All this is not nearly as complicated as it looks &lt;grin&gt;.
	      </programlisting></para>

	    <example id="ex33">
	      <title>Using <command>getopts</command> to read the flags/options
		  passed to a script</title>
	      <programlisting>&ex33;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>exit</command></term>
	  <indexterm>
	    <primary>exit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exit</secondary>
	  </indexterm>
	  <listitem><para>Unconditionally terminates a script. The
	      <command>exit</command> command may optionally take an integer
	      argument, which is returned to the shell as the <firstterm>exit
		status</firstterm> of the script. It is a good practice to end all
	      but the simplest scripts with an <userinput>exit 0</userinput>,
	      indicating a successful run.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>set</command></term>
	  <indexterm>
	    <primary>set</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>set</secondary>
	  </indexterm>
	  <listitem><para>The <command>set</command> command changes the value
	      of internal script variables. One use for this is to toggle flags
	      which help determine the behavior of the script (see 
	      <xref linkend="debugging">). Another application for  
	      it is to reset the positional parameters that a script sees as the
	      result of a command (<userinput>set `command`</userinput>). The
	      script can then parse the fields of the command output.</para>
	    
	    <example id="ex34">
	      <title>Using <command>set</command> with positional parameters</title>
	      <programlisting>&ex34;</programlisting>
	    </example>	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>unset</command></term>
	  <indexterm>
	    <primary>unset</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>unset</secondary>
	  </indexterm>
	  <listitem><para>The <command>unset</command> command deletes an
	      internal script variable. It is a way of negating a previous
	      <command>set</command>. Note that this command does not affect 
	      positional parameters.</para>
	    </listitem>
	  </varlistentry>
	
	<varlistentry>
	  <term><command>readonly</command></term>
	  <indexterm>
	    <primary>readonly</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>readonly</secondary>
	  </indexterm>
	  <listitem><para>Same as <userinput>declare -r</userinput>, sets a variable
	      as read-only, or, in effect, as a constant. Attempts to change the
	      variable fail with an error message. This is the shell analog of
	      the C language <command>const</command> type qualifier.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>basename</command></term>
	  <indexterm>
	    <primary>basename</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>basename</secondary>
	  </indexterm>
	  <listitem><para>Strips the path information from a file name, printing
	      only the file name. The construction  <userinput>basename
		$0</userinput> lets the script know its name, that is, the name it
	      was invoked by. This can be used for <quote>usage</quote> messages if, 
	      for example a script is called with missing arguments:
              <programlisting>echo "Usage: `basename $0` arg1 arg2 ... argn"</programlisting>
	    </para>

	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>dirname</command></term>
	  <indexterm>
	    <primary>dirname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirname</secondary>
	  </indexterm>
	  <listitem><para>Strips the <command>basename</command> from a file
	      name, printing only the path information.</para>
	    <note>
	      <para><command>basename</command> and <command>dirname</command>
		can operate on any arbitrary string. The filename given as an
		argument does not need to refer to an existing file.</para>
	    </note>
	    
	    <example id="ex35">
	      <title><command>basename</command> and <command>dirname</command></title>
	      <programlisting>&ex35;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>read</command></term>
	  <indexterm>
	    <primary>read</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>read</secondary>
	  </indexterm>
	  <listitem><para><quote>Reads</quote> the value of a variable from stdin,
	    that is, interactively fetches input from the keyboard. The <option>-a</option>
	    option lets <command>read</command> get array variables (see 
	      <xref linkend="ex67">).</para>

	    <example id="ex36">
	      <title>Variable assignment, using <command>read</command></title>
	      <programlisting>&ex36;</programlisting>
	    </example>	    
	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>true</command></term>
	  <indexterm>
	    <primary>true</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>true</secondary>
	  </indexterm>
	  <listitem><para>A command that returns a successful
	    (<errorcode>zero</errorcode>) exit status, but does nothing else.
	  </para>

	  <para><programlisting># Endless loop
while true
# alias for :
do
   operation-1
   operation-2
   ...
   operation-n
   # Need a way to break out of loop.
done</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>false</command></term>
	  <indexterm>
	    <primary>false</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>false</secondary>
	  </indexterm>
	  <listitem><para>A command that returns an unsuccessful exit status,
	    but does nothing else.</para>

	  <para><programlisting># Null loop
while false
do
   # The following code will not execute.
   operation-1
   operation-2
   ...
   operation-n
   # Nothing happens!
done   
</programlisting></para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>factor</command></term>
	  <indexterm>
	    <primary>factor</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>factor</secondary>
	  </indexterm>
	  <listitem><para>Factor an integer into prime factors.</para>
	  <para>
	      <screen><prompt>bash$ </prompt><userinput>factor 27417</userinput>
<computeroutput>27417: 3 13 19 37</computeroutput>
	      </screen>
	    </para>

	    </listitem>
	  </varlistentry>

      <varlistentry>
	<term><command>hash [cmds]</command></term>
	  <indexterm>
	    <primary>hash</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>hash</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PATH</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PATH</secondary>
	  </indexterm>
	  <listitem><para>Record the path name of specified commands (in the
	      shell hash table), so the shell or script will not need to search
	      the <varname>$PATH</varname> on subsequent calls to those
		commands. When <command>hash</command> is called with no
	      arguments,  it simply lists the commands that have been hashed.
	    </para>
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>pwd</command></term>
	  <indexterm>
	    <primary>pwd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pwd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>$PWD</primary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>$PWD</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <listitem><para>Print Working Directory. This gives the user's (or script's) current
	      directory.</para>
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>pushd</command></term>
	<term><command>popd</command></term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>pushd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pushd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>popd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>popd</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>working</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>bookmark</primary>
	  </indexterm>
	  <listitem><para>This command set is a mechanism for bookmarking working directories,
	      a means of moving back and forth through directories in an orderly
	      manner.  A pushdown stack is used to keep track of directory names.
	      Options allow various manipulations of the directory stack.</para>

	    <para><userinput>pushd dir-name</userinput> pushes the path
	      <replaceable>dir-name</replaceable> onto the directory 
	      stack and simultaneously changes the current working directory to
	      <replaceable>dir-name</replaceable></para>

	    <para><command>popd</command> removes (pops) the top directory path
	      name off the directory stack and simultaneously changes the
	      current working directory to that directory popped from the stack.
	      </para>
	    
	    <para><command>dirs</command> lists the contents of the directory
	      stack. A successful <command>pushd</command> or
	      <command>popd</command> will automatically invoke
	      <command>dirs</command>.</para>
	    

	    <para>Scripts that require various changes to the current working directory
	      without hard-coding the directory name changes can make good use of
	      these commands. Note that the implicit <varname>DIRSTACK</varname> array variable,
	      accessible from within a script, holds the contents of the directory stack.
	    </para>

	    <example id="ex37">
	      <title>Changing the current working directory   </title>
	      <programlisting>&ex37;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

      <varlistentry>
	<term><command>source</command></term>
	<term><token>.</token> (<command>dot</command> command)</term>
	<term><command>dirs</command></term>
	  <indexterm>
	    <primary>source</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>source</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>.</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>.</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>dirs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dirs</secondary>
	  </indexterm>

	  <listitem><para>This command, when invoked from the command line, executes a script. Within
	      a script, a <userinput>source file-name</userinput> loads the file
	      <replaceable>file-name</replaceable>. This is the 
	      shell scripting equivalent of a C/C++ <userinput>#include</userinput>
	      directive. It is useful in situations when multiple scripts use a
	      common data file or function library.</para>

	    <example id="ex38">
	      <title><quote>Including</quote> a data file</title>
	      <programlisting>&ex38;</programlisting>
	      <para>File <filename>data-file</filename> for <xref linkend="ex38">, above.
		Must be present in same directory.</para>
	      <programlisting>&ex38bis;</programlisting>
	    </example>	    
	    
	    </listitem>
	  </varlistentry>

      </variablelist>

      <sect2>
	<title>Job Control Commands</title>
	
	<variablelist>
	  <varlistentry>
	    <term><command>wait</command></term>
	  <indexterm>
	    <primary>wait</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wait</secondary>
	  </indexterm>
	    <listitem>
	      <para>Stop script execution until all jobs running in background have terminated,
		or until the job number specified as an option terminates.</para>

	    <example id="ex39">
	      <title>Waiting for a process to finish before proceeding</title>
	      <programlisting>&ex39;</programlisting>
	    </example>	    

	    </listitem>
	  </varlistentry>


	  <varlistentry>
	    <term><command>suspend</command></term>
	    <indexterm>
	      <primary>suspend</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>suspend</secondary>
	    </indexterm>
	    <listitem>
	      <para>This has the same effect as
		<keycombo><keycap>Control</keycap><keycap>Z</keycap></keycombo>, 
		pausing a foreground job.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>stop</command></term>
	    <indexterm>
	      <primary>stop</primary>
	    </indexterm>
	    <indexterm>
	      <primary>command</primary>
	      <secondary>stop</secondary>
	    </indexterm>
	    <listitem>
	      <para>This has the same effect as <command>suspend</command>, but
		for a background job.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>disown</command></term>
	  <indexterm>
	    <primary>disown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>disown</secondary>
	  </indexterm>
	    <listitem>
	      <para>Remove job(s) from the shell's table of active jobs.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>jobs</command></term>
	  <indexterm>
	    <primary>jobs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jobs</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	    <listitem>
	      <para>Lists the jobs running in the background, giving the job number.
		Not as useful as <command>ps</command>.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>times</command></term>
	  <indexterm>
	    <primary>times</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>times</secondary>
	  </indexterm>
	    <listitem>
	      <para>Gives statistics on the system time used in executing commands, in the
		following form:
		<screen><computeroutput>0m0.020s 0m0.020s</computeroutput></screen>
		This capability is of very limited value, since it is uncommon to
		profile and benchmark shell scripts.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>kill</command></term>
	  <indexterm>
	    <primary>kill</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>kill</secondary>
	    </indexterm>
	    <listitem>
	      <para>Forcibly terminate a process. Note that <userinput>kill
	      -l</userinput> lists all the <quote>signals</quote>.</para>
	    </listitem>
	  </varlistentry>

	</variablelist>

      </sect2> <!-- Job Control Commands -->
    </sect1> <!-- Internal Commands and Builtins -->

    <sect1 id="external">
      <title>External Filters, Programs and Commands</title>
      <para>This is a descriptive listing of standard UNIX commands useful in shell
	scripts.</para>

      <variablelist>
	<varlistentry>
	  <term><command>ls</command></term>
	  <indexterm>
	    <primary>ls</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ls</secondary>
	  </indexterm>
	  <listitem>
	    <para>The basic file <quote>list</quote> command. It is all too easy
	      to underestimate the power of this humble command. For example,
	      using the <option>-R</option>, recursive option,
	      <command>ls</command> provides a tree-like listing of a directory
	      structure.</para>

	    <example id="ex40">
	      <title>Using <command>ls</command> to create a table of contents
		for burning a <abbrev>CDR</abbrev> disk</title>
	      <programlisting>&ex40;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chmod</command></term>
	  <indexterm>
	    <primary>chmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Changes the attributes of a file.</para>
	    <para><programlisting>chmod +x filename
# Makes "filename" executable for all users.</programlisting></para>
	    <para><programlisting>chmod 644 filename
# Makes "filename" readable/writable to owner, readable to
# others
# (octal mode).</programlisting></para>
	    <para><programlisting>chmod 1777 directory-name
# Gives everyone read, write, and execute permission in directory,
# however also sets the "sticky bit", which means that
# only the directory owner can change files in the directory.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <indexterm>
	    <primary>umask</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umask</secondary>
	  </indexterm>
	  <term><command>umask</command></term>
	  <listitem>
	    <para>Set the default file attributes (for a particular user).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>find</command></term>
	  <indexterm>
	    <primary>find</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>find</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>{}</primary>
	  </indexterm>
	  <indexterm>
	    <primary>special character</primary>
	    <secondary>{}</secondary>
	  </indexterm>

	  <indexterm>
	    <primary>\;</primary>
	  </indexterm>
	  <indexterm>
	    <primary>escaped character</primary>
	    <secondary>\;</secondary>
	  </indexterm>

	  <listitem>
	    <para>exec <replaceable>COMMAND</replaceable></para>
	    <para>Carries out <replaceable>COMMAND</replaceable> on each file
	      that <command>find</command> scores a hit on. 
	      <replaceable>COMMAND</replaceable> is followed by <token>{} \;</token>
	      (the <token>;</token> is escaped to make certain the shell
	      reads it literally and terminates the command sequence).
	      This causes <replaceable>COMMAND</replaceable> to bind
	      to and act on the path name of the files found (see <xref
	      linkend="ex57">)
	    </para>
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>xargs</command></term>
	  <indexterm>
	    <primary>xargs</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>xargs</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter for feeding arguments to a command, and also a tool for
	      assembling the commands themselves. It breaks a data stream into small
	      enough chunks for filters and commands to process.  Consider it as a
	      powerful replacement for backquotes.  In situations where backquotes
	      fail with a <errorname>too many arguments</errorname> error,
	      substituting <command>xargs</command> often works. Normally, xargs
	      reads from 'stdin' or from a pipe, but it can also be given the
	      output of a file.</para>
	    
	    <para><userinput>ls | xargs -p -l gzip</userinput> gzips every file in
	      current directory, one at a time, prompting before each operation.</para>

	    <para>One of the more interesting xargs options is 
	      <option>-n <replaceable>XX</replaceable></option>, which limits
	      the number of arguments passed to <replaceable>XX</replaceable>.</para> 

	    <para><userinput>ls | xargs -n 8 echo</userinput> lists the files in the
	      current directory in <literal>8</literal> columns.</para>

	    <example id="ex41">
	      <title>Log file using <command>xargs</command> to monitor system log</title>
	      <programlisting>&ex41;</programlisting>
	    </example>	    

	    <example id="ex42">
	      <title><command>copydir</command>, copying files in current
		directory to another, using <command>xargs</command></title>
	      <programlisting>&ex42;</programlisting>
	    </example>	    

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><userinput>eval arg1, arg2, ...</userinput></term>
	  <indexterm>
	    <primary>eval</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>eval</secondary>
	  </indexterm>
	  <listitem>
	    <para>Translates into commands the arguments in a list
	      (useful for code generation within a script).</para>

	    <example id="ex43">
	      <title>Showing the effect of <command>eval</command></title>
	      <programlisting>&ex43;</programlisting>
	    </example>	    

	    <example id="ex44">
	      <title>Forcing a log-off</title>
	      <programlisting>&ex44;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><userinput>expr arg1 operation arg2 ...</userinput></term>
	  <indexterm>
	    <primary>expr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expr</secondary>
	  </indexterm>
	  <listitem>
	    <para>All-purpose expression evaluator:
	      Concatenates and evaluates the arguments according
	      to the operation given (arguments must be separated
	      by spaces). Operations may be arithmetic, comparison,
	      string, or logical.</para>

	    <variablelist>
	      <varlistentry>
		<term><userinput>expr 3 + 5</userinput></term>
		<listitem>
		  <para>returns <literal>8</literal></para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>expr 5 % 3</userinput></term>
		<listitem>
		  <para>returns 2</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>y=`expr $y + 1`</userinput></term>
		<listitem>
		  <para>incrementing variable, same as <userinput>let y=y+1</userinput> and
		    <userinput>y=$(($y+1))</userinput>, as discussed elsewhere</para>
		</listitem>
	      </varlistentry>

	      <varlistentry>
		<term><userinput>z=`expr substr $string28 $position $length`</userinput></term>
		<listitem>
		  <para>Note that external programs, such as
		    <command>sed</command> and <command>Perl</command> have far superior 
		    string parsing facilities, and it might well be advisable to use
		    them instead of the built-in bash ones.</para>
		</listitem>
	      </varlistentry>
	    </variablelist>

	    <example id="ex45">
	      <title>Using <command>expr</command></title>
	      <programlisting>&ex45;</programlisting>
	    </example>	    
	    
	    <para>Note that <token>:</token> can substitute for <command>match</command>.
	      <userinput>b=`expr $a : [0-9]*`</userinput> is an exact equivalent of
	      <userinput>b=`expr match $a [0-9]*`</userinput> in the above example.</para>
	  
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>let</command></term>
	  <indexterm>
	    <primary>let</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>let</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>let</command> command carries out arithmetic
	      operations on variables. In many cases, it functions as a less
	      complex version of <command>expr</command>.</para>

	    <example id="ex46">
	      <title>Letting <command>let</command> do some arithmetic.</title>
	      <programlisting>&ex46;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>printf</command></term>
	  <indexterm>
	    <primary>printf</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>printf</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>printf</command>, formatted print, command is an
	      enhanced <command>echo</command>.  It is a limited variant of the
	      C language <function>printf</function>, and the syntax is somewhat 
	      different.</para>
	    <cmdsynopsis>
	      <command>printf</command>
	      <arg choice=plain rep=repeat><replaceable>format-string</replaceable></arg>
	      <arg choice=plain rep=repeat><replaceable>parameter</replaceable></arg>
	    </cmdsynopsis>

	    <para>See the <command>printf</command> man page for in-depth coverage.</para>
	    
	    <note><para>Older versions of <command>bash</command> may not
		support <command>printf</command>.</para></note> 

	    <example id="ex47">
	      <title><command>printf</command> in action</title>
	      <programlisting>&ex47;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>at</command></term>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>at</command> job control command executes a given
	      set of commands at a specified time. This is a user version of
	      <command>cron</command>.</para>
	    
	    <para><userinput>at 2pm January 15</userinput> prompts for a set of
	      commands to execute at that time.</para>

	    <para>Using the <option>-f</option> option, <command>at</command>
	      reads a command list from a file, which can be useful in a
	      non-interactive script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ps</command></term>
	  <indexterm>
	    <primary>ps</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ps</secondary>
	  </indexterm>
	  <listitem>
	    <para>Lists currently executing jobs by owner and process id. This is usually
	      invoked with <option>ax</option> options, and may be piped to
	      <command>grep</command> to search for a specific process.</para>
	    
	    <para><userinput>ps ax | grep sendmail</userinput> results in:
	      <screen><computeroutput>295 ?        S      0:00 sendmail: accepting connections on port 25</computeroutput></screen>
	    </para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>batch</command></term>
	  <indexterm>
	    <primary>batch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>batch</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>at</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>at</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>batch</command> job control command is similar to
	      <command>at</command>, but it runs a command list when the system
	      load drops below <literal>.8</literal>. Like
	      <command>at</command>, it can read commands from a file with the
	      <option>-f</option> option.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sleep</command></term>
	  <indexterm>
	    <primary>sleep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sleep</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the shell equivalent of a wait loop. It pauses for a
	      specified number of seconds, doing nothing. This can be useful for
	      timing or in processes running in the background, checking for a
	      specific event every so often.
	      <programlisting>sleep 3
# Pauses 3 seconds.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>dd</command></term>
	  <indexterm>
	    <primary>dd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>dd</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the somewhat obscure and much feared <quote>data duplicator</quote>
	      command. It simply copies a file (or stdin/stdout), but with
	      conversions. Possible conversions are ASCII/EBCDIC, upper/lower case,
	      swapping of byte pairs between input and output, and skipping and/or
	      truncating the head or tail of the input file. A <userinput>dd --help</userinput> lists
	      the conversion and other options that this powerful utility takes.</para>

	    <para>The <command>dd</command> command can copy raw data and disk
	      images to and from devices, such as floppies.  It can even be used
	      to create boot floppies. 
	      <programlisting>dd if=kernel-image of=/dev/fd0H1440</programlisting>
	      One important use for <command>dd</command> is initializing
	      temporary swap files (see <xref linkend="ex73">).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sort</command></term>
	  <indexterm>
	    <primary>sort</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sort</secondary>
	  </indexterm>
	  <listitem>
	    <para>File sorter, often used as a filter in a pipe. See the man page
	      for options.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>diff</command></term>
	  <indexterm>
	    <primary>diff</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>diff</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simple file comparison utility. The files must be sorted (this may, if
	      necessary be accomplished by filtering the files through <command>sort</command> before
	      passing them to <command>diff</command>). <userinput>diff file-1
	      file-2</userinput> outputs the lines in the files that differ, with
	      carets showing which file each particular line belongs to.
	      A common use for <command>diff</command> is to generate difference
	      files to be used with <command>patch</command> (see below).
	      The <option>-e</option> option outputs files suitable for <command>ed</command> or
	      <command>ex</command> scripts.</para>

	    <para><programlisting>patch -p1 &lt;patch-file
# Takes all the changes listed in 'patch-file' and applies them
# to the files referenced therein.

cd /usr/src
gzip -cd patchXX.gz | patch -p0
# Upgrading kernel source using 'patch'.
# From the Linux kernel docs "README",
# by anonymous author (Alan Cox?).</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>comm</command></term>
	  <indexterm>
	    <primary>comm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>comm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Versatile file comparison utility. The files must be sorted for this to be
	      useful.</para>

	    <para><command>comm
		<replaceable>-options</replaceable>
		<replaceable>first-file</replaceable>
		<replaceable>second-file</replaceable></command></para>

	    <para><userinput>comm file-1 file-2</userinput> outputs three columns:
	      <itemizedlist>
		<listitem><para>column 1 = lines unique to <replaceable>file-1</replaceable></para>
		</listitem>
		
		<listitem><para>column 2 = lines unique to <replaceable>file-2</replaceable></para>
		</listitem>
		
		<listitem><para>column 3 = lines common to both.</para>
		</listitem>
	      </itemizedlist></para>
	      
	    <para>The options allow suppressing output of one or more columns.
	      <itemizedlist>
		<listitem><para><option>-1</option> suppresses column
		    <literal>1</literal></para>
		</listitem>
		<listitem><para><option>-2</option> suppresses column
		    <literal>2</literal></para>
		</listitem>
		<listitem><para><option>-3</option> suppresses column
		    <literal>3</literal></para>
		</listitem>
		<listitem><para><option>-12</option> suppresses both columns
		    <literal>1</literal> and <literal>2</literal>, etc.</para>
		</listitem>
		</itemizedlist>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uniq</command></term>
	  <indexterm>
	    <primary>uniq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uniq</secondary>
	  </indexterm>
	  <listitem>
	    <para>This filter removes duplicate lines from a sorted file. It is often seen in
	      a pipe coupled with sort.
	      <programlisting>cat list-1 list-2 list-3 | sort | uniq > final.list</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>expand</command></term>
	  <indexterm>
	    <primary>expand</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>expand</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter than converts tabs to spaces, often seen in a pipe.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cut</command></term>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>A tool for extracting fields from files. It is similar to the 
	      <userinput>print $N</userinput> command set in <command>awk</command>,
	      but more limited. It may be simpler to use <command>cut</command>
	      in a script than <command>awk</command>. Particularly important
	      are the <option>-d</option> (delimiter) and <option>-f</option>
	      (field specifier) options.</para>

	    <para>Using <command>cut</command> to obtain a listing of the
	      mounted filesystems: 
	      <programlisting>cat /etc/mtab | cut -d ' ' -f1,2</programlisting></para>

	    <para>Using <command>cut</command> to list the OS and kernel version:
	      <programlisting>uname -a | cut -d" " -f1,3,11,12</programlisting></para>

	    <para><userinput>cut -d ' ' -f2,3 filename</userinput> is equivalent to
	      <userinput>awk '{ print $2, $3 }' filename</userinput>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>colrm</command></term>
	  <indexterm>
	    <primary>colrm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>colrm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Column removal filter. This removes columns (characters) from a file
	      and writes them, lacking the specified columns, back to stdout. 
	      <userinput>colrm 2 3 &lt;filename</userinput> removes the second and
	      third characters from each line of the text file <replaceable>filename</replaceable>.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>paste</command></term>
	  <indexterm>
	    <primary>paste</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>paste</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>cut</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cut</secondary>
	  </indexterm>
	  <listitem>
	    <para>Tool for merging together different files into a single, multi-column file.
	      In combination with <command>cut</command>, useful for creating system log files.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>join</command></term>
	  <indexterm>
	    <primary>join</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>join</secondary>
	  </indexterm>
	  <listitem>
	    <para>Consider this a more flexible version of
	      <command>paste</command>. It works on exactly two files, but
	      permits specifying which fields to paste together, and in which
	      order.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cpio</command></term>
	  <indexterm>
	    <primary>cpio</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cpio</secondary>
	  </indexterm>
	  <listitem>
	    <para>This specialized archiving copy command is rarely used any more,
	      having been supplanted by
	      <command>tar</command>/<command>gzip</command>. It still has its
	      uses, such as moving a directory tree.</para>

	    <example id="ex48">
	      <title>Using <command>cpio</command> to move a directory tree</title>
	      <programlisting>&ex48;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cd</command></term>
	  <indexterm>
	    <primary>cd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cd</secondary>
	  </indexterm>
	  <listitem>
	    <para>The familiar <command>cd</command> change directory command finds use in scripts where
	      execution of a command requires being in a specified directory.
	      <programlisting>(cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xvfp -)</programlisting>
	      [from the previously cited example by Alan Cox]</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>touch</command></term>
	  <indexterm>
	    <primary>touch</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>touch</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for updating access/modification times of a file to current
	      system time or other specified time, but also useful for creating
	      a new file. The command <userinput>touch zzz</userinput> will create a new file of zero
	      length, named <filename>zzz</filename>, assuming that
	      <filename>zzz</filename> did not previously exist.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>split</command></term>
	  <indexterm>
	    <primary>split</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>split</secondary>
	  </indexterm>
	  <listitem>
	    <para>Utility for splitting a file into smaller chunks. Usually used 
	      for splitting up large files in order to back them up on floppies or
	      preparatory to e-mailing or uploading them.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rm</command></term>
	  <indexterm>
	    <primary>rm</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rm</secondary>
	  </indexterm>
	  <listitem>
	    <para>Delete (remove) a file or files. When used with the recursive flag
	      <option>-r</option>, this removes files all the way down the directory tree (very
	      dangerous!).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ln</command></term>
	  <listitem>
	    <para>Creates links to pre-existings files. Most often used with the <option>-s</option>,
	      symbolic or <quote>soft</quote> link flag. This permits referencing the linked
	      file by more than one name and is a superior alternative to aliasing.</para>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cp</command></term>
	  <indexterm>
	    <primary>cp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cp</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is the file copy command. <userinput>cp file1
	      file2</userinput> copies <replaceable>file1</replaceable> to
	      <replaceable>file2</replaceable>, overwriting
	      <replaceable>file2</replaceable> if it already exists.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mv</command></term>
	  <listitem>
	    <para>This is the file move command. It is equivalent to a combination of
	      <command>cp</command> and <command>rm</command>. It may be used to
	      move multiple files to a directory.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rcp</command></term>
	  <indexterm>
	    <primary>rcp</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rcp</secondary>
	  </indexterm>
	  <listitem>
	    <para><quote>Remote copy</quote>, copies files between two different networked machines.
	      Using <command>rcp</command> and similar utilities with security
	      implications in a shell script may not be advisable. Consider
	      instead, using an <command>expect</command> script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>yes</command></term>
	  <indexterm>
	    <primary>yes</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>yes</secondary>
	  </indexterm>
	  <listitem>
	    <para>In its default behavior the <command>yes</command> command feeds a continuous string
	      of the character <computeroutput>y</computeroutput> followed by a line feed to
	      stdout. A
	      <keycombo><keycap>control</keycap><keycap>c</keycap></keycombo> 
	      terminates the run. A different output string may be specified, as in
	      <userinput>yes different string</userinput>, which would continually
	      output 
	      <computeroutput>different	string</computeroutput> to stdout. 
	      One might well ask the purpose of this. From the command
	      line or in a script, the output of <command>yes</command> can be
	      redirected or piped into a
	      program expecting user input. In effect, this becomes a sort of poor man's
	      version of <command>expect</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>echo</command></term>
	  <indexterm>
	    <primary>echo</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>echo</secondary>
	  </indexterm>
	  <listitem>
	    <para>prints (to stdout) an expression or variable (<varname>$variable</varname>).
	      <programlisting>echo Hello
echo $a</programlisting></para>
	    
	    <para>Normally, each <command>echo</command> command prints a terminal newline, but
	      the <option>-n</option> option suppresses this.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cat</command></term>
	  <term><command>tac</command></term>
	  <indexterm>
	    <primary>cat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cat</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>tac</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tac</secondary>
	  </indexterm>
	  <listitem>
	    <para><command>cat</command>, an acronym for <wordasword>concatenate</wordasword>,
	      lists a file to stdout. When combined with redirection
	      (<token>></token> or <token>>></token>), it is commonly used to
	      concatenate files.
	      <programlisting>cat filename
cat file.1 file.2 file.3 > file.123</programlisting></para>

	    <para><command>tac</command>, is the inverse of
	      <wordasword>cat</wordasword>, listing a file backwards from its end.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>head</command></term>
	  <indexterm>
	    <primary>head</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>head</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the first <literal>10</literal> lines of a file to stdout.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tail</command></term>
	  <indexterm>
	    <primary>tail</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tail</secondary>
	  </indexterm>
	  <listitem>
	    <para>lists the last <literal>10</literal> lines of a file to stdout.
	      Commonly used to keep track of changes to a system logfile,
	      using the <option>-f</option> option, which outputs lines appended to the file.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tee</command></term>
	  <indexterm>
	    <primary>tee</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tee</secondary>
	  </indexterm>
	  <listitem>
	    <para>[UNIX borrows an idea here from the plumbing trade.]</para>
	    <para>This is a redirection operator, but with a difference. Like the
	      plumber's <emphasis>tee</emphasis>, it permits <quote>siponing
		off</quote> the output of a command 
	      or commands within a pipe, but without affecting the result. This is
	      useful for printing an ongoing process to a file or paper, perhaps to
	      keep track of it for debugging purposes.</para>
	    
	    <screen>
                   tee
                 |------> to file
                 |
  ===============|===============
  command--->----|-operator-->---> result of command(s)
  ===============================
	      </screen>


	    <para><programlisting>cat listfile* | sort | tee check.file | uniq > result.file</programlisting>
	      (The file <filename>check.file</filename> contains the
	      concatenated sorted <quote>listfiles</quote>, 
	      before the duplicate lines are removed by <command>uniq</command>.)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sed</command></term>
	  <term><command>awk</command></term>
	  <indexterm>
	    <primary>sed</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sed</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>awk</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>awk</secondary>
	  </indexterm>
	  <listitem>
	    <para>manipulation scripting languages in order to parse text and command
	      output</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sed</command></term>
	  <listitem>
	    <para>Non-interactive <quote>stream editor</quote>, permits using
	      many <command>ex</command> commands in batch mode.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>awk</command></term>
	  <listitem>
	    <para>Programmable file extractor and formatter, good for manipulating and/or
	      extracting fields (columns) in text files. Its syntax is similar to C.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wc</command></term>
	  <indexterm>
	    <primary>wc</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wc</secondary>
	  </indexterm>
	  <listitem>
	    <para>wc gives a <quote>word count</quote> on a file or I/O stream.
	      <screen><prompt>% </prompt><userinput>wc /usr/doc/sed-3.02/README</userinput>
<computeroutput>20     127     838 /usr/doc/sed-3.02/README</computeroutput>
[20 lines  127 words  838 characters]</screen></para>

	    <para><userinput>wc -w</userinput> gives only the word count.</para>
	    <para><userinput>wc -l</userinput> gives only the line count.</para>
	    <para><userinput>wc -c</userinput> gives only the character count.</para>
	    <para><userinput>wc -L</userinput> gives only the length of the longest line.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>tr</command></term>
	  <indexterm>
	    <primary>tr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tr</secondary>
	  </indexterm>
	  <listitem>
	    <para>character translation filter.</para>
	    
	    <note><para>must use quoting and/or brackets, as appropriate.</para></note>
	    
	    <para><userinput>tr "A-Z" "*" &lt;filename</userinput>
	      changes all the uppercase letters in
	      <replaceable>filename</replaceable> to asterisks (writes to stdout).</para>

	    <para><userinput>tr -d [0-9] &lt;filename</userinput> deletes all digits
	      from the file <replaceable>filename</replaceable>.</para>

	    <example id="ex49">
	      <title><command>toupper</command>: Transforms a file to all uppercase.</title>
	      <programlisting>&ex49;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fold</command></term>
	  <indexterm>
	    <primary>fold</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fold</secondary>
	  </indexterm>
	  <listitem>
	    <para>A filter that wraps inputted lines to a specified width.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fmt</command></term>
	  <indexterm>
	    <primary>fmt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fmt</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simple-minded file formatter.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>pr</command></term>
	  <indexterm>
	    <primary>pr</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>pr</secondary>
	  </indexterm>
	  <listitem>
	    <para>Print formatting filter. This will paginate a file (or stdout) into
	      sections suitable for hard copy printing. A particularly useful option
	      is <option>-d</option>, forcing double-spacing.</para>

	    <example id="ex50">
	      <title>Formatted file listing.</title>
	      <programlisting>&ex50;</programlisting>
	    </example>	    
	    
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>date</command></term>
	  <indexterm>
	    <primary>date</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>date</secondary>
	  </indexterm>
	  <listitem>
	    <para>Simply invoked, <command>date</command> prints the date and
	      time to stdout. Where this command gets interesting is in its
	      formatting and parsing options.</para>

	    <example id="ex51">
	      <title>Using <command>date</command></title>
	      <programlisting>&ex51;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>time</command></term>
	  <indexterm>
	    <primary>time</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>time</secondary>
	  </indexterm>
	  <listitem>
	    <para>Outputs very verbose timing statistics for executing a command.</para>
	    <para><userinput>time ls -l /</userinput> gives something like this:
<screen><computeroutput>0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
0inputs+0outputs (149major+27minor)pagefaults 0swaps</computeroutput></screen>
	  </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>grep</command></term>
	  <indexterm>
	    <primary>grep</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>grep</secondary>
	  </indexterm>
	  <listitem>
	    <para>A multi-purpose file search tool that uses regular expressions.
	      Originally a command/filter in the ancient <command>ed</command> line editor, <userinput>g/re/p</userinput>, or <emphasis>global - regular expression - print</emphasis>.</para>
  
	    <para><cmdsynopsis>
		<command>grep</command>
		<arg choice="plain"><replaceable>pattern</replaceable></arg>
		<arg choice="opt" rep="repeat"><replaceable>file</replaceable></arg>
	      </cmdsynopsis>
	      search the files <replaceable>file</replaceable>, etc. for
	      occurrences of <replaceable>pattern</replaceable>.</para>

	    <para><userinput>ls -l | grep '.txt'</userinput> has the same effect as <userinput>ls -l *.txt</userinput>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>script</command></term>
	  <indexterm>
	    <primary>script</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>script</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility records (saves to a file) all the user keystrokes at
	      the command line in a console or an xterm window. This, in effect,
	      create a record of a session.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>tar</command></term>
	  <indexterm>
	    <primary>tar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>tar</secondary>
	  </indexterm>
	  <listitem>
	    <para>The standard UNIX archiving utility. Originally a <wordasword>Tape ARchiving</wordasword>
	      program, from whence it derived its name, it has developed into a
	      general purpose package that can handle all manner of archiving with
	      all types of destination devices, ranging from tape drives to regular
	      files to even stdout. GNU tar has long since been patched to accept
	      <command>gzip</command> options, see below.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>gzip</command></term>
	  <indexterm>
	    <primary>gzip</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>gzip</secondary>
	  </indexterm>
	  <listitem>
	    <para>The standard GNU/UNIX compression utility, replacing the inferior and
	      proprietary <command>compress</command>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shar</command></term>
	  <indexterm>
	    <primary>shar</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shar</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shell archiving utility. The files in a shell archive are concatenated
	      without compression, and the resultant archive is essentially a
	      shell script, complete with <token>#!/bin/sh</token> header, and containing all
	      the necessary unarchiving commands.  Shar archives still show up in
	      Internet newsgroups, but otherwise <command>shar</command> has
	      been pretty well replaced by
	      <command>tar</command>/<command>gzip</command>. The <command>unshar</command>
	      command unpacks <command>shar</command> archives.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>file</command></term>
	  <indexterm>
	    <primary>file</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>file</secondary>
	  </indexterm>
	  <listitem>
	    <para>A utility for identifying file types. The command <userinput>file file-name</userinput>
	      will return a file specification for
	      <replaceable>file-name</replaceable>, such as
	      <computeroutput>ascii text</computeroutput> 
		or <computeroutput>data</computeroutput>. It references the
		magic numbers found in <filename>/usr/share/magic</filename>, 
		<filename>/etc/magic</filename>, or
	      <filename>/usr/lib/magic</filename>, depending on the Linux/UNIX
		distribution.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uuencode</command></term>
	  <indexterm>
	    <primary>uuencode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uuencode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility encodes binary files into ASCII characters, making them
	      suitable for transmission in the body of an e-mail message or in a
	      newsgroup posting.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>uudecode</command></term>
	  <indexterm>
	    <primary>uudecode</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uudecode</secondary>
	  </indexterm>
	  <listitem>
	    <para>This reverses the encoding, decoding uuencoded files back into the
	      original binaries.</para>

	    <example id="ex52">
	      <title>uuencoding encoded files</title>
	      <programlisting>&ex52;</programlisting>
	    </example>	    	   
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>more</command></term>
	  <term><command>less</command></term>
	  <indexterm>
	    <primary>more</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>more</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>less</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>less</secondary>
	  </indexterm>
	  <listitem>
	    <para>Pagers that display a text file or text streaming to stdout, one page at a
	      time.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>jot</command></term>
	  <term><command>seq</command></term>
	  <indexterm>
	    <primary>jot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>jot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>seq</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>seq</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>loop</primary>
	    <secondary>arguments</secondary>
	  </indexterm>
	  <listitem>
	    <para>These utilities emit a sequence of integers, with a user selected
	      increment. This can be used to advantage in a <command>for</command> loop.</para>

	    <example id="ex53">
	      <title>Using <command>seq</command> to generate loop arguments</title>
	      <programlisting>&ex53;</programlisting>
	    </example>	    	   
	  </listitem>
	</varlistentry>

      </variablelist>

    </sect1> <!-- External Filters, Programs and Commands -->

    <sect1 id="system">
      <title>System and Administrative Commands</title>
      <para>The startup and shutdown scripts in 
	<filename class="directory">/etc/rc.d</filename> illustrate the uses
	(and usefulness) of these comands. These are usually invoked by root and used
	for system maintenance or emergency filesystem repairs. Use with caution,
	as some of these commands may damage your system if misused.</para>

      <variablelist>
	<varlistentry>
	  <term><command>uname</command></term>
	  <indexterm>
	    <primary>uname</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>uname</secondary>
	  </indexterm>
	  <listitem>
	    <para>Output system specifications (OS, kernel version, etc.) to stdout.
	      Invoked with the <option>-a</option> option, gives verbose system info.</para>

	    <para><userinput>uname -a</userinput> outputs something like:
<screen><computeroutput>Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i586 unknown</computeroutput></screen></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>env</command></term>
	  <indexterm>
	    <primary>env</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>env</secondary>
	  </indexterm>
	  <listitem>
	    <para>Runs a program or script with certain environmental variables set or changed
	      (without changing the overall system environment).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>shopt</command></term>
	  <indexterm>
	    <primary>shopt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shopt</secondary>
	  </indexterm>
	  <listitem>
	    <para>This command permits changing shell options on the fly.
	      Works with version 2 of <command>bash</command> only.
	      
	      <programlisting>shopt -s cdspell
# Allows misspelling directory names with 'cd' command.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lockfile</command></term>
	  <indexterm>
	    <primary>lockfile</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lockfile</secondary>
	  </indexterm>
	  <listitem>
	    <para>This utility is part of the <command>procmail</command>
	      package (<ulink url="http://www.procmail.org">www.procmail.org</ulink>).
	      It creates a <emphasis>lock file</emphasis>, a semaphore file that
	      controls access to a file, device, or resource. The lock file
	      serves as a flag that this particular file, device, or resource is
	      in use by a particular process (<quote>busy</quote>), and
	      permitting only restricted access (or no access) to other
	      processes. Lock files are used in such applications as protecting 
	      system mail folders from simultaneously being changed by multiple
	      users, indicating that a modem port is being accessed, and showing
	      that an instance of <application>Netscape</application> is using its
	      cache.  Scripts may check for the existence of a lock file created
	      by a certain process to check if that process is running.  Note
	      that if a script attempts create a lock file that already exists,
	      the script will likely hang.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>cron</command></term>
	  <indexterm>
	    <primary>cron</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>cron</secondary>
	  </indexterm>
	  <listitem>
	    <para>Administrative program scheduler, performing such duties as cleaning up
	      and deleting system log files and updating the
	      <database>slocate</database> database. This is the superuser
	      version of <command>at</command>.  It runs as a daemon (background
	      process) and executes scheduled entries from <filename>/etc/crontab</filename>.
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>chroot</command></term>
	  <indexterm>
	    <primary>chroot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>chroot</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>directory</primary>
	    <secondary>root</secondary>
	    <tertiary>change</tertiary>
	  </indexterm>
	  <listitem>
	    <para>CHange ROOT directory. Normally commands are fetched from <varname>$PATH</varname>,
	      relative to <filename class="directory">/</filename>, the default
	      root directory. This changes the root directory to a different one
	      (and also changes the working directory to there). A <userinput>chroot /opt</userinput>
	      would cause references to <filename class="directory">/usr/bin</filename> to be 
	      translated to <filename class="directory">/opt/usr/bin</filename>,
	      for example. This is useful for security purposes, for instance
	      when the system administrator wishes to restrict 
	      certain users, such as those telnetting in, to a secured portion of
	      the filesystem. Note that after a <command>chroot</command>, the execution path for
	      system binaries is no longer valid.</para>

	    <para>The <command>chroot</command> command is also handy when running from an emergency
	      boot floppy (<command>chroot</command> to
	      <filename>/dev/fd0</filename>), or as an option to <command>lilo</command> when 
	      recovering from a system crash. Other uses include installation from
	      a different filesystem (an <command>rpm</command> option).  Invoke only as root, and
	      use with caution.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ldd</command></term>
	  <indexterm>
	    <primary>ldd</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ldd</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show shared lib dependencies for an executable file.</para>
	    <screen><prompt>bash$ </prompt><userinput>ldd /bin/ls</userinput>
<computeroutput>libc.so.6 => /lib/libc.so.6 (0x4000c000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000)</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>who</command></term>
	  <indexterm>
	    <primary>who</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>who</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all users logged on to the system.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>w</command></term>
	  <indexterm>
	    <primary>w</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>w</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show all logged on users and the processes belonging to them. This is
	      an extended version of <command>who</command>. The output of <command>w</command>
	      may be piped to <command>grep</command> to find a specific user and/or process.</para>
	    <screen><prompt>bash# </prompt><userinput>w | grep startx</userinput>
<computeroutput>grendel  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>wall</command></term>
	  <indexterm>
	    <primary>wall</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>wall</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is an acronym for <quote>write all</quote>, i.e.,
	      sending a message to all users every terminal logged on in the
	      network. It is primarily a system administrator's tool, useful,
	      for example, when warning everyone that the system will shortly go
	      down due to a problem.</para>
	    <screen><computeroutput>wall System going down for maintenance in 5 minutes!</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>fuser</command></term>
	  <indexterm>
	    <primary>fuser</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>fuser</secondary>
	  </indexterm>
	  <listitem>
	    <para>Identifies the processes (by pid) that are accessing a given file, set of
	      files, or directory.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>logger</command></term>
	  <indexterm>
	    <primary>logger</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>logger</secondary>
	  </indexterm>
	  <listitem>
	    <para>Appends a user-generated message to the system log (<filename>/var/log/messages</filename>).
	      <programlisting>logger Experiencing instability in network connection at 23:10, 05/21.
# Now, do a 'tail /var/log/messages'.</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>free</command></term>
	  <indexterm>
	    <primary>free</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>free</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows memory and cache usage in tabular form. The output of this command
	      lends itself to parsing, using <command>grep</command>, <command>awk</command> or <command>Perl</command>.
	    </para>

	    <screen><prompt>bash$ </prompt><command>free</command>
<computeroutput>                total       used       free     shared    buffers     cached
   Mem:         30504      28624       1880      15820       1608       16376
   -/+ buffers/cache:      10640      19864
   Swap:        68540       3128      65412</computeroutput></screen>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>sync</command></term>
	  <indexterm>
	    <primary>sync</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>sync</secondary>
	  </indexterm>
	  <listitem>
	    <para>Forces writing all updated data from buffers to hard drive. While not
	      strictly necessary, a <command>sync</command> assures the sys
	      admin or user that the data just changed will survive a sudden
	      power failure. In the olden days, a <userinput>sync sync</userinput>
	      was a useful precautionary measure before a system reboot.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>init</command></term>
	  <indexterm>
	    <primary>init</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>init</secondary>
	  </indexterm>
	  <listitem>
	    <para>The <command>init</command> command is the parent of all processes. Called in the
	      final step of a bootup, <command>init</command> determines the runlevel of the system
	      from <filename>/etc/inittab</filename>. Invoked by its alias
	      <command>telinit</command>, and by root only.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>telinit</command></term>
	  <indexterm>
	    <primary>telinit</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>telinit</secondary>
	  </indexterm>
	  <listitem>
	    <para>Symlinked to <command>init</command>, this is a means of changing the system runlevel,
	      usually done for system maintenance or emergency filesystem
	      repairs. Invoked only by root. This command can be dangerous - be
	      certain you understand it well before using!</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>runlevel</command></term>
	  <indexterm>
	    <primary>runlevel</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>runlevel</secondary>
	  </indexterm>
	  <listitem>
	    <para>Shows the current and last runlevel, that is, whether the system
	      is halted (runlevel <literal>0</literal>), in single-user mode
	      (<literal>1</literal>), in multi-user mode (<literal>2</literal>
	      or <literal>3</literal>), in X Windows (<literal>5</literal>), or
	      rebooting (<literal>6</literal>).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>halt</command></term>
	  <term><command>shutdown</command></term>
	  <term><command>reboot</command></term>
	  <indexterm>
	    <primary>halt</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>halt</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>shutdown</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>shutdown</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>reboot</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>reboot</secondary>
	  </indexterm>
	  <listitem>
	    <para>Command set to shut the system down, usually just prior to a power down.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>exec</command></term>
	  <indexterm>
	    <primary>exec</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>exec</secondary>
	  </indexterm>
	  <listitem>
	    <para>This is actually a system call that replaces the current process with
	      a specified command. It is mostly seen in combination with <command>find</command>,
	      to execute a command on the files found. When used as a standalone in
	      a script, this forces an exit from the script when the <command>exec</command>'ed command
	      terminates. An <command>exec</command> is also used to reassign file descriptors.
	      <userinput>exec &lt;zzz-file</userinput> replaces stdin with the file
	      <replaceable>zzz-file</replaceable>.</para>

	    <example id="ex54">
	      <title>Effects of <command>exec</command></title>
	      <programlisting>&ex54;</programlisting>
	    </example>	    	   

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>ifconfig</command></term>
	  <indexterm>
	    <primary>ifconfig</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>ifconfig</secondary>
	  </indexterm>
	  <listitem>
	    <para>Network interface configuration utility.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>route</command></term>
	  <indexterm>
	    <primary>route</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>route</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show info about or make changes to the kernel routing table.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>netstat</command></term>
	  <indexterm>
	    <primary>netstat</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>netstat</secondary>
	  </indexterm>
	  <listitem>
	    <para>Show current network information and statistics, such as routing tables and
	      active connections.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mknod</command></term>
	  <indexterm>
	    <primary>mknod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mknod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Creates block or character device files (may be necessary when installing
	      new hardware on the system).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>mount</command></term>
	  <indexterm>
	    <primary>mount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>mount</secondary>
	  </indexterm>
	  <listitem>
	    <para>Mount a filesystem, usually on an external device, such as a floppy
	      or CDROM. The file <filename>/etc/fstab</filename> provides a
	      handy listing of available filesystems, including options, that
	      may be automatically or manually mounted. The file 
	      <filename>/etc/mtab</filename> shows the currently mounted filesystems
	      (including the virtual ones, such as <filename class="directory">/proc</filename>).

	      <programlisting>mount -t iso9660 /dev/cdrom /mnt/cdrom
# Mounts CDROM
mount /mnt/cdrom
# Shortcut, if /mnt/cdrom listed in /etc/fstab</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>umount</command></term>
	  <indexterm>
	    <primary>umount</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>umount</secondary>
	  </indexterm>
	  <listitem>
	    <para>Unmount a currently mounted filesystem. Before physically removing a
	      previously mounted floppy or CDROM disk, the device must be
	      <command>umount</command>'ed, else filesystem corruption may result.
	      <programlisting>umount /mnt/cdrom</programlisting></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>lsmod</command></term>
	  <indexterm>
	    <primary>lsmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>lsmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>List installed kernel modules.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>insmod</command></term>
	  <indexterm>
	    <primary>insmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>insmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Force insertion of a kernel module. Must be invoked as root.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>modprobe</command></term>
	  <indexterm>
	    <primary>modprobe</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>modprobe</secondary>
	  </indexterm>
	  <listitem>
	    <para>Module loader that is normally invoked automatically in a startup script.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term><command>depmod</command></term>
	  <indexterm>
	    <primary>depmod</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>depmod</secondary>
	  </indexterm>
	  <listitem>
	    <para>Creates module dependency file, usually invoked from startup script.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>rdev</command></term>
	  <indexterm>
	    <primary>rdev</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>rdev</secondary>
	  </indexterm>
	  <listitem>
	    <para>Get info about or make changes to root device, swap space, or video
	       mode.  The functionality of <command>rdev</command> has generally been taken over by
	       <command>lilo</command>, but <command>rdev</command> remains
	       useful for setting up a ram disk. This is another dangerous command, if misused.
	     </para>
	   </listitem>
	 </varlistentry>
	
      </variablelist>
      <para>Using our knowledge of administrative commands, let us examine a system
	script. One of the shortest and simplest to understand scripts is
	<command>killall</command>, used to suspend running processes at system shutdown.</para>

	    <example id="ex55">
	      <title><command>killall</command>, from <filename class="directory">/etc/rc.d/init.d</filename></title>
	      <programlisting>&ex55;</programlisting>
	    </example>
      
      <para>That wasn't so bad. Aside from a little fancy footwork with variable
	matching, there is no new material there.</para>

      <formalpara><title>Exercise</title>
	  <para>In <filename class="directory">/etc/rc.d/init.d</filename>,
	  analyze the <command>halt</command> script. It is a bit longer than 
	  <command>killall</command>, but similar in concept. Make a copy of this script somewhere in
	  your home directory and experiment with it (do <emphasis>not</emphasis> run it as root). Do
	  a simulated run with the <option>-vn</option> flags 
	  (<userinput>sh -vn scriptname</userinput>). Add extensive comments. Change
	  the <quote>action</quote> commands to <quote>echos</quote>.</para></formalpara>

      <para>Now, look at some of the more complex scripts in 
	<filename class="directory">/etc/rc.d/init.d</filename>. See if you
	can understand parts of them. Follow the above procedure to analyze them.</para>

      <para>For those scripts needing a single do-it-all tool, a Swiss army knife,
	there is Perl. Perl combines the capabilities of
	<command>sed</command>, <command>awk</command>, and throws 
	in a large subset of C, to boot. It is modular and contains support for
	everything ranging from object oriented programming up to and including
	the kitchen sink. Short Perl scripts can be effectively embedded in
	shell scripts, and there may even be some substance to the claim that
	Perl can totally replace shell scripting.</para>

      <example id="ex56">
	<title>Perl embedded in a <command>bash</command> script</title>
	<programlisting>&ex56;</programlisting>
      </example>
      
    </sect1> <!-- System and Administrative Commands -->

    <sect1 id="backticks">
      <title>Backticks (`...`)</title>
      <indexterm>
	<primary>`</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>`</secondary>
      </indexterm>
      <variablelist>
	<varlistentry>
	  <term>Command substitution</term>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>substitution</secondary>
	  </indexterm>
	  <listitem>
	    <para>Use the output of the command within backticks as arguments to another
	      to generate command line text.
	      <programlisting>rm `cat filename`</programlisting>
	      (where <replaceable>filename</replaceable> contains list of files to delete)
	      </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Incrementing / decrementing variables</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>increment</secondary>
	  </indexterm>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>decrement</secondary>
	  </indexterm>
	  <listitem>
	    <para><programlisting>z=`expr $z + 3`</programlisting>
	      Note that this use of backticks has been superseded by double parentheses
	      <userinput>$((...))</userinput> or the <command>let</command> construction.
	      <programlisting>z=$(($z+3))</programlisting>
	      or
	      <programlisting>let z=z+3</programlisting>
	      <programlisting>let "z += 3"</programlisting>
	    </para>

	    <example id="ex57">
	      <title><command>Badname</command>, eliminate file names
		in current directory containing
		bad characters and white space.</title>
	      <programlisting>&ex57;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>-</command></term>
	  <listitem>
	    <para>Where file name expected, redirects output to stdout
	      (mostly seen with <userinput>tar cf</userinput>)</para>
	    
	    <example id="ex58">
	      <title>Backup of all files changed in last day</title>
	      <programlisting>&ex58;</programlisting>
	    </example>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect1> <!-- Backticks (`...`) -->

    <sect1 id="io-redirection">
      <title>I/O Redirection</title>
      <para>There are always three default <quote>files</quote> open, stdout (the screen), stderr
	(the screen, also) and  stdin (the keyboard).</para>

      <programlisting>>
>>
2>&1</programlisting>

      <variablelist>
	<varlistentry>
	  <term><token>n<&-</token></term>
	  <listitem>
	    <para>close input file descriptor <replaceable>n</replaceable></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token><&-</token></term>
	  <listitem>
	    <para>close stdin</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>n>&-</token></term>
	  <listitem>
	    <para>close output file descriptor <replaceable>n</replaceable></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><token>>&-</token></term>
	  <listitem>
	    <para>close stdout</para>
	  </listitem>
	</varlistentry>
      </variablelist>


      <blockquote>
	<title>Recess Time</title>
	<attribution>Courtesy 'NIX "fortune cookies", with a few alterations and many apologies</attribution>
	<para>A bizarre little intermission whose purpose is to give the reader a chance to
	  catch his/her breath and maybe giggle a little.</para>
	
	<para>Fellow Linux user, greetings!  You are reading a something which will
	  bring you luck and good fortune.  Just e-mail ten copies of this document
	  to ten of your friends.  Before you make the copies, send a 100-line
	  'bash' script to the first person on the list given at the bottom of this
	  letter.  Then delete their name and add yours to the bottom of the list.</para>
	
	<para>Don't break the chain!  Make the copy within 48 hours.  Wilfred P. of
	  Houston failed to send out his ten copies and woke the next morning to
	  find his job description changed to "COBOL programmer."  Howard L. of
	  Newport News sent out his ten copies and within a month had enough
	  hardware and software to build a 100-node Beowulf cluster dedicated to
	  playing 'xbill'.  Amelia V. of Chicago laughed at this letter and broke
	  the chain.  Shortly thereafter, a fire broke out in her terminal and
	  she now spends her days writing documentation for MS Windows.</para>
	
	<para>Don't break the chain!  Send out your ten copies today!</para>
      </blockquote>
      
    </sect1> <!-- I/O Redirection -->

    <sect1 id="regexp">
      <title>Regular Expressions</title>
      <para>In order to fully utilize the power of shell scripting, you need to
	master regular expressions.</parA>

      <sect2><title>A Brief Introduction to Regular Expressions</title>

	<para>An expression is simply a set of characters that has an interpretation
	  above and beyond its literal meaning. A quote symbol (<token>"</token>), for example,
	  may denote speech by a character, ditto, or a meta-meaning for the
	  symbols that follow. Regular expressions are a set of characters that
	  UNIX endows with special features.</para>

	<para>The main uses for regular expressions (REs) are text searches
	  and manipulation. An RE <firstterm>matches</firstterm> a single character or a set of
	  characters.</para>
	<itemizedlist>
	  <listitem>
	    <indexterm>
	      <primary>*</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>*</secondary>
	    </indexterm>
	    <para>The asterisk <token>*</token> matches any number of characters, including zero.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>.</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>.</secondary>
	    </indexterm>
	    <para>The dot <token>.</token> matches any one character, except a newline.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>?</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>?</secondary>
	    </indexterm>
	    <para>The question mark <token>?</token>  matches zero or one of the previous RE.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>+</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>+</secondary>
	    </indexterm>
	    <para>The plus <token>+</token> matches one or more of the previous RE.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>^</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>^</secondary>
	    </indexterm>
	    <para>The caret <token>^</token> matches the beginning of a line, but sometimes,
	      depending on context, negates the meaning of a set of characters
	      in an RE.
	    </para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>$</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>$</secondary>
	    </indexterm>
	    <para>The dollar sign <token>$</token> at the end of a an RE matches the end of a line.</para>
	  </listitem>
	  <listitem>
	    <indexterm>
	      <primary>[]</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>[]</secondary>
	    </indexterm>
	    <para>Brackets <token>[]</token> enclose a set of characters to match in a single RE.</para>
	  </listitem>
	  <listitem>
	    <para>The backslash <token>\</token> escapes a special character.</para>
	    <indexterm>
	      <primary>\</primary>
	    </indexterm>
	    <indexterm>
	      <primary>special character</primary>
	      <secondary>\</secondary>
	    </indexterm>
	  </listitem>
	</itemizedlist>

	<para>See "Sed & Awk", by Dougherty and Robbins (see 
	  <xref linkend="biblio">) for a complete treatment of REs.</para>
	
      </sect2> <!-- A Brief Introduction to Regular Expressions -->

      <sect2>
	<title>Using REs in scripts</title>
	<para>Sed, awk, and Perl, used as filters in scripts, take REs as arguments
	  when "sifting" or transforming files or I/O streams.</para>
      </sect2>
    </sect1> <!-- Regular Expressions -->

    <sect1 id="subshells">
      <title>Subshells</title>
      <itemizedlist>
	<listitem>
	  <para>()</para>
	</listitem>
	<listitem>
	  <para>{}</para>
	</listitem>
      </itemizedlist>
    </sect1> <!-- Subshells -->

    <sect1 id="functions">
      <title>Functions</title>
      <para>Like <quote>real</quote> programming languages,
	<command>bash</command> has functions, though in a 
	somewhat limited implementation.  A function is a subroutine, a code block
	that implements a set of operations.  Whenever there is repetitive code,
	when a task repeats with only slight variations, then writing a function
	should be investigated.</para>

      <para><cmdsynopsis>
	  <command>function</command>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
	or 
	<cmdsynopsis>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">()</arg>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>The second form will cheer the hearts of C programmers.</para>

      <para>The opening bracket in the function may optionally be placed on the
	second line, to more nearly resemble C function syntax.</para>

      <para><cmdsynopsis>
	  <arg choice="plain"><replaceable>function-name</replaceable></arg> 
	  <arg choice="plain">()</arg><sbr>
	  <arg choice="plain">{</arg><sbr>
	  <arg rep="repeat" choice="plain"><replaceable>command</replaceable></arg><sbr>
	  <arg choice="plain">}</arg><sbr>
	</cmdsynopsis>
      </para>

      <para>Functions are called, <firstterm>triggered</firstterm>, simply by
	invoking their names.</para>

      <para>Note that a function itself must precede the first call to it. There is
	no method of <quote>declaring</quote> the function, as, for example, in C.</para>

      <example id="ex59">
	<title>Simple function</title>
	<programlisting>&ex59;</programlisting>
      </example>

      <para>More complex functions may have arguments passed to them and may return
	exit values to the script for further processing.</para>
	
      <programlisting>function-name $arg1 $arg2</programlisting>

      <para>The function refers to the passed arguments by position (as if they were
	positional parameters), that is, <varname>$1</varname>, <varname>$2</varname>, etc.</para>

      <example id="ex60">
	<title>Positional Parameters</title>
	<programlisting>&ex60;</programlisting>
      </example>

      <variablelist>
	<varlistentry>
	  <term>exit status</term>
	  <listitem>
	    <para>Functions return a value, called an <firstterm>exit
		status</firstterm>. The exit status may be explicitly specified
	      by a <command>return</command> statement, otherwise it is 
	      the exit status of the last command in the function
	      (<errorcode>0</errorcode> if successful, and a non-zero error code
	      if not). This exit status may be used in the script by referring
	      to as <varname>$?</varname>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><command>return</command></term>
	  <indexterm>
	    <primary>return</primary>
	  </indexterm>
	  <indexterm>
	    <primary>command</primary>
	    <secondary>return</secondary>
	  </indexterm>
	  <listitem>
	    <para>Terminates a function. The <command>return</command> statement
	      may optionally take an integer argument, which is returned to the
	      calling script as the <quote>exit status</quote> of the function,
	      and this exit status is assigned to the variable <varname>$?</varname>.</para>

	    <example id="ex61">
	      <title>Converting numbers to Roman numerals</title>
	      <programlisting>&ex61;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>local variables</term>
	  <indexterm>
	    <primary>variable</primary>
	    <secondary>local</secondary>
	  </indexterm>
	  <listitem>
	    <para>A variable declared as <firstterm>local</firstterm> is one
	      that is visible only within the block of code in which it
	      appears. In a shell script, this means the variable has meaning
	      only within the function it is internal to.</para>

	    <example id="ex62">
	      <title>Local variable visibility</title>
	      <programlisting>&ex62;</programlisting>
	    </example>

	    <para>Local variables permit recursion (a recursive function is one that calls
	      itself), but this practice can involve much computational overhead and
	      is definitely <emphasis>not</emphasis> recommended in a shell script.</para>

	    <example id="ex63">
	      <title>Recursion, using a local variable</title>
	      <programlisting>&ex63;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

      </variablelist>

    </sect1> <!-- Functions -->

    <sect1 id="list-cons">
      <title>List Constructs</title>
      <indexterm>
	<primary>&&</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>&&</secondary>
      </indexterm>
      <indexterm>
	<primary>AND</primary>
	<secondary>list</secondary>
      </indexterm>
      <indexterm>
	<primary>||</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary>||</secondary>
      </indexterm>
      <indexterm>
	<primary>OR</primary>
	<secondary>list</secondary>
      </indexterm>

      <para>The <quote>and list</quote> and <quote>or list</quote>
	constructs provide a means of processing a number of commands
	consecutively. These can effectively replace complex 
	nested <command>if</command>/<command>then</command> or even
	<command>case</command> statements. Note that the exit status 
	of an <quote>and list</quote> or an <quote>or list</quote> is
	the exit status of the last command executed.</para>

      <variablelist>
	<varlistentry>
	  <term>and list</term>
	  <listitem>
	    <para><programlisting>command-1 && command-2 && command-3 && ... command-n</programlisting>
	        Each command executes in turn provided that the previous command
	      has given a return value of <errorcode>true</errorcode>. At the
	      first <errorcode>false</errorcode> return, 
	      the command chain terminates (the first command returning <errorcode>false</errorcode>
	      is the last one to execute).</para>

	    <example id="ex64">
	      <title>Using an <quote>and list</quote> to test for command-line arguments</title>
	      <programlisting>&ex64;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>or list</term>
	  <listitem>
	    <para><programlisting>command-1 || command-2 || command-3 || ... command-n</programlisting>
	      Each command executes in turn for as long as the previous command
	      returns <errorcode>false</errorcode>. At the first
	      <errorcode>true</errorcode> return, the command chain terminates 
	      (the first command returning <errorcode>true</errorcode> is the
	      last one to execute). This is obviously the inverse of the
	      <quote>and list</quote>.</para>

	    <example id="ex65">
	      <title>Using <quote>or lists</quote> in combination with an <quote>and list</quote></title>
	      <programlisting>&ex65;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>
	</variablelist>

	<para>Clever combinations of <quote>and</quote> and <quote>or</quote>
	lists are possible, but the logic may easily become convoluted and
	require extensive debugging.</para>

    </sect1> <!-- List Constructs -->

    <sect1 id="arrays">
      <title>Arrays</title>
      <para>Newer versions of <command>bash</command> support one-dimensional
	arrays.  Arrays may be declared with the <userinput>variable[xx]</userinput>
	notation or explicitly by a <userinput>declare -a variable</userinput>
	statement. To dereference (find the contents of) an array variable, use
	<firstterm>curly bracket</firstterm> notation, that is, <userinput>${variable[xx]}</userinput>.</para>

      <example id="ex66">
	<title>Simple array usage</title>
	<programlisting>&ex66;</programlisting>
      </example>

      <para>Arrays variables have a syntax all their own, and even standard bash operators
	have special options adapted for array use.</para>

      <example id="ex67">
	<title>Some special properties of arrays</title>
	<programlisting>&ex67;</programlisting>
      </example>

      <para>Arrays enable implementing a shell script version of the <emphasis>Sieve of
	Erastosthenes</emphasis>. Of course, a resource-intensive application of this
	nature should really be written in a compiled language, such as C. It
	runs excruciatingly slowly as a script.</para>

      <example id="ex68">
	<title>Complex array application:
             <emphasis>Sieve of Erastosthenes</emphasis></title>
	<programlisting>&ex68;</programlisting>
      </example>

    </sect1> <!-- Arrays -->

    <sect1 id="files">
      <title>Files</title>
      <itemizedlist>
	<listitem>
	  <para><filename>/etc/profile</filename></para>
	</listitem>
	<listitem>
	  <para><filename><varname>$HOME</varname>/.bashrc</filename></para>
	</listitem>
      </itemizedlist>
    </sect1> <!-- Files -->

    <!-- fixme: empty ?
  <sect1>
  <title>Coprocesses</title>
  <para></para>
  </sect1>
    -->

    <sect1 id="here-docs">
      <title>Here Documents</title>
      <indexterm>
	<primary><<</primary>
      </indexterm>
      <indexterm>
	<primary>special character</primary>
	<secondary><<</secondary>
      </indexterm>
      <para>A <firstterm>here document</firstterm> is a way of feeding a command
	script to an interactive program, such as <command>ftp</command>,
	<command>telnet</command>, or <command>ex</command>.  Typically, it
	consists of a command  list to the program, delineated by a limit
	string.  The special symbol <token><<</token> precedes the limit string.
	This has the same effect as redirecting the output of a file into the
	program, that is, 
	<programlisting>interactive-program < command-file</programlisting>
	where <replaceable>command-file</replaceable> contains
	  <programlisting>command #1
command #2
...</programlisting></para>

      <para>The <quote>here document</quote> alternative looks like this:
	<programlisting>#!/bin/bash
interactive-program &lt;&lt;LimitString
command #1
command #2
...
LimitString</programlisting></para>

      <para>Choose a limit string sufficiently unusual that it will not occur anywhere
	in the command list and confuse matters.</para>

      <para>Note that <quote>here documents</quote> may sometimes be used to good effect with
	non-interactive utilities and commands.</para>

      <example id="ex69">
	<title><command>dummyfile</command>: Creates a 2-line dummy file</title>
	<programlisting>&ex69;</programlisting>
      </example>

      <para>The above script could just as effectively have been implemented with
	<command>ex</command>, rather than <command>vi</command>. Here documents
	containing a list of <command>ex</command> commands are common enough to
	form their own category, known as <firstterm>ex scripts</firstterm>.</para>

      <example id="ex70">
	<title><command>broadcast</command>: Sends message to everyone logged in</title>
	<programlisting>&ex70;</programlisting>
      </example>

      <example id="ex71">
	<title>Multi-line message using <command>cat</command></title>
	<programlisting>&ex71;</programlisting>
      </example>

      <example id="ex72">
	<title><command>upload</command>: Uploads a file pair to <quote>Sunsite</quote>
	  incoming directory</title>
	<programlisting>&ex72;</programlisting>
      </example>

      <note>
	<para>Some utilities will not work in a 
	  <quote>here document</quote>. The pagers, <command>more</command> and 
	  <command>less</command> are among these.</para>

	<para>For those tasks too complex for a <quote>here document</quote>,
	  consider using the <command>expect</command> scripting language, which
	  is specifically tailored for feeding input into non-interactive programs.</para>
      </note>
    </sect1> <!-- Here Documents -->

    <sect1 id="misc">
      <title>Miscellany</title>

      <variablelist>
	<varlistentry>
	  <term>Uses of <filename>/dev/null</filename></term>
	  <listitem>
	    <para>Think of <filename>/dev/null</filename> as a <quote>black
		hole</quote>. It is the nearest equivalent to a 
	      write-only file. Everything written to it disappears forever. Attempts
	      to read or output from it result in nothing. Nevertheless,
		<filename>/dev/null</filename> can be quite useful both from the
	      command line and in scripts.</para>

	    <para>Suppressing stdout or stderr (from <xref linkend="ex74">):
	      <programlisting>rm $badname 2>/dev/null
#           So error messages [stderr] deep-sixed.</programlisting>
	      </para>

	    <para>Deleting contents of a file, but preserving the file itself, with
	      all attendant permissions (from <xref linkend="ex1"> and <xref linkend="ex2">):
	      <programlisting>cat /dev/null > /var/log/messages
cat /dev/null > /var/log/wtmp</programlisting>
	      </para>

	    <para>Automatically emptying the contents of a log file (especially good for
	      dealing with those nasty <quote>cookies</quote> sent by Web commercial sites):
	      <programlisting>rm ~/.netscape/cookies
ln -s /dev/null ~/.netscape/cookies
# All cookies now get sent to a black hole.</programlisting>
	    </para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>Uses of <filename>/dev/zero</filename></term>
	  <listitem>
	    <para>Like <filename>/dev/null</filename>,
	      <filename>/dev/zero</filename> is a pseudo file, but it actually
	      contains nulls (numerical zeros, not the ASCII kind). Output written to it
	      disappears, and it is fairly difficult to actually read the nulls in
	      <filename>/dev/zero</filename>, though it can be done with <command>od</command> or
	      a hex editor. The chief use for <filename>/dev/zero</filename> is
	      in creating an initialized dummy file of specified length intended
	      as a temporary swap file.</para>

	    <example id="ex73">
	      <title>Setting up a swapfile using <filename>/dev/zero</filename></title>
	      <programlisting>&ex73;</programlisting>
	    </example>

	  </listitem>
	</varlistentry>

      </variablelist>
    </sect1> <!-- Miscellany -->

    <sect1 id="debugging">
      <title>Debugging</title>
      <para>The bash shell contains no debugger, nor even any debugging-specific
	commands or constructs.  Syntax errors or outright typos in the script
	generate cryptic error messages that are often of no help in debugging
	a non-functional script.</para>

      <example id="ex74">
	<title>test23, a buggy script</title>
	<programlisting>&ex74;</programlisting>
      </example>

      <para>Output from script:
	<screen><computeroutput>./test23: [37: command not found</computeroutput></screen>
	</para>

      <para>What's wrong with the above script (hint: after the <command>if</command>)?</para>


      <para>What if the script executes, but does not work as expected? This is the
	all too familiar logic error.</para>

      <example id="ex75">
	<title>test24, another buggy script</title>
	<programlisting>&ex75;</programlisting>
      </example>

      <para>To find out what's wrong with <xref linkend="ex75">, uncomment the
	<userinput>echo "$badname"</userinput> line. Echo statements are useful for
	seeing whether what you expect is actually what you get.</para>

      <para>Summarizing the symptoms of a buggy script,
	<orderedlist>
	  <listitem>
	    <para>It bombs with an error message <errorname>syntax error</errorname>, or</para>
	  </listitem>
	  <listitem>
	    <para>It runs, but does not work as expected 
	      (<errorname>logic error</errorname>)</para> 
	  </listitem>
	  <listitem>
	    <para>It runs, works as expected, but has nasty side effects
	      (<errorname>logic bomb</errorname>.</para> 
	  </listitem>
	</orderedlist>
      </para>
	
      <para>Tools for debugging non-working scripts include
	<orderedlist>
	  <listitem>
	    <para>echo statements at critical points in the script to trace the variables,
	      and otherwise give a snapshot of what is going on.</para>
	  </listitem>
	  <listitem>
	    <para>using the <command>tee</command> filter to check processes or
	      data flows at critical points.</para>
	  </listitem>
	  <listitem>
	    <para>setting option flags <option>-n -v -x</option></para>

	<para><userinput>sh -n scriptname</userinput> checks for syntax errors
	      without actually running the script. This is the equivalent of
	      inserting <userinput>set -n</userinput> or 
	      <userinput>set -o noexec</userinput> into the script. Note that
	      certain types of syntax errors can slip past this check.</para>

	    <para><userinput>sh -v scriptname</userinput> echoes each command before
	      executing it. This is the equivalent of inserting <userinput>set -v</userinput> or 
	      <userinput>set -o verbose</userinput> in the script.</para>
	    
	    <para><userinput>sh -x scriptname</userinput> echoes the result each
	      command, but in an abbreviated manner. This is the equivalent of
	      inserting <userinput>set -x</userinput> or 
	      <userinput>set -o xtrace</userinput> in the script.</para>

	    <para>Inserting <userinput>set -u</userinput> or 
		<userinput>set -o nounset</userinput> in the script runs it, but
		gives an <errorname>unbound variable</errorname> error message
		at each attempt to use an undeclared variable.</para>
	  </listitem>
	  <listitem>
	    <para>trapping at exit</para>
	<para>The <command>exit</command> command in a script actually sends a
	      signal <errorcode>0</errorcode>, terminating 
	      the process, that is, the script itself. It is often useful to trap
	      the <command>exit</command>, forcing a <quote>printout</quote> of
	      variables, for example. The <command>trap</command> must be the
	      first command in the script.</para>
	  </listitem>
	</orderedlist>
      </para>
	<variablelist>
	  <varlistentry>
	    <term><command>trap</command></term>
	    <listitem>
	      <para>Specifies an action on receipt of a signal; also useful for debugging.
		<programlisting>trap 2 #ignore interrupts (no action specified) 
trap 'echo "Control-C disabled."' 2</programlisting>
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>

      <example id="ex76">
	<title>trapping at exit</title>
	<programlisting>&ex76;</programlisting>
      </example>
	
    </sect1> <!-- Debugging -->

    <sect1 id="options">
      <title>Options</title>
      <para>Options are settings that change shell and/or script behavior. 
	A script enables options by the <command>set</command> command.</para>

      <para>The following are some useful options. They may be set in either abbreviated
	form or by complete name.</para>

      <table>
	<title>bash options</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>Abbreviation</entry>
	      <entry>Name</entry>
	      <entry>Effect</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><option>-C</option></entry>
	      <entry>noclobber</entry>
	      <entry>Prevent overwriting of files by redirection (may be
		overridden by <token>>|</token>)</entry> 
	    </row>
	    <row>
	      <entry><option>-f</option></entry>
	      <entry>noglob</entry>
	      <entry>Filename expansion disabled</entry>
	    </row>
	    <row>
	      <entry><option>-p</option></entry>
	      <entry>privileged</entry>
	      <entry>Script runs as <quote>suid</quote></entry>
	    </row>
	    <row>
	      <entry><option>-u</option></entry>
	      <entry>nounset</entry>
	      <entry>Attempts to use undefined variables
		result in error message</entry>
	    </row>
	    <row>
	      <entry><option>-v</option></entry>
	      <entry>verbose</entry>
	      <entry>Print commands to stdout before executing</entry>
	    </row>
	    <row>
	      <entry><option>-x</option></entry>
	      <entry>xtrace</entry>
	      <entry>Similar to <option>-v</option>, but expands commands</entry>
	    </row>
	    <row>
	      <entry><option>-</option></entry>
	      <entry>(none)</entry>
	      <entry>End of options flag. All other args
		are positional parameters.</entry>
	    </row>
	    <row>
	      <entry><option>--</option></entry>
	      <entry>(none)</entry>
	      <entry>Unset positional parameters.
		If arguments given (<option>--arg1arg2</option>),
		positional parameters set to arguments.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect1> <!-- Options -->
  
    <sect1 id="gotchas">
      <title>Gotchas</title>
      <para>Assigning reserved words or characters to variable names.
	<programlisting>var1=case
# Causes problems.
var2=xyz((!*
# Causes even worse problems.</programlisting>
	</para>

      <para>Using a hyphen or other reserved characters in a variable name.
	<programlisting>var-1=23
# Use 'var_1' instead.</programlisting>
	</para>

      <para>Using white space inappropriately (in contrast to other programming
	languages <command>bash</command> can be finicky about white space).
	<programlisting>var1 = 23
# 'var1=23' is correct.
let c = $a - $b
# 'let c=$a-$b' or 'let "c = $a - $b"' are correct.
if [ $a -le 5]
# 'if [ $a -le 5 ]' is correct.</programlisting>
	</para>

      <para>Using uninitialized variables (that is, using variables before a value is
	assigned to them). An uninitialized variable has a value of
	<quote>null</quote>, <emphasis>not</emphasis> zero.</para>

      <para>Commands issued from a script may fail to execute because the script owner
	lacks execute permission for them. If a user cannot invoke a command from
	the command line, then putting it into a script will likewise fail. Try
	changing the attributes of the command in question, perhaps setting the
	suid bit (as root, of course).</para>

      <para>Using bash version 2 functionality (see below)
	in a script headed with <userinput>#!/bin/bash</userinput> may cause a
	bailout with error messages. Your system may still have an older version
	of bash as the default installation. Try changing the header of the
	script to <userinput>#!/bin/bash2</userinput>.</para>

      <para>Making scripts <quote>suid</quote> is generally a bad idea, as it
	may compromise system security. Administrative scripts should be run by
	root, not regular users.</para>
    </sect1> <!-- Gotchas -->

    <sect1 id="bash2">
      <title>Bash, version 2</title>
      <para>The current version of <command>bash</command>, the one you have
	running on your machine, is actually version 2. This update of the
	classic <command>bash</command> scripting language added array
	variables, string and parameter expansion, and indirect variable
	references, among other features.</para>

      <example id="ex77">
	<title>String expansion</title>
	<programlisting>&ex77;</programlisting>
      </example>

      <example id="ex78">
	<title>Indirect variable references</title>
	<programlisting>&ex78;</programlisting>
      </example>
	
      <example id="ex79">
	<title>Using arrays and other miscellaneous trickery
	  to deal four random hands from a deck of cards</title>
	<programlisting>&ex79;</programlisting>
      </example>

    </sect1> <!-- Bash, version 2 -->
  </chapter> <!-- Tutorial / Reference -->


  <chapter id="credits">
    <title>Credits</title>

      <para><ulink url="mailto:feloy@free.fr">Philippe Martin</ulink>
      translated this document into DocBook/SGML. While not on
      the job at a small French company as a software developer,
      he enjoys working on GNU/Linux documentation and software,
      reading literature, playing music, and for his peace of mind
      making merry with friends. You may run across him somewhere
      in France or in the Basque Country, or email him at <ulink
      url="mailto:feloy@free.fr">feloy@free.fr</ulink>.</para>

  </chapter> <!-- Credits --> 


  <bibliography id="biblio">
    <biblioentry>
      <authorgroup>
	<author><firstname>Dale</firstname><surname>Dougherty</surname></author>
	<author><firstname>Arnold</firstname><surname>Robbins</surname></author>
      </authorgroup>
      <title>Sed and Awk</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-156592-225-5</isbn>
      <abstract><para>
	  To unfold the full power of shell scripting, you need at least a passing
	  familiarity with <command>sed</command> and
	  <command>awk</command>. This is the standard tutorial. It 
	  includes an excellent introduction to <quote>regular expressions</quote>. Read this
	  book.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Aeleen</firstname><surname>Frisch</surname></author>
      </authorgroup>
      <title>Essential System Administration</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1995</year>
      </copyright>
      <isbn>1-56592-127-5</isbn>
      <abstract><para>This excellent sys admin manual has a decent introduction to shell
	  scripting for sys administrators and does a nice job of explaining the
	  startup and initialization scripts. The book is long overdue for a third
	  edition (are you listening, Tim O'Reilly?).</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Stephen</firstname><surname>Kochan</surname></author>
	<author><firstname>Patrick</firstname><surname>Woods</surname></author>
      </authorgroup>
      <title>Unix Shell Programming</title>
      <publisher>
	<publishername>Hayden</publishername>
      </publisher>
      <copyright>
	<year>1990</year>
      </copyright>
      <isbn>067248448X</isbn>
      <abstract><para>The standard reference, though a bit dated by now.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Cameron</firstname><surname>Newham</surname></author>
	<author><firstname>Bill</firstname><surname>Rosenblatt</surname></author>
      </authorgroup>
      <title>Learning the Bash Shell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1998</year>
      </copyright>
      <isbn>1-56592-347-2</isbn>
      <abstract><para>This is a valiant effort at a decent shell primer, but somewhat deficient
	  in coverage on programming topics and lacking sufficient examples.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Jerry</firstname><surname>Peek</surname></author>
	<author><firstname>Tim</firstname><surname>O'Reilly</surname></author>
	<author><firstname>Mike</firstname><surname>Loukides</surname></author>
      </authorgroup>
      <title>Unix Power Tools</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <publisher>
	<publishername>Random House</publishername>
      </publisher>
      <copyright>
	<year>1997</year>
      </copyright>
      <isbn>1-56592-260-3</isbn>
      <abstract><para>Contains a couple of sections of very informative in-depth articles on
	  shell programming, but falls short of being a tutorial. It also reproduces
	  much of the regular expressions tutorial from the Dougherty and Robbins
	  book, above.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <authorgroup>
	<author><firstname>Ellen</firstname><surname>Siever</surname></author>
	<!-- fixme: and the Staff -->
      </authorgroup>
      <title>Linux in a Nutshell</title>
      <edition>2nd edition</edition>
      <publisher>
	<publishername>O'Reilly and Associates</publishername>
      </publisher>
      <copyright>
	<year>1999</year>
      </copyright>
      <isbn>1-56592-585-8</isbn>
      <abstract><para>The all-around best Linux command reference, even has a bash section.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The O'Reilly books on Perl. (Actually, any O'Reilly books.)</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The man pages for <command>bash</command> and
	  <command>bash2</command>, <command>date</command>,
	  <command>expect</command>, <command>expr</command>,
	  <command>find</command>, <command>grep</command>,
	  <command>gzip</command>,
	  <command>patch</command>, <command>tar</command>, <command>tr</command>,
	  <command>xargs</command>.  The texinfo documentation on
	  <command>bash</command>, <command>dd</command>, <command>gawk</command>,
	  and <command>sed</command>.</para>
      </abstract>
    </biblioentry>

    <biblioentry>
      <abstract>
	<para>The excellent "Bash Reference Manual", by Chet Ramey and Brian Fox,
	  distributed as part of the "bash-2-doc" package (available as an rpm).</para>
      </abstract>
    </biblioentry>

  </bibliography>

  <appendix id="copyright">
    <title>Copyright</title>
    <para>The "Advanced Bash-Scripting HOWTO" is copyright,
      (c) 2000, by Mendel Cooper. This document may only be
      distributed subject to the terms and conditions set forth in
      the <ulink url="http://www.linuxdoc.org/manifesto.html">LDP
      License</ulink>.</para>
    <para>If this document is incorporated into a printed book, the author
      requests a courtesy copy (this is a request, not a requirement).</para>
  </appendix>

<!-- Uncomment line below to generate index. -->
<!--
&indice;
-->

</book>
<!--
</article>
-->
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-indent-step:2
sgml-indent-data:t
End:
-->

