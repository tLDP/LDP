<!doctype linuxdoc system>

<!-- 
************************** begin comment *****************************
     The following is the HOW-TO for CVS/RCS source code revision system.
	 This document is in the SGML format. You must use sgml package to 
	 process this document
************************* end of comment *****************************
 -->
<!-- 
************************** SGML USER GUIDE *****************************
	The SGML user guide on linux is located at /usr/doc/sgml-tools
	Read the example.sgml and guide.html documents.
	Usage:
		HTML	  	sgml2html foo  (Do not give extension .sgml here!!)
		Text	 	sgml2txt foo.sgml
		Latex	  	sgml2latex foo.sgml

		Note: Use 2 dashes - before language, error while compiling
		Postscript 	sgml2latex -language=english -o ps foo.sgml
		DVI  		sgml2latex -d foo.sgml
		Lyx		sgml2lyx foo.sgml
		Richtext 	sgml2rtf foo.sgml
		gnuinfo  	sgml2info foo.sgml
		man		sgml2txt -man foo.sgml
		SGML	 	sgmlcheck foo.sgml
************************* end of comment *****************************
-->

<article>

<!-- Title information -->

<title>CVS-RCS- HOW-TO document for Linux (Source Code Control System)
<!-- chapt change
CVS-RCS HOW-TO
Concurrent Version Control System and
Revision Control System
(Source Code Management Tools)



-->
<author>Al Dev (Alavoor Vasudevan) 
       <htmlurl url="mailto:alavoor@yahoo.com"
             name="alavoor@yahoo.com">
<date>v19.0, 22 Jan 2001
<abstract>
This document is a "practical guide" to very quickly setup CVS/RCS source code
control system. This document has custom shell scripts which are wrappers 
on top of CVS. These scripts provide an easy user interface for CVS. 
Several shell scripts are provided to make RCS more easy to use.
The information in this document applies to Linux and as well as to all other 
flavors of Unix liks Solaris, HPUX, AIX, SCO, Sinix, BSD, SCO, etc.. and BeOS.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Introduction
-->
<sect>Introduction
<p>
Source code control system is a MUST to manage 
the changes occuring to software project during development. Developers need a complete history of changes
to backtrack to previous versions in case of any problems.
Since source code is the most vital component of any software project and  
software development takes a huge amount of time and money, it is very important to spend some 
time in <it><bf>safe-guarding</bf></it> the source code by using source code control systems like CVS and RCS.
<p>
CVS (Concurrent Version Control System) is a powerful tool which allows 
concurrent development of software by multiple users. It uses RCS 
underneath and has application layer interface as a wrapper on top RCS.

CVS can record the history of your files (usually,
but not always, source code). CVS only stores the differences
between versions, instead of every version of every file
you've ever created. CVS also keeps a log of who, when and
why changes occurred, among other aspects.

CVS is very helpful for managing releases and controlling
the concurrent editing of source files among multiple
authors. Instead of providing version control for a
collection of files in a single directory, CVS provides
version control for a hierarchical collection of
directories consisting of revision controlled files.

These directories and files can then be combined together
to form a software release.

CVS can be used for storing "C", "C++", Java, Perl, HTML and
other files.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Which one is for me? CVS or RCS
-->
<sect> Which one is for me? CVS or RCS
<p>
CVS actually uses RCS underneath. CVS is a lot more powerful tool and
can control a complete source code tree. 
It is <it><bf>very strongly</bf></it> recommended that you use CVS, because you can greatly customize CVS with scripting languages like PERL, korn and bash shells. 
See the sample korn shell scripts at <ref id="Shell Scripts">.

Advantages of CVS
<itemize>
<item> CVS is de-centralised an user checks out files/directories 
from the repostitory
and has his own separate stable source directory tree.
<item> CVS can "STAMP" releases of entire project source tree.
<item> CVS can enable concurrent editing of files.
<item> CVS can be greatly customized to enable strong locking of files or
enable concurrent editing of files using shell scripts or PERL.
</itemize>

Disadvantages of CVS
<itemize>
<item> Needs a little more administration than RCS
<item> Very highly sophisticated and complex system. It is the "State of the Art" technology. The cvs software is very advanced and capable system developed
over very long period of time (it took several years!!).
<item> Has a large number of commands and command options, hence a steeper 
learning curve for beginners. The shell scripts at <ref id="Shell Scripts"> can ease usage.
</itemize>

Advantages of RCS
<itemize>
<item> RCS is very simple to setup, with less administrative work.
<item> RCS is used in a centralized area where everyone works. 
<item> RCS is useful for simple systems.
<item> Very strong locking of files - concurrency eliminated.
</itemize>

Downside of RCS
<itemize>
<item> Concurrent development by multiple developers is not possible due to file locking and being limited to a single working directory. Because of the single working directory limitation changes to files by multiple developers can cause failure of the 'make' command.
<item> Cannot stamp releases of an entire software project.
</itemize>

This document also has 
shell scripts which provide
simple commands to check-out, check-in, commit files.
See shell scripts at <ref id="Shell Scripts">

For RCS see the RCS mini-howto on the linux cdrom -
<CODE>
cd /mnt/cdrom/Redhat/RPMS
ls -l howto-6.0-*.noarch.rpm
rpm -qpl howto-6* | grep -i rcs 
</CODE>
or visit <url url="http://www.LinuxDoc.org/HOWTO/mini/RCS.html">

See also the RCS shell scripts at 
<ref id="rcs_scripts">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Setting up CVS <label id="Setting up CVS">
-->
<sect> Setting up CVS <label id="Setting up CVS">
<p>
First you need to install the CVS package, on Redhat linux use
<CODE>
cd /mnt/cdrom/Redhat/RPMS
rpm -i rcs*.rpm
rpm -i cvs*.rpm
To see the list of files installed do -
rpm -qpl cvs*.rpm | less
</CODE>
and browse output using j,k, CTRL+f, CTRL+D, CTRL+B, CTRL+U or using arrow keys, page up/down keys.
See 'man less'.

On other flavors of unix, you may need to download the RCS and CVS tar balls
and follow README, INSTALL files to setup CVS.
Visit <url url="http://www.cyclic.com">
and <url url="http://www.loria.fr/~molli/cvs-index.html">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Environment variables <label id="CVS-Env">
<p>
The following environment variables need to be setup in /etc/profile - default values required for all users.
If not set in /etc/profile, than you should add these to your local profile file ~/.bash_profile.
<CODE>
export EDITOR=/bin/vi
export CVSROOT=/home/cvsroot
export CVSREAD=yes
</CODE>

Create a directory to store the source code repository 
and give read, write access to unix group/user.
Also make sure that the directory name of CVSROOT does not contain
any blank spaces. For example CVSROOT should not be like '/home/my rootcvs'.
<CODE>
export CVSROOT=/home/cvsroot
mkdir $CVSROOT
chmod o-rwx $CVSROOT
chmod ug+rwx $CVSROOT
</CODE>
Now, change the group of $CVSROOT to group-name of users who want to use cvs sytem.
<CODE>
chgrp users $CVSROOT
</CODE>
To initialize the CVS and to put in source code files do -
<CODE>
cvs init

# Change directory is a must
cd $HOME/my_source_code_dir

# Must give vendor tag and revision tag
cvs import my_source_code_dir V1_0 R1_0  

</CODE>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Migrate RCS to CVS <label id="RCS2CVS">
<p>
To migrate the existing RCS files to CVS, use the following script. Make sure
that you installed korn shell package pdksh*.rpm from Linux contrib cdrom.

<bf>NOTE : <it>Korn shell /bin/ksh is obtained by installing pdksh*.rpm from Linux contrib cdrom</it></bf>
<CODE>
#!/bin/ksh

#############################################################
# Program to Migrate the existing source code in RCS to CVS 
#
# Needs the korn shell RPM package  pdksh*.rpm from Linux 
# contrib cdrom
#############################################################

#
# rcs2cvs - convert source tree from RCS to CVS
#

# project to convert
PROJECT='project'

# current RCS root
RCSROOT="$HOME/rcs"

if cd "$RCSROOT/$PROJECT"
then
	cd "$RCSROOT"
else
	echo >&2 "`basename "$0"`: can't change to RCS directory '$RCSROOT/$PROJECT'."
	exit 1
fi

# current CVS root
CVSROOT="$HOME/cvs"

# create new CVS directory for project 'project'
if mkdir "$CVSROOT/$PROJECT"
then
	:
else
	echo >&2 "`basename "$0"`: can't create CVS directory '$CVSROOT/$PROJECT'."
	exit 2
fi

# create CVS project tree from RCS tree
find "$PROJECT" -type d -name RCS -print |
while read RCS
do
	CVS="`dirname "$RCS"`"
	(if cd "$RCS"
	then
#		if find . -type f -name '*,v' -print | cpio -pdmv "$CVSROOT/$CVS"
		if find . -type f -print | cpio -pdmv "$CVSROOT/$CVS"
		then
			:
		else
			echo >&2 "`basename "$0"`: can't convert RCS subdirectory '$RCSROOT/$RCS' to CVS subdirectory '$CVSROOT/$CVS'."
		fi
	else
		echo >&2 "`basename "$0"`: can't change to RCS subdirectory '$RCSROOT/$RCS'."
	fi)
done
</CODE>
Now the RCS is migrated to CVS as 'project'. You can start using the
CVS commands on module 'project'.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Intro to CVS commands <label id="Intro_CVS">
-->
<sect> Intro to CVS commands <label id="Intro_CVS">
<p>
cvs provides a rich variety of  commands  (cvs_command  in
the  Synopsis),  each  of  which  often  has  a  wealth of
options, to satisfy the many needs of source management in
distributed environments.  However, you don't have to master
every detail to do useful work with cvs; in fact, five
commands  are  sufficient  to  use (and contribute to) the
source repository.
The most commonly used CVS commands are 
<bf>checkout</bf>,
<bf>update</bf>,
<bf>add</bf>,
<bf>remove</bf>,
<bf>commit</bf> and
<bf>diff</bf>.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> checkout<label id="checkout">
<p>
<bf>cvs checkout modules...</bf>
A necessary preliminary for most cvs work:  creates
your  private copy of the source for modules (named
collections of source; you can also use a path relative
to the source repository here).  You can work
with this copy  without  interfering  with  others'
work.   At  least  one subdirectory level is always
created.
<code>
bash$ cvs --help checkout
Usage:
  cvs checkout [-ANPRcflnps] [-r rev | -D date] [-d dir]
    [-j rev1] [-j rev2] [-k kopt] modules...
        -A      Reset any sticky tags/date/kopts.
        -N      Don't shorten module paths if -d specified.
        -P      Prune empty directories.
        -R      Process directories recursively.
        -c      "cat" the module database.
        -f      Force a head revision match if tag/date not found.
        -l      Local directory only, not recursive
        -n      Do not run module program (if any).
        -p      Check out files to standard output (avoids stickiness).
        -s      Like -c, but include module status.
        -r rev  Check out revision or tag. (implies -P) (is sticky)
        -D date Check out revisions as of date. (implies -P) (is sticky)
        -d dir  Check out into dir instead of module name.
        -k kopt Use RCS kopt -k option on checkout.
        -j rev  Merge in changes made between current revision and rev.
(Specify the --help global option for a list of other help options) 
</code>
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>update<label id="update">
<p>
<bf>cvs update</bf>
Execute  this  command  from  within  your  private
source  directory  when  you  wish  to  update your
copies of source  files  from  changes  that  other
developers  have  made to the source in the repository.
<code>
bash$ cvs --help update
Usage: cvs update [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]
    [-I ign] [-W spec] [files...]
        -A      Reset any sticky tags/date/kopts.
        -P      Prune empty directories.
        -d      Build directories, like checkout does.
        -f      Force a head revision match if tag/date not found.
        -l      Local directory only, no recursion.
        -R      Process directories recursively.
        -p      Send updates to standard output (avoids stickiness).
        -k kopt Use RCS kopt -k option on checkout.
        -r rev  Update using specified revision/tag (is sticky).
        -D date Set date to update from (is sticky).
        -j rev  Merge in changes made between current revision and rev.
        -I ign  More files to ignore (! to reset).
        -W spec Wrappers specification line.
(Specify the --help global option for a list of other help options) 
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>add<label id="add">
<p>
<bf>cvs add file...</bf>
Use this command to enroll new files in cvs records
of your working directory.  The files will be added
to the  repository  the  next  time  you  run  `cvs
commit'.   Note:  You  should  use the `cvs import'
command to bootstrap new sources  into  the  source
repository.   `cvs  add' is only used for new files
to an already checked-out module.
<code>
bash$ cvs --help add
Usage: cvs add [-k rcs-kflag] [-m message] files...
        -k      Use "rcs-kflag" to add the file with the specified kflag.
        -m      Use "message" for the creation log.
(Specify the --help global option for a list of other help options)  
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>remove<label id="remove">
<p>
<bf>cvs remove file...</bf>
Use this command (after erasing any  files  listed)
to  declare  that  you wish to eliminate files from
the repository.  The removal does not affect others
until you run `cvs commit'.
<code>
bash$ cvs --help remove
Usage: cvs remove [-flR] [files...]
        -f      Delete the file before removing it.
        -l      Process this directory only (not recursive).
        -R      Process directories recursively.
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>commit<label id="commit">
<p>
<bf>cvs commit file...</bf>
Use  this command when you wish to ``publish'' your
changes to other developers, by incorporating  them
in the source repository.
<code>
bash$ cvs --help commit
Usage: cvs commit [-nRlf] [-m msg | -F logfile] [-r rev] files...
        -n      Do not run the module program (if any).
        -R      Process directories recursively.
        -l      Local directory only (not recursive).
        -f      Force the file to be committed; disables recursion.
        -F file Read the log message from file.
        -m msg  Log message.
        -r rev  Commit to this branch or trunk revision.
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>diff<label id="diff">
<p>
<bf>cvs diff file...</bf>
Show differences between files in working directory
and  source repository, or between two revisions in
source repository.  (Does not change either reposi­
tory or working directory.)
<code>
bash$ cvs --help diff
Usage: cvs diff [-lNR] [rcsdiff-options]
    [[-r rev1 | -D date1] [-r rev2 | -D date2]] [files...]
        -l      Local directory only, not recursive
        -R      Process directories recursively.
        -D d1   Diff revision for date against working file.
        -D d2   Diff rev1/date1 against date2.
        -N      include diffs for added and removed files.
        -r rev1 Diff revision for rev1 against working file.
        -r rev2 Diff rev1/date1 against rev2.
        --ifdef=arg     Output diffs in ifdef format.
(consult the documentation for your diff program for rcsdiff-options.
The most popular is -c for context diffs but there are many more).
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Emacs Editor <label id="Emacs">
<p>
Emacs is a powerful editor and it supports CVS/RCS - especially 
for revision merging and comparing. Emacs main site 
is at <url url="http://www.emacs.org">.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Shell Scripts <label id="Shell Scripts">
-->
<sect> Shell Scripts <label id="Shell Scripts">
<p>
The following are wrappers around the basic CVS commands. These scripts
give you initial <bf>booster-push</bf> into the CVS system and are useful 
untill you become very familiar with the CVS commands. The scripts 
are written for Korn shell since korn shell is always available 
on all flavors of unixes, but you can translate to bash or 
PERL if needed. You can customize
these scrips to your taste. They are basically CVS commands but features are
added to make it site specific. For example, sedit script provides locking
so that users will know some-one is editing the file. Of course users can 
directly use the CVS commands to by-pass these scripts. These scripts 
demonstrate how CVS can be <bf>customized</bf> to a great extent.

<bf>NOTE: </bf> <it>The wrapper shell scripts assume that the user's 
home directory as the root and check out the tree from cvs to build the 
tree underneath user's home directory.
</it>

<bf> TIP: </bf> <it>In shell scripts, every target filename is composed 
of 3 parts - Home directory, sub-directory 
and the filename. The full-path is $HOME/$subdir/$fname
And in CVS the same directory structure is maintained (by 
variable $subdir) therefore in cvs there will be something 
like  $CVSROOT/$subdir/$fname.
In all scripts, these 4 variables $HOME, $CVSROOT, $subdir and $fname
play an important role. For example, sample values can be like
HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
and fname=foo.cpp
</it>

Copy these scripts to /usr/local/bin and this should be in the user's PATH environment.
<enum>
<item> <bf>sget</bf> &lsqb;-r revision_number&rsqb; &lt;file/directory name&gt;
	To get a file or entire directory from CVS in READ ONLY mode.
	Click <ref id="sget">

<item> <bf>sedit</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To edit a file in order to make changes to code. This will lock the
	file so that nobody else can checkout. Ofcourse you can change the script to your requirement - make no locking, warning message or very strong locking.
	Click <ref id="sedit">

<item> <bf>scommit</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To commit the changes you made to filename or entire 
	directory. Upload your changes to CVS
	Click <ref id="scommit">

<item> <bf>supdate</bf>	&lt;filename/directory&gt; 
	To update a filename or to update an entire directory by 
	getting the latest files from CVS
	Click <ref id="supdate">

<item> <bf>sunlock</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To unlock the file got by sedit. Will release the lock.
	Click <ref id="sunlock">

<item> <bf>slist</bf>	
	To see the list of files currently being edited by you. 
	Does 'ls -l | grep | ...' command.
	Click <ref id="slist">. 
	Note that there is also another unix
	command by name slist (list available Netware servers), you
	should make sure cvs script slist comes before other in your
	PATH environment.

<item> <bf>sinfo</bf> &lt;filename/directory&gt; 
	To get the information of changes/revisions to a file 
	Click <ref id="sinfo">

<item> <bf>slog</bf> &lt;filename&gt; 
	To get the history of changes/revisions to a file from CVS
	Click <ref id="slog">

<item> <bf>sdif</bf> &lt;filename&gt;
<p><bf>sdif</bf> -r rev1 -r rev2 &lt;filename&gt; 
	To get the diff of your file with CVS.
	Click <ref id="sdif">

	NOTE: sdif has only one 'f' because there is already another 
		unix command called 'sdiff'

<item> <bf>sadd</bf> &lt;filename&gt;   
	To add a new file to CVS repository
	Click <ref id="sadd">

<item> <bf>sdelete</bf>	&lt;filename&gt; 
	To delete a file from CVS repository
	Click <ref id="sdelete">

<item> <bf>sfreeze</bf>	&lt;revision name&gt; &lt;directory name&gt;
	To freeze the code, that is make release of entire source tree.
	Click <ref id="sfreeze">
<p>
	For example : 
<code>
	cd $HOME;   
	sfreeze REVISION_1_0  srctree  
</code>
 	   This will freeze code with tag REVISION_1_0  so that you can later 
	   checkout the entire tree by using with revision name
</enum>

<tscreen><verb>
		******************************************************

</verb></tscreen>
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> CVS Documentation <label id="CVS Documentation">
-->
<sect> CVS Documentation <label id="CVS Documentation">
<p>
At unix prompt type -
<enum>
<item> cvs --help
<item> cvs --help-options
<item> cvs --help-commands
<item> cvs -H checkout
<item> cvs -H commit
<item> man cvs
<item> man tkcvs
<item> Visit <url url="http://www.cyclic.com">
<item> Visit <url url="http://www.loria.fr/~molli/cvs-index.html">
</enum>

The tkcvs 
	<url url="http://www.tkcvs.org">
is the Tcl/Tk GUI interface to CVS. It also has online help.
<itemize>
<item> cd $HOME/src/foo.cpp
<item> tkcvs
<item> Click on foo.cpp
<item> Click on 'Revision Log Icon' which is located next to 'spectacle' icon
<item> This will display the branch TREE in the window. Now RIGHT Mouse button click on the text '1.3' and LEFT Mouse button click on text '1.1'. Than click on "Diff" button. This will display 2 pane-window!!  
<item> Click on "Next" button to step thru more diffs. 
Click on "Center" to center the text.
</itemize>

There is also a Windows 95 client for CVS, and is called WinCVS 
	<url url="http://www.wincvs.org">
and <url name="cyclicsite" url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">
WinCVS can be used along with Samba(on cdrom samba*.rpm) - <url url="http://www.samba.org">

The essential command are -
<itemize>
<item> cvs checkout &lt;filename &gt;
<item> cvs update &lt;filename&gt;
<item> cvs add &lt;file, ..&gt;
<item> cvs remove &lt;file, ..&gt;
<item> cvs commit &lt;file&gt;
<item> cvs status &lt;filename&gt;
<item> cvs log &lt;filename&gt;
<item> cvs diff -r1.4 -r1.5 &lt;filename&gt;  
This gives diff between version 1.4 and 1.5 on filename.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Online documentation <label id="onlinedocs">
<p>
On linux systems, you can find the CVS documentation in postscript format at
<bf>/usr/doc/cvs*/*.ps</bf>. Also there is FAQ and other useful information.
<code>
bash# cd /usr/doc/cvs*
bash# gv cvs.ps
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> CVS Org documentation <label id="cederquist">
<p>
The documentation on CVS from "CVS Organisation" is at
<url url="http://www.cvshome.org/docs">

Official manual for CVS by Cederqvist 
is at <url url="http://www.cvshome.org/docs/manual/cvs.html">

FAQ for CVS is at <url url="http://www.cs.utah.edu/dept/old/texinfo/cvs/FAQ.txt">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> CVS Training <label id="training">
<p>
<itemize>
<item> <url url="http://rpmfind.net/tools/CVS/training/cvstrain.html">
<item> <url url="http://www.loria.fr/~molli/cvs/cvs-tut/cvs_tutorial_toc.html">
<item> <url url="http://atlas.web.cern.ch/Atlas/GROUPS/SOFTWARE/OO/tools/srt/">
<item> <url url="http://durak.org/cvswebsites/">
<item> <url url="http://www-users.informatik.rwth-aachen.de/~wge/tools/cvs/cvsclient/cvsclient_toc.html">
<item> <url url="http://www-users.informatik.rwth-aachen.de/~wge/tools/cvs.html">
<p>
General utilities for cvs (third party)
<item> <url url="http://www.zevils.com/doc/cvsbook/cvsbook_8.html">
<item> <url url="http://www.zevils.com/doc/cvsbook/cvsbook_toc.html#SEC_Contents">
<item> <url url="http://rcs.ee.washington.edu/spp/Projects/Manastash/Links/cvsbook_toc.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Graphical Front ends <label id="frontend">
-->
<sect> Graphical Front ends <label id="frontend">
<p>
The following GUI front ends for CVS are available.
But it is <bf>very strongly recommended</bf> that you use 
<url name="Samba(on cdrom samba*.rpm)" url="http://www.samba.org">
and 
<ref id="win95" name="PC X-Server"> 
on MS Windows 95/NT. By using Samba the remote directory on unix
will look like local folder on MS Windows. See next section for 
<ref id="win95" name="PC X-Server">.
<itemize>
<item> CVS Web for windows <url url="http://www.devguy.com/fp/cfgmgmt/cvs/cvs_admin_nt.htm#CVSWEBIIS"> and at <url url="http://stud.fh-heilbronn.de/~zeller/cgi/cvsweb.cgi">
<item> TkCVS <url url="http://www.tkcvs.org"> is the Tcl/Tk GUI interface to CVS.
And at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/tkcvs/index.html">
<item> gCVS: A portable GUI for non-technical CVS user <url url="http://www.arachne.org/software/gcvs">
<item> jCVS is a CVS client package written entirely in Java <url url="http://www.jcvs.org">
And at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/jcvs/index.html">
<item> WinCVS <url url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">
and at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">
<item> Component soft Win CVS <url url="http://www.componentsoftware.com/cvs">
<item> JA-SIG UPortal CVS <url url="http://www.mis3.udel.edu/~jlaker/development">
<item> <url url="http://ppprs1.phy.tu-dresden.de/~trogisch/lincvs/lincvsen.html">
<item> <url url="http://www.loria.fr/~molli/cvs/doc/cvs_toc.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> CVS from Windows 95/NT/2000 <label id="win95">
<p>
It is <bf>very strongly recommended</bf> that you use 
<url name="Samba(on cdrom samba*.rpm)" url="http://www.samba.org">
and PC X-Server on MS Windows 95/NT. By using Samba the remote directory on unix
will look like local folder on MS Windows. 
Install samba*.rpm on unix/linux server(which has CVS repository) and install the PC X-server on 
MS Windows 95/NT/2000 desktop. Using PC X-server you can easily log on to the
unix box and check-out/check-in the files. And you can use the tools like
Java Visual Cafe or Java JBuilder on MS Windows to edit the files located in unix/linux
folder(via samba). With samba the unix/linux CVS server will be like a <bf>file server</bf>.
After editing, you can check-in the files to unix thru PC X-server.

The following PC X-servers are available
<itemize>
<item> Low cost, best and small size (3 MB) <url url="http://www.microimages.com"> and
        click on "X-Server (MI/X) for Windows"
<item> Humming bird eXceed 14 MB <url url="http://www.hummingbird.com">
<item> Starnet 5.2 MB<url url="http://www.starnet.com">
<p> 
There are more than 2 dozen vendors for X-Server for Windows:
<item> X-win pro 6.34 MB <url url="http://www.labf.com">
<item> X-WinPro <url url="http://lab-pro.com">
<item> X-Link <url url="http://www.xlink.com/x.htm">
<item> Xoftware <url url="http://www.age.com">
<p>
University resources:
<item> University listings <url url="http://www.et.byu.edu/support/pc/xterm.html">
<item> Floppy based PC "X server" <url url="http://mirriwinni.cse.rmit.edu.au/~brad/co338/sem1/floppy.html">

<p> Alternatives to X-servers:
<item>VNC (Virtual Network Computing) at <url url="http://www.uk.research.att.com/vnc">
VNC is not a X-server but can display the remote unix on Windows.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Windows 95/NT/2000 FTP Tools<label id="ftptools">
<p>
You can also use the ftp tools on MS Windows to transfer files from Unix/linux(CVS repository)
to windows:
<itemize>
<item> Goto Tucows and search "ftp tools" for MS Windows <url url="http://www.tucows.com">
</itemize>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Multi-User CVS Remote Repository <label id="multiuser">
-->
<sect> Multi-User CVS Remote Repository <label id="multiuser">
<p>
The Cederqvist manual at 
<url url="http://cvshome.org/docs/manual/cvs_2.html#SEC30"> 
describes how to setup CVS for external access.

In order to use CVS for a group, one has to set up a permissions 
system to allow people to access the system from other machines. 
There are three ways to do this (:server:, :pserver:, and :ext:). 
The pserver mechanism and use of rsh are 
both insecure.  Only the :ext: (with ssh) offers sufficient security 
protection.

If you set CVS_RSH to SSH or some other rsh replacement, 
the instructions <bf>may be</bf> similar to `.rhosts' but 
consult the documentation for your rsh replacement.

To get ssh visit
<url url="http://rpmfind.net"> and in search box enter "ssh".
Or visit <url url="http://www.redhat.com/apps/download"> and in search box enter "ssh".
Download and install ssh RPM and then configure CVS to use it.  
See also <url url="http://www.ssh.org">

Note: If you plan to configure CVS for use with rsh then 
you MUST do this critical step:
<code>
bash# chmod 6000 .rhosts
</code>

See also JA-SIG UPortal CVS repository <url url="http://www.mis3.udel.edu/~jlaker/development">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> RCS Shell scripts <label id="rcs_scripts">
-->
<sect> RCS Shell scripts <label id="rcs_scripts">
<p>
If you want to use RCS instead of CVS then you can use the following
shell scripts.
<sect1> cotree.sh <label id="cotree.sh">
<p>
<code>
#!/bin/ksh

# cotree.sh (Check Out Tree shell script)
# cotree.sh - Check out the entire RCS directory

# Usage :
# This will get the all the directories
#	unix> cotree.sh 
#
# This will get just one single directory tree
#	unix> cotree.sh <directory name>

# See also cofiles.sh

###############################################################
# Setting up RCS (Revision Control System)
# Install the RCS programs - which gives command co, ci, rcslog
# Create a rcs home directory where you want to put all the
# source code repository. Call this $RCSDIR=/home/rcs_version_control
# Setup up an environment variable RCSDIR=/home/rcs_version_control
# in $HOME/.profile file. Like -
#		export RCSDIR=/home/rcs_version_control
# Create a directory structure under $RCSDIR and check in all your
# files using ci . See 'man ci'
# Now create a link from your home directory to your project
# under $RCSDIR
# 		cd $HOME
#		mkdir $HOME/myproject
#		cd $HOME/myproject
# and run this script to get all the files and directory tree
#		cotree.sh
# This script will create the entire source-tree under user's
# home and also will have a soft link to RCS directories. Each 
# user will run this script under his home directory.
###############################################################

check_out_directory()
{
	# Root directory of RCS (revision control system)
	# like RCSDIR=/home/rcs_version_control
	RCSDIR=$1
	DIRNAME=$2

	# The given directory name must exist in rcs root directory
	if [ "$DIRNAME" = "" -o  ! -d $RCSDIR/$DIRNAME ]; then
		print "\nDirectory DIRNAME=$DIRNAME does not exist!!"
		print "\nAborting the program ... and exiting...\n"
		exit
	fi
	
	mkdir -p $DIRNAME
	ln -s $RCSDIR/$DIRNAME/RCS $DIRNAME
	(
		cd $DIRNAME

		# This fails in case of filename=sample,vv 
		# which inside RCS will be RCS/sample,vv,v
		# ls RCS | cut -d',' -f1 | xargs co
		# Use match to end of name $, as below -
		# Use ls RCS/* to avoid getting the names ./ and ../
		#ls RCS/* | cut -d'/' -f2 | sed -e's/,v$//g' | xargs co
		if [ -d RCS ]; then
			ls RCS/* | cut -d'/' -f2 | sed -e's/,v$//g' | \
			while read ii
			do
				#echo "ii is : $ii"
				if [ -f "RCS/$ii,v" ]; then
					co $ii
				fi
			done
		fi
	)
}

# Root directory of RCS (revision control system)
# like RCSDIR=/home/rcs_version_control
if [ "$RCSDIR" = "" -o ! -d $RCSDIR ]; then
	print "\nDirectory RCSDIR=$RCSDIR does not exist!!"
	print "\nAborting the program ... and exiting...\n"
	exit
fi
#echo "rcsdir is : $RCSDIR"

# If a directory argument is passed, then check out all
# files for this directory only and exit.
if [ "$1" != "" ]; then
	(cd $RCSDIR; find $1 -type d -print ) | 
	while read DIRNAME
	do
		#echo DIRNAME=$DIRNAME
		#DIRNAME=c_src
		# Send rcs root directory and dir name relative to rcs root dir
		tmpaa=` basename $DIRNAME `
		if [ "$tmpaa" != "RCS" ]; then
			check_out_directory $RCSDIR $DIRNAME
		fi
	done
else
	(cd $RCSDIR; find * -type d -print ) | 
	while read DIRNAME
	do
		echo DIRNAME=$DIRNAME
		#DIRNAME=c_src
		# Send rcs root directory and dir name relative to rcs root dir
		tmpaa=` basename $DIRNAME `
		if [ "$tmpaa" != "RCS" ]; then
			check_out_directory $RCSDIR $DIRNAME
		fi
	done
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> cofiles.sh <label id="cofiles.sh">
<p>
<code>
#!/bin/ksh

# cofiles.sh (Check Out files shell script)
# cofiles.sh - Check out all the files in current directory from RCS
# See also cotree.sh and 'man rcsclean'

if [ ! -d RCS ]; then
	print "\nDirectory RCS does not exist!!"
	print "\nAborting the program ... and exiting...\n"
	exit
fi

#echo "No. of args = " $# " and all args " $@

while true
do
	print -n "\n\nCheck-out all files in read-write mode? <y/n> [n]: "
	read ans
	if [ "$ans" = "" -o "$ans" = "n" -o "$ans" = "N" ]; then
		ans="N"
		break
	elif [ "$ans" = "y" -o "$ans" = "Y" ]; then
		ans="Y"
		break
	else
		print "\nWrong entry! Try again!!"
	fi
done
#echo "The ans is : " $ans

if [ $# -eq 0 ]; then
	# The 'ls RCS' fails in case of filename=sample,vv in RCS/sample,vv,v
	# ls RCS | cut -d',' -f1 | xargs co
	# Use match to end of name $, as below -
	if [ "$ans" = "Y" ]; then
		ls RCS | sed -e's/,v$//g' | xargs co -l 
	else
		ls RCS | sed -e's/,v$//g' | xargs co
	fi
elif [ $# -eq 1 ]; then
	if [ -f "RCS/$1,v" ]; then
		# Here, in this case $1 will be like dbalter.sql
		# and not like db*.sql....
		#echo "One arg, no. of args = " $# " and all args " $@
		if [ "$ans" = "Y" ]; then
			co -l "$1"
		else
			co "$1"
		fi
	else
		# For case where $1=db*.sql and there is no db*.sql in
		# current directory
		#echo "No files... no. of args = " $# " and all args " $@
		tmpaa="RCS/$1,v"  # will be like RCS/db*.sql,v
		ls $tmpaa | \
		while read ii
		do
			#echo "ii is : $ii"
			if [ "$ans" = "Y" ]; then
				co -l "$ii"
			else
				co "$ii"
			fi
		done
	fi
else
	for ii in $@
	do
		#echo "ii is : $ii,v"
		if [ "$ans" = "Y" ]; then
			co -l "$ii"
		else
			co "$ii"
		fi
	done
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> ciall.sh <label id="ciall.sh">
<p>
<code>
#!/bin/ksh

# ciall.sh (Check in files shell script)
# ciall.sh - Check in all the files in current directory into RCS
# This script is very useful for checking in enmass large number
# of new files into RCS. Saves time by avoiding to type the
# 'description' for every file
# And for files already in RCS, it does regular check-in command


# To convert filenames to lower case filenames, use this
# technique - use 'tr', see 'man tr'
#ls * | \
#while read ii
#do
#	jj=`echo $ii | tr [A-Z] [a-z] `
#	echo "ii is : $ii"
#	echo "jj is : $jj"
#	mv $ii $jj
#done

if [ ! -d RCS ]; then
	print "\nDirectory RCS does not exist!!"
	print "\nWill be creating RCS directory now ...\n"
	mkdir RCS
fi

print "\n\nNOTE: This is not log message!"
print "Please enter description (will be used for"
print -n "all the files checked in) : "
read description

#find * -prune -type f | 

# The number of args is zero or more.... 
if  [ $# -eq 0 ]; then
	listoffiles="*"
else
	listoffiles="$@"
fi

find $listoffiles -prune -type f | 
while read ii
do
	#echo $ii
	if [ -f "RCS/$ii,v" ]; then
		#print "The file $ii already in RCS"
		ci -m"$description" $ii 
	else
		#print "The file $ii is new file"
		ci $ii << EOF
$description
EOF
	fi
done
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Problem Reporting System <label id="PRS">
-->
<sect> Problem Reporting System <label id="PRS">
<p>
Along with CVS, you may want to use Project Tracking system or Problem
Reporting system. Every software project needs a Problem Reporting System
where in bugs are tracked and assigned to various developers. 
Visit the site <url url="http://www.stonekeep.com">
for Project tracking system.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Configuration Management System Tools <label id="configmgt">
-->
<sect> Configuration Management System Tools <label id="configmgt">
<p>
<bf>What is Configuration Management (CM) ?</bf>

There are a number of different interpretations. 
It is about tracking and
control of software development and its activities. That is, the 
mangement of software development projects with
respect to issues such as multiple developers working on the 
same code at the same time, targetting multiple
platforms, supporting multiple versions, and controlling the 
status of code (for example beta test versus real release).
Even within that scope there are different schools of thought:

<itemize>
<item>Traditional Configuration Management - checkin/checkout control 
of sources (and sometimes binaries) and the
ability to perform builds (or compiles) of the entities. Other
functions may be included as well. 

<item>Process Management - control of the software development 
activities. For example, it might check to ensure
that a change request existed and had been approved for fixing
and that the associated design, documentation,
and review activities have been completed before allowing the 
code to be "checked in" again.
</itemize>

While process management and control are necessary for a
repeatable, optimized development process, a solid
configuration management foundation for that process is essential.

Visit the following links:
<itemize>
<item> FAQ on Configuration Management tools <url url="http://www.iac.honeywell.com/Pub/Tech/CM/CMFAQ.html">
<item>Linux version control and configuration management tools <url url="http://linas.org/linux/cmvc.html">
<item> Configuration Management systems <url url="http://www.cmtoday.com/yp/commercial.html">
<item> Configuration Management Tools <url url="http://www.iac.honeywell.com/Pub/Tech/CM/CMTools.html">
<item> DevGuy CVS config mgmt <url url="http://devguy.com/fp/cfgmgmt/cvs">
<item> <url name="Yahoo category site" url="http://dir.yahoo.com/Computers_and_Internet/software/programming_tools/software_engineering/configuration_management/cvs___concurrent_versions_system">
<item> Free config mgmt tool <url url="http://www.canb.auug.org.au/~millerp/aegis/aegis.html">
<item> Free CM tools <url url="http://www.loria.fr/cgi-bin/molli/cm/wilma/fcmt">
<item> Rational ClearCase tool <url url="http://www.rational.com/products/clearcase/prodinfo.jsp">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Related sites <label id="relatedsites">
-->
<sect> Related sites <label id="relatedsites">
<p>
Related URLs are at -
<itemize>
<item> Linux goodies <url url="http://www.aldev.8m.com"> 
and mirrors at
  <url url="http://aldev.webjump.com" name="webjump">,
  <url url="http://www.angelfire.com/nv/aldev" name="angelfire">,
  <url url="http://www.geocities.com/alavoor/index.html" name="geocities">,
  <url url="http://aldev.virtualave.net" name="virtualave">,
  <url url="http://aldev.bizland.com" name="bizland">,
  <url url="http://members.theglobe.com/aldev/index.html" name="theglobe">,
  <url url="http://members.spree.com/technology/aldev" name="spree">,
  <url url="http://homepages.infoseek.com/~aldev1/index.html" name="infoseek">,
  <url url="http://www3.bcity.com/aldev" name="bcity">,
  <url url="http://aldev.50megs.com" name="50megs">

<item> CVS Bubbles <url url="http://www.loria.fr/~molli/cvs-index.html">
<item> CSSC (SCCS like system) <url url="ftp://alpha.gnu.org/pub/gnu/CSSC">
<item> SCCS for linux <url url="http://www.bitmover.com/bitkeeper">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> SCCS v/s CVS-RCS
-->
<sect> SCCS v/s CVS-RCS
<p>
SCCS (Source Code Control System) 
is no longer being enhanced or improved. 
The general consensus has been that this tool is clumsy and not
suited to large numbers of users working on one project. 
Actually, SCCS interleaves 
all the versions; but it can make new development get 
<bf>progressively slower</bf>. Hence, SCCS is NOT recomended for
new projects, it is still there to support old code base in SCCS.

RCS (Revision Control System) is often considered to be 
better than SCCS. One reason for this is that RCS baselines the most
recent version and keeps deltas for earlier ones, making new
development faster. Additional discussions concerning SCCS vs RCS
is at <url url="http://www.faqs.org/faqs/unix-faq/faq/part7">

<bf>Note that RCS learned from the mistakes of SCCS... </bf>

CVS, which requires RCS, extends RCS 
to control concurrent editing of sources by several users
working on releases built from a hierarchical set of 
directories. "RCS is [analogous to using] assembly language, while CVS is
[like using] Pascal". 
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Other Formats of this Document
-->
<sect> Other Formats of this Document
<p>
This document is published in 12 different formats namely - DVI, Postscript, 
Latex, Adobe Acrobat PDF,
LyX, GNU-info, HTML(multi-pages), single HTML page,
RTF(Rich Text Format), Plain-text, Unix man pages and SGML.
<itemize>
<item>
You can get this HOWTO document as a single file tar ball in HTML, DVI, 
Postscript or SGML formats from -
<url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/other-formats/">
and <url url="http://www.linuxdoc.org/docs.html#howto">

<item>Plain text format is in: <url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
<item>Single HTML file format is in: 
<url url="http://www.linuxdoc.org/docs.html#howto">

<item>Translations to other languages like French, German, Spanish, 
Chinese, Japanese are in
<url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
Any help from you to translate to other languages is welcome.
</itemize>
The document is written using a tool called "SGML-Tools" which can be got from - 
<url url="http://www.sgmltools.org">
Compiling the source you will get the following commands like
<itemize>
<item>sgml2html CVS-HOWTO.sgml     (to generate html file)
<item>sgml2rtf  CVS-HOWTO.sgml     (to generate RTF file)
<item>sgml2latex CVS-HOWTO.sgml    (to generate latex file)
</itemize>

LaTeX documents may be converted into PDF files simply by 
producing a Postscript output using <bf>sgml2latex</bf> ( and dvips) and running the
output through the Acrobat <bf>distill</bf> (<url url="http://www.adobe.com">) command as follows: 
<code>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &
</code>
Or you can use Ghostscript command <bf>ps2pdf</bf>.
ps2pdf is a work-alike for nearly all the functionality of 
Adobe's Acrobat Distiller product: it
converts PostScript files to Portable Document Format (PDF) files. 
<bf>ps2pdf</bf> is implemented as a very small command script (batch file) that invokes Ghostscript, selecting a special "output device"
called <bf>pdfwrite</bf>. In order to use ps2pdf, the pdfwrite device must be included in the makefile when Ghostscript was compiled;
see the documentation on building Ghostscript for details.

This howto document is located at -
<itemize>
<item> <url url="http://sunsite.unc.edu/LDP/HOWTO/CVS-HOWTO.html">
</itemize>

Also you can find this document at the following mirrors sites -
<itemize>
<item> <url url="http://www.caldera.com/LDP/HOWTO/CVS-HOWTO.html">
<item> <url url="http://www.WGS.com/LDP/HOWTO/CVS-HOWTO.html">
<item> <url url="http://www.cc.gatech.edu/linux/LDP/HOWTO/CVS-HOWTO.html">
<item> <url url="http://www.redhat.com/linux-info/ldp/HOWTO/CVS-HOWTO.html">

<item> Other mirror sites near you (network-address-wise) can be found at
<url url="http://sunsite.unc.edu/LDP/hmirrors.html">
select a site and go to directory /LDP/HOWTO/CVS-HOWTO.html
</itemize>


In order to view the document in dvi format, use the xdvi program. The xdvi
program is located in tetex-xdvi*.rpm package in Redhat Linux which can be
located through ControlPanel | Applications | Publishing | TeX menu buttons.
	To read dvi document give the command -
<tscreen><verb>
	xdvi -geometry 80x90 howto.dvi
	man xdvi
</verb></tscreen>
	And resize the window with mouse.
	To navigate use Arrow keys, Page Up, Page Down keys, also
	you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' letter
	keys to move up, down, center, next page, previous page etc.
	To turn off expert menu press 'x'.

You can read postscript file using the program 'gv' (ghostview) or 
'ghostscript'.
The ghostscript program is in ghostscript*.rpm package and gv 
program is in gv*.rpm package in Redhat Linux
which can be located through ControlPanel | Applications | Graphics menu 
buttons. The gv program is much more user friendly than ghostscript.
Also ghostscript and gv are available on other platforms like OS/2,
Windows 95 and NT, you view this document even on those platforms.
 
<itemize>
<item>Get ghostscript for Windows 95, OS/2, and for all OSes from <url url="http://www.cs.wisc.edu/~ghost">
</itemize>

To read postscript document give the command -
<tscreen><verb>
		gv howto.ps
		ghostscript howto.ps
</verb></tscreen>

You can read HTML format document using Netscape Navigator, Microsoft Internet
explorer, Redhat Baron Web browser or any of the 10 other web browsers.

You can read the latex, LyX output using LyX a X-Windows front end to latex.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Copyright
-->
<sect> Copyright and License
<p>
Copyright Al Dev (Alavoor Vasudevan) 1998-2000.

License is GNU GPL, but it is requested that you retain the author's name
and email on all copies.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sget <label id="sget">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sget
# Program to check out the file from CVS read-only

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number/symbolic_tag_name] <file/directory name> "
	print "The options -r are optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " $cmdname some_directory "
	print "Extract by symbolic revision tag like - "
	print " $cmdname -r REVISION_1 some_directory "
	print " "
	exit
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
	Usage
fi

bkextn=sget_bak

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# Check if file already exists....
if [ -f "$HOME/$subdir/$fname" ]; then
	tmpaa="$HOME/$subdir/$fname"
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		print "\nError: The file is writable. Aborting $cmdname ......"
		print "       You should either backup, scommit or delete the file and"
		print "       try $cmdname again\n"
		exit
	fi
fi

# Move the file
mkdir -p "$HOME/$subdir"
touch "$HOME/$subdir/$fname" 2>/dev/null
\mv -f "$HOME/$subdir/$fname" "$HOME/$subdir/$fname.$bkextn"

# Create subshell
(
	cd $homedir

	# Use -A option to clear all sticky flags
	if [ "$FLAG1" = "" ]; then
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout -A $fname
		else
			cvs -r checkout -A "$subdir/$fname"
		fi
	else
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout -A -$FLAG1 $OARG1 $fname
		else
			cvs -r checkout -A -$FLAG1 $OARG1 "$subdir/$fname"
		fi
	fi
)
#pwd

if [ -f "$HOME/$subdir/$fname" ]; then
	print "\nREAD-ONLY copy of the file $subdir/$fname obtained."
	print "Done $cmdname"
	#print "\nTip (Usage): $cmdname <file/directory name> \n"
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sedit <label id="sedit">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sedit
# Program to check out the file from CVS read/write mode with locking

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
#       print "\nUsage: $cmdname [-r revision_number] [-F] <filename>"
#       print "The options -r, -F are optional "
#       print "The option -F is FORCE edit even if file is "
#       print "locked by another developer"

        print "\nUsage: $cmdname [-r revision_number] <filename>"
        print "The options -r are optional "

        print "For example - "
        print " $cmdname -r 1.1 foo.cpp"
        print " $cmdname foo.cpp "
#       print " $cmdname -F foo.cpp "
        print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
#while getopts r:F ii
while getopts r: ii
do
        case $ii in
        r) FLAG1=$ii; OARG1="$OPTARG";;
#       F) FLAG2=$ii; OARG2="$OPTARG";;
        ?) Usage; exit 2;;
        esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
        Usage
        exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
        print "\nError: \$HOME is not set!!\n"
        exit
fi

bkextn=sedit_bak

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# If file is already checked out by another developer....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi
mkdir -p "$CVSROOT/$subdir/Locks" 2>/dev/null

if [ ! -e "$CVSROOT/$subdir/$fname,v" ]; then
        print "\nError: File $fname does not exist in CVS repository!!\n"
        exit
fi

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the tip revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sedit-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs log $fname | head -6 | grep head: | awk '{print $2}' > $tmpfile
		else
			cvs log "$subdir/$fname" | head -6 | grep head: | awk '{print $2}' > $tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
#echo "lockfile is : " $lockfile
#if [ -e $lockfile -a "$FLAG2" = "" ]; then
if [ -e $lockfile ]; then
        print "\nError: File $fname Revision $OARG1 already locked by another developer !!"
        aa=` ls -l $lockfile | awk '{print "Locking developers unix login name is = " $3}' `
        print $aa
        print "That developer should do scommit OR sunlock to release the lock"
        print " "
#       print "You can also use -F option to force edit the file even if"
#       print "the file is locked by another developer. But you must talk to"
#       print "other developer to work concurrently on this file."
#       print "For example - this option is useful if you work on a seperate"
#       print "C++ function in the file which does not interfere with other"
#       print "developer."
#       print " "
        exit
fi

# Get read-only copy now....
if [ ! -e "$HOME/$subdir/$fname" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout $fname 1>/dev/null
		else
			cvs -r checkout "$subdir/$fname" 1>/dev/null
		fi
	)
fi

# Check if file already exists....
tmpaa="$HOME/$subdir/$fname"
if [ -f $tmpaa ]; then
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		print "\nError: The file is writable. Aborting $cmdname ......"
		print "       You must backup, scommit or delete file and"
		print "       try $cmdname again\n"
		exit
	fi
	#print "\nNote: The file $tmpaa is read-only."
	#print "Hence I am moving it to $tmpaa.$bkextn ....\n"
	\mv -f $tmpaa $tmpaa.$bkextn
	chmod 444 $tmpaa.$bkextn
elif [ -d $tmpaa ]; then
	print "\nError: $tmpaa is a directory and NOT a file. Aborting $cmdname ....\n"
	exit
fi

# Create subshell
print "\nNow getting the file $fname from CVS repository ...\n"
(
	cd $homedir
	# Use -A option to clear the sticky tag and to get
	# the HEAD revision version
	if [ "$FLAG1" = "" ]; then
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -w checkout -A $fname
		else
			cvs -w checkout -A "$subdir/$fname"
		fi
	else
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -w checkout -A -$FLAG1 $OARG1 $fname
		else
			cvs -w checkout -A -$FLAG1 $OARG1 "$subdir/$fname"
		fi
	fi
)

if [ -e "$HOME/$subdir/$fname" ]; then
	# The lockfile is $CVSROOT/$subdir/Locks/$fname-$OARG1
	touch $lockfile
	if [ -e $lockfile ]; then
		print "\nDone $cmdname"
	else
		print "\nFatal Error: File $fname Revision $OARG1 not locked !!"
		print "\nCheck the reason for this failure.. before proceeding..."
	fi
fi

#pwd

#print "\nTip (Usage): $cmdname <filename> \n"

</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> scommit <label id="scommit">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program scommit
# Program to commit the changes and check in the file into CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number] <filename>"
	print "The options -r are optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
	Usage
	exit 2
fi

if [ -d $1 ]; then
	Usage
	exit 2
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

# Find sub-directory
cur_dir=`pwd`
#echo $cur_dir
len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
# echo "subdir is : " $subdir
# echo "fname is : " $fname

# If file is already checked out by another user....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
	print "\nError: \$CVSROOT is not set!!\n"
	exit
fi
mkdir -p "$CVSROOT/$subdir/Locks" 2>/dev/null

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the working revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sedit-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs status $fname 2>/dev/null | grep "Working revision:" | awk '{print $3}' >$tmpfile
		else
			cvs status "$subdir/$fname" 2>/dev/null | grep "Working revision:" | awk '{print $3}' >$tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

if [ "$OARG1" = "" ]; then
	print "The file $subdir/$fname is NEW, it is not in the CVS repository"
else
	lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"

	if [ -e $lockfile ]; then
		# Check if this revision is owned by you...
		aa=` ls -l $lockfile | awk '{print $3}' `
		userid=`id | cut -d'(' -f2 | cut -d')' -f1 `
		if [ "$aa" != "$userid" ]; then
			print " "
			print "The file $subdir/$fname is NOT locked by you!!"
			print "It is locked by unix user name $aa and your login name is $userid"
#                       print "If you are working concurrently with other developer"
#                       print "and you used -F option with sedit."
			print "You need to wait untill other developer does scommit"
			print "or sunlock"
			print "Aborting the $cmdname ...."
			print " "
			exit 2
		fi
	else
		# The file must exist in cvs 
		if [ -f "$CVSROOT/$subdir/$fname,v" ]; then
			print "You did not lock the file $subdir/$fname with sedit!!"
			print "Aborting the $cmdname ...."
			exit 2
		else
			print "\nThe file $subdir/$fname does not exist in CVS repository yet!!"
			print "You should have done sadd on $subdir/$fname ...."
			exit 2
		fi
	fi
fi

# Operate inside sub-shell - and operate from root directory
(
	cd $homedir

	# Do not allow directory commits for now ...
	#if [ -d "$subdir/$fname" ]; then
	#	cvs commit "$subdir/$fname"
	#fi

	if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
		cvs commit $fname
	else
		cvs commit "$subdir/$fname"
	fi
	exit_status=$?

	if [ $exit_status -eq 0 ]; then
		lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
		if [ -e $lockfile ]; then
			\rm -f $lockfile
		fi

		# Must change the permissions on file in case
		# there are no changes to file
		chmod a-w "$HOME/$subdir/$fname"
		print "\nDone $cmdname. $cmdname successful"
		#print "\nTip (Usage): $cmdname <filename/directory name>\n"
	fi
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> supdate <label id="supdate">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program supdate
# Program to update the file from CVS read/write mode

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename>"
	exit
fi

# Put double quotes to protect spaces in $1
tmpaa="$1"

# Check if file already exists....
if [ $# -gt 0 -a  -f $tmpaa ]; then
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		while :
		do
			print "\n$cmdname will backup your working file "
			print "$tmpaa to $tmpaa.supdate_bak before doing any merges."
			print "Are you sure you want the merge the changes from"
			print -n "CVS repository to your working file ? <y/n> [n]: "
			read ans
			if [ "$ans" = "y" -o "$ans" = "Y" ]; then
				if [ -f $tmpaa.supdate_bak ]; then
					print "\nWarning : File $tmpaa.supdate_bak already exists!!"
					print "Please examine the file $tmpaa.supdate_bak and delete it"
					print "and than re-try this $cmdname "
					print "Aborting $cmdname ...."
					exit
				else
					cp $tmpaa $tmpaa.supdate_bak
					break
				fi
			elif [ "$ans" = "n" -o "$ans" = "N" -o "$ans" = "" -o "$ans" = " " ]; then
				exit
			fi
		done
	fi
fi

if [ -d $tmpaa ]; then
	print "\nDirectory update is disabled because cvs update"
	print "merges the changes from repository to your working directory."
	print "Hence give the filename to update - as shown below: "
	print " Usage: $cmdname <filename>"
	exit
#       cvs update
else
	cvs update $tmpaa
fi

print "\nDone $cmdname. $cmdname successful"
print "\n\nThe original file is backed-up to $tmpaa.supdate_bak"
print "\nHence your original file is SAVED to $tmpaa.supdate_bak"
print "\n\n"
#print "\nTip (Usage): $cmdname <filename/directory name>\n"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sunlock <label id="sunlock">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sunlock
# Program to unlock the file to release the lock done by sedit

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number] <filename>"
	print " The options -r is optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

if [ $# -lt 1 ]; then
	Usage
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
	print "\nError: \$CVSROOT is not set!!\n"
	exit
fi

if [ ! -e "$CVSROOT/$subdir/$fname,v" ]; then
	print "\nError: File $fname does not exist in CVS repository!!\n"
	exit
fi

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the tip revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sunlock-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	# Operate inside sub-shell - from root directory
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs log $fname | head -6 | grep head: | awk '{print $2}' > $tmpfile
		else
			cvs log "$subdir/$fname" | head -6 | grep head: | awk '{print $2}' > $tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
#echo lockfile is : $lockfile
if [ ! -e $lockfile ]; then
	print "\nFile $fname revision $OARG1 is NOT locked by anyone"
	print " "
	exit
fi

ans=""
while :
do
	print "\n\n***************************************************"
	print "WARNING: $cmdname will release lock and enable other"
	print "         developers to edit the file. It is advisable"
	print "         to save your changes with scommit command"
	print "***************************************************"
	print -n "\nAre you sure you want to unlock the file <y/n>? [n]: "
	read ans
	if [ "$ans" = "" -o "$ans" = " " -o "$ans" = "n" -o "$ans" = "N" ]; then
		print "\nAborting $cmdname ...."
		exit
	fi
	if [ "$ans" = "y" -o "$ans" = "Y" ]; then
		print "\n\n\n\n\n "
		print "CAUTION: You may lose all the changes made to file!!"
		print -n "Are you sure? Do you really want to unlock the file <y/n>? [n]: "
		read ans
		if [ "$ans" = "y" -o "$ans" = "Y" ]; then
			break
		elif [ "$ans" = "" -o "$ans" = " " -o "$ans" = "n" -o "$ans" = "N" ]; then
			exit
		else
			print "\n\nWrong entry. Try again..."
			sleep 1
		fi
	else
		print "\n\nWrong entry. Try again..."
		sleep 1
	fi
done

if [ -e $lockfile ]; then
	\rm -f $lockfile
	print "\nDone $cmdname"
else
	print "\nFile $fname is NOT locked by anyone"
	print " "
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> slist <label id="slist">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

	Note that there is also another unix
	command by name slist (list available Netware servers), you
	should make sure cvs script slist comes before other in your
	PATH environment.

<code>
#!/bin/ksh

# CVS program slist
# Program to list all edited source files from CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

# Usage:
# 		$ slist      (All files and sub-directories)
# 		$ slist *.*      (All files)
# 		$ slist *      (All files and sub-directories)
# 		$ slist ab*      (All files starting with ab wild-card)

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir

# If file is already checked out by another developer....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi

# If the current directory tree is not in cvs-root then exit
if [ ! -d $CVSROOT/$subdir ]; then
	print "\nThe directory $subdir does not exist in $CVSROOT"
	exit
fi

#echo "no of params : " $#
#echo "The arg $ 1 is : " $1
#echo "all args : " $@

if [ $# -eq 0 ]; then
	tmpbb=` find * -prune -type d `
elif [ $# -eq 1 ]; then
	if [ "$1" = "." ]; then
		tmpbb=` find * -prune -type d `
	else
		if [ -d $1 -a ! -d $CVSROOT/$subdir/$1 ]; then
			print "\nThe directory $subdir/$1 does not exist in $CVSROOT"
			exit
		fi
		tmpbb=$@
	fi
else
	tmpbb=$@
fi

#echo "The tmpbb is : " $tmpbb

# Now, remove all the directory names which are not in cvs-root
dirnames=""
for ii in $tmpbb ; do
	if [ -d $CVSROOT/$subdir/$ii ]; then
		dirnames="$dirnames $ii "
	fi
done
#echo "The dirnames is : " $dirnames

if [ "$dirnames" != "" ]; then
	find $dirnames  -type f |
	while read ii
	do
		# List only those files which are in cvs system
		if [ -f "$CVSROOT/$subdir/$ii,v" ]; then
			#echo "ii is : " $ii
			ls -l $ii | grep ^\-rw
		fi
	done;
fi

# Get all the files in the current directory
listfiles=`ls $tmpbb `
find * -prune -type f |
while read ii
do
	for jj in $listfiles ; do
		if [ "$jj" = "$ii" ]; then
			# List only those files which are in cvs system
			if [ -f "$CVSROOT/$subdir/$ii,v" ]; then
				#echo "ii is : " $ii
				ls -l $ii | grep ^\-rw
			fi
		fi
	done
done;
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sinfo <label id="sinfo">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sinfo
# Program to get the status of files in working directory

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname [file/directory name] "
	print "For example - "
	print " $cmdname foo.cpp"
	print " $cmdname some_directory "
	print " "
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Create subshell
if [ -f $1 ]; then
	(
        cd $homedir
		clear
		print "\ncvs status is : "
        cvs status "$subdir/$fname"
	)
elif [ -d $1 ]; then
	(
		cd $homedir
		clear
		print "\ncvs status is : "
		tmpfile="$homedir/cvs_sinfo.tmp"
		rm -f $tmpfile
        echo "  " >> $tmpfile
        echo "  ****************************************" >> $tmpfile
        echo "        Overall Status of Directory" >> $tmpfile
        echo "  ****************************************" >> $tmpfile
        cvs release "$subdir/$fname" 1>>$tmpfile 2>>$tmpfile << EOF
N
EOF
        echo "\n   -------------------------------\n" >> $tmpfile

        aa=`cat $tmpfile | grep ^"M " | awk '{print $2}' `
        for ii in $aa
        do
			jj="(cd $homedir; cvs status \"$subdir/$ii\" );"
			echo $jj | /bin/sh  \
					| grep -v Sticky | awk '{if (NF != 0) print $0}' \
					1>>$tmpfile 2>>$tmpfile
        done

        cat $tmpfile | grep -v ^? | grep -v "Are you sure you want to release" \
        | less
        rm -f $tmpfile
	)
else
	print "\nArgument $1 if not a file or directory"
	exit
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> slog <label id="slog">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program slog
# Program to list history of the file in CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
        print "\nUsage: $cmdname <filename> \n"
        exit
fi

# Check if file does not exist....
if [ ! -f "$1" ]; then
        print "\nError: $1 is NOT a file. Aborting $cmdname ......"
        exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname="$1"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside a sub-shell
(
	cd $homedir
	cvs log "$homedir/$subdir/$fname" | less
)

print "\nDone $cmdname. $cmdname successful"
#print "\nTip (Usage): $cmdname <filename>\n"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sdif <label id="sdif">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sdif
# Program to see difference of the working file with CVS copy

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname <filename> "
	print "$cmdname -r<rev1> -r<rev2> <filename> \n"
	exit
}

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

FLAG1=""
FLAG2=""
OARG1=""
OARG2=""
# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r:r: ii
do
	case $ii in
	r)
		if [ "$FLAG1" = "" ]; then
			FLAG1=$ii;
			OARG1="$OPTARG"
		else
			FLAG2=$ii;
			OARG2="$OPTARG"
		fi
		;;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

if [ "$FLAG2" = "" ]; then
	FLAG2=r
	OARG2=HEAD
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname="$1"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside sub-shell
(
	cd $homedir
	if [ "$FLAG1" = "" ]; then
		cvs diff -r HEAD "$homedir/$subdir/$fname" | less
	else
		cvs diff -$FLAG1 $OARG1 -$FLAG2 $OARG2 "$homedir/$subdir/$fname" | less
	fi
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sadd <label id="sadd">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sadd
# Program to add the file to CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`
if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename/directory> \n"
	exit
fi

onearg="$1"
if [ ! -f "$onearg" -a ! -d "$onearg" ]; then
	print "\nArgument $onearg is not a file or a directory!"
	print "Usage: $cmdname <filename/directory> \n"
	exit
fi

# Argument is a directory name .....
homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname "$onearg" `
if [ "$tmpaa" = "." ]; then
	fname="$onearg"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename "$onearg" `
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Check if file exists ....
if [ $# -eq 1 ]; then
	if [ -f "$onearg" ]; then
		cvs add "$onearg"
		exit
	fi
elif [ $# -gt 1 ]; then
	print "\n\n\nAdding all the files in the current directory to CVS"
	print "Directories will not be added"
	print -n "Hit return to continue or CTRL+C to abort..."
	read ans
	for ii in $@
	do
		if [ -f "$ii" ]; then
			cvs add "$ii"
		fi
	done;
	exit
fi

# When $subdir is "." then you are at the root directory
if [ "$subdir" = "." ]; then
	# The $onearg is a directory and not a file at this point...
	if [ -d "$CVSROOT/$onearg" ]; then
		print "\nDirectory $onearg already exists in CVSROOT"
		exit
	else
		# You are adding at root directory $CVSROOT
		if [ "$2" = "" -o "$3" = "" ]; then
			print "\nUsage: $cmdname <directory> <vendor tag> <release tag>"
			print "For example - "
			print " $cmdname foo_directory V_1_0 R_1_0"
			exit
		else
			(
				cd "$homedir/$subdir";
				cvs import "$onearg" $2 $3
			)
		fi
	fi
else
	# If current directory exists in CVS...
	if [ -d "$CVSROOT/$subdir/$onearg" ]; then
		print "\nDirectory $onearg already in CVS repository!"
		exit
	else
		(
			if [ -d "$homedir/$subdir/$onearg/CVS" ]; then 
				print "\nError: Directory $homedir/$subdir/$onearg/CVS exists!!"
				print "\nAborting now ...."
				exit
			fi

			# For import you MUST change to target directory
			# and you MUST specify full-path starting with $subdir
			cd "$homedir/$subdir/$onearg";
			cvs import "$subdir/$onearg" Ver_1 Rel_1
		)
	fi
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sdelete <label id="sdelete">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sdelete
# Program to delete the file from CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename> \n"
	exit
fi

onearg="$1"

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname "$onearg" `
if [ "$tmpaa" = "." ]; then
	fname="$onearg"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename "$onearg" `
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside a sub-shell ...
(
	cd $homedir

	# Check if file does not exist....
	if [ ! -f "$subdir/$fname" ]; then
		# Try to get the file from CVS
		sget "$subdir/$fname"
		if [ ! -f "$subdir/$fname" ]; then
			print "\nError: $subdir/$fname does NOT exist in CVS repository."
			print "\nAborting $cmdname ......"
			exit
		fi
	fi

	bkextn=cvs_sdelete_safety_backup
	\mv -f "$subdir/$fname" "$subdir/$fname.$bkextn" 

	cvs remove "$subdir/$fname"

	print "\nsdelete command removes the file from CVS repository"
	print "and archives the file in CVS Attic directory. In case"
	print "you need this file in future than contact your CVS administrator"
	print " "

	print "\nDone $cmdname. $cmdname successful"
	print "Run scommit on $homedir/$subdir/$fname to"
	print "make this change permanent"
	\mv -f "$subdir/$fname.$bkextn" "$subdir/$fname"
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sfreeze <label id="sfreeze">
<p>
<bf>NOTE : <it>Korn shell /bin/ksh is got by installing pdksh*.rpm from Linux contrib cdrom</it></bf>

Save this file as text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sfreeze
# Program to freeze and cut out the release of source tree from CVS

cmdname=`basename $0`

Usage()
{
	clear
	print "\nUsage: $cmdname symbolic_tag <directory name> "

	print "\nFor example :- "
	print "   cd \$HOME"
	print "   $cmdname  REVISION_1   myprojectsource_directory"
	print "To see the list of revisons do -"
	print "slog <filename> and see the symbolic name and do -"
	print "cvs history -T"

	print "\nTo create a branch off-shoot from main trunk, use"
	print "the -b and -r options which makes the tag a branch tag. This is"
	print "useful for creating a patch to previously released software"
	print "For example :- "
	print "   cd \$HOME"
	print "   cvs rtag -b -r REVISION_1   REVISION_1_1   myprojectsource_directory"
	print " "

#   print "\nTag info is located at \$CVSROOT/CVSROOT/taginfo,v"
#   print "You can do - cd $HOME; sget CVSROOT"
#   print "to see this file"
	exit
}

# Command getopt will not supported in next major release.
# Use getopts instead.
#while getopts r: ii
#do
#	case $ii in
#		r) FLAG1=$ii; OARG1="$OPTARG";;
#		?) Usage; exit 2;;
#	esac
#done
#shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 2 ]; then
	Usage
fi

if [ ! -d $2 ]; then
	print "\nError: Second argument $2 is not a directory!"
	print "       Aborting $cmdname...."
	print " "
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

if [ "$cur_dir" != "$homedir" ]; then
	print "\nYou are not in home directory $homedir!!"
	print "You must give the sfreeze command "
	print "from home directory $homedir"
	exit
fi

# cvs rtag symbolic_tag <directory name>
cvs rtag $1 $2

print "\nDone $cmdname. $cmdname successful"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
</article>
