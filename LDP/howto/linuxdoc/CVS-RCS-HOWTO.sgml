<!doctype linuxdoc system>

<!-- 
************************** begin comment *****************************
     The following is the HOW-TO for CVS/RCS source code revision system.
	 This document is in the SGML format. You must use sgml package to 
	 process this document
************************* end of comment *****************************
 -->
<!-- 
************************** SGML USER GUIDE *****************************
	The SGML user guide on linux is located at /usr/doc/sgml-tools
	Read the example.sgml and guide.html documents.
	Usage:
		HTML	  	sgml2html foo  (Do not give extension .sgml here!!)
		Text	 	sgml2txt foo.sgml
		Latex	  	sgml2latex foo.sgml

		Note: Use 2 dashes - before language, error while compiling
		Postscript 	sgml2latex -language=english -o ps foo.sgml
		DVI  		sgml2latex -d foo.sgml
		Lyx		sgml2lyx foo.sgml
		Richtext 	sgml2rtf foo.sgml
		gnuinfo  	sgml2info foo.sgml
		man		sgml2txt -man foo.sgml
		SGML	 	sgmlcheck foo.sgml
************************* end of comment *****************************
-->

<article>

<!-- Title information -->

<title>CVS-RCS- HOW-TO Document for Linux (Source Code Control System)
<!-- chapt change
CVS-RCS HOW-TO
Concurrent Version Control System and
Revision Control System
(Source Code Management Tools)



-->
<author>Al Dev (Alavoor Vasudevan) 
       <htmlurl url="mailto:alavoor@yahoo.com"
             name="alavoor@yahoo.com">
<date>v21.6, 04 Oct 2001
<abstract>
This document is a "practical guide" to very quickly setup CVS/RCS source code
control system. This document has custom shell scripts that are wrappers 
on top of CVS. These scripts provide an easy user interface for CVS. 
Several shell scripts are provided to make RCS easier to use.
The information in this document applies to Linux and as well as to all other 
flavors of Unix liks Solaris, HPUX, AIX, SCO, Sinix, BSD, SCO, Apple 
Macintosh (which is BSD unix) etc.. and BeOS.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Introduction
-->
<sect>Introduction
<p>
A source code control system is a MUST to manage 
the changes occurring to a software project during development. Developers need a complete history of changes
to backtrack to previous versions in case of any problems.
Since source code is the most vital component of any software project and  
software development takes a huge amount of time and money, it is very important to spend some 
time in <it><bf>safe-guarding</bf></it> the source code by using source code control systems like CVS and RCS.
<p>
CVS (Concurrent Version Control System) is a powerful tool which allows 
concurrent development of software by multiple users. It uses RCS 
underneath and has an application layer interface as a wrapper on top of RCS.

CVS can record the history of your files (usually,
but not always, source code). CVS only stores the differences
between versions, instead of every version of every file
you've ever created. CVS also keeps a log of who, when and
why changes occurred, among other aspects.

CVS is very helpful for managing releases and controlling
the concurrent editing of source files among multiple
authors. Instead of providing version control for a
collection of files in a single directory, CVS provides
version control for a hierarchical collection of
directories consisting of revision controlled files.

These directories and files can then be combined 
to form a software release.

CVS can be used for storing "C", "C++", Java, Perl, HTML and
other files.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Which One Is for Me? CVS or RCS
-->
<sect> Which One Is for Me? CVS or RCS
<p>
CVS actually uses RCS underneath. CVS is a lot more powerful tool and
can control a complete source code tree. 
It is <it><bf>very strongly</bf></it> recommended that you use CVS, because you can greatly customize CVS with scripting languages like PERL, Korn and bash shells. 
See the sample korn shell scripts at <ref id="Shell Scripts">.

Advantages of CVS:
<itemize>
<item> CVS is decentralised so a user checks out files/directories 
from the repostitory
and have his own separate stable source directory tree.
<item> CVS can "STAMP" releases of an entire project source tree.
<item> CVS can enable concurrent editing of files.
<item> CVS can be greatly customized to enable strong locking of files 
via shell scripts or PERL scripts.
CVS supports weak locking with the command 'cvs watches' and also
no locking permitting concurrent editing of files. 
</itemize>

Disadvantages of CVS:
<itemize>
<item> Needs a little more administration than RCS.
<item> Very highly sophisticated and complex system. It is "State of the Art" 
technology. The cvs software is a very advanced and capable system developed
over a very long period of time (it took several years!!).
<item> Has a large number of commands and command options, hence a steeper 
learning curve for beginners. The shell scripts at <ref id="Shell Scripts"> can ease usage.
</itemize>

Advantages of RCS:
<itemize>
<item> RCS is very simple to setup, with less administrative work.
<item> RCS is used in a centralized area where everyone works. 
<item> RCS is useful for simple systems.
<item> Very strong locking of files - concurrency eliminated.
</itemize>

Downside of RCS:
<itemize>
<item> Concurrent development by multiple developers is not possible due to file 
locking and being limited to a single working directory. Because of the 
single working directory limitation, changes to files by multiple developers can 
cause failure of the 'make' command.
<item> Cannot stamp releases of an entire software project.
</itemize>

This document also has 
shell scripts which provide
simple commands to check-out, check-in, and commit files.
See shell scripts at <ref id="Shell Scripts">

For RCS see the RCS mini-howto on the Linux cdrom: 
<CODE>
cd /mnt/cdrom/Redhat/RPMS
ls -l howto-6.0-*.noarch.rpm
rpm -qpl howto-6* | grep -i rcs 
</CODE>
or visit <url url="http://www.LinuxDoc.org/HOWTO/mini/RCS.html">

See also the RCS shell scripts at 
<ref id="rcs_scripts">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Setting up CVS <label id="Setting up CVS">
-->
<sect> Setting up CVS <label id="Setting up CVS">
<p>
First you need to install the CVS package. On Redhat Linux use:
<CODE>
cd /mnt/cdrom/Redhat/RPMS
rpm -i rcs*.rpm
rpm -i cvs*.rpm
To see the list of files installed do -
rpm -qpl cvs*.rpm | less
</CODE>
and browse the output using j,k, CTRL+f, CTRL+D, CTRL+B, CTRL+U or using arrow keys, page up/down keys.
See 'man less'.

On other flavors of Unix, you may need to download the RCS and CVS tar balls
and follow the README, INSTALL files to setup CVS.
Visit <url url="http://www.cyclic.com">
and <url url="http://www.loria.fr/~molli/cvs-index.html">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Environment variables <label id="CVS-Env">
<p>
The following environment variables need to be setup in /etc/profile - default values required for all users.
If not set in /etc/profile, then you should add these to your local profile file ~/.bash_profile.
<CODE>
export EDITOR=/bin/vi
export CVSROOT=/home/cvsroot
export CVSREAD=yes
</CODE>

Create a directory to store the source code repository 
and give read, write access to Unix group/user.
Also make sure that the directory name of CVSROOT does not contain
any blank spaces. For example CVSROOT should not be like '/home/my rootcvs'.
<CODE>
bash$ su - root
bash# export CVSROOT=/home/cvsroot
bash# groupadd --help
bash# groupadd cvs
bash# useradd --help
bash# useradd -g cvs -d /home/cvsroot cvs

bash# ls -ld $CVSROOT   ... (you should see the listing)
bash# chmod o-rwx $CVSROOT
bash# chmod ug+rwx $CVSROOT

#To initialize the CVS repository and to put in source code files do:
bash# cvs init

# Add the unix users to the cvs group. Create supplementary groups for users.
# Note that you MUST not put any blank spaces after comma seperating the
# group names in -G option.
# In example below user tom belongs to groups cvs, users and staff and user
# johnson belongs to group cvs only.
bash# usermod --help
bash# usermod -G cvs some_unix_username
bash# usermod -G cvs,users,staff tom
bash# usermod -G cvs,users,staroffice billclinton
bash# usermod -G cvs johnson
bash# exit    .... (logout of root superuser mode)

# Login as a user and import files into cvs....
bash$ su - billclinton
bash$ export EDITOR=/bin/vi
bash$ export CVSROOT=/home/cvsroot
bash$ export CVSREAD=yes

# Change directory is a must
bash$ cd $HOME/somedir/anotherdir/directory/my_source_code_dir

# Must give vendor tag and revision tag
cvs import somedir/anotherdir/directory/my_source_code_dir Vendor1_0 Rev1_0  

# Also note that it is very important to give the directory tree starting
# from the $HOME, that is, in above example starting from somedir.
# For example I did:
bash$ cd $HOME/howto/foobar
bash$ cvs import howto/foobar Vendor1_0 Rev1_0

# Another example is:
bash$ cd $HOME/javafilesdir
bash$ cvs import javafilesdir Vendor1_0 Rev1_0

# A sample testing and verification:
bash$ cd $HOME/howto/foobar
bash$ cvs checkout myfoo.java
</CODE>

<bf>TROUBLESHOOTING:</bf> When doing checkout it says module is unknown. It 
is a common mistake not to change directory while doing cvs import. You 
<bf><it>MUST change directory</it></bf> to the 
source-code-directory and then do cvs import. For example:
<code>
bash$ cd $HOME/somedirectory/foobardir
bash$ cvs import somedirectory/foobardir Vendor1_0 Rev1_0
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Migrate RCS to CVS <label id="RCS2CVS">
<p>
To migrate the existing RCS files to CVS, use the following script. Make sure
that you installed the Korn shell package pdksh*.rpm from the Linux contrib cdrom.

<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from the Linux contrib cdrom</it></bf>
<CODE>
#!/bin/ksh

#############################################################
# Program to Migrate the existing source code in RCS to CVS 
#
# Needs the korn shell RPM package  pdksh*.rpm from Linux 
# contrib cdrom
#############################################################

#
# rcs2cvs - convert source tree from RCS to CVS
#

# project to convert
PROJECT='project'

# current RCS root
RCSROOT="$HOME/rcs"

if cd "$RCSROOT/$PROJECT"
then
	cd "$RCSROOT"
else
	echo >&2 "`basename "$0"`: can't change to RCS directory '$RCSROOT/$PROJECT'."
	exit 1
fi

# current CVS root
CVSROOT="$HOME/cvs"

# create new CVS directory for project 'project'
if mkdir "$CVSROOT/$PROJECT"
then
	:
else
	echo >&2 "`basename "$0"`: can't create CVS directory '$CVSROOT/$PROJECT'."
	exit 2
fi

# create CVS project tree from RCS tree
find "$PROJECT" -type d -name RCS -print |
while read RCS
do
	CVS="`dirname "$RCS"`"
	(if cd "$RCS"
	then
#		if find . -type f -name '*,v' -print | cpio -pdmv "$CVSROOT/$CVS"
		if find . -type f -print | cpio -pdmv "$CVSROOT/$CVS"
		then
			:
		else
			echo >&2 "`basename "$0"`: can't convert RCS subdirectory '$RCSROOT/$RCS' to CVS subdirectory '$CVSROOT/$CVS'."
		fi
	else
		echo >&2 "`basename "$0"`: can't change to RCS subdirectory '$RCSROOT/$RCS'."
	fi)
done
</CODE>
Now the RCS is migrated to CVS as 'project'. You can start using the
CVS commands on module 'project'.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Intro to CVS Commands <label id="Intro_CVS">
-->
<sect> Intro to CVS Commands <label id="Intro_CVS">
<p>
CVS provides a rich variety of  commands  (cvs_command  in
the  Synopsis),  each  of  which  often  has  a  wealth of
options, to satisfy the many needs of source management in
distributed environments.  However, you don't have to master
every detail to do useful work with CVS; in fact, five
commands  are  sufficient  to  use (and contribute to) the
source repository.
The most commonly used CVS commands are: 
<bf>checkout</bf>,
<bf>update</bf>,
<bf>add</bf>,
<bf>remove</bf>,
<bf>commit</bf> and
<bf>diff</bf>.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> checkout<label id="checkout">
<p>
<bf>cvs checkout modules...</bf>
A necessary preliminary for most CVS work:  creates
your  private copy of the source for modules (named
collections of source; you can also use a path relative
to the source repository here).  You can work
with this copy  without  interfering  with  others'
work.   At  least  one subdirectory level is always
created.
<code>
bash$ cvs --help checkout
Usage:
  cvs checkout [-ANPRcflnps] [-r rev | -D date] [-d dir]
    [-j rev1] [-j rev2] [-k kopt] modules...
        -A      Reset any sticky tags/date/kopts.
        -N      Don't shorten module paths if -d specified.
        -P      Prune empty directories.
        -R      Process directories recursively.
        -c      "cat" the module database.
        -f      Force a head revision match if tag/date not found.
        -l      Local directory only, not recursive
        -n      Do not run module program (if any).
        -p      Check out files to standard output (avoids stickiness).
        -s      Like -c, but include module status.
        -r rev  Check out revision or tag. (implies -P) (is sticky)
        -D date Check out revisions as of date. (implies -P) (is sticky)
        -d dir  Check out into dir instead of module name.
        -k kopt Use RCS kopt -k option on checkout.
        -j rev  Merge in changes made between current revision and rev.
(Specify the --help global option for a list of other help options) 
</code>
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>update<label id="update">
<p>
<bf>cvs update</bf>
Execute  this  command  from  within  your  private
source  directory  when  you  wish  to  update your
copies of source  files  from  changes  that  other
developers  have  made to the source in the repository.
<code>
bash$ cvs --help update
Usage: cvs update [-APdflRp] [-k kopt] [-r rev|-D date] [-j rev]
    [-I ign] [-W spec] [files...]
        -A      Reset any sticky tags/date/kopts.
        -P      Prune empty directories.
        -d      Build directories, like checkout does.
        -f      Force a head revision match if tag/date not found.
        -l      Local directory only, no recursion.
        -R      Process directories recursively.
        -p      Send updates to standard output (avoids stickiness).
        -k kopt Use RCS kopt -k option on checkout.
        -r rev  Update using specified revision/tag (is sticky).
        -D date Set date to update from (is sticky).
        -j rev  Merge in changes made between current revision and rev.
        -I ign  More files to ignore (! to reset).
        -W spec Wrappers specification line.
(Specify the --help global option for a list of other help options) 
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>add<label id="add">
<p>
<bf>cvs add file...</bf>
Use this command to enroll new files in CVS records
of your working directory.  The files will be added
to the  repository  the  next  time  you  run  `cvs
commit'.   Note:  You  should  use the `cvs import'
command to bootstrap new sources  into  the  source
repository.   `cvs  add' is only used for new files
to an already checked-out module.
<code>
bash$ cvs --help add
Usage: cvs add [-k rcs-kflag] [-m message] files...
        -k      Use "rcs-kflag" to add the file with the specified kflag.
        -m      Use "message" for the creation log.
(Specify the --help global option for a list of other help options)  
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>remove<label id="remove">
<p>
<bf>cvs remove file...</bf>
Use this command (after erasing any  files  listed)
to  declare  that  you wish to eliminate files from
the repository.  The removal does not affect others
until you run `cvs commit'.
<code>
bash$ cvs --help remove
Usage: cvs remove [-flR] [files...]
        -f      Delete the file before removing it.
        -l      Process this directory only (not recursive).
        -R      Process directories recursively.
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>commit<label id="commit">
<p>
<bf>cvs commit file...</bf>
Use  this command when you wish to ``publish'' your
changes to other developers, by incorporating  them
in the source repository.
<code>
bash$ cvs --help commit
Usage: cvs commit [-nRlf] [-m msg | -F logfile] [-r rev] files...
        -n      Do not run the module program (if any).
        -R      Process directories recursively.
        -l      Local directory only (not recursive).
        -f      Force the file to be committed; disables recursion.
        -F file Read the log message from file.
        -m msg  Log message.
        -r rev  Commit to this branch or trunk revision.
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>diff<label id="diff">
<p>
<bf>cvs diff file...</bf>
Show differences between files in the working directory
and  source repository, or between two revisions in the
source repository.  (Does not change either repository or working directory.)
<code>
bash$ cvs --help diff
Usage: cvs diff [-lNR] [rcsdiff-options]
    [[-r rev1 | -D date1] [-r rev2 | -D date2]] [files...]
        -l      Local directory only, not recursive
        -R      Process directories recursively.
        -D d1   Diff revision for date against working file.
        -D d2   Diff rev1/date1 against date2.
        -N      include diffs for added and removed files.
        -r rev1 Diff revision for rev1 against working file.
        -r rev2 Diff rev1/date1 against rev2.
        --ifdef=arg     Output diffs in ifdef format.
(consult the documentation for your diff program for rcsdiff-options.
The most popular is -c for context diffs but there are many more).
(Specify the --help global option for a list of other help options)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Emacs Editor <label id="Emacs">
<p>
Emacs is a powerful editor and it supports CVS/RCS - especially 
for revision merging and comparing. The main Emacs site 
is at <url url="http://www.emacs.org">.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Strong, Weak or No Locking <label id="locking">
-->
<sect> Strong, Weak or No Locking <label id="locking">
<p>
CVS is a powerful system and is highly customizable. CVS supports:
<itemize>
<item> Strong locking with "reserved checkouts" via <bf>cvs admin -l</bf> or <ref id="Shell Scripts">.
Also read the <url name="Reserved checkouts" url="http://www.cvshome.org/docs/inforeserve.html">.
Here is a patch (<url url="http://www.cvshome.org/dev/patches/editf">) from 
Eric Griswold for reserved checkouts. 
<p>
<item> Weak locking via 'cvs watch' features.
Also see "cvs edit" to give a warning(<url url="http://www.cvshome.org/dev/text2/res2">) if 
someone else is already editing the file.
<p>
<item> No locking - the default permitting concurrent editing of files.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Shell Scripts <label id="Shell Scripts">
-->
<sect> Shell Scripts <label id="Shell Scripts">
<p>
The following are wrappers around the basic CVS commands. These scripts
give you initial <bf>booster-push</bf> into the CVS system and are useful 
until you become very familiar with the CVS commands. The scripts 
are written for Korn shell since it is always available 
on all flavors of Unix, but you can translate to bash or 
Perl if needed. You can customize
these scripts to your taste. They are basically CVS commands, but features are
added to make it site specific. For example, the sedit script provides locking
so that users will know someone is editing the file. Of course users can 
directly use the CVS commands to bypass these scripts. These scripts 
demonstrate how CVS can be <bf>customized</bf> to a great extent.

<bf>NOTE: </bf> <it>The wrapper shell scripts assume the user's 
home directory as the root and check out the tree from CVS to build the 
tree underneath user's home directory.
</it>

<bf> TIP: </bf> <it>In these shell scripts, every target filename is composed 
of 3 parts - Home directory, sub-directory 
and the filename. The full-path is $HOME/$subdir/$fname
And in CVS the same directory structure is maintained (by 
variable $subdir) therefore in cvs there will be something 
like  $CVSROOT/$subdir/$fname.
In all scripts, these 4 variables $HOME, $CVSROOT, $subdir and $fname
play an important role. For example, sample values can be like
HOME=/home/aldev, subdir=myproject/src, CVSROOT=/home/cvsroot,
and fname=foo.cpp
</it>

Copy these scripts to /usr/local/bin and this should be in the user's PATH environment.
<enum>
<item> <bf>sget</bf> &lsqb;-r revision_number&rsqb; &lt;file/directory name&gt;
	To get a file or entire directory from CVS in READ ONLY mode.
	Click <ref id="sget">

<item> <bf>sedit</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To edit a file in order to make changes to code. This will lock the
	file so that nobody else can check it out. Of course you can change the script to your requirement - make no locking, warning message, or very strong locking.
	Click <ref id="sedit">

<item> <bf>scommit</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To commit the changes you made to filename or entire 
	directory. Upload your changes to CVS.
	Click <ref id="scommit">

<item> <bf>supdate</bf>	&lt;filename/directory&gt; 
	To update a filename or to update an entire directory by 
	getting the latest files from CVS.
	Click <ref id="supdate">

<item> <bf>sunlock</bf> &lsqb;-r revision_number&rsqb; &lt;filename&gt;
	To unlock the file got by sedit. Will release the lock.
	Click <ref id="sunlock">

<item> <bf>slist</bf>	
	To see the list of files currently being edited by you. 
	Does 'ls -l | grep | ...' command.
	Click <ref id="slist">. 
	Note that there is also another Unix
	command by the name slist (list available Netware servers). You
	should make sure cvs script slist comes before other in your
	PATH environment.

<item> <bf>sinfo</bf> &lt;filename/directory&gt; 
	To get the information of changes/revisions to a file. 
	Click <ref id="sinfo">

<item> <bf>slog</bf> &lt;filename&gt; 
	To get the history of changes/revisions to a file from CVS.
	Click <ref id="slog">

<item> <bf>sdif</bf> &lt;filename&gt;
<p><bf>sdif</bf> -r rev1 -r rev2 &lt;filename&gt; 
	To get the diff of your file with CVS.
	Click <ref id="sdif">

	NOTE: sdif has only one 'f' because there is already another 
		Unix command called 'sdiff'

<item> <bf>sadd</bf> &lt;filename&gt;   
	To add a new file to CVS repository.
	Click <ref id="sadd">

<item> <bf>sdelete</bf>	&lt;filename&gt; 
	To delete a file from CVS repository.
	Click <ref id="sdelete">

<item> <bf>sfreeze</bf>	&lt;revision name&gt; &lt;directory name&gt;
	To freeze the code, that is make a release of the entire source tree.
	Click <ref id="sfreeze">
<p>
	For example : 
<code>
	cd $HOME;   
	sfreeze REVISION_1_0  srctree  
</code>
 	   This will freeze code with tag REVISION_1_0  so that you can later 
	   checkout the entire tree by using the revision name.
</enum>

<tscreen><verb>
		******************************************************

</verb></tscreen>
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> CVS Documentation <label id="CVS Documentation">
-->
<sect> CVS Documentation <label id="CVS Documentation">
<p>
At Unix prompt type: 
<enum>
<item> cvs --help
<item> cvs --help-options
<item> cvs --help-commands
<item> cvs -H checkout
<item> cvs -H commit
<item> man cvs
<item> man tkcvs
<item> Visit <url url="http://www.cyclic.com">
<item> Visit <url url="http://www.loria.fr/~molli/cvs-index.html">
</enum>

The tkcvs 
	<url url="http://www.tkcvs.org">
is the Tcl/Tk GUI interface to CVS. It also has online help. Try the following:
<itemize>
<item> cd $HOME/src/foo.cpp
<item> tkcvs
<item> Click on foo.cpp
<item> Click on 'Revision Log Icon' which is located next to 'spectacle' icon.
<item> This will display the branch TREE in the window. Now click the RIGHT Mouse 
button on the text '1.3' and click the LEFT Mouse button on text '1.1'. Then 
click on "Diff" button. This will display a two-pane window!!  
<item> Click on the "Next" button to step thru more diffs. 
Click on "Center" to center the text.
</itemize>

There is also a Windows 95 client for CVS called WinCVS  (see:
	<url url="http://www.wincvs.org">
and <url name="cyclicsite" url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">).
WinCVS can be used along with Samba(on cdrom samba*.rpm) - <url url="http://www.samba.org">

The essential command are:
<itemize>
<item> cvs checkout &lt;filename &gt;
<item> cvs update &lt;filename&gt;
<item> cvs add &lt;file, ..&gt;
<item> cvs remove &lt;file, ..&gt;
<item> cvs commit &lt;file&gt;
<item> cvs status &lt;filename&gt;
<item> cvs log &lt;filename&gt;
<item> cvs diff -r1.4 -r1.5 &lt;filename&gt;  
This gives a diff between version 1.4 and 1.5 on filename.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Online Documentation <label id="onlinedocs">
<p>
On Linux systems, you can find the CVS documentation in postscript format at
<bf>/usr/doc/cvs*/*.ps</bf>. Also there is an FAQ and other useful information.
<code>
bash# cd /usr/doc/cvs*
bash# gv cvs.ps
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> CVS Org Documentation <label id="cederquist">
<p>
The documentation on CVS from "CVS Organisation" is at
<url url="http://www.cvshome.org/docs">

The Official manual for CVS by Cederqvist 
is at <url url="http://www.cvshome.org/docs/manual/cvs.html">

FAQ for CVS is at <url url="http://www.cs.utah.edu/dept/old/texinfo/cvs/FAQ.txt">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> CVS Training <label id="training">
<p>
<itemize>
<item> <url url="http://rpmfind.net/tools/CVS/training/cvstrain.html">
<item> <url url="http://www.loria.fr/~molli/cvs/cvs-tut/cvs_tutorial_toc.html">
<item> <url url="http://atlas.web.cern.ch/Atlas/GROUPS/SOFTWARE/OO/tools/srt/">
<item> <url url="http://durak.org/cvswebsites/">
<item> <url url="http://www-users.informatik.rwth-aachen.de/~wge/tools/cvs/cvsclient/cvsclient_toc.html">
<item> <url url="http://www-users.informatik.rwth-aachen.de/~wge/tools/cvs.html">
<p>
General utilities for cvs (third party):
<item> The textbook "Open Source Development with CVS" by Karl Fogel at
<url url="http://cvsbook.red-bean.com"> has 
<url name="third-party-tools" url="http://cvsbook.red-bean.com/cvsbook.html#Third-Party_Tools">
and mirror sites at
<url name="Zevils" url="http://www.zevils.com/doc/cvsbook/cvsbook_8.html">
<item> <url url="http://rcs.ee.washington.edu/spp/Projects/Manastash/Links/cvsbook_toc.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Graphical Front Ends <label id="frontend">
-->
<sect> Graphical Front Ends <label id="frontend">
<p>
The following GUI front ends for CVS are available:
<itemize>
<item> CVS home.org <url url="http://www.cvshome.org/dev/addons.html">
<item> CVS Web for windows <url url="http://www.devguy.com/fp/cfgmgmt/cvs/cvs_admin_nt.htm#CVSWEBIIS"> and at <url url="http://stud.fh-heilbronn.de/~zeller/cgi/cvsweb.cgi">
<item> TkCVS <url url="http://www.tkcvs.org"> is the Tcl/Tk GUI interface to CVS
and at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/tkcvs/index.html">
<item> gCVS: A portable GUI for the non-technical CVS user <url url="http://www.arachne.org/software/gcvs">
<item> jCVS is a CVS client package written entirely in Java <url url="http://www.jcvs.org">
And at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/jcvs/index.html">
<item> WinCVS <url url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">
and at <url name="cyclicsite" url="http://www.cvshome.org/cyclic/cvs/soft-maccvs.html">
<item> Component soft Win CVS <url url="http://www.componentsoftware.com/cvs">
<item> JA-SIG UPortal CVS <url url="http://www.mis3.udel.edu/~jlaker/development">
<item> <url url="http://ppprs1.phy.tu-dresden.de/~trogisch/lincvs/lincvsen.html">
<item> <url url="http://www.loria.fr/~molli/cvs/doc/cvs_toc.html">
</itemize>
It is <bf>very strongly recommended</bf> that you use 
<url name="Samba(on cdrom samba*.rpm)" url="http://www.samba.org">
and a
<ref id="win95" name="PC X Server"> 
on MS Windows 95/NT. By using Samba the remote directory on Unix
will look like local folder on MS Windows. See the next section for 
<ref id="win95" name="PC X Server">.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> CVS for MS Windows 95/98/NT/2000 <label id="win95">
<p>
It is <bf>VERY STRONGLY recommended</bf> that you use 
<url name="Samba(on cdrom samba*.rpm)" url="http://www.samba.org">
and a VNC viewer (or PC X Server) on MS Windows 95/NT. 
With samba the Unix/Linux CVS server will be like a <bf>file server</bf>.
By using Samba the remote directory on Unix
will look like a local folder on MS Windows on the local disk. 
Install samba*.rpm on Unix/Linux server(which has the CVS repository) and install 
the VNC viewer (or PC X server) on 
MS Windows 95/NT/2000 desktop. Using a VNC (or PC X server) you can easily log on to the
Unix box and check-out/check-in the files. And you can use tools like
Java Visual Cafe or Java JBuilder on MS Windows to edit the files located in Unix/Linux
folder(via samba). 
After editing, you can check-in the files to Unix through VNC or PC X-server.

Advantages of using CVS on Linux/Unix via MS Windows are:
<itemize>
<item> Only one single Linux File server (CVS server) can serve many MS Windows clients.
<item> A Linux file server (CVS) is very robust, secure and reliable
<item> Only one UPS (uninterrupted power supply) battery is required for a linux server.
<item> Linux can serve as MS Windows folder through Samba package.
<item> A Linux file server (CVS) supports centralised backups via tools like
<url name="Arkeia, Bru" url="http://www.aldev.8m.com">
mirrors at 
<url url="http://aldev0.webjump.com">,
<url name="angelfire" url="http://www.angelfire.com/country/aldev0">,
<url name="geocities" url="http://www.geocities.com/alavoor/index.html">,
<url name="virtualave" url="http://aldev0.virtualave.net">,
<url name="50megs" url="http://aldev0.50megs.com">,
<url name="theglobe" url="http://members.theglobe.com/aldev1/index.html">,
<url name="NBCi" url="http://members.nbci.com/alavoor">,
<url name="Terrashare" url="http://aldev.terrashare.com">,
<url name="Fortunecity" url="http://members.fortunecity.com/aldev">,
<url name="Freewebsites" url="http://aldev.freewebsites.com">,
<url name="Tripod" url="http://members.tripod.lycos.com/aldev">,
<url name="Spree" url="http://members.spree.com/technology/aldev">,
<url name="Escalix" url="http://www.escalix.com/freepage/aldev">,
<url name="Httpcity" url="http://www.httpcity.com/aldev/index.html">,
<url name="Freeservers" url="http://aldev.freeservers.com">.

<item> A Linux file server (CVS) requires just one small server room which can air-contitioned
and dust free. Small room keeps the cooling/heating costs down.
<item> A Linux file server (CVS) provides security via Unix groups and user id authentication
</itemize>

The best tool for remote access is VNC. The VNC is lightweight and is 
much better than the PC X servers. <bf><it>The VNC is very strongly recommended 
over PC X server</it></bf>. The remote access methods available are:
<itemize>
<item>VNC (Virtual Network Computing) at <url url="http://www.uk.research.att.com/vnc">
VNC is not an X-server but can display the remote Unix on Windows.
VNC is the best tool in the market for remote access, it is very lightweight and 
is a very powerful software.
<p>
<item> Get VNC rpms from <url name="rpmfind" url="http://rpmfind.net/linux/rpm2html/search.php?query=vnc">.
<p>
<item> The best Window manager for VNC is QVWM which is like MS Windows 98/NT/2000 interface, get
it from <url url="http://www.qvwm.org">.
<p>
<item> After starting vncserver, you can start the <bf>vncviewer</bf> program on clients
like MS Windows, Mac or Linux.
<p>
<item> See also the
<url name="List of X11 Windows Managers" url="http://www.dlhoffman.com/publiclibrary/RPM/X11_Window_Managers.html">.
</itemize>

<bf>Compiling qvwm on Solaris : </bf>
On Solaris you should install the following packages which you can get 
from <url url="http://sun.freeware.com"> - xpm, imlib, jpeg, libungif, giflib, libpng, tiff.
And you can download the binary package for solaris from
<url url="http://www.qvwm.org">.

Or you can download the qvwm source for solaris from
<url url="http://www.qvwm.org"> and compile it using gcc.

Troubleshooting compile:
You should put unsigned long before arg in usleep()
usleep((unsigned long) 10000)

The following PC X servers are available:
<itemize>
<item> Low cost, best and small size (3 MB) <url url="http://www.microimages.com"> and
        click on "X-Server (MI/X) for Windows"
<item> Humming bird eXceed 14 MB <url url="http://www.hummingbird.com">
<item> Starnet 5.2 MB<url url="http://www.starnet.com">
<p> 
There are more than 2 dozen vendors for X servers for Windows:
<item> X-win pro 6.34 MB <url url="http://www.labf.com">
<item> X-WinPro <url url="http://lab-pro.com">
<item> X-Link <url url="http://www.xlink.com/x.htm">
<item> Xoftware <url url="http://www.age.com">
<p>
University resources:
<item> University listings <url url="http://www.et.byu.edu/support/pc/xterm.html">
<item> Floppy based PC "X server" <url url="http://mirriwinni.cse.rmit.edu.au/~brad/co338/sem1/floppy.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Windows 95/NT/2000 FTP Tools<label id="ftptools">
<p>
You can also use the ftp tools on MS Windows to transfer files from a Unix/Linux (CVS repository)
to windows:
<itemize>
<item> Go to Tucows and search "ftp tools" for MS Windows <url url="http://www.tucows.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Visual Cafe(Java), JBuilder, MS Visual C++, HTML files <label id="mstools">
<p>
Using Samba and a PC X server it is possible to use CVS on MS Windows platform.
And the tools like Symantec Visual Cafe (Java), Inprise JBuilder, MS Visual C++
and others are easily supported by CVS.

You can also store the HTML files on a CVS repository via Samba and easily
access them from MS Windows.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************


-->
<sect1> Samba Admin tool <label id="samba">
<p>
To administer samba use the admin tools from <url url="http://www.samba.org">. Go here
and click on "GUI Interfaces Tools".
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Multi-User CVS Remote Repository <label id="multiuser">
-->
<sect> Security of CVS Repository <label id="cvssecurity">
<p>
To make a CVS server and CVS repository secure do the following:
<itemize>
<item> Run CVS on a stand-alone Linux/Unix box, 
see <ref id="perftuning" name="Performance Tuning">.
<item> Remove unnecessary software packages from CVS linux box - to prevent 
external vandals running it. Just in case vandals break into the system, you 
do not want to give them a chance to run dangerous programs.
<item> Consider SSH as given in the chapter <ref id="multiuser" name="Multi-User Repository">
<item> Consider Kerberos - install cvs-*-kerberos*.rpm package <url url="http://cvshome.org/dev/codelinux.html">.
<item> Visit <url url="http://www.cvshome.org"> and post your security questions in the
<url name="mailing list" url="http://cvshome.org/communication.html">.
</itemize>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Multi-User CVS Remote Repository <label id="multiuser">
-->
<sect> Multi-User CVS Remote Repository <label id="multiuser">
<p>
The Cederqvist manual at 
<url url="http://cvshome.org/docs/manual/cvs_2.html#SEC30"> 
describes how to setup CVS for external access.

In order to use CVS for a group, one has to set up a permissions 
system to allow people to access the system from other machines. 
There are three ways to do this (:server:, :pserver:, and :ext:). 
The pserver mechanism and use of rsh are 
both insecure.  Only the :ext: (with ssh) offers sufficient security 
protection.

If you set CVS_RSH to SSH or some other rsh replacement, 
the instructions <bf>may be</bf> similar to `.rhosts' but 
consult the documentation for your rsh replacement.

To get ssh visit
<url url="http://rpmfind.net"> and in the search box enter "ssh".
Or visit <url url="http://www.redhat.com/apps/download"> and in the search box enter "ssh".
Download and install the ssh RPM and then configure CVS to use it.  
See also <url url="http://www.ssh.org">.

Note: If you plan to configure CVS for use with rsh then 
you MUST do this critical step:
<code>
bash# chmod 600 .rhosts
</code>

See also JA-SIG UPortal CVS repository <url url="http://www.mis3.udel.edu/~jlaker/development">.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> RCS Shell Scripts <label id="rcs_scripts">
-->
<sect> RCS Shell Scripts <label id="rcs_scripts">
<p>
If you want to use RCS instead of CVS then you can use the following
shell scripts.
<sect1> cotree.sh <label id="cotree.sh">
<p>
<code>
#!/bin/ksh

# cotree.sh (Check Out Tree shell script)
# cotree.sh - Check out the entire RCS directory

# Usage :
# This will get the all the directories
#	unix> cotree.sh 
#
# This will get just one single directory tree
#	unix> cotree.sh <directory name>

# See also cofiles.sh

###############################################################
# Setting up RCS (Revision Control System)
# Install the RCS programs - which gives command co, ci, rcslog
# Create a rcs home directory where you want to put all the
# source code repository. Call this $RCSDIR=/home/rcs_version_control
# Setup up an environment variable RCSDIR=/home/rcs_version_control
# in $HOME/.profile file. Like -
#		export RCSDIR=/home/rcs_version_control
# Create a directory structure under $RCSDIR and check in all your
# files using ci . See 'man ci'
# Now create a link from your home directory to your project
# under $RCSDIR
# 		cd $HOME
#		mkdir $HOME/myproject
#		cd $HOME/myproject
# and run this script to get all the files and directory tree
#		cotree.sh
# This script will create the entire source-tree under user's
# home and also will have a soft link to RCS directories. Each 
# user will run this script under his home directory.
###############################################################

check_out_directory()
{
	# Root directory of RCS (revision control system)
	# like RCSDIR=/home/rcs_version_control
	RCSDIR=$1
	DIRNAME=$2

	# The given directory name must exist in rcs root directory
	if [ "$DIRNAME" = "" -o  ! -d $RCSDIR/$DIRNAME ]; then
		print "\nDirectory DIRNAME=$DIRNAME does not exist!!"
		print "\nAborting the program ... and exiting...\n"
		exit
	fi
	
	mkdir -p $DIRNAME
	ln -s $RCSDIR/$DIRNAME/RCS $DIRNAME
	(
		cd $DIRNAME

		# This fails in case of filename=sample,vv 
		# which inside RCS will be RCS/sample,vv,v
		# ls RCS | cut -d',' -f1 | xargs co
		# Use match to end of name $, as below -
		# Use ls RCS/* to avoid getting the names ./ and ../
		#ls RCS/* | cut -d'/' -f2 | sed -e's/,v$//g' | xargs co
		if [ -d RCS ]; then
			ls RCS/* | cut -d'/' -f2 | sed -e's/,v$//g' | \
			while read ii
			do
				#echo "ii is : $ii"
				if [ -f "RCS/$ii,v" ]; then
					co $ii
				fi
			done
		fi
	)
}

# Root directory of RCS (revision control system)
# like RCSDIR=/home/rcs_version_control
if [ "$RCSDIR" = "" -o ! -d $RCSDIR ]; then
	print "\nDirectory RCSDIR=$RCSDIR does not exist!!"
	print "\nAborting the program ... and exiting...\n"
	exit
fi
#echo "rcsdir is : $RCSDIR"

# If a directory argument is passed, then check out all
# files for this directory only and exit.
if [ "$1" != "" ]; then
	(cd $RCSDIR; find $1 -type d -print ) | 
	while read DIRNAME
	do
		#echo DIRNAME=$DIRNAME
		#DIRNAME=c_src
		# Send rcs root directory and dir name relative to rcs root dir
		tmpaa=` basename $DIRNAME `
		if [ "$tmpaa" != "RCS" ]; then
			check_out_directory $RCSDIR $DIRNAME
		fi
	done
else
	(cd $RCSDIR; find * -type d -print ) | 
	while read DIRNAME
	do
		echo DIRNAME=$DIRNAME
		#DIRNAME=c_src
		# Send rcs root directory and dir name relative to rcs root dir
		tmpaa=` basename $DIRNAME `
		if [ "$tmpaa" != "RCS" ]; then
			check_out_directory $RCSDIR $DIRNAME
		fi
	done
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> cofiles.sh <label id="cofiles.sh">
<p>
<code>
#!/bin/ksh

# cofiles.sh (Check Out files shell script)
# cofiles.sh - Check out all the files in current directory from RCS
# See also cotree.sh and 'man rcsclean'

if [ ! -d RCS ]; then
	print "\nDirectory RCS does not exist!!"
	print "\nAborting the program ... and exiting...\n"
	exit
fi

#echo "No. of args = " $# " and all args " $@

while true
do
	print -n "\n\nCheck-out all files in read-write mode? <y/n> [n]: "
	read ans
	if [ "$ans" = "" -o "$ans" = "n" -o "$ans" = "N" ]; then
		ans="N"
		break
	elif [ "$ans" = "y" -o "$ans" = "Y" ]; then
		ans="Y"
		break
	else
		print "\nWrong entry! Try again!!"
	fi
done
#echo "The ans is : " $ans

if [ $# -eq 0 ]; then
	# The 'ls RCS' fails in case of filename=sample,vv in RCS/sample,vv,v
	# ls RCS | cut -d',' -f1 | xargs co
	# Use match to end of name $, as below -
	if [ "$ans" = "Y" ]; then
		ls RCS | sed -e's/,v$//g' | xargs co -l 
	else
		ls RCS | sed -e's/,v$//g' | xargs co
	fi
elif [ $# -eq 1 ]; then
	if [ -f "RCS/$1,v" ]; then
		# Here, in this case $1 will be like dbalter.sql
		# and not like db*.sql....
		#echo "One arg, no. of args = " $# " and all args " $@
		if [ "$ans" = "Y" ]; then
			co -l "$1"
		else
			co "$1"
		fi
	else
		# For case where $1=db*.sql and there is no db*.sql in
		# current directory
		#echo "No files... no. of args = " $# " and all args " $@
		tmpaa="RCS/$1,v"  # will be like RCS/db*.sql,v
		ls $tmpaa | \
		while read ii
		do
			#echo "ii is : $ii"
			if [ "$ans" = "Y" ]; then
				co -l "$ii"
			else
				co "$ii"
			fi
		done
	fi
else
	for ii in $@
	do
		#echo "ii is : $ii,v"
		if [ "$ans" = "Y" ]; then
			co -l "$ii"
		else
			co "$ii"
		fi
	done
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> ciall.sh <label id="ciall.sh">
<p>
<code>
#!/bin/ksh

# ciall.sh (Check in files shell script)
# ciall.sh - Check in all the files in current directory into RCS
# This script is very useful for checking in enmass large number
# of new files into RCS. Saves time by avoiding to type the
# 'description' for every file
# And for files already in RCS, it does regular check-in command


# To convert filenames to lower case filenames, use this
# technique - use 'tr', see 'man tr'
#ls * | \
#while read ii
#do
#	jj=`echo $ii | tr [A-Z] [a-z] `
#	echo "ii is : $ii"
#	echo "jj is : $jj"
#	mv $ii $jj
#done

if [ ! -d RCS ]; then
	print "\nDirectory RCS does not exist!!"
	print "\nWill be creating RCS directory now ...\n"
	mkdir RCS
fi

print "\n\nNOTE: This is not log message!"
print "Please enter description (will be used for"
print -n "all the files checked in) : "
read description

# Option prune does not work, use -maxdepth 0
#find * -prune -type f | 

# The number of args is zero or more.... 
if  [ $# -eq 0 ]; then
	listoffiles="*"
else
	listoffiles="$@"
fi

# Option prune does not work, use -maxdepth 0
#find $listoffiles -prune -type f | 
find $listoffiles -maxdepth 0 -type f | 
while read ii
do
	#echo $ii
	if [ -f "RCS/$ii,v" ]; then
		#print "The file $ii already in RCS"
		ci -m"$description" $ii 
	else
		#print "The file $ii is new file"
		ci $ii << EOF
$description
EOF
	fi
done
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Performance Tuning of a CVS Server <label id="perftuning">
-->
<sect> Performance Tuning of a CVS Server <label id="perftuning">
<p>
For optimum performance a CVS server must be running on a stand alone Linux/Unix box.

To get more bang for a given CPU processing power, do the following:
<itemize>
<item> Recompile the Linux kernel to make it small and lean. Remove items 
which are not used. See the kernel 
howto at <url url="http://www.linuxdoc.org/HOWTO/Kernel-HOWTO.html">
<p>
<item> Turn off unneccessary Unix processes - on Linux/Unix systems run chkconfig.
<code>
bash$ su - root
bash# man chkconfig
bash# chkconfig --help
bash# chkconfig --list | grep on | less
From the above list, turn off the processes you do not want to start automatically -
bash# chkconfig --level 0123456 <service name> off
Next time when the machine is booted these services will not be started.
Now, shutdown the services manually which you just turned off.
bash# cd /etc/rc.d/init.d
bash# ./<service name> stop
</code>
<p>
<item> Do not run any other application processes which are unnecessary.
<p>
<item> Do not leave X Window running unattended because its processes
consume memory and contribute to CPU load. It can also be a serious 
security hole from outside attacks.
The X Window managers generally used are KDE, GNOME, CDE, XDM and others. 
You must exit the X Window immediately after using and most of the time
you should see a command line console login prompt on the CVS server machine.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Problem Reporting System <label id="PRS">
-->
<sect> Problem Reporting System <label id="PRS">
<p>
Along with CVS, you may want to use project tracking system or problem
reporting system. Every software project needs a problem reporting system
that track bugs and assigns them to various developers. 
See GNU gpl GNATS at <url url="http://www.gnu.org/software/gnats/gnats.html">
and
<url url="http://dcl.sourceforge.net">
And commercial PRS at <url url="http://www.stonekeep.com">
look for a project tracking system.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Configuration Management System Tools <label id="configmgt">
-->
<sect> Configuration Management System Tools <label id="configmgt">
<p>
<bf>What is Configuration Management (CM) ?</bf>

There are a number of different interpretations. 
It is about the tracking and
control of software development and its activities. That is, it concerns the 
mangement of software development projects with
respect to issues such as multiple developers working on the 
same code at the same time, targeting multiple
platforms, supporting multiple versions, and controlling the 
status of code (for example a beta test versus a real release).
Even within that scope there are different schools of thought:

<itemize>
<item>Traditional Configuration Management - checkin/checkout control 
of sources (and sometimes binaries) and the
ability to perform builds (or compiles) of the entities. Other
functions may be included as well. 

<item>Process Management - control of the software development 
activities. For example, it might check to ensure
that a change request existed and had been approved for fixing
and that the associated design, documentation,
and review activities have been completed before allowing the 
code to be "checked in" again.
</itemize>

While process management and control are necessary for a
repeatable, optimized development process, a solid
configuration management foundation for that process is essential.

Visit the following links:
<itemize>
<item> FAQ on Configuration Management tools <url url="http://www.iac.honeywell.com/Pub/Tech/CM/CMFAQ.html">
<item>Linux version control and configuration management tools <url url="http://linas.org/linux/cmvc.html">
<item> Configuration Management systems <url url="http://www.cmtoday.com/yp/commercial.html">
<item> Configuration Management Tools <url url="http://www.iac.honeywell.com/Pub/Tech/CM/CMTools.html">
<item> DevGuy CVS config mgmt <url url="http://devguy.com/fp/cfgmgmt/cvs">
<item> <url name="Yahoo category site" url="http://dir.yahoo.com/Computers_and_Internet/software/programming_tools/software_engineering/configuration_management/cvs___concurrent_versions_system">
<item> Free config mgmt tool <url url="http://www.canb.auug.org.au/~millerp/aegis/aegis.html">
<item> Free CM tools <url url="http://www.loria.fr/cgi-bin/molli/cm/wilma/fcmt">
<item> Rational ClearCase tool <url url="http://www.rational.com/products/clearcase/prodinfo.jsp">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Related Sites <label id="relatedsites">
-->
<sect> Related Sites <label id="relatedsites">
<p>
Related URLs are at: 
<itemize>
<item> Linux goodies <url url="http://www.aldev.8m.com"> 
and mirrors at
<url url="http://aldev0.webjump.com">,
<url name="angelfire" url="http://www.angelfire.com/country/aldev0">,
<url name="geocities" url="http://www.geocities.com/alavoor/index.html">,
<url name="virtualave" url="http://aldev0.virtualave.net">,
<url name="50megs" url="http://aldev0.50megs.com">,
<url name="theglobe" url="http://members.theglobe.com/aldev1/index.html">,
<url name="NBCi" url="http://members.nbci.com/alavoor">,
<url name="Terrashare" url="http://aldev.terrashare.com">,
<url name="Fortunecity" url="http://members.fortunecity.com/aldev">,
<url name="Freewebsites" url="http://aldev.freewebsites.com">,
<url name="Tripod" url="http://members.tripod.lycos.com/aldev">,
<url name="Spree" url="http://members.spree.com/technology/aldev">,
<url name="Escalix" url="http://www.escalix.com/freepage/aldev">,
<url name="Httpcity" url="http://www.httpcity.com/aldev/index.html">,
<url name="Freeservers" url="http://aldev.freeservers.com">.

<item> CVS Bubbles <url url="http://www.loria.fr/~molli/cvs-index.html">
<item> CSSC (SCCS like system) 
<url url="http://cssc.sourceforge.net"> and
<url name="mirror-site" url="ftp://alpha.gnu.org/pub/gnu/CSSC">
<item> SCCS for Linux <url url="http://www.bitmover.com/bitkeeper">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> SCCS v/s CVS-RCS
-->
<sect> SCCS v/s CVS-RCS
<p>
SCCS (Source Code Control System) 
is no longer being enhanced or improved. 
The general consensus has been that this tool is clumsy and not
suited to large numbers of users working on one project. 
Actually, SCCS interleaves 
all the versions, but it can make new development get 
<bf>progressively slower</bf>. Hence, SCCS is NOT recommended for
new projects; however, it is still there to support old code base in SCCS.

RCS (Revision Control System) is often considered to be 
better than SCCS. One reason for this is that RCS baselines the most
recent version and keeps deltas for earlier ones, making new
development faster. Additional discussions concerning SCCS vs RCS
are at <url url="http://www.faqs.org/faqs/unix-faq/faq/part7">

<bf>Note that RCS learned from the mistakes of SCCS... </bf>

CVS, which requires RCS, extends RCS 
to control concurrent editing of sources by several users
working on releases built from a hierarchical set of 
directories. "RCS is [analogous to using] assembly language, while CVS is
[like using] Pascal". 
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Other Formats of this Document
-->
<sect> Other Formats of this Document
<p>
This document is published in 14 different formats namely: DVI, Postscript, 
Latex, Adobe Acrobat PDF,
LyX, GNU-info, HTML, RTF(Rich Text Format), Plain-text, Unix man pages, single 
HTML file, SGML (Linuxdoc format), SGML (Docbook format), and MS WinHelp format.

This howto document is located at:
<itemize>
<item> <url url="http://www.linuxdoc.org"> and click on HOWTOs and search 
for the howto document name using CTRL+f or ALT+f within the web-browser.
</itemize>

You can also find this document at the following mirrors sites: 
<itemize>
<item> <url url="http://www.caldera.com/LDP/HOWTO">
<item> <url url="http://www.linux.ucla.edu/LDP">
<item> <url url="http://www.cc.gatech.edu/linux/LDP">
<item> <url url="http://www.redhat.com/mirrors/LDP">

<item> Other mirror sites near you (network-address-wise) can be found at
<url url="http://www.linuxdoc.org/mirrors.html">
select a site and go to directory /LDP/HOWTO/xxxxx-HOWTO.html
</itemize>


<itemize>
<item>
You can get this HOWTO document as a single file tar ball in HTML, DVI, 
Postscript or SGML formats from -
<url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO/other-formats/">
and <url url="http://www.linuxdoc.org/docs.html#howto">
<p>
<item>Plain text format is in: <url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
<p>
<item>Single HTML file format is in: 
<url url="http://www.linuxdoc.org/docs.html#howto">
<p> A single HTML file can be created with the command (see man sgml2html) - 
sgml2html -split 0   xxxxhowto.sgml
<p>
<item>Translations to other languages like French, German, Spanish, 
Chinese, and Japanese are in
<url url="ftp://www.linuxdoc.org/pub/Linux/docs/HOWTO">
and <url url="http://www.linuxdoc.org/docs.html#howto">
Any help from you to translate to other languages is welcome.
</itemize>
The document is written using a tool called "SGML-Tools" which can be got from: 
<url url="http://www.sgmltools.org">
Compiling the source you will get the following commands like:
<itemize>
<item>sgml2html xxxxhowto.sgml     (to generate html file)
<item>sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
<item>sgml2rtf  xxxxhowto.sgml     (to generate RTF file)
<item>sgml2latex xxxxhowto.sgml    (to generate latex file)
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Acrobat PDF format <label id="acrobatpdf">
<p>
A PDF file can be generated from postscript file using 
either acrobat <bf>distill</bf> or <bf>Ghostscript</bf>.
And a postscript file is generated
from DVI which in turn is generated from a LaTex file.
You can download distill software from <url url="http://www.adobe.com">. Given below 
is a sample session:
<code>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &
</code>
Or you can use the Ghostscript command <bf>ps2pdf</bf>.
ps2pdf is a work-alike for nearly all the functionality of 
Adobe's Acrobat Distiller product: it
converts PostScript files to Portable Document Format (PDF) files. 
<bf>ps2pdf</bf> is implemented as a very small command script 
(batch file) that invokes Ghostscript, selecting a special "output device"
called <bf>pdfwrite</bf>. In order to use ps2pdf, the pdfwrite 
device must be included in the makefile when Ghostscript was compiled;
see the documentation on building Ghostscript for details.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Convert Linuxdoc to Docbook format <label id="linuxdoc2docbook">
<p>
This document is written in linuxdoc SGML format. The Docbook SGML format
supercedes the linuxdoc format and has a lot more features than linuxdoc.
The linuxdoc is very simple and easy to use. To convert linuxdoc SGML 
file to Docbook SGML use the program <bf>ld2db.sh</bf> and some Perl scripts.
The ld2db output is not 100% clean and you need to use the <bf>clean_ld2db.pl</bf>
Perl script. You may need to manually correct a few lines in the document.
<itemize>
<item> Download the ld2db program from <url url="http://www.dcs.gla.ac.uk/~rrt/docbook.html">
or from <url name="Al Dev site" url="http://www.aldev.8m.com/cppsrc.html">
<item> Download the cleanup_ld2db.pl perl script from
from <url name="Al Dev site" url="http://www.aldev.8m.com/cppsrc.html">
</itemize>
The ld2db.sh is not 100% clean, so you will get some errors when you run it.
<code>
	bash$ ld2db.sh file-linuxdoc.sgml db.sgml
	bash$ cleanup.pl db.sgml > db_clean.sgml
	bash$ gvim db_clean.sgml 
	bash$ docbook2html db.sgml
</code>
And you may have to manually edit some of the minor errors after 
running the Perl script. For example you may need to put closing tag <
/Para> for each <
Listitem>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Convert to MS WinHelp format <label id="mswinhelp">
<p>
You can convert the SGML howto document to a Microsoft Windows Help file, 
First convert the sgml to html using:
<code>
	bash$ sgml2html xxxxhowto.sgml     (to generate html file)
	bash$ sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
</code>
Then use the tool <url name="HtmlToHlp" url="http://javadocs.planetmirror.com/htmltohlpe.html">.
You can also use sgml2rtf and then use the RTF files for generating winhelp files.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Reading various formats <label id="readformats">
<p>
In order to view the document in dvi format, use the xdvi program. The xdvi
program is located in tetex-xdvi*.rpm package in Redhat Linux which can be
located through ControlPanel | Applications | Publishing | TeX menu buttons.
	To read a dvi document give the command:
<tscreen><verb>
	xdvi -geometry 80x90 howto.dvi
	man xdvi
</verb></tscreen>
	And resize the window with the mouse.
	To navigate use Arrow keys, Page Up, Page Down keys, also
	you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' letter
	keys to move up, down, center, next page, previous page etc.
	To turn off expert menu press 'x'.

You can read a postscript file using the program 'gv' (ghostview) or 
'ghostscript'.
The ghostscript program is in the ghostscript*.rpm package and the gv 
program is in the gv*.rpm package in Redhat Linux
which can be located through ControlPanel | Applications | Graphics menu 
buttons. The gv program is much more user friendly than ghostscript.
Also ghostscript and gv are available on other platforms like OS/2,
Windows 95 and NT. You  can view this document even on those platforms.
 
<itemize>
<item>Get ghostscript for Windows 95, OS/2, and for 
all OSes from <url url="http://www.cs.wisc.edu/~ghost">
</itemize>

To read a postscript document give the command:
<tscreen><verb>
		gv howto.ps
		ghostscript howto.ps
</verb></tscreen>

You can read an HTML format document using Netscape Navigator, Microsoft Internet
explorer, Redhat Baron Web browser or any of the 10 other web browsers.

You can read the latex, LyX output using LyX an X Window front end to LaTex.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Copyright
-->
<sect> Copyright and License
<p>
Copyright Al Dev (Alavoor Vasudevan) 1998-2000.

License is GNU GPL, but it is requested that you retain the author's name
and email on all copies.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sget <label id="sget">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sget
# Program to check out the file from CVS read-only

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number/symbolic_tag_name] <file/directory name> "
	print "The options -r are optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " $cmdname some_directory "
	print "Extract by symbolic revision tag like - "
	print " $cmdname -r REVISION_1 some_directory "
	print " "
	exit
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
	Usage
fi

bkextn=sget_bak

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# Check if file already exists....
if [ -f "$HOME/$subdir/$fname" ]; then
	tmpaa="$HOME/$subdir/$fname"
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		print "\nError: The file is writable. Aborting $cmdname ......"
		print "       You should either backup, scommit or delete the file and"
		print "       try $cmdname again\n"
		exit
	fi
fi

# Move the file
mkdir -p "$HOME/$subdir"
touch "$HOME/$subdir/$fname" 2>/dev/null
\mv -f "$HOME/$subdir/$fname" "$HOME/$subdir/$fname.$bkextn"

# Create subshell
(
	cd $homedir

	# Use -A option to clear all sticky flags
	if [ "$FLAG1" = "" ]; then
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout -A $fname
		else
			cvs -r checkout -A "$subdir/$fname"
		fi
	else
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout -A -$FLAG1 $OARG1 $fname
		else
			cvs -r checkout -A -$FLAG1 $OARG1 "$subdir/$fname"
		fi
	fi
)
#pwd

if [ -f "$HOME/$subdir/$fname" ]; then
	print "\nREAD-ONLY copy of the file $subdir/$fname obtained."
	print "Done $cmdname"
	#print "\nTip (Usage): $cmdname <file/directory name> \n"
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sedit <label id="sedit">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sedit
# Program to check out the file from CVS read/write mode with locking

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
#       print "\nUsage: $cmdname [-r revision_number] [-F] <filename>"
#       print "The options -r, -F are optional "
#       print "The option -F is FORCE edit even if file is "
#       print "locked by another developer"

        print "\nUsage: $cmdname [-r revision_number] <filename>"
        print "The options -r are optional "

        print "For example - "
        print " $cmdname -r 1.1 foo.cpp"
        print " $cmdname foo.cpp "
#       print " $cmdname -F foo.cpp "
        print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
#while getopts r:F ii
while getopts r: ii
do
        case $ii in
        r) FLAG1=$ii; OARG1="$OPTARG";;
#       F) FLAG2=$ii; OARG2="$OPTARG";;
        ?) Usage; exit 2;;
        esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
        Usage
        exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
        print "\nError: \$HOME is not set!!\n"
        exit
fi

bkextn=sedit_bak

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# If file is already checked out by another developer....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi
mkdir -p "$CVSROOT/$subdir/Locks" 2>/dev/null

if [ ! -e "$CVSROOT/$subdir/$fname,v" ]; then
        print "\nError: File $fname does not exist in CVS repository!!\n"
        exit
fi

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the tip revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sedit-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs log $fname | head -6 | grep head: | awk '{print $2}' > $tmpfile
		else
			cvs log "$subdir/$fname" | head -6 | grep head: | awk '{print $2}' > $tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
#echo "lockfile is : " $lockfile
#if [ -e $lockfile -a "$FLAG2" = "" ]; then
if [ -e $lockfile ]; then
        print "\nError: File $fname Revision $OARG1 already locked by another developer !!"
        aa=` ls -l $lockfile | awk '{print "Locking developers unix login name is = " $3}' `
        print $aa
        print "That developer should do scommit OR sunlock to release the lock"
        print " "
#       print "You can also use -F option to force edit the file even if"
#       print "the file is locked by another developer. But you must talk to"
#       print "other developer to work concurrently on this file."
#       print "For example - this option is useful if you work on a seperate"
#       print "C++ function in the file which does not interfere with other"
#       print "developer."
#       print " "
        exit
fi

# Get read-only copy now....
if [ ! -e "$HOME/$subdir/$fname" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -r checkout $fname 1>/dev/null
		else
			cvs -r checkout "$subdir/$fname" 1>/dev/null
		fi
	)
fi

# Check if file already exists....
tmpaa="$HOME/$subdir/$fname"
if [ -f $tmpaa ]; then
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		print "\nError: The file is writable. Aborting $cmdname ......"
		print "       You must backup, scommit or delete file and"
		print "       try $cmdname again\n"
		exit
	fi
	#print "\nNote: The file $tmpaa is read-only."
	#print "Hence I am moving it to $tmpaa.$bkextn ....\n"
	\mv -f $tmpaa $tmpaa.$bkextn
	chmod 444 $tmpaa.$bkextn
elif [ -d $tmpaa ]; then
	print "\nError: $tmpaa is a directory and NOT a file. Aborting $cmdname ....\n"
	exit
fi

# Create subshell
print "\nNow getting the file $fname from CVS repository ...\n"
(
	cd $homedir
	# Use -A option to clear the sticky tag and to get
	# the HEAD revision version
	if [ "$FLAG1" = "" ]; then
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -w checkout -A $fname
		else
			cvs -w checkout -A "$subdir/$fname"
		fi
	else
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs -w checkout -A -$FLAG1 $OARG1 $fname
		else
			cvs -w checkout -A -$FLAG1 $OARG1 "$subdir/$fname"
		fi
	fi
)

if [ -e "$HOME/$subdir/$fname" ]; then
	# The lockfile is $CVSROOT/$subdir/Locks/$fname-$OARG1
	touch $lockfile
	if [ -e $lockfile ]; then
		print "\nDone $cmdname"
	else
		print "\nFatal Error: File $fname Revision $OARG1 not locked !!"
		print "\nCheck the reason for this failure.. before proceeding..."
	fi
fi

#pwd

#print "\nTip (Usage): $cmdname <filename> \n"

</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> scommit <label id="scommit">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program scommit
# Program to commit the changes and check in the file into CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play a important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number] <filename>"
	print "The options -r are optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 1 ]; then
	Usage
	exit 2
fi

if [ -d $1 ]; then
	Usage
	exit 2
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

# Find sub-directory
cur_dir=`pwd`
#echo $cur_dir
len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
# echo "subdir is : " $subdir
# echo "fname is : " $fname

# If file is already checked out by another user....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
	print "\nError: \$CVSROOT is not set!!\n"
	exit
fi
mkdir -p "$CVSROOT/$subdir/Locks" 2>/dev/null

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the working revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sedit-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs status $fname 2>/dev/null | grep "Working revision:" | awk '{print $3}' >$tmpfile
		else
			cvs status "$subdir/$fname" 2>/dev/null | grep "Working revision:" | awk '{print $3}' >$tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

if [ "$OARG1" = "" -o "$OARG1" = "New" -o "$OARG1" = "NEW" ]; then
	print "The file $subdir/$fname is NEW, it is not in the CVS repository"
	print "The OARG1 is $OARG1"
else
	lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"

	if [ -e $lockfile ]; then
		# Check if this revision is owned by you...
		aa=` ls -l $lockfile | awk '{print $3}' `
		userid=`id | cut -d'(' -f2 | cut -d')' -f1 `
		if [ "$aa" != "$userid" ]; then
			print " "
			print "The file $subdir/$fname is NOT locked by you!!"
			print "It is locked by unix user name $aa and your login name is $userid"
#                       print "If you are working concurrently with other developer"
#                       print "and you used -F option with sedit."
			print "You need to wait untill other developer does scommit"
			print "or sunlock"
			print "Aborting the $cmdname ...."
			print " "
			exit 2
		fi
	else
		# The file must exist in cvs 
		if [ -f "$CVSROOT/$subdir/$fname,v" ]; then
			print "You did not lock the file $subdir/$fname with sedit!!"
			print "Aborting the $cmdname ...."
			exit 2
		else
			print "\nThe file $subdir/$fname does not exist in CVS repository yet!!"
			print "You should have done sadd on $subdir/$fname ...."
			exit 2
		fi
	fi
fi

# Operate inside sub-shell - and operate from root directory
(
	cd $homedir

	# Do not allow directory commits for now ...
	#if [ -d "$subdir/$fname" ]; then
	#	cvs commit "$subdir/$fname"
	#fi

	if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
		cvs commit $fname
	else
		cvs commit "$subdir/$fname"
	fi
	exit_status=$?

	if [ $exit_status -eq 0 ]; then
		lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
		if [ -e $lockfile ]; then
			\rm -f $lockfile
		fi

		# Must change the permissions on file in case
		# there are no changes to file
		chmod a-w "$HOME/$subdir/$fname"
		print "\nDone $cmdname. $cmdname successful"
		#print "\nTip (Usage): $cmdname <filename/directory name>\n"
	fi
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> supdate <label id="supdate">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program supdate
# Program to update the file from CVS read/write mode

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename>"
	exit
fi

# Put double quotes to protect spaces in $1
tmpaa="$1"

# Check if file already exists....
if [ $# -gt 0 -a  -f $tmpaa ]; then
	user_perms=" "
	group_perms=" "
	other_perms=" "
	user_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b3-3 `
	group_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b6-6 `
	other_perms=`ls -l $tmpaa | awk '{print $tmpaa }' | cut -b9-9 `
	if [ "$user_perms" = "w" -o "$group_perms" = "w"  \
			-o "$other_perms" = "w" ]; then
		while :
		do
			print "\n$cmdname will backup your working file "
			print "$tmpaa to $tmpaa.supdate_bak before doing any merges."
			print "Are you sure you want the merge the changes from"
			print -n "CVS repository to your working file ? <y/n> [n]: "
			read ans
			if [ "$ans" = "y" -o "$ans" = "Y" ]; then
				if [ -f $tmpaa.supdate_bak ]; then
					print "\nWarning : File $tmpaa.supdate_bak already exists!!"
					print "Please examine the file $tmpaa.supdate_bak and delete it"
					print "and then re-try this $cmdname "
					print "Aborting $cmdname ...."
					exit
				else
					cp $tmpaa $tmpaa.supdate_bak
					break
				fi
			elif [ "$ans" = "n" -o "$ans" = "N" -o "$ans" = "" -o "$ans" = " " ]; then
				exit
			fi
		done
	fi
fi

if [ -d $tmpaa ]; then
	print "\nDirectory update is disabled because cvs update"
	print "merges the changes from repository to your working directory."
	print "Hence give the filename to update - as shown below: "
	print " Usage: $cmdname <filename>"
	exit
#       cvs update
else
	cvs update $tmpaa
fi

print "\nDone $cmdname. $cmdname successful"
print "\n\nThe original file is backed-up to $tmpaa.supdate_bak"
print "\nHence your original file is SAVED to $tmpaa.supdate_bak"
print "\n\n"
#print "\nTip (Usage): $cmdname <filename/directory name>\n"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sunlock <label id="sunlock">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sunlock
# Program to unlock the file to release the lock done by sedit

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname [-r revision_number] <filename>"
	print " The options -r is optional "
	print "For example - "
	print " $cmdname -r 1.1 foo.cpp"
	print " $cmdname foo.cpp "
	print " "
}

# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r: ii
do
	case $ii in
	r) FLAG1=$ii; OARG1="$OPTARG";;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

if [ $# -lt 1 ]; then
	Usage
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
	print "\nError: \$CVSROOT is not set!!\n"
	exit
fi

if [ ! -e "$CVSROOT/$subdir/$fname,v" ]; then
	print "\nError: File $fname does not exist in CVS repository!!\n"
	exit
fi

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Get the tip revision number of the file....
# Use tmpfile as the arg cannot be set inside the sub-shell
tmpfile=$homedir/sunlock-lock.tmp
\rm -f $tmpfile 2>/dev/null
if [ "$FLAG1" = "" ]; then
	# Operate inside sub-shell - from root directory
	(
        cd $homedir
		if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
			cvs log $fname | head -6 | grep head: | awk '{print $2}' > $tmpfile
		else
			cvs log "$subdir/$fname" | head -6 | grep head: | awk '{print $2}' > $tmpfile
		fi
	)
	OARG1=`cat $tmpfile`
	\rm -f $tmpfile 2>/dev/null
fi

lockfile="$CVSROOT/$subdir/Locks/$fname-$OARG1"
#echo lockfile is : $lockfile
if [ ! -e $lockfile ]; then
	print "\nFile $fname revision $OARG1 is NOT locked by anyone"
	print " "
	exit
fi

ans=""
while :
do
	print "\n\n***************************************************"
	print "WARNING: $cmdname will release lock and enable other"
	print "         developers to edit the file. It is advisable"
	print "         to save your changes with scommit command"
	print "***************************************************"
	print -n "\nAre you sure you want to unlock the file <y/n>? [n]: "
	read ans
	if [ "$ans" = "" -o "$ans" = " " -o "$ans" = "n" -o "$ans" = "N" ]; then
		print "\nAborting $cmdname ...."
		exit
	fi
	if [ "$ans" = "y" -o "$ans" = "Y" ]; then
		print "\n\n\n\n\n "
		print "CAUTION: You may lose all the changes made to file!!"
		print -n "Are you sure? Do you really want to unlock the file <y/n>? [n]: "
		read ans
		if [ "$ans" = "y" -o "$ans" = "Y" ]; then
			break
		elif [ "$ans" = "" -o "$ans" = " " -o "$ans" = "n" -o "$ans" = "N" ]; then
			exit
		else
			print "\n\nWrong entry. Try again..."
			sleep 1
		fi
	else
		print "\n\nWrong entry. Try again..."
		sleep 1
	fi
done

if [ -e $lockfile ]; then
	\rm -f $lockfile
	print "\nDone $cmdname"
else
	print "\nFile $fname is NOT locked by anyone"
	print " "
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> slist <label id="slist">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

	Note that there is also another Unix
	command by the name slist (list available Netware servers). You
	should make sure the CVS script slist comes before other in your
	PATH environment.

<code>
#!/bin/ksh

# CVS program slist
# Program to list all edited source files from CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

# Usage:
# 		$ slist      (All files and sub-directories)
# 		$ slist *.*      (All files)
# 		$ slist *      (All files and sub-directories)
# 		$ slist ab*      (All files starting with ab wild-card)

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir

# If file is already checked out by another developer....
cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi

# If the current directory tree is not in cvs-root then exit
if [ ! -d $CVSROOT/$subdir ]; then
	print "\nThe directory $subdir does not exist in $CVSROOT"
	exit
fi

#echo "no of params : " $#
#echo "The arg $ 1 is : " $1
#echo "all args : " $@

if [ $# -eq 0 ]; then
	#tmpbb=` find * -prune -type d `
	tmpbb=` find * -maxdepth 0 -type d `
elif [ $# -eq 1 ]; then
	if [ "$1" = "." ]; then
		#tmpbb=` find * -prune -type d `
		tmpbb=` find * -maxdepth 0 -type d `
	else
		if [ -d $1 -a ! -d $CVSROOT/$subdir/$1 ]; then
			print "\nThe directory $subdir/$1 does not exist in $CVSROOT"
			exit
		fi
		tmpbb=$@
	fi
else
	tmpbb=$@
fi

#echo "The tmpbb is : " $tmpbb

# Now, remove all the directory names which are not in cvs-root
dirnames=""
for ii in $tmpbb ; do
	if [ -d $CVSROOT/$subdir/$ii ]; then
		dirnames="$dirnames $ii "
	fi
done
#echo "The dirnames is : " $dirnames

if [ "$dirnames" != "" ]; then
	find $dirnames  -type f |
	while read ii
	do
		# List only those files which are in cvs system
		if [ -f "$CVSROOT/$subdir/$ii,v" ]; then
			#echo "ii is : " $ii
			ls -l $ii | grep ^\-rw
		fi
	done;
fi

# Get all the files in the current directory
listfiles=`ls $tmpbb `
# Option prune does not work use maxdepth
#find * -prune -type f |
find * -maxdepth 0 -type f |
while read ii
do
	for jj in $listfiles ; do
		if [ "$jj" = "$ii" ]; then
			# List only those files which are in cvs system
			if [ -f "$CVSROOT/$subdir/$ii,v" ]; then
				#echo "ii is : " $ii
				ls -l $ii | grep ^\-rw
			fi
		fi
	done
done;
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sinfo <label id="sinfo">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sinfo
# Program to get the status of files in working directory

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname [file/directory name] "
	print "For example - "
	print " $cmdname foo.cpp"
	print " $cmdname some_directory "
	print " "
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname=$1
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Create subshell
if [ -f $1 ]; then
	(
        cd $homedir
		clear
		print "\ncvs status is : "
        cvs status "$subdir/$fname"
	)
elif [ -d $1 ]; then
	(
		cd $homedir
		clear
		print "\ncvs status is : "
		tmpfile="$homedir/cvs_sinfo.tmp"
		rm -f $tmpfile
        echo "  " >> $tmpfile
        echo "  ****************************************" >> $tmpfile
        echo "        Overall Status of Directory" >> $tmpfile
        echo "  ****************************************" >> $tmpfile
        cvs release "$subdir/$fname" 1>>$tmpfile 2>>$tmpfile << EOF
N
EOF
        echo "\n   -------------------------------\n" >> $tmpfile

        aa=`cat $tmpfile | grep ^"M " | awk '{print $2}' `
        for ii in $aa
        do
			jj="(cd $homedir; cvs status \"$subdir/$ii\" );"
			echo $jj | /bin/sh  \
					| grep -v Sticky | awk '{if (NF != 0) print $0}' \
					1>>$tmpfile 2>>$tmpfile
        done

        cat $tmpfile | grep -v ^? | grep -v "Are you sure you want to release" \
        | less
        rm -f $tmpfile
	)
else
	print "\nArgument $1 if not a file or directory"
	exit
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> slog <label id="slog">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program slog
# Program to list history of the file in CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
        print "\nUsage: $cmdname <filename> \n"
        exit
fi

# Check if file does not exist....
if [ ! -f "$1" ]; then
        print "\nError: $1 is NOT a file. Aborting $cmdname ......"
        exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname="$1"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside a sub-shell
(
	cd $homedir
	cvs log "$homedir/$subdir/$fname" | less
)

print "\nDone $cmdname. $cmdname successful"
#print "\nTip (Usage): $cmdname <filename>\n"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sdif <label id="sdif">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sdif
# Program to see difference of the working file with CVS copy

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

Usage()
{
	print "\nUsage: $cmdname <filename> "
	print "$cmdname -r<rev1> -r<rev2> <filename> \n"
	exit
}

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

FLAG1=""
FLAG2=""
OARG1=""
OARG2=""
# Command getopt will not supported in next major release.
# Use getopts instead.
while getopts r:r: ii
do
	case $ii in
	r)
		if [ "$FLAG1" = "" ]; then
			FLAG1=$ii;
			OARG1="$OPTARG"
		else
			FLAG2=$ii;
			OARG2="$OPTARG"
		fi
		;;
	?) Usage; exit 2;;
	esac
done
shift ` expr $OPTIND - 1 `

if [ "$FLAG2" = "" ]; then
	FLAG2=r
	OARG2=HEAD
fi

cur_dir=`pwd`
#echo $cur_dir

len=${#homedir}
len=$(($len + 2))
#echo $len

subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname $1`
if [ "$tmpaa" = "." ]; then
	fname="$1"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename $1`
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside sub-shell
(
	cd $homedir
	if [ "$FLAG1" = "" ]; then
		cvs diff -r HEAD "$homedir/$subdir/$fname" | less
	else
		cvs diff -$FLAG1 $OARG1 -$FLAG2 $OARG2 "$homedir/$subdir/$fname" | less
	fi
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sadd <label id="sadd">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sadd
# Program to add the file to CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`
if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename/directory> \n"
	exit
fi

onearg="$1"
if [ ! -f "$onearg" -a ! -d "$onearg" ]; then
	print "\nArgument $onearg is not a file or a directory!"
	print "Usage: $cmdname <filename/directory> \n"
	exit
fi

# Argument is a directory name .....
homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cvs_root=` echo $CVSROOT | cut -f1 -d' '  `
if [ "$cvs_root" = "" ]; then
        print "\nError: \$CVSROOT is not set!!\n"
        exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname "$onearg" `
if [ "$tmpaa" = "." ]; then
	fname="$onearg"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename "$onearg" `
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Check if file exists ....
if [ $# -eq 1 ]; then
	if [ -f "$onearg" ]; then
		cvs add "$onearg"
		exit
	fi
elif [ $# -gt 1 ]; then
	print "\n\n\nAdding all the files in the current directory to CVS"
	print "Directories will not be added"
	print -n "Hit return to continue or CTRL+C to abort..."
	read ans
	for ii in $@
	do
		if [ -f "$ii" ]; then
			cvs add "$ii"
		fi
	done;
	exit
fi

# When $subdir is "." then you are at the root directory
if [ "$subdir" = "." ]; then
	# The $onearg is a directory and not a file at this point...
	if [ -d "$CVSROOT/$onearg" ]; then
		print "\nDirectory $onearg already exists in CVSROOT"
		exit
	else
		# You are adding at root directory $CVSROOT
		if [ "$2" = "" -o "$3" = "" ]; then
			print "\nUsage: $cmdname <directory> <vendor tag> <release tag>"
			print "For example - "
			print " $cmdname foo_directory V_1_0 R_1_0"
			exit
		else
			(
				cd "$homedir/$subdir";
				cvs import "$onearg" $2 $3
			)
		fi
	fi
else
	# If current directory exists in CVS...
	if [ -d "$CVSROOT/$subdir/$onearg" ]; then
		print "\nDirectory $onearg already in CVS repository!"
		exit
	else
		(
			if [ -d "$homedir/$subdir/$onearg/CVS" ]; then 
				print "\nError: Directory $homedir/$subdir/$onearg/CVS exists!!"
				print "\nAborting now ...."
				exit
			fi

			# For import you MUST change to target directory
			# and you MUST specify full-path starting with $subdir
			cd "$homedir/$subdir/$onearg";
			cvs import "$subdir/$onearg" Ver_1 Rel_1
		)
	fi
fi
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sdelete <label id="sdelete">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sdelete
# Program to delete the file from CVS

# Every filename is composed of 3 parts - Home directory, sub-directory 
# and the filename. The full-path is $HOME/$subdir/$fname
# And in CVS the same directory structure is maintained (by 
# variable $subdir) therefore in cvs we will have $CVSROOT/$subdir/$fname
# In this program these 4 variables $HOME, $CVSROOT, $subdir and $fname
# play an important role. For example, sample values can be like
# HOME=/home/aldev, subdir=myproject/src CVSROOT=/home/cvsroot 
# and fname=foo.cpp

# Caution: Put double-quotes to protect the variables having 
#          spaces, like "$HOME/$subdir" if subdir is 'some foo.cpp'

cmdname=`basename $0`

if [ $# -lt 1 ]; then
	print "\nUsage: $cmdname <filename> \n"
	exit
fi

onearg="$1"

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir
tmpaa=`dirname "$onearg" `
if [ "$tmpaa" = "." ]; then
	fname="$onearg"
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	fi
else
	fname=`basename "$onearg" `
	if [ "$subdir" = "" ]; then
		subdir=$tmpaa
	else
		subdir="$subdir/$tmpaa"
	fi
fi
#echo "subdir is : " $subdir
#echo "fname is : " $fname

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

# Operate inside a sub-shell ...
(
	cd $homedir

	# Check if file does not exist....
	if [ ! -f "$subdir/$fname" ]; then
		# Try to get the file from CVS
		sget "$subdir/$fname"
		if [ ! -f "$subdir/$fname" ]; then
			print "\nError: $subdir/$fname does NOT exist in CVS repository."
			print "\nAborting $cmdname ......"
			exit
		fi
	fi

	bkextn=cvs_sdelete_safety_backup
	\mv -f "$subdir/$fname" "$subdir/$fname.$bkextn" 

	cvs remove "$subdir/$fname"

	print "\nsdelete command removes the file from CVS repository"
	print "and archives the file in CVS Attic directory. In case"
	print "you need this file in future then contact your CVS administrator"
	print " "

	print "\nDone $cmdname. $cmdname successful"
	print "Run scommit on $homedir/$subdir/$fname to"
	print "make this change permanent"
	\mv -f "$subdir/$fname.$bkextn" "$subdir/$fname"
)
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect> sfreeze <label id="sfreeze">
<p>
<bf>NOTE : <it>Get the Korn shell /bin/ksh by installing pdksh*.rpm from 
the Linux contrib cdrom</it></bf>

Save this file as a text file and chmod a+rx on it.

<code>
#!/bin/ksh

# CVS program sfreeze
# Program to freeze and cut out the release of source tree from CVS

cmdname=`basename $0`

Usage()
{
	clear
	print "\nUsage: $cmdname symbolic_tag <directory name> "

	print "\nFor example :- "
	print "   cd \$HOME"
	print "   $cmdname  REVISION_1   myprojectsource_directory"
	print "To see the list of revisons do -"
	print "slog <filename> and see the symbolic name and do -"
	print "cvs history -T"

	print "\nTo create a branch off-shoot from main trunk, use"
	print "the -b and -r options which makes the tag a branch tag. This is"
	print "useful for creating a patch to previously released software"
	print "For example :- "
	print "   cd \$HOME"
	print "   cvs rtag -b -r REVISION_1   REVISION_1_1   myprojectsource_directory"
	print " "

#   print "\nTag info is located at \$CVSROOT/CVSROOT/taginfo,v"
#   print "You can do - cd $HOME; sget CVSROOT"
#   print "to see this file"
	exit
}

# Command getopt will not supported in next major release.
# Use getopts instead.
#while getopts r: ii
#do
#	case $ii in
#		r) FLAG1=$ii; OARG1="$OPTARG";;
#		?) Usage; exit 2;;
#	esac
#done
#shift ` expr $OPTIND - 1 `

#echo FLAG1 = $FLAG1 , OARG1 = $OARG1

if [ $# -lt 2 ]; then
	Usage
fi

if [ ! -d $2 ]; then
	print "\nError: Second argument $2 is not a directory!"
	print "       Aborting $cmdname...."
	print " "
	exit
fi

homedir=` echo $HOME | cut -f1 -d' '  `
if [ "$homedir" = "" ]; then
	print "\nError: \$HOME is not set!!\n"
	exit
fi

cur_dir=`pwd`
len=${#homedir}
len=$(($len + 2))
subdir=` echo $cur_dir | cut -b $len-2000 `
#echo "subdir is : " $subdir

# CVS directory in your local directory is required for all commands..
if [ ! -d  "$homedir/$subdir/CVS" ]; then
	#tmpaa=` (cd "$CVSROOT/$subdir"; find * -prune -type f -print | head -1 ) `
	tmpaa=` (cd "$CVSROOT/$subdir"; find * -maxdepth 0 -type f -print | head -1 ) `
	tmpbb=`basename $tmpaa | cut -d',' -f1 `
	if [ "$tmpaa" = "" -o ! -f "$CVSROOT/$subdir/$tmpbb,v" ]; then
		print "\nThe directory $homedir/$subdir/CVS does not exist"
		print "You must do a sget on `basename $subdir` directory. Give -"
		print "       cd $homedir/`dirname $subdir` "
		print "       sget `basename $subdir` "
		exit
	else
		# Now try to create CVS in local dir by sget
		(
			cd "$homedir"
			if [ "$subdir" = "." ]; then  # don't use dot, will mess up cvs
				cvs -r checkout -A $tmpbb
			else
				cvs -r checkout -A "$subdir/$tmpbb"
			fi
		)
	fi
fi

if [ "$cur_dir" != "$homedir" ]; then
	print "\nYou are not in home directory $homedir!!"
	print "You must give the sfreeze command "
	print "from home directory $homedir"
	exit
fi

# cvs rtag symbolic_tag <directory name>
cvs rtag $1 $2

print "\nDone $cmdname. $cmdname successful"
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
</article>
