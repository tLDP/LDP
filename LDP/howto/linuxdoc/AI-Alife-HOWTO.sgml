<!--  -->

<!doctype linuxdoc system>

<article>

<title>GNU/Linux AI &amp; Alife HOWTO
<author>by <htmlurl url="mailto:jae@zhar.net" name="John Eikenberry">
<date>v2.2, 25 Aug 2005

<!-- hhmts start -->
<!-- hhmts end -->

<abstract>
This howto mainly contains information about, and links to,
various AI related software libraries, applications, etc. 
that work on the GNU/Linux platform. All of it is (at least) 
free for personal use. 

The new master page for this document is 
<htmlurl url="http://zhar.net/gnu-linux/howto/" 
    name="http://zhar.net/gnu-linux/howto/">
</abstract>

<toc>

<sect>Introduction
<p>

<sect1>Purpose
<p>

The GNU/Linux OS has evolved from its origins in hackerdom to a full
blown UNIX, capable of rivaling any commercial UNIX.  It now provides
an inexpensive base to build a great workstation.  It has shed its
hardware dependencies, having been ported to DEC Alphas, Sparcs,
PowerPCs, and many others.  This potential speed boost along with its
networking support will make it great for workstation clusters.  As a
workstation it allows for all sorts of research and development,
including artificial intelligence and artificial life.


The purpose of this Howto is to provide a source to find out
about various software packages, code libraries, and anything else
that will help someone get started working with (and find resources
for) artificial intelligence, artificial life, etc.  All done with 
GNU/Linux specifically in mind.

<sect1>What's New
<p>

<itemize>
    <item>v2.2 -

    Fixed a some bad links and was forced to move a few entries into
    the MIA (missing) section. I also removed one duplicate entry.

    New entries: <ref id="MASON">, <ref id="spyse">, <ref id="AntWars">,
        <ref id="OpenSteer">, <ref id="Pyro">, <ref id="Robocode">,
        <ref id="Trend"> and <ref id="Open BEAGLE">.

    <item>v2.1 - 

    New entries: <ref id="NLTK">, <ref id="NEURObjects">, <ref id="KANREN">,
        <ref id="Neural Networks at your Fingertips">, <ref id="SimWorld">,
        <ref id="SimAgent">, <ref id="Fuzzy sets for Ada">, <ref id="maxent">,
        <ref id="Evo">, <ref id="breve"> and <ref id="AJA">


    <item>v2.0 - Ran linkchecker and for any bad links I either found a new
link or removed the item. See the new section MIA for a list of the removed
entries (please let me know if you know of a new home for them).

    New entries: <ref id="Yale">, <ref id="DIET Agents">, <ref id="JASA">,
        <ref id="Jason">, <ref id="Noble Ape">, <ref id="Maude">,
        <ref id="ECLiPSe">, <ref id="lush">, and <ref id="pygp">

    <item>v1.9 - One new entry (<ref id="Bond">) and fixed the link below
    to the dynamic list (now defunct). 

    <item>v1.8 - Cleaned up bad links, finding new ones where possible and
eliminating those that seem to have disappeared. Quite a few new entries as
well.

    New entries: <ref id="Torch">, <ref id="Aleph">, <ref id="AI Kernel">,
        <ref id="OpenCyc">, <ref id="HTK">, <ref id="FFLL">, <ref id="JCK">, 
        <ref id="Joone">, <ref id="scnANNlib">, <ref id="GAUL">, 
        <ref id="Cougaar">, and <ref id="RoboTournament">

    <item>v1.7 - Another 9 new entries, a bunch of links fixed, and a few
items removed that have vanished from the net.

    New entries: <ref id="SPASS">, <ref id="CNNs">, <ref id="JCASim">,
        <ref id="Genetic">, <ref id="CAGE">, <ref id="AgentFarms">,
        <ref id="MATREM">, <ref id="OAA">, and
        <ref id="UTCS" name="UTCS Neural Nets Research Group Software">

    <item>v1.6 - 9 new entries, a couple link fixes and one duplicate item
removed.
    <item>v1.5 - 26 new entries plus a couple link fixes.
    <item>v1.4 - 10 new updates and fixed some lisp-related links.
    <item>v1.3 - Putting a dent in the backlog, I added 30+ new entries today  
and submitted it to the LDP.
    <item>No record for anything previous. :(
</itemize>

<sect1>Where to find this software
<p>

All this software should be available via the net (ftp || http).  The
links to where to find it will be provided in the description of each
package.  There will also be plenty of software not covered on these
pages (which is usually platform independent) located on one of the 
resources listed on the <htmlurl url="http://zhar.net/mlp/ai/"
name="links section"> of the Master Site (given above).

 
<sect1>Updates and comments
<p> 

If you find any mistakes, know of updates to one of the items below,
or have problems compiling any of the applications, please mail me at:
<htmlurl url="mailto:jae@zhar.net" name="jae@zhar.net"> 
and I'll see what I can do.  


If you know of any AI/Alife applications, class libraries,
etc. <bf>Please</bf> <htmlurl url="mailto:jae@zhar.net" name=" email me">
about them. Include your name, ftp and/or http sites where they can be
found, plus a brief overview/commentary on the software (this info
would make things a lot easier on me... but don't feel obligated ;).

 
I know that keeping this list up to date and expanding it will take quite
a bit of work. So please be patient (I do have other projects). I hope you 
will find this document helpful.

<sect1>Copyright/License
<p>
Copyright (c) 1996-2005 John A. Eikenberry

LICENSE

 This document may be reproduced and distributed in whole or in part, in 
 any medium physical or electronic, provided that this license notice is 
 displayed in the reproduction. Commercial redistribution is permitted and 
 encouraged. Thirty days advance notice, via email to the author, of 
 redistribution is appreciated, to give the authors time to provide updated 
 documents.

 A. REQUIREMENTS OF MODIFIED WORKS

  All modified documents, including translations, anthologies, and partial 
  documents, must meet the following requirements: 

  <p><itemize>
   <item>The modified version must be labeled as such.
   <item>The person making the modifications must be identified.
   <item>Acknowledgement of the original author must be retained.
   <item>The location of the original unmodified document be identified.
   <item>The original author's name(s) may not be used to assert or imply 
        endorsement of the resulting document without the original author's 
        permission.
  </itemize>

  In addition it is requested (not required) that: 

  <itemize>
    <item>The modifications (including deletions) be noted. 
    <item>The author be notified by email of the modification in advance of 
        redistribution, if an email address is provided in the document. 
  </itemize>

   As a special exception, anthologies of LDP documents may include a single 
   copy of these license terms in a conspicuous location within the anthology 
   and replace other copies of this license with a reference to the single 
   copy of the license without the document being considered "modified" for 
   the purposes of this section. 

   Mere aggregation of LDP documents with other documents or programs on the 
   same media shall not cause this license to apply to those other works. 

   All translations, derivative documents, or modified documents that 
   incorporate this document may not have more restrictive license terms 
   than these, except that you may require distributors to make the resulting 
   document available in source format. 

     
   
<sect>Traditional Artificial Intelligence
    <p>
	Traditional AI is based around the ideas of logic, rule
	systems, linguistics, and the concept of rationality.  At its
	roots are programming languages such as Lisp and Prolog.
	Expert systems are the largest successful example of this
	paradigm.  An expert system consists of a detailed knowledge
	base and a complex rule system to utilize it.  Such systems
	have been used for such things as medical diagnosis support
	and credit checking systems.

     
    <sect1>AI class/code libraries
<p>

    These are libraries of code or classes for use in programming within
    the artificial intelligence field.  They are not meant as stand alone
    applications, but rather as tools for building your own applications.
    
    <descrip>

    <label id="ACL2">
    <tag/ACL2/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.cliki.net/ACL2" 
                name="www.cliki.net/ACL2">
        </itemize>

        ACL2 (A Computational Logic for Applicative Common Lisp) is a theorem
        prover for industrial applications. It is both a mathematical logic and
        a system of tools for constructing proofs in the logic.  ACL2 works
        with GCL (GNU Common Lisp).


    <label id="AI Kernel">
    <tag/AI Kernel/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://aikernel.sourceforge.net/"
                name="aikernel.sourceforge.net">
            <item>Sourceforge site: <htmlurl 
                url="http://sourceforge.net/projects/aikernel/"
                name="sourceforge.net/projects/aikernel/">
        </itemize>

        The AI Kernel is a re-usable artificial intelligence engine that uses
        natural language processing and an Activator / Context model to allow
        multi tasking between installed cells.


      <label id="AI Search II"> 
      <tag/AI Search II/
    <itemize>
	    <item>WEB site: <htmlurl
            url="http://www.bell-labs.com/topic/books/ooai-book/"
            name="www.bell-labs.com/topic/books/ooai-book/">
    </itemize>
       
	Basically, the library offers the programmer a set of search
	algorithms that may be used to solve all kind of different
	problems. The idea is that when developing problem solving software
	the programmer should be able to concentrate on the representation of
	the problem to be solved and should not need to bother with the
	implementation of the search algorithm that will be used to actually
	conduct the search. This idea has been realized by the implementation
	of a set of search classes that may be incorporated in other software
	through <bf>C++</bf>'s features of derivation and inheritance.  The
	following search algorithms have been implemented:
	

        <itemize>
	<item>depth-first tree and graph search.</item>
	<item>breadth-first tree and graph search.</item>
	<item>uniform-cost tree and graph search.</item>
	<item>best-first search.</item>
	<item>bidirectional depth-first tree and graph search.</item>
	<item>bidirectional breadth-first tree and graph search.</item>
	<item>AND/OR depth tree search.</item>
	<item>AND/OR breadth tree search.</item>
        </itemize>

    
        This library has a corresponding book, "<htmlurl
        url="http://www.bell-labs.com/topic/books/ooai-book/"
        name="Object-Oriented Artificial Instelligence, Using C++">".


    <label id="Aleph">
    <tag/Aleph/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/"
                name="web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/">
        </itemize>

        This document provides reference information on A Learning Engine for
        Proposing Hypotheses (Aleph). Aleph is an Inductive Logic Programming
        (ILP) system. Aleph is intended to be a prototype for exploring ideas.
        Aleph is an ILP algorithm implemented in Prolog by Dr Ashwin
        Srinivasan at the Oxford University Computing Laboratory, and is
        written specifically for compilation with the YAP Prolog compiler


    <label id="Chess In List">
    <tag/Chess In Lisp (CIL)/
    <itemize>
      <item>Web site: *found as part of the CLOCC archive at: <htmlurl
                url="http://clocc.sourceforge.net/"
                name="clocc.sourceforge.net">
     </itemize>
    
     
      The CIL (Chess In Lisp) foundation is a Common Lisp
      implementaion of all the core functions needed for development
      of chess applications.  The main purpose of the CIL project is
      to get AI researchers interested in using Lisp to work in the
      chess domain.
     

    

    <label id="DAI">
    <tag/DAI/
        <itemize> 
            <item>Web site: <htmlurl 
                url="http://starship.python.net/crew/gandalf/DNET/AI/" 
                name="starship.python.net/crew/gandalf/DNET/AI/">
      </itemize>
     
      A library for the Python programming language that provides an
      object oriented interface to the CLIPS expert system tool. It 
      includes an interface to COOL (CLIPS Object Oriented Language)
      that allows:
      <itemize>	<item>Investigate COOL classes</item>
	<item>Create and manipulate with COOL instances</item>
	<item>Manipulate with COOL message-handler's</item>
	<item>Manipulate with Modules</item>
      </itemize>
     

    <label id="FFLL">
    <tag/FFLL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://ffll.sourceforge.net/" 
                name="ffll.sourceforge.net">
        </itemize>

        The Free Fuzzy Logic Library (FFLL) is an open source fuzzy logic class
        library and API that is optimized for speed critical applications, such
        as video games. FFLL is able to load files that adhere to the  IEC
        61131-7 standard.


    <label id="Fuzzy sets for Ada">
    <tag/Fuzzy sets for Ada/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.dmitry-kazakov.de/ada/fuzzy.htm"
                name="www.dmitry-kazakov.de/ada/fuzzy.htm">
            <item>Freshmeat: <htmlurl 
                url="http://freshmeat.net/projects/fuzzy/"
                name="freshmeat.net/projects/fuzzy/">
        </itemize>
        
        Fuzzy sets for Ada is a library providing implementations of confidence
        factors with the operations not, and, or, xor, +, and *, classical
        fuzzy sets with the set-theoretic operations and the operations of the
        possibility theory, intuitionistic fuzzy sets with the operations on
        them, fuzzy logic based on the intuitionistic fuzzy sets and the
        possibility theory; fuzzy numbers, both integer and floating-point with
        conventional arithmetical operations, and linguistic variables and sets
        of linguistic variables with operations on them.  String-oriented I/O
        is supported.


    <label id="HTK">
    <tag/HTK/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://htk.eng.cam.ac.uk/" 
                name="htk.eng.cam.ac.uk">
        </itemize>

        The Hidden Markov Model Toolkit (HTK) is a portable toolkit for
        building and manipulating hidden Markov models.  HTK consists of a set
        of library modules and tools available in C source form. The tools
        provide sophisticated facilities for speech analysis, HMM training,
        testing and results analysis. The software supports HMMs using both
        continuous density mixture Gaussians and discrete distributions and can
        be used to build complex HMM systems.  The HTK release contains
        extensive documentation and examples.


    <label id="JCK">
    <tag/JCK/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.pms.informatik.uni-muenchen.de/software/jack/"
                name="www.pms.informatik.uni-muenchen.de/software/jack/">
        </itemize>

        JCK is a new library providing constraint programming and search for
        Java.
        <itemize>
        JCK consists of three components:
            <item>
             - JCHR: Java Constraint Handling Rules.
                     A high-level language to write constraint solvers.
            <item>
             - JASE: Java Abstract Search Engine.
                     A generic search engine for JCHR to solve constraint 
                     problems.
            <item>
             - VisualCHR:
                     An interactive tool to visualize JCHR computations.
        </itemize>
        Source and documentation available from link above.


    <label id="KANREN">
    <tag/KANREN/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://kanren.sourceforge.net/"
                name="kanren.sourceforge.net">
        </itemize>

        KANREN is a declarative logic programming system with first-class
        relations, embedded in a pure functional subset of Scheme. The system
        has a set-theoretical semantics, true unions, fair scheduling,
        first-class relations, lexically-scoped logical variables, depth-first
        and iterative deepening strategies. The system achieves high
        performance and expressivity without cuts.

    
    <label id="LK">
    <tag/LK/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.cs.utoronto.ca/&tilde;neto/research/lk/" 
                name="www.cs.utoronto.ca/&tilde;neto/research/lk/">
        </itemize>

        LK is an implementation of the Lin-Kernighan heuristic for the
        Traveling Salesman Problem and for the minimum weight perfect matching
        problem. It is tuned for 2-d geometric instances, and has been applied
        to certain instances with up to a million cities. Also included are
        instance generators and Perl scripts for munging TSPLIB instances. 

        This implementation introduces ``efficient cluster compensation'', an
        experimental algorithmic technique intended to make the Lin-Kernighan
        heuristic more robust in the face of clustered data.


    <label id="maxent">
    <tag/maxent/
        <itemize>
            <item>Python/C++ version: <htmlurl 
                url="http://homepages.inf.ed.ac.uk/s0450736/maxent_toolkit.html"
                name="homepages.inf.ed.ac.uk/s0450736/maxent_toolkit.html">
            <item>Java version: <htmlurl 
                url="http://maxent.sourceforge.net/"
                name="maxent.sourceforge.net">
         </itemize>

        The Maximum Entropy Toolkit provides a set of tools and library for
        constructing maximum entropy (maxent) models in either Python or C++.
        It features conditional maximum entropy models, L-BFGS and GIS
        parameter estimation, Gaussian Prior smoothing, a C++ API, a Python
        extension module, a command line utility, and good documentation. A
        Java version is also available.


    <label id="Nyquist"> 
    <tag/Nyquist/
	<itemize> 
            <item>Web site: <htmlurl
                url="http://www-2.cs.cmu.edu/~music/nyquist/" 
                name="www-2.cs.cmu.edu/~music/nyquist/">
        </itemize>

        The Computer Music Project at CMU is developing computer music
        and interactive performance technology to enhance human musical
        experience and creativity. This interdisciplinary effort draws
        on Music Theory, Cognitive Science, Artificial Intelligence and
        Machine Learning, Human Computer Interaction, Real-Time Systems,
        Computer Graphics and Animation, Multimedia, Programming
        Languages, and Signal Processing. A paradigmatic example of
        these interdisciplinary efforts is the creation of interactive
        performances that couple human musical improvisation with
        intelligent computer agents in real-time.
     

    <label id="OpenCyc">
    <tag/OpenCyc/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.opencyc.org/"
                name="www.opencyc.org">
            <item>Alt Web site: <htmlurl 
                url="http://sourceforge.net/projects/opencyc/"
                name="sourceforge.net/projects/opencyc/">
        </itemize>

        OpenCyc is the open source version of Cyc, the largest and most
        complete general knowledge base and commonsense reasoning engine. An
        ontology based on 6000 concepts and 60000 assertions about them.


    <label id="PDKB">
    <tag/PDKB/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://lynx.eaze.net/&tilde;pdkb/web/" 
                name="lynx.eaze.net/&tilde;pdkb/web/">
            <item>SourceForge site: <htmlurl 
                url="http://sourceforge.net/projects/pdkb/" 
                name="sourceforge.net/projects/pdkb">
        </itemize>
        
        Public Domain Knowledge Bank (PDKB) is an Artificial Intelligence
        Knowledge Bank of common sense rules and facts. It is based on the Cyc
        Upper Ontology and the MELD language.



    <label id="Python Fuzzy Logic Module">
    <tag/Python Fuzzy Logic Module/
        <itemize>
            <item>FTP site: <htmlurl
            url="ftp://ftp.csh.rit.edu/pub/members/retrev/"
            name="ftp://ftp.csh.rit.edu/pub/members/retrev/">
        </itemize>
        
        A simple python module for fuzzy logic. The file is 'fuz.tar.gz' in
        this directory. The author plans to also write a simple genetic
        algorithm and a neural net library as well. Check the 00_index file in
        this directory for release info.


    <label id="QUANT/1">
    <tag/QUANT1/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://linux.irk.ru/projects/QUANT/" 
                name="linux.irk.ru/projects/QUANT/">
        </itemize>

        QUANT/1 stands for type QUANTifier. It aims to be an alternative to
        Prolog-like (Resulutional-like) systems. Main features include a lack
        of necessity for eliminating Quantifiers, scolemisation, ease of
        comprehension, large scale formulae operation, acceptance of nonHorn
        formulaes, and Iterative deeping. The actual library implemented in
        this project is called ATPPCF (Automatic Theorem Prover in calculus of
        Positively Constructed Formulae).

        ATPPCF will be a library (inference engine) and an extension of the
        Predicate Calculus Language as a new logical language. The library will
        be incorporable in another software such as TCL, Python, Perl. The
        engine's primary inference method will be the "search of inference in
        language of Positively Constructed Formulas (PCFs)" (a subset of
        Predicate Calculus well translated in both directions). The language
        will be used as scripting language to the engine. But there will be
        possibility to replace it with extensions languages of main software.



    <label id="Screamer">
    <tag/Screamer/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.cis.upenn.edu/&tilde;screamer-tools/home.html"
                name="www.cis.upenn.edu/&tilde;screamer-tools/home.html">
            <item>Latest version is part of CLOCC: <htmlurl 
                url="http://clocc.sourceforge.net/"
                name="clocc.sourceforge.net">
        </itemize>
     
      Screamer is an extension of Common Lisp that adds support for
      nondeterministic programming. Screamer consists of two
      levels. The basic nondeterministic level adds support for
      backtracking and undoable side effects.  On top of this
      nondeterministic substrate, Screamer provides a comprehensive
      constraint programming language in which one can formulate and
      solve mixed systems of numeric and symbolic
      constraints. Together, these two levels augment Common Lisp with
      practically all of the functionality of both Prolog and
      constraint logic programming languages such as CHiP and CLP(R).
      Furthermore, Screamer is fully integrated with Common
      Lisp. Screamer programs can coexist and interoperate with other
      extensions to Common Lisp such as CLOS, CLIM and Iterate.


    <label id="SPASS">
    <tag/SPASS/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://spass.mpi-sb.mpg.de/"
                name="spass.mpi-sb.mpg.de">
        </itemize>

        SPASS: An Automated Theorem Prover for First-Order Logic with Equality

        If you are interested in first-order logic theorem proving, the formal
        analysis of software, systems, protocols, formal approaches to AI
        planning, decision procedures, modal logic theorem proving, SPASS may
        offer you the right functionality.


    <label id="ThoughtTreasure">
    <tag/ThoughtTreasure/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.signiform.com/tt/htm/tt.htm" 
                name="www.signiform.com/tt/htm/tt.htm">
        </itemize>
        
        ThoughtTreasure is a project to create a database of commonsense rules
        for use in any application. It consists of a database of a little over
        100K rules and a C API to integrate it with your applications. Python,
        Perl, Java and TCL wrappers are already available.

    <label id="Torch">
    <tag/Torch/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.torch.ch/" 
                name="www.torch.ch">
        </itemize>
        
        Torch is a machine-learning library, written in C++.  Its aim is to
        provide the state-of-the-art of the best algorithms.  It is, and it
        will be, in development forever.
  
        <itemize>
            <item>Many gradient-based methods, including multi-layered
            perceptrons, radial basis functions, and mixtures of experts.  Many
            small "modules" (Linear module, Tanh module, SoftMax module, ...)
            can be plugged together.
            
            <item>Support Vector Machine, for classification and regression.
            
            <item>Distribution package, includes Kmeans, Gaussian Mixture
            Models, Hidden Markov Models, and Bayes Classifier, and classes for
            speech recognition with embedded training.  
            
            <item>Ensemble models such as Bagging and Adaboost.

            <item>Non-parametric models such as K-nearest-neighbors, Parzen
            Regression and Parzen Density Estimator.
             
            <item>
        </itemize>
        
        Torch is an open library whose authors encourage everybody to develop
        new packages to be included in future versions on the official website.

  </descrip>


    <sect1>AI software kits, applications, etc.
    <p>
    
    These are various applications, software kits, etc. meant for research
    in the field of artificial intelligence. Their ease of use will vary,
    as they were designed to meet some particular research interest more
    than as an easy to use commercial package.
    
    <descrip>
       
      <label id="ASA">
      <tag/ASA - Adaptive Simulated Annealing/
	    <itemize> 
            <item>Web site: <htmlurl url="http://www.ingber.com/&num;ASA-CODE" name="www.ingber.com/&num;ASA-CODE">
        	<item>FTP site: <htmlurl url="ftp://ftp.ingber.com/" name="ftp.ingber.com/">
        </itemize>

       
	ASA (Adaptive Simulated Annealing) is a powerful global
	optimization C-code algorithm especially useful for nonlinear and/or
	stochastic systems.
	

        ASA is developed to statistically find the best global fit of a
        nonlinear non-convex cost-function over a D-dimensional space. This
        algorithm permits an annealing schedule for 'temperature' T decreasing
        exponentially in annealing-time k, T = T&lowbar;0 exp(-c k&circ;1/D).
        The introduction of re-annealing also permits adaptation to changing
        sensitivities in the multi-dimensional parameter-space. This annealing
        schedule is faster than fast Cauchy annealing, where T = T&lowbar;0/k,
        and much faster than Boltzmann annealing, where T = T&lowbar;0/ln k.  


    <label id="Babylon"> 
    <tag/Babylon/
        <itemize>
            <item>FTP site: <htmlurl 
                url="ftp://ftp.gmd.de/gmd/ai-research/Software/Babylon/" 
                name="ftp.gmd.de/gmd/ai-research/Software/Babylon/">
        </itemize>
     
      BABYLON is a modular, configurable, hybrid environment for
      developing expert systems. Its features include objects, rules with
      forward and backward chaining, logic (Prolog) and constraints. BABYLON
      is implemented and embedded in Common Lisp.
     
    
    <label id="cfengine">
    <tag/cfengine/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.iu.hio.no/cfengine/" 
                name="www.iu.hio.no/cfengine/">
        </itemize>
        
        Cfengine, or the configuration engine is a very high level language for
        building expert systems which administrate and configure large computer
        networks. Cfengine uses the idea of classes and a primitive form of
        intelligence to define and automate the configuration of large systems
        in the most economical way possible. Cfengine is design to be a part of
        computer immune systems.


    <label id="CLEARS">
    <tag/CLEARS/
        <itemize>
            <item>Web site: ???? (anyone know where to find this anymore)
        </itemize>

      The CLEARS system is an interactive graphical environment for
      computational semantics. The tool allows exploration and
      comparison of different semantic formalisms, and their
      interaction with syntax. This enables the user to get an idea of
      the range of possibilities of semantic construction, and also
      where there is real convergence between theories.
     
     
    <label id="CLIPS">
    <tag/CLIPS/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.ghg.net/clips/CLIPS.html"
                name="www.ghg.net/clips/CLIPS.html">
        </itemize>
      
      CLIPS is a productive development and delivery expert system tool
      which provides a complete environment for the construction of rule
      and/or object based expert systems.  
      
 
      CLIPS provides a cohesive tool for handling a wide variety of
      knowledge with support for three different programming paradigms:
      rule-based, object-oriented and procedural.  Rule-based programming
      allows knowledge to be represented as heuristics, or "rules of thumb,"
      which specify a set of actions to be performed for a given
      situation. Object-oriented programming allows complex systems to be
      modeled as modular components (which can be easily reused to model
      other systems or to create new components).  The procedural
      programming capabilities provided by CLIPS are similar to capabilities
      found in languages such as C, Pascal, Ada, and LISP.
     

    <label id="EMA-XPS">
    <tag/EMA-XPS - A Hybrid Graphic Expert System Shell/
      <itemize>
        <item>Web site: <htmlurl 
                url="http://www.iai.uni-wuppertal.de/EMA-XPS/"
                name="www.iai.uni-wuppertal.de/EMA-XPS/">
      </itemize>

     
      EMA-XPS is a hybrid graphic expert system shell based on the
      ASCII-oriented shell Babylon 2.3 of the German National Research
      Center for Computer Sciences (GMD). In addition to Babylon's AI-power
      (object oriented data representation, forward and backward chained
      rules - collectible into sets, horn clauses, and constraint networks)
      a graphic interface based on the X11 Window System and the OSF/Motif
      Widget Library has been provided.


    <label id="Fool-Fox">
    <tag/FOOL &amp; FOX/
    <itemize>
      <item>Web site: <htmlurl 
                url="http://rhaug.de/fool/" 
                name="rhaug.de/fool/">
      <item>FTP site: <htmlurl 
                url="ftp://ftp.informatik.uni-oldenburg.de/pub/fool/" 
                name="ftp.informatik.uni-oldenburg.de/pub/fool/">
    </itemize>

     
      FOOL stands for the Fuzzy Organizer OLdenburg. It is a result from
      a project at the University of Oldenburg. FOOL is a graphical user
      interface to develop fuzzy rulebases.  FOOL will help you to invent
      and maintain a database that specifies the behavior of a
      fuzzy-controller or something like that.
      

      FOX is a small but powerful fuzzy engine which reads this database,
      reads some input values and calculates the new control value.
     
    
    <label id="FUF-SURGE">
    <tag/FUF and SURGE/
      <itemize>
        <item>Web site: <htmlurl 
                url="http://www.cs.bgu.ac.il/research/projects/surge/index.htm" 
                name="www.cs.bgu.ac.il/research/projects/surge/index.htm">
        <item>FTP site: <htmlurl 
                url="ftp://ftp.cs.bgu.ac.il/pub/fuf/" 
                name="ftp.cs.bgu.ac.il/pub/fuf/">
      </itemize>
     
      FUF is an extended implementation of the formalism of functional
      unification grammars (FUGs) introduced by Martin Kay specialized to
      the task of natural language generation. It adds the following
      features to the base formalism:
      <itemize>	
        <item>Types and inheritance. 
	    <item>Extended control facilities (goal freezing, intelligent 
                    backtracking). 
	    <item>Modular syntax.
      </itemize>
      These extensions allow the development of large grammars which can be
      processed efficiently and can be maintained and understood more
      easily.  SURGE is a large syntactic realization grammar of English
      written in FUF. SURGE is developed to serve as a black box syntactic
      generation component in a larger generation system that encapsulates a
      rich knowledge of English syntax. SURGE can also be used as a platform
      for exploration of grammar writing with a generation perspective.
     
    
    <label id="Grammar Workbench">
    <tag/The Grammar Workbench/
      <itemize>
        <item>Web site: ??? <htmlurl 
                url="http://www.cs.kun.nl/agfl/" 
                name="www.cs.kun.nl/agfl/">
      </itemize>     

      Seems to be obsolete??? Its gone from the site, though its parent 
      project is still ongoing. 
     
      The Grammar Workbench, or GWB for short, is an environment for the
      comfortable development of Affix Grammars in the AGFL-formalism. Its
      purposes are: 
      <itemize>	
        <item>to allow the user to input, inspect and modify a grammar; 
    	<item>to perform consistency checks on the grammar; 
	    <item>to compute grammar properties; 
	    <item>to generate example sentences; 
	    <item>to assist in performing grammar transformations. 
      </itemize>
     
    
    <label id="GSM Suite">
    <tag/GSM Suite/
        <itemize> 
            <item>Alt site: <htmlurl 
                url="http://www.ibiblio.org/pub/Linux/apps/graphics/draw/" 
                name="www.ibiblio.org/pub/Linux/apps/graphics/draw/">
        </itemize>
  
      The GSM Suite is a set of programs for using Finite State
      Machines in a graphical fashion. The suite consists of programs
      that edit, compile, and print state machines. Included in the
      suite is an editor program, gsmedit, a compiler, gsm2cc, that
      produces a C++ implementation of a state machine, a PostScript
      generator, gsm2ps, and two other minor programs. GSM is licensed
      under the GNU Public License and so is free for your use under
      the terms of that license.


    <label id="Isabelle">
    <tag/Isabelle/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://isabelle.in.tum.de/" 
                name="isabelle.in.tum.de">
        </itemize>

        Isabelle is a popular generic theorem prover developed at Cambridge
        University and TU Munich. Existing logics like Isabelle/HOL provide a
        theorem proving environment ready to use for sizable applications.
        Isabelle may also serve as framework for rapid prototyping of deductive
        systems. It comes with a large library including Isabelle/HOL
        (classical higher-order logic), Isabelle/HOLCF (Scott's Logic for
        Computable Functions with HOL), Isabelle/FOL (classical and
        intuitionistic first-order logic), and Isabelle/ZF (Zermelo-Fraenkel
        set theory on top of FOL).


    <label id="Jess">
    <tag/Jess, the Java Expert System Shell/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://herzberg.ca.sandia.gov/jess/" 
                name="herzberg.ca.sandia.gov/jess/">
        </itemize>
 
      Jess is a clone of the popular CLIPS expert system shell written
      entirely in Java. With Jess, you can conveniently give your
      applets the ability to 'reason'. Jess is compatible with all
      versions of Java starting with version 1.0.2. Jess implements
      the following constructs from CLIPS: defrules, deffunctions,
      defglobals, deffacts, and deftemplates.  


    <label id="learn">
    <tag/learn/
    <itemize>
        <item>Web site: <htmlurl 
            url="http://www.ibiblio.org/pub/Linux/apps/cai/" 
            name="www.ibiblio.org/pub/Linux/apps/cai/">
    </itemize>
      
      Learn is a vocable learning program with memory model. 
     

    <label id="LISA">
    <tag/LISA/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://lisa.sourceforge.net/" 
                name="lisa.sourceforge.net">
        </itemize>

        LISA (Lisp-based Intelligent Software Agents) is a production-rule
        system heavily influenced by JESS (Java Expert System Shell). It has at
        its core a reasoning engine based on the Rete pattern matching
        algorithm. LISA also provides the ability to reason over ordinary CLOS
        objects.


    <label id="NICOLE">
    <tag/NICOLE/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://nicole.sourceforge.net/" 
                name="nicole.sourceforge.net">
        </itemize>

        NICOLE (Nearly Intelligent Computer Operated Language Examiner) is a
        theory or experiment that if a computer is given enough combinations of
        how words, phrases and sentences are related to one another, it could
        talk back to you. It is an attempt to simulate a conversation by
        learning how words are related to other words. A human communicates
        with NICOLE via the keyboard and NICOLE responds back with its own
        sentences which are automatically generated, based on what NICOLE has
        stored in it's database. Each new sentence that has been typed in, and
        NICOLE doesn't know about, is included into NICOLE's database, thus
        extending the knowledge base of NICOLE.
    

    <label id="NLTK">
    <tag/NLTK/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://nltk.sourceforge.net/"
                name="nltk.sourceforge.net">
        </itemize>
        
        NLTK, the Natural Language Toolkit, is a suite of Python libraries and
        programs for symbolic and statistical natural language processing.
        NLTK includes graphical demonstrations and sample data. It is
        accompanied by extensive documentation, including tutorials that
        explain the underlying concepts behind the language processing tasks
        supported by the toolkit.


        NLTK is ideally suited to students who are learning NLP (natural
        language processing) or conducting research in NLP or closely related
        areas, including empirical linguistics, cognitive science, artificial
        intelligence, information retrieval, and machine learning. NLTK has
        been used successfully as a teaching tool, as an individual study tool,
        and as a platform for prototyping and building research systems. 


    <label id="Otter">
    <tag/Otter: An Automated Deduction System/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www-unix.mcs.anl.gov/AR/otter/"
                name="www-unix.mcs.anl.gov/AR/otter/">
        </itemize>
     
      Our current automated deduction system  Otter is designed to prove
      theorems stated in first-order logic with equality.  Otter's
      inference rules are based on resolution and paramodulation, and it
      includes facilities for term rewriting, term orderings, Knuth-Bendix
      completion, weighting, and strategies for directing and restricting
      searches for proofs.   Otter can also be used as a symbolic
      calculator and has an embedded equational programming system.
     

      <label id="PVS">
      <tag/PVS/
        <itemize>
            <item>Web site: <htmlurl url="http://pvs.csl.sri.com/" name="pvs.csl.sri.com/">
        </itemize>
     
      PVS is a verification system: that is, a specification language
      integrated with support tools and a theorem prover. It is
      intended to capture the state-of-the-art in mechanized formal
      methods and to be sufficiently rugged that it can be used for
      significant applications. PVS is a research prototype: it
      evolves and improves as we develop or apply new capabilities,
      and as the stress of real use exposes new requirements.


    <label id="SNePS">
    <tag/SNePS/
      <itemize>
        <item>Web site: <htmlurl 
                url="http://www.cse.buffalo.edu/sneps/" 
                name="www.cse.buffalo.edu/sneps/">
      </itemize>
     
      The long-term goal of The SNePS Research Group is the design and
      construction of a natural-language-using computerized cognitive
      agent, and carrying out the research in artificial intelligence,
      computational linguistics, and cognitive science necessary for
      that endeavor. The three-part focus of the group is on knowledge
      representation, reasoning, and natural-language understanding
      and generation. The group is widely known for its development of
      the SNePS knowledge representation/reasoning system, and Cassie,
      its computerized cognitive agent.  
     

    <label id="Soar">
    <tag/Soar/
      <itemize>
        <item>Web site: <htmlurl 
                url="http://sitemaker.umich.edu/soar"
                name="sitemaker.umich.edu/soar">
      </itemize>

     
      Soar has been developed to be a general cognitive architecture.
      We intend ultimately to enable the Soar architecture to:
      <itemize>	
        <item>work on the full range of tasks expected of an
	    intelligent agent, from highly routine to extremely difficult,
	    open-ended problems
	    <item>represent and use appropriate forms of knowledge, such as
	    procedural, declarative, episodic, and possibly iconic
	    <item>employ the full range of problem solving methods 
	    <item>interact with the outside world and 
	    <item>learn about all aspects of the tasks and its performance on them. 
      </itemize>
      In other words, our intention is for Soar to support all the
      capabilities required of a general intelligent agent.

    <label id="TCM">
    <tag/TCM/
    <itemize>
        <item>Web site: <htmlurl 
            url="http://wwwhome.cs.utwente.nl/&tilde;tcm/" 
            name="wwwhome.cs.utwente.nl/&tilde;tcm/">
        <item>FTP site: <htmlurl 
            url="ftp://ftp.cs.utwente.nl/pub/tcm/" 
            name="ftp.cs.utwente.nl/pub/tcm/">
      </itemize>

      TCM (Toolkit for Conceptual Modeling) is our suite of graphical
      editors. TCM contains graphical editors for Entity-Relationship
      diagrams, Class-Relationship diagrams, Data and Event Flow
      diagrams, State Transition diagrams, Jackson Process Structure
      diagrams and System Network diagrams, Function Refinement trees
      and various table editors, such as a Function-Entity table
      editor and a Function Decomposition table editor.  TCM is easy
      to use and performs numerous consistency checks, some of them
      immediately, some of them upon request.
     

    <label id="Yale">
    <tag/Yale/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://yale.cs.uni-dortmund.de/index.html.html"
                name="yale.cs.uni-dortmund.de/index.html.html">
        </itemize>
        
        YALE (Yet Another Learning Environment) is an environment for machine
        learning experiments. Experiments can be made up of a large number of
        arbitrarily nestable operators and their setup is described by XML
        files which can easily created with a graphical user interface.
        Applications of YALE cover both research and real-world learning tasks.


    <label id="WEKA">
    <tag/WEKA/ 
      <itemize>
        <item>Web site: <htmlurl
            url="http://www.cs.waikato.ac.nz/&tilde;ml/"
            name="lucy.cs.waikato.ac.nz/&tilde;ml/">
      </itemize>
    
     
      WEKA (Waikato Environment for Knowledge Analysis) is an
      state-of-the-art facility for applying machine learning
      techniques to practical problems. It is a comprehensive software
      "workbench" that allows people to analyse real-world data. It
      integrates different machine learning tools within a common
      framework and a uniform user interface. It is designed to
      support a "simplicity-first" methodology, which allows users to
      experiment interactively with simple machine learning tools
      before looking for more complex solutions.
     

  </descrip>
     
     
    
<sect>Connectionism
<p>
	Connectionism is a technical term for a group of related
	techniques. These techniques include areas such as Artificial
	Neural Networks, Semantic Networks and a few other similar
	ideas. My present focus is on neural networks (though I am
	looking for resources on the other techniques). Neural
	networks are programs designed to simulate the workings of the
	brain. They consist of a network of small mathematical-based
	nodes, which work together to form patterns of information.
	They have tremendous potential and currently seem to be having
	a great deal of success with image processing and robot
	control.

     
    <sect1>Connectionist class/code libraries
<p>

    These are libraries of code or classes for use in programming within
    the Connectionist field.  They are not meant as stand alone
    applications, but rather as tools for building your own applications.

    <descrip>

    <label id="Baysian Modeling">
    <tag/Software for Flexible Bayesian Modeling/
      <itemize>
        <item>Web site: <htmlurl url="http://www.cs.utoronto.ca/&tilde;radford/fbm.software.html" name="www.cs.utoronto.ca/&tilde;radford/fbm.software.html">
      </itemize>
    
     
      This software implements flexible Bayesian models for regression
      and classification applications that are based on multilayer
      perceptron neural networks or on Gaussian processes.  The
      implementation uses Markov chain Monte Carlo methods.  Software
      modules that support Markov chain sampling are included in the
      distribution, and may be useful in other applications.


      <label id="BELIEF">
      <tag/BELIEF/
      <itemize>
        <item>Web site: <htmlurl url="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/" name="www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/">
      </itemize>
    
     
      BELIEF is a Common Lisp implementation of the Dempster and Kong
      fusion and propagation algorithm for Graphical Belief Function
      Models and the Lauritzen and Spiegelhalter algorithm for
      Graphical Probabilistic Models. It includes code for
      manipulating graphical belief models such as Bayes Nets and
      Relevance Diagrams (a subset of Influence Diagrams) using both
      belief functions and probabilities as basic representations of
      uncertainty. It uses the Shenoy and Shafer version of the
      algorithm, so one of its unique features is that it supports
      both probability distributions and belief functions.  It also
      has limited support for second order models (probability
      distributions on parameters).
     
    <label id="bpnn.py">
    <tag/bpnn.py/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://arctrix.com/nas/python/bpnn.py" 
                name="http://arctrix.com/nas/python/bpnn.py">
        </itemize>

        A simple back-propogation ANN in Python.


    <label id="CNNs">
    <tag/CNNs/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.isi.ee.ethz.ch/&tilde;haenggi/CNNsim.html"
                name="www.isi.ee.ethz.ch/&tilde;haenggi/CNNsim.html">
            <item>Newer Version: <htmlurl 
                url="http://www.isi.ee.ethz.ch/&tilde;haenggi/CNNsim_adv_manual.html"
                name="www.isi.ee.ethz.ch/&tilde;haenggi/CNNsim_adv_manual.html">
            <item>Old Page: <htmlurl 
                url="http://www.ce.unipr.it/research/pardis/CNN/cnn.html"
                name="www.ce.unipr.it/research/pardis/CNN/cnn.html">
        </itemize>

        Cellular Neural Networks (CNN)  is a massive parallel computing
        paradigm defined in discrete N-dimensional spaces.




      <label id="CONICAL">
      <tag/CONICAL/  
          <itemize>
            <item>Web site: <htmlurl 
                    url="http://strout.net/conical/" name="strout.net/conical/">
          </itemize>
     
          CONICAL is a C++ class library for building simulations common
          in computational neuroscience. Currently its focus is on
          compartmental modeling, with capabilities similar to GENESIS and
          NEURON. A model neuron is built out of compartments, usually
          with a cylindrical shape. When small enough, these open-ended
          cylinders can approximate nearly any geometry. Future classes
          may support reaction-diffusion kinetics and more. A key feature
          of CONICAL is its cross-platform compatibility; it has been
          fully co-developed and tested under Unix, DOS, and Mac OS.
     


    <label id="Jet's Neural Architecture">
    <tag/Jet's Neural Architecture/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.voltar-confed.org/jneural/" 
                name="www.voltar-confed.org/jneural/">
        </itemize>

        Jet's Neural Architecture is a C++ framework for doing neural net
        projects. The goals of this project were to make a fast, flexible
        neural architecture that isn't stuck to one kind of net and to make
        sure that end users could easily write useful applications. All the
        documentation is also easily readable.


    <label id="Joone">
    <tag/Joone/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://joone.sourceforge.net/" 
                name="joone.sourceforge.net">
        </itemize>

        Joone is a neural net framework to create, train and test neural nets.
        The aim is to create a distributed environment based on JavaSpaces both
        for enthusiastic and professional users, based on the newest Java
        technologies.  Joone is composed of a central engine that is the
        fulcrum of all applications that already exist or will be developed.
        The neural engine is modular, scalable, multitasking and tensile.
        Everyone can write new modules to implement new algorithms or new
        architectures starting from the simple components distributed with the
        core engine.  The main idea is to create the basis to promote a zillion
        of AI applications that revolve around the core framework.


    <label id="Matrix Class">
    <tag/Matrix Class/
        <itemize>
	    <item>FTP site: <htmlurl 
                url="ftp://ftp.cs.ucla.edu/pub/" 
                name="ftp.cs.ucla.edu/pub/">
        </itemize>
      
        A simple, fast, efficient C++ Matrix class designed for
        scientists and engineers. The Matrix class is well suited for
        applications with complex math algorithms. As an demonstration
        of the Matrix class, it was used to implement the backward error
        propagation algorithm for a multi-layer feed-forward artificial
        neural network.


    <label id="Neural Networks at your Fingertips">
    <tag/Neural Networks at your Fingertips/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.neural-networks-at-your-fingertips.com/"
                name="www.neural-networks-at-your-fingertips.com">
        </itemize>

        A set of ANSI C packages that illustrate Adaline networks,
        back-propagation, the Hopfield model, BAM, Boltzman, CPN, SOM, and
        ART1. Coded in portable, self-contained ANSI C. With complete example
        applications from a variety of well-known application domains.


    <label id="NEURObjects">
    <tag/NEURObjects/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.disi.unige.it/person/ValentiniG/NEURObjects/"
                name="www.disi.unige.it/person/ValentiniG/NEURObjects/">
        </itemize>

        NEURObjects is  a set   of C++ library   classes for neural networks
        development.  The main goal of  the library consists in supporting
        researchers and practitioners in developing new neural network methods
        and applications, exploiting the potentialities  of object-oriented
        design and  programming.  NEURObjects provides also general purpose
        applications for classification problems and can be used for fast
        prototyping  of inductive  machine learning applications.


    <label id="Pulcinella">
    <tag/Pulcinella/
	<itemize>
        <item>Web site: <htmlurl 
            url="http://iridia.ulb.ac.be/pulcinella/" 
            name="iridia.ulb.ac.be/pulcinella/">
    </itemize>

      Pulcinella is written in CommonLisp, and appears as a library of
      Lisp functions for creating, modifying and evaluating valuation
      systems. Alternatively, the user can choose to interact with
      Pulcinella via a graphical interface (only available in Allegro
      CL). Pulcinella provides primitives to build and evaluate
      uncertainty models according to several uncertainty calculi,
      including probability theory, possibility theory, and
      Dempster-Shafer's theory of belief functions; and the
      possibility theory by Zadeh, Dubois and Prade's. A User's Manual
      is available on request.
     

    <label id="scnANNlib">
    <tag/scnANNlib/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.sentinelchicken.org/projects/scnANNlib/" 
                name="www.sentinelchicken.org/projects/scnANNlib/">
        </itemize>

        SCN Artificial Neural Network Library provides a programmer with a
        simple object-oriented API for constructing ANNs. Currently, the
        library supports non-recursive networks with an arbitrary number of
        layers, each with an arbitrary number of nodes. Facilities exist for
        training with momentum, and there are plans to gracefully extend the
        functionality of the library in later releases. 


    <label id="TresBel">
    <tag/TresBel/
    <itemize>
        <item>Abstract: <htmlurl 
            url="http://iridia.ulb.ac.be/Projects/imple.html" 
            name="iridia.ulb.ac.be/Projects/imple.html">
        <item>Direct Download: <htmlurl 
            url="ftp://iridia.ulb.ac.be/pub/hongxu/software/TresBel.tar.Z" 
            name="ftp://iridia.ulb.ac.be/pub/hongxu/software/TresBel.tar.Z">
      </itemize>
     
      Libraries containing (Allegro) Common Lisp code for Belief Functions 
      (aka. Dempster-Shafer evidential reasoning) as a representation 
      of uncertainty. Very little documentation. Has a limited GUI.
     

    <label id="UTCS">
    <tag/UTCS Neural Nets Research Group Software/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://nn.cs.utexas.edu/pages/software/software.html"
                name="nn.cs.utexas.edu/pages/software/software.html">
        </itemize>

        A bit different from the other entries, this is a reference to a
        collection of software rather than one application. It was all
        developed by the <htmlurl
        url="http://nn.cs.utexas.edu/pages/" name="UTCS Neural Net
        Research Group">. Here's a summary of the packages available:

        <itemize>
            <item>Natural Language Processing
            <itemize>
                <item>MIR - Tcl/Tk-based rapid prototyping for sentence
                    processing
                <item>SPEC - Parsing complex sentences
                <item>DISCERN - Processing script-based stories, including
                <itemize>
                    <item>PROC - Parsing, generation, question answering
                    <item>HFM - Episodic memory organization
                    <item>DISLEX - Lexical processing
                    <item>DISCERN - The full integrated model    
                </itemize>
                <item>FGREPNET - Learning distributed representations
            </itemize>
            <item>Self-Organization
            <itemize>
                <item>LISSOM - Maps with self-organizing lateral connections.
                <item>FM - Generic Self-Organizing Maps
            </itemize>
            <item>Neuroevolution
            <itemize>
                <item>Enforced Sub-Populations (ESP) for sequential decision
                tasks
                <itemize>
                    <item>Non-Markov Double Pole Balancing
                </itemize>
                <item>Symbiotic, Adaptive NeuroEvolution (SANE; predecessor of
                ESP)
                <itemize>
                    <item>JavaSANE - Java software package for applying SANE to
                    new tasks
                    <item>SANE-C - C version, predecessor of JavaSANE
                    <item>Pole Balancing - Neuron-level SANE on the Pole
                    Balancing task
                </itemize>
                <item>NeuroEvolution of Augmenting Topologies (NEAT)
                software for evolving neural networks using structure
            </itemize>
        </itemize>


    <label id="C++ ANNs">
    <tag/Various (C++) Neural Networks/
     <itemize> 
        <item>Web site: <htmlurl 
            url="http://www.dontveter.com/nnsoft/nnsoft.html" 
            name="www.dontveter.com/nnsoft/nnsoft.html">
    </itemize>
     
      Example neural net codes from the book, <htmlurl
      url="http://www.dontveter.com/basisofai/basisofai.html" name="The
      Pattern Recognition Basics of AI">.
      These are simple example codes of these various
      neural nets. They work well as a good starting point for simple
      experimentation and for learning what the code is like behind the
      simulators. The types of networks available on this site are: 
      (implemented in C++)
      

      <itemize>	<item>The Backprop Package
	    <item>The Nearest Neighbor Algorithms
    	<item>The Interactive Activation Algorithm
	    <item>The Hopfield and Boltzman machine Algorithms
	    <item>The Linear Pattern Classifier
    	<item>ART I
    	<item>Bi-Directional Associative Memory
    	<item>The Feedforward Counter-Propagation Network
      </itemize>
     


  </descrip>
    
    <sect1>Connectionist software kits/applications
    <p>
    
    These are various applications, software kits, etc. meant for research
    in the field of Connectionism. Their ease of use will vary, as they
    were designed to meet some particular research interest more than as
    an easy to use commercial package.
    <descrip>

      
      <label id="Aspirin-MIGRANES">
      <tag/Aspirin - MIGRAINES/ (am6.tar.Z on ftp site)
      <itemize>
	    <item>FTP site: <htmlurl url="ftp://sunsite.unc.edu/pub/academic/computer-science/neural-networks/programs/Aspirin/" name="sunsite.unc.edu/pub/academic/computer-science/neural-networks/programs/Aspirin/">
      </itemize>

       
	The software that we are releasing now is for creating, 
	and evaluating, feed-forward networks such as those used with the 
	backpropagation learning algorithm. The software is aimed both at 
	the expert programmer/neural network researcher who may wish to tailor
	significant portions of the system to his/her precise needs, as well
	as at casual users who will wish to use the system with an absolute
	minimum of effort.
       


      <label id="DDLab">
      <tag/DDLab/   
        <itemize>
         <item>Web site: <htmlurl url="http://www.santafe.edu/&tilde;wuensch/ddlab.html" name="www.santafe.edu/&tilde;wuensch/ddlab.html">
         <item>FTP site: <htmlurl url="ftp://ftp.santafe.edu/pub/wuensch/" name="ftp.santafe.edu/pub/wuensch/">
        </itemize>
     
      DDLab is an interactive graphics program for research into the
      dynamics of finite binary networks, relevant to the study of
      complexity, emergent phenomena, neural networks, and aspects of
      theoretical biology such as gene regulatory networks. A network
      can be set up with any architecture between regular CA (1d or
      2d) and "random Boolean networks" (networks with arbitrary
      connections and heterogeneous rules). The network may also have
      heterogeneous neighborhood sizes.

    
      <label id="GENESIS">
      <tag/GENESIS/  
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.genesis-sim.org/GENESIS/" 
                name="www.genesis-sim.org/GENESIS/">
            <item>FTP site: <htmlurl 
                url="ftp://genesis-sim.org/pub/genesis/" 
                name="genesis-sim.org/pub/genesis/">
        </itemize>   
     
      GENESIS (short for GEneral NEural SImulation System) is a
      general purpose simulation platform which was developed to
      support the simulation of neural systems ranging from complex
      models of single neurons to simulations of large networks made
      up of more abstract neuronal components. GENESIS has provided
      the basis for laboratory courses in neural simulation at both
      Caltech and the Marine Biological Laboratory in Woods Hole, MA,
      as well as several other institutions. Most current GENESIS
      applications involve realistic simulations of biological neural
      systems. Although the software can also model more abstract
      networks, other simulators are more suitable for backpropagation
      and similar connectionist modeling.
     

    
    <label id="JavaBayes">
    <tag/JavaBayes/
    <itemize>
        <item>Web site: <htmlurl url="http://www.cs.cmu.edu/People/javabayes/index.html/" name="www.cs.cmu.edu/People/javabayes/index.html/">
    </itemize>

       
        The JavaBayes system is a set of tools, containing a
        graphical editor, a core inference engine and a parser.
        JavaBayes can produce:
        <itemize>	  
            <item> the marginal distribution for any variable in a network.
	        <item> the expectations for univariate functions (for example, 
                expected value for variables).
	        <item> configurations with maximum a posteriori probability.
	        <item> configurations with maximum a posteriori expectation for 
                univariate functions.
        </itemize>
       


    <label id="Jbpe">
    <tag/Jbpe/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://cs.felk.cvut.cz/&tilde;koutnij/studium/jbpe.html" 
                name="cs.felk.cvut.cz/&tilde;koutnij/studium/jbpe.html">
        </itemize>

        Jbpe is a back-propagation neural network editor/simulator.

        Features 
        <itemize>
         <item>Standart back-propagation networks creation. 
         <item>Saving network as a text file, which can be edited and loaded 
               back. 
         <item>Saving/loading binary file 
         <item>Learning from a text file (with structure specified below), 
               number of learning periods / desired network energy can be
               specified as a criterion. 
         <item>Network recall 
        </itemize>


    <label id="NN Generator">
    <tag/Neural Network Generator/   
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.idsia.ch/&tilde;rafal/research.html"
                name="www.idsia.ch/&tilde;rafal/research.html">
            <item>FTP site: <htmlurl 
                url="ftp://ftp.idsia.ch/pub/rafal/" 
                name="ftp.idsia.ch/pub/rafal">
        </itemize>
     
      The Neural Network Generator is a genetic algorithm for the
      topological optimization of feedforward neural networks. It
      implements the Semantic Changing Genetic Algorithm and the
      Unit-Cluster Model. The Semantic Changing Genetic Algorithm is
      an extended genetic algorithm that allows fast dynamic
      adaptation of the genetic coding through population
      analysis. The Unit-Cluster Model is an approach to the
      construction of modular feedforward networks with a ''backbone''
      structure. 
      

      NOTE: To compile this on Linux requires one change in the Makefiles. 
      You will need to change '-ltermlib' to '-ltermcap'.
     

    <label id="Neureka ANS">
    <tag/Neureka ANS (nn&#47;xnn)/
        <itemize>
         <item>FTP site: <htmlurl 
                url="ftp://ftp.ii.uib.no/pub/neureka/" 
                name="ftp.ii.uib.no/pub/neureka/">
        </itemize> 
     
      nn is a high-level neural network specification language. The
      current version is best suited for feed-forward nets, but
      recurrent models can and have been implemented, e.g. Hopfield
      nets, Jordan/Elman nets, etc.  In nn, it is easy to change
      network dynamics. The nn compiler can generate C code or
      executable programs (so there must be a C compiler available),
      with a powerful command line interface (but everything may also
      be controlled via the graphical interface, xnn). It is possible
      for the user to write C routines that can be called from inside
      the nn specification, and to use the nn specification as a
      function that is called from a C program. Please note that no
      programming is necessary in order to use the network models that
      come with the system (`netpack').  
      
 
      xnn is a graphical front end to networks generated by the nn
      compiler, and to the compiler itself. The xnn graphical
      interface is intuitive and easy to use for beginners, yet
      powerful, with many possibilities for visualizing network data.
      
 
      NOTE: You have to run the install program that comes with this
      to get the license key installed. It gets put (by default) in
      /usr/lib. If you (like myself) want to install the package
      somewhere other than in the /usr directory structure (the
      install program gives you this option) you will have to set up
      some environmental variables (NNLIBDIR & NNINCLUDEDIR are
      required). You can read about these (and a few other optional
      variables) in appendix A of the documentation (pg 113).


      <label id="NEURON">
      <tag/NEURON/  
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.neuron.yale.edu/" 
                name="www.neuron.yale.edu/">
        </itemize>
     
      NEURON is an extensible nerve modeling and simulation
      program. It allows you to create complex nerve models by
      connecting multiple one-dimensional sections together to form
      arbitrary cell morphologies, and allows you to insert multiple
      membrane properties into these sections (including channels,
      synapses, ionic concentrations, and counters). The interface was
      designed to present the neural modeler with a intuitive
      environment and hide the details of the numerical methods used
      in the simulation.
     

    
    <label id="PDP++">
    <tag/PDP++/
      <itemize>
        <item>Web site: <htmlurl
            url="http://www.cnbc.cmu.edu/Resources/PDP++/"
            name="www.cnbc.cmu.edu/Resources/PDP++/">
        <item>FTP site (US): <htmlurl
            url="ftp://cnbc.cmu.edu/pub/pdp++/"
            name="cnbc.cmu.edu/pub/pdp++/">
        <item>FTP mirror (US): <htmlurl
            url="ftp://grey.colorado.edu/pub/oreilly/pdp++/"
            name="grey.colorado.edu/pub/oreilly/pdp++/">
        <item>FTP mirror (Europe): <htmlurl
            url="ftp://unix.hensa.ac.uk/mirrors/pdp++/"
            name="unix.hensa.ac.uk/mirrors/pdp++/">
      </itemize>
     
      As the field of Connectionist modeling has grown, so has the need
      for a comprehensive simulation environment for the development and
      testing of Connectionist models. Our goal in developing PDP++ has been
      to integrate several powerful software development and user interface
      tools into a general purpose simulation environment that is both user
      friendly and user extensible. The simulator is built in the C++
      programming language, and incorporates a state of the art script
      interpreter with the full expressive power of C++. The graphical user
      interface is built with the Interviews toolkit, and allows full access
      to the data structures and processing modules out of which the
      simulator is built. We have constructed several useful graphical
      modules for easy interaction with the structure and the contents of
      neural networks, and we've made it possible to change and adapt many
      things. At the programming level, we have set things up in such a way
      as to make user extensions as painless as possible. The programmer
      creates new C++ objects, which might be new kinds of units or new
      kinds of processes; once compiled and linked into the simulator, these
      new objects can then be accessed and used like any other.
     


      <label id="RNS">
      <tag/RNS/  
    	<itemize>
            <item>Web site: <htmlurl url="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/rns/" name="www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/rns/">
        </itemize>
     
      RNS (Recurrent Network Simulator) is a simulator for recurrent
      neural networks. Regular neural networks are also supported. The
      program uses a derivative of the back-propagation algorithm, but
      also includes other (not that well tested) algorithms.
      
      Features include
      <itemize>	
        <item>freely choosable connections, no restrictions besides memory
	        or CPU constraints
    	<item>delayed links for recurrent networks
	    <item>fixed values or thresholds can be specified for weights
	    <item>(recurrent) back-propagation, Hebb, differential Hebb, 
                simulated annealing and more  
	    <item>patterns can be specified with bits, floats, characters, 
                numbers, and random bit patterns with Hamming distances can 
                be chosen for you
	    <item>user definable error functions
	    <item>output results can be used without modification as input
      </itemize>
     

    
    <label id="Python ANN">
    <tag/Simple Neural Net (in Python)/
     	<itemize>
            <item>Web site: <htmlurl
            url="http://www.amk.ca/python/unmaintained/"
            name="http://www.amk.ca/python/unmaintained/">
        </itemize>
     
      Simple neural network code, which implements a class for 3-level
      networks (input, hidden, and output layers). The only learning
      rule implemented is simple backpropagation. No documentation (or
      even comments) at all, because this is simply code that I use to
      experiment with. Includes modules containing sample datasets
      from Carl G. Looney's NN book. Requires the Numeric
      extensions. 
     


    <label id="SCNN">
    <tag/SCNN/
      <itemize>
        <item>Web site: <htmlurl 
         url="http://www.uni-frankfurt.de/fb13/iap/e_ag_rt/SCNN/" 
         name="www.uni-frankfurt.de/fb13/iap/e_ag_rt/SCNN/">
      </itemize>
     
      SCNN is an universal simulating system for Cellular Neural
      Networks (CNN).  CNN are analog processing neural networks
      with regular and local interconnections, governed by a set of
      nonlinear ordinary differential equations. Due to their local
      connectivity, CNN are realized as VLSI chips, which operates
      at very high speed.
     


    <label id="Python Smantic Nets">
    <tag/Semantic Networks in Python/
      <itemize>
        <item>Web site: <htmlurl
        url="http://strout.net/info/coding/python/ai/index.html" name="strout.net/info/coding/python/ai/index.html">
      </itemize>
    
     
      The semnet.py module defines several simple classes for
      building and using semantic networks.  A semantic network is a
      way of representing knowledge, and it enables the program to
      do simple reasoning with very little effort on the part of the
      programmer.
      

      The following classes are defined:
      <itemize>    	
        <item><bf>Entity</bf>: This class represents a noun; it is
	        something which can be related to other things, and about
	        which you can store facts.
	    <item><bf>Relation</bf>: A Relation is a type of relationship
	        which may exist between two entities.  One special relation,
	        "IS&lowbar;A", is predefined because it has special meaning (a sort
	        of logical inheritance).
	    <item><bf>Fact</bf>: A Fact is an assertion that a relationship 
	        exists between two entities.
      </itemize>
      <p>

      With these three object types, you can very quickly define knowledge 
      about a set of objects, and query them for logical conclusions.
     


    <label id="SNNS">
    <tag/SNNS/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www-ra.informatik.uni-tuebingen.de/SNNS/"
            name="www-ra.informatik.uni-tuebingen.de/SNNS/">
        <item>FTP site: <htmlurl 
            url="ftp://ftp.informatik.uni-stuttgart.de/pub/SNNS/" 
            name="ftp.informatik.uni-stuttgart.de/pub/SNNS/">
      </itemize>
     
      Stuttgart Neural Net Simulator (version 4.1).  An awesome neural
      net simulator. Better than any commercial simulator I've seen. The
      simulator kernel is written in C (it's fast!). It supports over 20
      different network architectures, has 2D and 3D X-based graphical
      representations, the 2D GUI has an integrated network editor, and can
      generate a separate NN program in C. SNNS is very powerful, though
      a bit difficult to learn at first. To help with this it comes with
      example networks and tutorials for many of the architectures.
      ENZO, a supplementary system allows you to evolve your networks with
      genetic algorithms.
      

    <label id="SPRLIB-ANNLIB">
    <tag/SPRLIB&#47;ANNLIB/
      <itemize>
        <item>Web site: <htmlurl url="http://www.ph.tn.tudelft.nl/&tilde;sprlib/" name="www.ph.tn.tudelft.nl/&tilde;sprlib/">
      </itemize>
    
     
      SPRLIB (Statistical Pattern Recognition Library) was developed
      to support the easy construction and simulation of pattern
      classifiers. It consist of a library of functions (written in C)
      that can be called from your own program. Most of the well-known
      classifiers are present (k-nn, Fisher, Parzen, ....), as well as
      error estimation and dataset generation routines.
      

      ANNLIB (Artificial Neural Networks Library) is a neural network
      simulation library based on the data architecture laid down by
      SPRLIB. The library contains numerous functions for creating,
      training and testing feed-forward networks.  Training algorithms
      include back-propagation, pseudo-Newton, Levenberg-Marquardt,
      conjugate gradient descent, BFGS.... Furthermore, it is possible
      - due to the datastructures' general applicability - to build
      Kohonen maps and other more exotic network architectures using
      the same data types.
     

   

      <label id="TOOLDIAG">
      <tag/TOOLDIAG/  
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.inf.ufes.br/&tilde;thomas/home/soft.html" 
                name="www.inf.ufes.br/&tilde;thomas/home/soft.html">
            <item>Alt site: <htmlurl 
                url="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/tooldiag/0.html" 
                name="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/neural/systems/tooldiag/0.html">
        </itemize>

      TOOLDIAG is a collection of methods for statistical pattern
      recognition. The main area of application is classification. The
      application area is limited to multidimensional continuous
      features, without any missing values. No symbolic features
      (attributes) are allowed. The program in implemented in the 'C'
      programming language and was tested in several computing
      environments. 
     

    <label id="XNBC">
    <tag/XNBC/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.b3e.jussieu.fr/xnbc/"
                name="www.b3e.jussieu.fr/xnbc/">
        </itemize>
	
	XNBC v8 is a simulation tool for the neuroscientists interested in
        simulating biological neural networks using a user friendly tool. 

        XNBC is a software package for simulating biological neural networks. 

        Four neuron models are available, three phenomenologic models (xnbc, 
	leaky integrator and conditional burster) and an ion-conductance based 
	model. Inputs to the simulated neurons can be provided by experimental 
	data stored in files, allowing the creation of `hybrid'' networks. 



  </descrip>
  
     
 
<sect>Evolutionary Computing
    <p>
	Evolutionary computing is actually a broad term for a vast
	array of programming techniques, including genetic algorithms,
	complex adaptive systems, evolutionary programming, etc.
	The main thrust of all these techniques is the idea of
	evolution. The idea that a program can be written that will
	<it>evolve</it> toward a certain goal.  This goal can be
	anything from solving some engineering problem to winning a
	game.

     
    <sect1>EC class/code libraries
    <p>
    
    These are libraries of code or classes for use in programming within
    the evolutionary computation field.  They are not meant as stand alone
    applications, but rather as tools for building your own applications.

    <descrip>


    <label id="daga">
    <tag/daga/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://garage.cps.msu.edu/software/daga3.2/"    
                name="garage.cps.msu.edu/software/daga3.2/">
        </itemize>


        daga is an experimental release of a 2-level genetic algorithm  
        compatible with the GALOPPS GA software. It is a meta-GA which
        dynamically evolves a population of GAs to solve a problem presented to
        the lower-level GAs. When multiple GAs (with different operators,
        parameter settings, etc.) are simultaneously applied to the same
        problem, the ones showing better performance have a higher probability
        of surviving and "breeding" to the next macro-generation (i.e.,
        spawning new "daughter"-GAs with characteristics inherited from the
        parental GA or GAs.  In this way, we try to encourage good  
        problem-solving strategies to spread to the whole population of GAs.


    <label id="Ease">
    <tag/Ease/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.sprave.com/Ease/Ease.html" 
                name="www.sprave.com/Ease/Ease.html">
        </itemize>

        Ease - Evolutionary Algorithms Scripting Evironment - is an extension
        to the Tcl scripting language, providing commands to create, modify,
        and evaluate populations of individuals represented by real number
        vectors and/or bit strings.



    <label id="EO">
    <tag/EO/ 
        <itemize>
            <item>Web site: <htmlurl
                url="http://eodev.sourceforge.net/"
                name="eodev.sourceforge.net">
        </itemize>

        EO is a templates-based, ANSI-C++ compliant evolutionary
        computation library. It contains classes for any kind of
        evolutionary computation (specially genetic algorithms) you might
        come up to. It is component-based, so that if you don't find the
        class you need in it, it is very easy to subclass existing  
        abstract or concrete class.



    <label id="Fortran GA">
    <tag/FORTRAN GA/
    <itemize>
        <item>Web site: <htmlurl 
            url="http://cuaerospace.com/carroll/ga.html" 
            name="cuaerospace.com/carroll/ga.html">
    </itemize>
      
       
        This program is a FORTRAN version of a genetic algorithm driver.
        This code initializes a random sample of individuals with
        different parameters to be optimized using the genetic algorithm
        approach, i.e.  evolution via survival of the fittest.  The
        selection scheme used is tournament selection with a shuffling
        technique for choosing random pairs for mating.  The routine
        includes binary coding for the individuals, jump mutation, creep
        mutation, and the option for single-point or uniform crossover.
        Niching (sharing) and an option for the number of children per
        pair of parents has been added.  More recently, an option for
        the use of a micro-GA has been added.
       

    <label id="GALib">
    <tag/GAlib: Matthew's Genetic Algorithms Library/ 
    <itemize>
        <item>Web Site: <htmlurl 
            url="http://lancet.mit.edu/ga/" 
            name="lancet.mit.edu/ga/"> 
        <item>Download: <htmlurl
            url="http://lancet.mit.edu/ga/dist/" 
            name="lancet.mit.edu/ga/dist/">
        <item>Register GAlib at: <htmlurl 
            url="http://lancet.mit.edu/ga/Register.html" 
            name="lancet.mit.edu/ga/Register.html">
     </itemize>

     
      GAlib contains a set of C++ genetic algorithm objects.  The
      library includes tools for using genetic algorithms to do
      optimization in any C++ program using any representation and genetic
      operators.  The documentation includes an extensive overview of how
      to implement a genetic algorithm as well as examples illustrating
      customizations to the GAlib classes.
     


    <label id="GALOPPS">
    <tag/GALOPPS/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://garage.cps.msu.edu/software/galopps/" 
            name="garage.cps.msu.edu/software/galopps/">
        <item>FTP site: <htmlurl 
            url="ftp://garage.cps.msu.edu/pub/GA/galopps/" 
            name="garage.cps.msu.edu/pub/GA/galopps/">
      </itemize>

     
      GALOPPS is a flexible, generic GA, in 'C'.  It was based upon
      Goldberg's Simple Genetic Algorithm (SGA) architecture, in order to
      make it easier for users to learn to use and extend.
      

      GALOPPS extends the SGA capabilities several fold:
      <itemize>	
            <item> (optional) A new Graphical User Interface, based on TCL/TK, 
                for Unix users, allowing easy running of GALOPPS 3.2 (single 
                or multiple subpopulations) on one or more processors.  GUI 
                writes/reads "standard" GALOPPS input and master files, and 
                displays graphical output (during or after run) of 
                user-selected variables.
	    <item> 5 selection methods: roulette wheel, stochastic remainder
	        sampling, tournament selection, stochastic universal sampling,
	        linear-ranking-then-SUS.
	    <item> Random or superuniform initialization of "ordinary"
	        (non-permutation) binary or non-binary chromosomes; random
	        initialization of permutation-based chromosomes; or 
                user-supplied initialization of arbitrary types of chromosomes.
	    <item> Binary or non-binary alphabetic fields on value-based
	        chromosomes, including different user-definable field sizes.
	    <item> 3 crossovers for value-based representations: 1-pt, 2-pt, and
	        uniform, all of which operate at field boundaries if a 
                non-binary alphabet is used.
	    <item> 4 crossovers for order-based reps: PMX, order-based, uniform
	        order-based, and cycle.
	    <item> 4 mutations: fast bitwise, multiple-field, swap and random
	        sublist scramble.
	    <item> Fitness scaling: linear scaling, Boltzmann scaling, sigma
	        truncation, window scaling, ranking.
	    <item><bf>Plus</bf> a whole lot more....
      </itemize>


    <label id="GAS">
    <tag/GAS/  
      <itemize>
        <item>Web site: <htmlurl url="http://starship.python.net/crew/gandalf/" name="starship.skyport.net/crew/gandalf">
      </itemize>

     
      GAS means "Genetic Algorithms Stuff".

      GAS is freeware.

      Purpose of GAS is to explore and exploit artificial evolutions.
      Primary implementation language of GAS is Python.  The GAS
      software package is meant to be a Python framework for applying
      genetic algorithms. It contains an example application where it
      is tried to breed Python program strings.  This special problem
      falls into the category of Genetic Programming (GP), and/or
      Automatic Programming.  Nevertheless, GAS tries to be useful for
      other applications of Genetic Algorithms as well.
     

    <label id="GAUL">
    <tag/GAUL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://gaul.sourceforge.net/"
                name="gaul.sourceforge.net">
            <item>SF project site: <htmlurl 
                url="http://sourceforge.net/projects/gaul/"
                name="sourceforge.net/projects/gaul/">
        </itemize>

        The Genetic Algorithm Utility Library (GAUL) is a flexible programming
        library designed to aid development of applications that require the
        use of genetic algorithms.  Features include:
        
        <itemize>
            <item>Darwinian, Lamarckian or Baldwinian evolutionary schemes.
            <item>Both steady-state and generation-based GAs included.
            <item>The island model of evolution is available.
            <item>Chromosome datatype agnostic. A selection of common chromosome
                types are built-in.
            <item>Allows user-defined crossover, mutation, selection, adaptation
                and replacement operators.
            <item>Support for multiple, simultaneously evolved,populations.
            <item>Choice of high-level or low-level interface functions.
            <item>Additional, non-GA, optimisation algorithms are built-in for
                local optimisation or comparative purposes.
            <item>Trivial to extend using external code via the built-in code 
                hooks.
            <item>May be driven by, or extended by, powerful S-Lang scripts.
            <item>Support for multiprocessor calculations.
            <item>Written using highly portable C code.
        </itemize>


    <label id="GECO">
    <tag/GECO/
    <itemize>
      <item>FTP site: <htmlurl
            url="ftp://ftp.aic.nrl.navy.mil/pub/galist/src/"
            name="ftp://ftp.aic.nrl.navy.mil/pub/galist/src/">
    </itemize>

     
      GECO (Genetic Evolution through Combination of Objects), an
      extendible object-oriented tool-box for constructing genetic algorithms
      (in Lisp).  It provides a set of extensible classes and methods
      designed for generality. Some simple examples are also provided to
      illustrate the intended use.
     

    <label id="Genetic">
    <tag/Genetic/
        <itemize>
            <item>Web site: ???
            <item>You can get it from the debian repository:
                <htmlurl
                    url="http://packages.qa.debian.org/g/genetic.html"
                    name="packages.qa.debian.org/g/genetic.html">
        </itemize>

        This is a package for genetic algorythms and AI in Python.

        Genetic can typically solve ANY problem that consists to minimize a 
        function.

        It also includes several demos / examples, like the TSP (traveling 
        saleman problem).


    <label id="GPdata">
    <tag/GPdata/
    <itemize>
      <item>FTP site: <htmlurl url="ftp://ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/" name="ftp.cs.bham.ac.uk/pub/authors/W.B.Langdon/gp-code/"> 
      <item>Documentation (GPdata-icga-95.ps): <htmlurl url="ftp://cs.ucl.ac.uk/genetic/papers/" name="cs.ucl.ac.uk/genetic/papers/">
     </itemize>

     
      GPdata-3.0.tar.gz (C++) contains a version of Andy Singleton's 
      GP-Quick version 2.1 which has been extensively altered to support:
      <itemize>	
        <item>Indexed memory operation (cf. teller)
    	<item>multi tree programs
        <item>Adfs
        <item>parameter changes without recompilation
        <item>populations partitioned into demes
        <item>(A version of) pareto fitness
      </itemize>
      This ftp site also contains a small C++ program (ntrees.cc) to 
      calculate the number of different there are of a given length and 
      given function and terminal set.
     

    <label id="Java GP - gpjpp">
    <tag/gpjpp Genetic Programming in Java/
      <itemize>
          <item>The code can be found in the tarball linked from 
            "GP and Othello Java code and READMEs" on this page: <htmlurl 
              url="http://www1.cs.columbia.edu/~evs/ml/hw4.html" 
              name="http://www1.cs.columbia.edu/~evs/ml/hw4.html">
      </itemize>

      gpjpp is a Java package I wrote for doing research in genetic
      programming. It is a port of the gpc++ kernel written by Adam
      Fraser and Thomas Weinbrenner. Included in the package are
      four of Koza's standard examples: the artificial ant, the
      hopping lawnmower, symbolic regression, and the boolean
      multiplexer. Here is a partial list of its features:
      <itemize>
        <item>graphic output of expression trees
	    <item>efficient diversity checking 
    	<item>Koza's greedy over-selection option for large populations
	    <item>extensible GPRun class that encapsulates most details of a
	        genetic programming test
    	<item>more robust and efficient streaming code, with automatic 
            checkpoint and restart built into the GPRun class
    	<item>an explicit complexity limit that can be set on each GP
	    <item>additional configuration variables to allow more testing 
                without recompilation
	    <item>support for automatically defined functions (ADFs)
	    <item>tournament and fitness proportionate selection
	    <item>demetic grouping
	    <item>optional steady state population
	    <item>subtree crossover
	    <item>swap and shrink mutation
      </itemize>


    <label id="jaga">
    <tag/jaga/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://cs.felk.cvut.cz/&tilde;koutnij/studium/jaga/jaga.html" 
                name="cs.felk.cvut.cz/&tilde;koutnij/studium/jaga/jaga.html">
        </itemize>

        Simple genetic algorithm package written in Java.


    <label id="lil-gp">
    <tag/lil-gp/
      <itemize>
        <item>Web site: <htmlurl
            url="http://garage.cps.msu.edu/software/lil-gp/" 
            name="garage.cps.msu.edu/software/lil-gp/">
        <item>FTP site: <htmlurl 
            url="ftp://garage.cps.msu.edu/pub/GA/lilgp/" 
            name="garage.cps.msu.edu/pub/GA/lilgp/">
      </itemize>

    <tag/patched lil-gp */  
       	<itemize>
            <item>Web site: <htmlurl
            url="http://www.cs.umd.edu/users/seanl/gp/"
            name="www.cs.umd.edu/users/seanl/gp/">
        </itemize>

      lil-gp is a generic 'C' genetic programming tool. It was written
      with a number of goals in mind: speed, ease of use and support for a
      number of options including:
      <itemize>
	    <item> Generic 'C' program that runs on UNIX workstations
	    <item> Support for multiple population experiments, using 
                arbitrary and user settable topologies for exchange, for 
                a single processor (i.e., you can do multiple population gp 
                experiments on your PC).
	    <item> lil-gp manipulates trees of function pointers which are 
                allocated in single, large memory blocks for speed and to 
                avoid swapping.
      </itemize>
      * The patched lil-gp kernel is strongly-typed, with modifications on 
      multithreading, coevolution, and other tweaks and features.
     

    <label id="Lithos">
    <tag/Lithos/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.esatclear.ie/&tilde;rwallace/lithos.html" 
                name="www.esatclear.ie/&tilde;rwallace/lithos.html">
        </itemize>

        Lithos is a stack based evolutionary computation system. Unlike most EC
        systems, its representation language is computationally complete, while
        also being faster and more compact than the S-expressions used in
        genetic programming. The version presented here applies the system to
        the game of Go, but can be changed to other problems by simply plugging
        in a different evaluation function. ANSI C source code is provided.


    <label id="Open BEAGLE">
    <tag/Open BEAGLE/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://beagle.gel.ulaval.ca/"
                name="beagle.gel.ulaval.ca">
        </itemize>

        Open BEAGLE is a C++ evolutionary computation framework. It provides a
        high-level software environment to do any kind of evolutionary
        computation, with support for tree-based genetic programming, bit
        string and real-valued genetic algorithms, evolution strategy,
        co-evolution, and evolutionary multi-objective optimization.


    <label id="PGAPack">
    <tag/PGAPack/ Parallel Genetic Algorithm Library
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www-fp.mcs.anl.gov/CCST/research/reports_pre1998/comp_bio/stalk/pgapack.html" 
            name="www-fp.mcs.anl.gov/CCST/research/reports_pre1998/comp_bio/stalk/pgapack.html">
        <item>FTP site: <htmlurl 
            url="ftp://ftp.mcs.anl.gov/pub/pgapack/" 
            name="ftp.mcs.anl.gov/pub/pgapack/">
      </itemize>

      PGAPack is a general-purpose, data-structure-neutral, parallel
      genetic algorithm library. It is intended to provide most capabilities
      desired in a genetic algorithm library, in an integrated, seamless,
      and portable manner. Key features are in PGAPack V1.0 include:
      <itemize>
        <item>Callable from Fortran or C. 
    	<item>Runs on uniprocessors, parallel computers, and workstation networks.
	    <item>Binary-, integer-, real-, and character-valued native data types. 
	    <item>Full extensibility to support custom operators and new data types. 
	    <item>Easy-to-use interface for novice and application users. 
	    <item>Multiple levels of access for expert users. 
	    <item>Parameterized population replacement. 
    	<item>Multiple crossover, mutation, and selection operators. 
	    <item>Easy integration of hill-climbing heuristics. 
    	<item>Extensive debugging facilities. 
	    <item>Large set of example problems. 
	    <item>Detailed users guide.
      </itemize>
     


      <label id="PIPE">
      <tag/PIPE/   
       <itemize>
        <item>Web site: <htmlurl
            url="http://www.idsia.ch/&tilde;rafal/research.html" 
            name="www.idsia.ch/&tilde;rafal/research.html">
        <item>FTP site: <htmlurl 
            url="ftp://ftp.idsia.ch/pub/rafal/" 
            name="ftp.idsia.ch/pub/rafal">
       </itemize>
     
      Probabilistic Incremental Program Evolution (PIPE) is a novel
      technique for automatic program synthesis. The software is written in C. It
      <itemize>
    	<item>is easy to install (comes with an automatic installation tool).
	    <item>is easy to use: setting up PIPE&lowbar;V1.0 for different problems
	        requires a minimal amount of programming. User-written, application-
	        independent program parts can easily be reused.
	    <item>is efficient: PIPE&lowbar;V1.0 has been tuned to speed up performance.
	    <item>is portable: comes with source code (optimized for SunOS 5.5.1).
	    <item>is extensively documented(!) and contains three example applications.
	    <item>supports statistical evaluations: it facilitates running  multiple
	        experiments and collecting results in output files.
	    <item>includes testing tool for testing generalization of evolved programs.
	    <item>supports floating point and integer arithmetic.
	    <item>has extensive output features.
	    <item>For lil-gp users: Problems  set up for lil-gp 1.0 can be easily ported to PIPE&lowbar;v1.0.
	        The  testing tool can also be used to process programs evolved by
	        lil-gp 1.0.
      </itemize>
     

    <label id="pygp">
    <tag/pygp/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://pygp.sourceforge.net/"
                name="pygp.sourceforge.net/">
        </itemize>

        Your basic genetic algorithm package for python.


    <label id="Sugal">
    <tag/Sugal/
      <itemize>
        <item>Web site: <htmlurl
            url="http://www.trajan-software.demon.co.uk/sugal.htm"
            name="www.trajan-software.demon.co.uk/sugal.htm">
      </itemize>

        Sugal &lsqb;soo-gall&rsqb; is the SUnderland Genetic ALgorithm system.
        The aim of Sugal is to support research and implementation in Genetic
        Algorithms on a common software platform. As such, Sugal supports a
        large number of variants of Genetic Algorithms, and has extensive
        features to support customization and extension.
     

  </descrip>

     
    <sect1>EC software kits/applications
    <p>
    
    These are various applications, software kits, etc. meant for research
    in the field of evolutionary computing. Their ease of use will vary, as they
    were designed to meet some particular research interest more than as
    an easy to use commercial package.

    <descrip>

      
      <label id="ADATE">
      <tag/ADATE/
    	<itemize>
            <item>Web site: <htmlurl 
                url="http://www-ia.hiof.no/&tilde;rolando/adate&lowbar;intro.html" 
                name="www-ia.hiof.no/&tilde;rolando/adate&lowbar;intro.html">
        </itemize>

	ADATE (Automatic Design of Algorithms Through Evolution) is a system 
        for automatic programming i.e., inductive inference of algorithms, 
        which may be the best way to develop artificial and general 
        intelligence.
	

	The ADATE system can automatically generate non-trivial and novel
	algorithms. Algorithms are generated through large scale combinatorial
	search that employs sophisticated program transformations and
	heuristics. The ADATE system is particularly good at synthesizing
	symbolic, functional programs and has several unique qualities.
       

 
   <label id="esep-xesep">
   <tag/esep & xesep/
    <itemize>
      <item>Web site(esep): <htmlurl 
            url="http://www.iit.edu/&tilde;elrad/esep.html" 
            name="www.iit.edu/&tilde;elrad/esep.html">
      <item>Web site(xesep): <htmlurl 
            url="http://www.iit.edu/&tilde;elrad/xesep.html" 
            name="www.iit.edu/&tilde;elrad/xesep.html">
    </itemize>

     
      This is a new scheduler, called Evolution Scheduler, based on
      Genetic Algorithms and Evolutionary Programming. It lives with
      original Linux priority scheduler.This means you don't have to
      reboot to change the scheduling policy. You may simply use the
      manager program esep to switch between them at any time, and
      esep itself is an all-in-one for scheduling status, commands,
      and administration. We didn't intend to remove the original
      priority scheduler; instead, at least, esep provides you with
      another choice to use a more intelligent scheduler, which
      carries out natural competition in an easy and effective way.
      

      Xesep is a graphical user interface to the esep (Evolution
      Scheduling and Evolving Processes). It's intended to show users
      how to start, play, and feel the Evolution Scheduling and
      Evolving Processes, including sub-programs to display system
      status, evolving process status, queue status, and evolution
      scheduling status periodically in as small as one mini-second.


    <label id="Corewars">
    <tag/Corewars/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://corewars.sourceforge.net/" 
                name="corewars.sourceforge.net/">
            <item>SourceForge site: <htmlurl
                url="http://sourceforge.net/projects/corewars/"
                name="sourceforge.net/projects/corewars/">
        </itemize>
        
        Corewars is a game which simulates a virtual machine with a number of
        programs. Each program tries to crash the others. The program that 
        lasts the longest time wins. A number of sample programs are provided
        and new programs can be written by the player. Screenshots are 
        available at the Corewars homepage.


    <label id="Grany-3">
    <tag/Grany-3/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://zarb.org/~gc/html/grany.html"
                name="zarb.org/~gc/html/grany.html">
        </itemize>

        Grany-3 is a full-featured cellular automaton simulator, made in C++
        with Gtk--, flex++/bison++, doxygen and gettext, useful to granular
        media physicists. 


    <label id="JCASim">
    <tag/JCASim/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.jweimar.de/jcasim/"
                name="www.jweimar.de/jcasim/">
        </itemize>

        JCASim is a general-purpose system for simulating cellular automata in
        Java. It includes a stand-alone application and an applet for web
        presentations. The cellular automata can be specified in Java, in CDL,
        or using an interactive dialogue. The system supports many different
        lattice geometries (1-D, 2-D square, hexagonal, triangular, 3-D),
        neighborhoods, boundary conditions, and can display the cells using
        colors, text, or icons.


    <label id="JGProg">
    <tag/JGProg/
        <itemize>
            <item>Web site: <htmlurl
                url="http://jgprog.sourceforge.net/"
                name="jgprog.sourceforge.net">
        </itemize>
        
        Genetic Programming (JGProg) is an open-source Java implementation of
        a strongly-typed Genetic Programming experimentation platform. Two 
        example "worlds" are provided, in which a population evolves and 
        solves the problem.


  </descrip>


     
    
<sect>Alife &amp; Complex Systems
    <p> 

    Alife takes yet another approach to exploring the mysteries of
    intelligence.  It has many aspects similar to EC and Connectionism, but
    takes these ideas and gives them a meta-level twist. Alife emphasizes the
    development of intelligence through <it>emergent</it> behavior of
    <it>complex adaptive systems</it>.  Alife stresses the social or group
    based aspects of intelligence. It seeks to understand life and survival. By
    studying the behaviors of groups of 'beings' Alife seeks to discover the
    way intelligence or higher order activity emerges from seemingly simple
    individuals. Cellular Automata and Conway's Game of Life are probably the
    most commonly known applications of this field. Complex Systems
    (abbreviated CS) are very similar to alife in the way the are approached,
    just more general in definition (ie.  alife is a type of complex system).
    Usually complex system software takes the form of a simulator.

     
    <sect1>Alife &amp; CS class/code libraries
    <p> 

    These are libraries of code or classes for use in programming within
    the artificial life field.  They are not meant as stand alone
    applications, but rather as tools for building your own applications.
    


    <descrip>


    <label id="AgentFarms">
    <tag/AgentFarms/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.agentfarms.net" 
                name="www.agentfarms.net">
        </itemize>

        Agent Farms is a system for modelling and simulation of complex,
        multi-agent based systems. The system can be used for:     
        <itemize>
         <item>Creating models of multi-agent systems
         <item>Interactive and distributed simulation
         <item>Observation and visualisation of the simulation
         <item>Population modification and migration
        </itemize>
               

    <label id="Biome">
    <tag/Biome/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://woes001.eco-station.uni-wuerzburg.de/&tilde;martin/biome/"
                name="woes001.eco-station.uni-wuerzburg.de/&tilde;martin/biome/">
            <item>Alt Web site: <htmlurl 
                url="http://132.187.24.1/&tilde;martin/biome/"
                name="http://132.187.24.1/&tilde;martin/biome/">
        </itemize>

        Biome is a C++ library aimed at individual-based/agent-based
        simulations. It is somewhat similar to Swarm, EcoSim or Simex but tries
        to be more efficient and less monolithic without compromising object-
        oriented design. Currently there is an event based scheduling system, a
        C++ified Mersenne-Twister RNG, several general analysis classes, some
        Qt-based GUI classes, a very basic persistence/database framework (used
        also for parameter storage) and many other small useful things. 


    <label id="CAGE">
    <tag/CAGE/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.alcyone.com/software/cage/"
                name="www.alcyone.com/software/cage/">
        </itemize>

         CAGE is a fairy generic and complete cellular automaton simulation
         engine in Python. It supports both 1D and 2D automata, a variety of
         prepackaged rules, and the concept of "agents" which can move about
         independently on the map for implementing agent behavior.


    <label id="Integrating Modelling Toolkit">
    <tag/Integrating Modelling Toolkit/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://sourceforge.net/projects/imt/"
                name="sourceforge.net/projects/imt/">
        </itemize>
        
        The Integrating Modelling Toolkit (IMT) is a generic, comprehensive,
        and extensible set of abstractions allowing definition and use of
        interoperable model components.  Modellers create an IMT "world" made
        of IMT "agents" that will perform each a particular phase of a
        modelling task.  The core set of IMT agents can describe generic,
        modular, distributed model components, either native to the IMT or
        integrating existing simulation toolkits, specialized for tasks that
        range from simple calculation of functions in an interpreted language
        to spatially explicit simulation, model optimization, GIS analysis,
        visualization and advanced statistical analysis.  IMT agents are
        designed to easily "glue" together in higher-level simulations
        integrating different modelling paradigms and toolkits.  The IMT can be
        easily extended by users and developers through a convenient plug-in
        mechanism


    <label id="MAML">
    <tag/MAML/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.maml.hu/" 
                name="www.maml.hu">
        </itemize>

        The current version of MAML is basically an extension to Objective-C
        (using the Swarm libraries). It consists of a couple of
        'macro-keywords' that define the general structure of a simulation. The
        remaining must be filled with pure swarm-code. A MAML-to-Swarm (named
        xmc) compiler is also being developed which compiles the source code
        into a swarm application.


    <label id="MASON">
    <tag/MASON/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://cs.gmu.edu/~eclab/projects/mason/"
                name="cs.gmu.edu/~eclab/projects/mason/">
        </itemize>

        MASON Stands for Multi-Agent Simulator Of Neighborhoods... or
        Networks... or something... 

        MASON is a fast discrete-event multiagent simulation library core in
        Java, designed to be the foundation for large custom-purpose Java
        simulations, and also to provide more than enough functionality for
        many lightweight simulation needs. MASON contains both a model library
        and an optional suite of visualization tools in 2D and 3D.


    <label id="SimWorld">
    <tag/SimWorld/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.nd.edu/~airolab/simworld/"
                name="www.nd.edu/~airolab/simworld/">
        </itemize>

        SimWorld is a free artificial life simulation (based on the free 
        <ref id="SimAgent"> toolkit developed by Aaron Sloman), which provides
        functionality for running different interacting agents and objects in a
        simulated, continuous environment.  The agents are controlled by rules
        written in the powerful rule interpreter.   New behaviors of agents can
        be defined without any programming knowledge.


    <label id="Swarm">
    <tag/Swarm/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www.swarm.org/" 
            name="www.swarm.org">
        <item>FTP site: <htmlurl 
            url="ftp://ftp.swarm.org/pub/swarm/" 
            name="ftp.swarm.org/pub/swarm/">
      </itemize>

     
      The swarm Alife simulation kit. Swarm is a simulation environment
      which facilitates development and experimentation with simulations
      involving a large number of agents behaving and interacting within a
      dynamic environment.  It consists of a collection of classes and
      libraries written in Objective-C and allows great flexibility in
      creating simulations and analyzing their results.  It comes with three
      demos and good documentation. 
      

  </descrip>

    
     
    <sect1>Alife &amp; CS software kits, applications, etc.
    <p>

    These are various applications, software kits, etc. meant for research
    in the field of artificial life. Their ease of use will vary, as they
    were designed to meet some particular research interest more than as
    an easy to use commercial package.

    <descrip>


    <label id="Achilles">
    <tag/Achilles/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://achilles.sourceforge.net/" 
                name="achilles.sourceforge.net">
        </itemize>

        Achilles is an evolution simulation based on Larry Yaeger's PolyWorld.
        It uses Hebbian neural networks, and an extremely simplified physical
        model that allows virtual organisms to interact freely in a simulated
        environment. 


    <label id="AntWars">
    <tag/AntWars/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://ant-wars.com/"
                name="ant-wars.com">
        </itemize>
        
         Ant Wars is a competition which pits clever programs against each
         other to do battle and compete for food in virtual worlds. Each
         contestant is a species of ant, which can visualize only the world
         immediately around him and pheromones left by fellow and enemy ants.
         Using this information, the ant brain (a simple state machine) must
         guide the ant towards collecting food at his home ant hill, while
         fending off or attacking enemies.

         Clever use of pheromones and subtle behaviors can create large scale
         tactics such as raiding, defense, harvesting, and scouting when many
         ants cooperate. 


    <label id="Avida">
    <tag/Avida/
        <itemize>
            <item>Web site: <htmlurl
                url="http://dllab.caltech.edu/avida/"
                name="dllab.caltech.edu/avida/">
        </itemize>

        The computer program avida is an auto-adaptive genetic system designed
        primarily for use as a platform in Artificial Life research. The avida
        system is based on concepts similar to those employed by the tierra
        program, that is to say it is a population of self-reproducing strings
        with a Turing-complete genetic basis subjected to Poisson-random
        mutations. The population adapts to the combination of an intrinsic
        fitness landscape (self-reproduction) and an externally imposed
        (extrinsic) fitness function provided by the researcher. By studying 
        this system, one can examine evolutionary adaptation, general traits of
        living systems (such as self-organization), and other issues pertaining
        to theoretical or evolutionary biology and dynamic systems.


    <label id="breve">
    <tag/breve/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.spiderland.org/breve/"
                name="www.spiderland.org/breve/">
        </itemize>

        breve is a free software package which makes it easy to build 3D
        simulations of decentralized systems and artificial life. Users define
        the behaviors of agents in a 3D world and observe how they interact.
        breve includes physical simulation and collision detection so you can
        simulate realistic creatures, and an OpenGL display engine so you can
        visualize your simulated worlds.

       
    <label id="BugsX">
    <tag/BugsX/
        <itemize>
            <item>FTP site: <htmlurl
                url="http://surf.de.uu.net/zooland/download/packages/bugsx/"
                name="http://surf.de.uu.net/zooland/download/packages/bugsx/">
        </itemize>

       
        Display and evolve biomorphs. It is a program which draws the
        biomorphs based on parametric plots of Fourier sine and cosine series
        and let's you play with them using the genetic algorithm.
       

    <label id="Cellular Automat Sim">
    <tag/The Cellular Automata Simulation System/
      <itemize>
        <item>Web site: <htmlurl
                url="http://staff.vbi.vt.edu/dana/ca/cellular.shtml"
                name="staff.vbi.vt.edu/dana/ca/cellular.shtml">
      </itemize>

     
      The system consists of a compiler for the Cellang cellular
      automata programming language, along with the corresponding
      documentation, viewer, and various tools. Cellang has been
      undergoing refinement for the last several years (1991-1995),
      with corresponding upgrades to the compiler.  Postscript
      versions of the tutorial and language reference manual are
      available for those wanting more detailed information. The most
      important distinguishing features of Cellang, include support
      for:
      <itemize>
        <item>any number of dimensions; 
	    <item>compile time specification of each dimensions size; 
	        cell neighborhoods of any size (though bounded at compile time) and
	        shape; 
	    <item>positional and time dependent neighborhoods; 
	    <item>associating multiple values (fields), including arrays,
	        with each cell;
	    <item>associating a potentially unbounded number of mobile
	        agents &lsqb; Agents are mobile entities based on a mechanism of
	        the same name in the Creatures system, developed by Ian
	        Stephenson (ian@ohm.york.ac.uk).&rsqb; with each cell; and
	    <item>local interactions only, since it is impossible to
	        construct automata that contain any global control or
	        references to global variables.
      </itemize>
     

    <label id="Creatures Docking Station">
    <tag/Creatures Docking Station/
        <itemize>
            <item>Linux info: <htmlurl 
                url="http://www.simons-rock.edu/&tilde;rlovison/" 
                name="http://www.simons-rock.edu/&tilde;rlovison/">
        </itemize>

        This is a free version of the Creatures3 ALife game. It has fewer
        species and a small 'space-station' world, but can connect to other
        worlds over the internet and (if you have the windows version of the
        game) can connect to your C3 world. The game itself revolves around
        breeding and training the alife creatures, 'Norns'. Its strikes a
        pretty nice balance between fun and science, or so I'm told.


   <label id="dblife-dblifelib">
    <tag/dblife &amp; dblifelib/
    <itemize>
      <item>FTP site: <htmlurl 
            url="http://ibiblio.org/pub/Linux/science/ai/life/"
            name="ibiblio.org/pub/Linux/science/ai/life/">
    </itemize>

     
      <it>dblife:</it> Sources for a fancy Game of Life program for X11
      (and curses).  It is not meant to be incredibly fast (use xlife for
      that:-).  But it IS meant to allow the easy editing and viewing of
      Life objects and has some powerful features.  The related dblifelib
      package is a library of Life objects to use with the program.
      

      <it>dblifelib:</it> This is a library of interesting Life objects,
      including oscillators, spaceships, puffers, and other weird things.
      The related dblife package contains a Life program which can read the
      objects in the Library.
     


    <label id="Drone">
    <tag/Drone/
      <itemize>
        <item>Web site: <htmlurl url="http://pscs.physics.lsa.umich.edu/Software/Drone/" name="pscs.physics.lsa.umich.edu/Software/Drone/">
      </itemize>

     
      Drone is a tool for automatically running batch jobs of a simulation
      program. It allows sweeps over arbitrary sets of parameters, as well
      as multiple runs for each parameter set, with a separate random seed
      for each run. The runs may be executed either on a single computer or
      over the Internet on a set of remote hosts. Drone is written in Expect
      (an extension to the Tcl scripting language) and runs under Unix. It
      was originally designed for use with the Swarm agent-based simulation
      framework, but Drone can be used with any simulation program that
      reads parameters from the command line or from an input file.
 

    <label id="EcoLab">
    <tag/EcoLab/
      <itemize>
        <item>Web site: <htmlurl
                url="http://parallel.hpc.unsw.edu.au/rks/ecolab/"
                name="parallel.hpc.unsw.edu.au/rks/ecolab/">
      </itemize>
      
     
      EcoLab is a system that implements an abstract ecology model. It
      is written as a set of Tcl/Tk commands so that the model
      parameters can easily be changed on the fly by means of editing
      a script. The model itself is written in C++.
     


    <label id="Game Of Life">
    <tag/Game Of Life (GOL)/  
      <itemize>
        <item>FTP site: <htmlurl
            url="http://ibiblio.org/pub/Linux/science/ai/life/"
            name="ibiblio.org/pub/Linux/science/ai/life/">
      </itemize>
     
      GOL is a simulator for conway's game of life (a simple cellular
      automata), and other simple rule sets. The emphasis here is on
      speed and scale, in other words you can setup large and fast
      simulations.   


    <label id="gant">
    <tag/gant/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://gant.sourceforge.net/" 
                name="gant.sourceforge.net">
        </itemize>
        
        This project is an ANSI C++ implementation of the Generalized Langton
        Ant, which lives on a torus.



    <label id="gLife">
    <tag/gLife/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://glife.sourceforge.net/" 
                name="glife.sourceforge.net">
            <item>SourceForge site: <htmlurl 
                url="http://sourceforge.net/projects/glife/" 
                name="sourceforge.net/projects/glife/">
        </itemize>
        
        This program is similiar to "Conway's Game of Life" but yet it is very
        different. It takes "Conway's Game of Life" and applies it to a society
        (human society). This means there is a very different (and much larger)
        ruleset than in the original game. Things need to be taken into account
        such as the terrain, age, sex, culture, movement, etc



    <label id="Langton's Ant">
    <tag/Langton's Ant/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.theory.org/software/ant/"
                name="www.theory.org/software/ant/">
        </itemize>

        Langton's Ant is an example of a finite-state cellular automata. The
        ant (or ants) start out on a grid. Each cell is either black or white.
        If the ant is on a black square, it turns right 90 and moves forward
        one unit. If the ant is on a white square, it turns left 90 and moves
        forward one unit.  And when the ant leaves a square, it inverts the
        color. The neat thing about Langton's Ant is that no matter what
        pattern field you start it out on, it eventually builds a "road," which
        is a series of 117 steps that repeat indefinitely, each time leaving
        the ant displaced one pixel vertically and horizontally.
        


    <label id="LEE">
    <tag/LEE/
      <itemize>
        <item>Web site: <htmlurl
            url="http://www.informatics.indiana.edu/fil/LEE/"
            name="www.informatics.indiana.edu/fil/LEE/">
      </itemize>

     
      LEE (Latent Energy Environments) is both an Alife model and a
      software tool to be used for simulations within the framework of that
      model. We hope that LEE will help understand a broad range of issues
      in theoretical, behavioral, and evolutionary biology. The LEE tool
      described here consists of approximately 7,000 lines of C code and
      runs in both Unix and Macintosh platforms.
     

    <label id="MATREM">
    <tag/MATREM/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.phys.uu.nl/&tilde;romans/"
                name="www.phys.uu.nl/&tilde;romans/">
        </itemize>

        Matrem is a computer program that simulates life. It belongs to the
        emerging science of "artificial life", which studies evolution and
        complex systems in general by simulation. Matrem is also a game, where
        players compete to create the fittest lifeform. Their efforts are the
        driving force behind the program.


    <label id="Noble Ape">
    <tag/Noble Ape/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.nobleape.com/sim/"
                name="www.nobleape.com/sim/">
        </itemize>

        The Noble Ape Simulation has been developed (as the Nervana Simulation)
        since 1996. The aim of the simulation is to create a detailed
        biological environment and a cognitive simulation. The Simulation is
        intended as a palette for open source development. It provides a stable
        means of simulating large scale environments and cognitive processes.

        For MacOS Classic and X, with Java, Windows and Linux(Motif) versions
        in beta.  Features a non-polygonal graphics engine (Ocelot) and a
        command-line version


      <label id="POSES++">
      <tag/POSES++/  
    	<itemize>
            <item>Web site: <htmlurl 
                url="http://www.gpc.de/eindex.html" 
                name="www.gpc.de/eindex.html">
        </itemize>
     
      The POSES++ software tool supports the development and
      simulation of models.  Regarding the simulation technique models
      are suitable reproductions of real or planned systems for their
      simulative investigation.
      <p>

      In all industrial sectors or branches POSES++ can model and
      simulate any arbitrary system which is based on a discrete and
      discontinuous behaviour. Also continuous systems can mostly be
      handled like discrete systems e.g., by quantity discretion and
      batch processing.
     

    <label id="Tierra">
    <tag/Tierra/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www.his.atr.jp/&tilde;ray/tierra/" 
            name="www.his.atr.jp/&tilde;ray/tierra/"> 
      </itemize>


      Tierra's written in the C programming language. This source code
      creates a virtual computer and its operating system, whose
      architecture has been designed in such a way that the executable
      machine codes are evolvable. This means that the machine code can be
      mutated (by flipping bits at random) or recombined (by swapping
      segments of code between algorithms), and the resulting code remains
      functional enough of the time for natural (or presumably artificial)
      selection to be able to improve the code over time.
     

    <label id="Trend">
    <tag/Trend/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.complex.iastate.edu/download/Trend/"
                name="www.complex.iastate.edu/download/Trend/">
        </itemize>
        
        Trend is a general purpose cellular automata simulation environment
        with an integrated high level language compiler, a beautiful graphical
        user interface, and a fast, three stage cached simulation engine. This
        is the simulation system that was used to discover the first emergent
        self-replicating cellular automata rule set, and the first problem
        solving self-replication loop.

        Since its simulator is very flexible with regard to cellular space
        sizes, cell structures, neighborhood structures and cellular automata
        rules, Trend can simulate almost all one or two-dimensional cellular
        automata models. It also has a smart backtracking feature which
        simplifies rule set development a lot by allowing users to go back to a
        previous stage of simulation! With other advanced features, Trend is
        probably the most easy to use 2-dimensional cellular automata
        simulator.

        Also available is jTrend. A Java version of Trend.


    <label id="XLIFE">
    <tag/XLIFE/
    <itemize>
      <item>FTP site: <htmlurl
                url="http://surf.de.uu.net/zooland/download/packages/xlife/"
                name="surf.de.uu.net/zooland/download/packages/xlife/">
    </itemize>

     
      This program will evolve patterns for John Horton Conway's game
      of Life.  It will also handle general cellular automata with the
      orthogonal neighborhood and up to 8 states (it's possible to recompile
      for more states, but very expensive in memory).  Transition rules and
      sample patterns are provided for the 8-state automaton of E. F. Codd,
      the Wireworld automaton, and a whole class of `Prisoner's Dilemma'
      games.
     


      <label id="Xtoys">
      <tag/Xtoys/   
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www.physics.mun.ca/&tilde;johnw/xtoys.html" 
            name="www.physics.mun.ca/&tilde;johnw/xtoys.html">
      </itemize>
     
      xtoys contains a set of cellular automata simulators for X windows.
      Programs included are:
      <itemize>
        <item> xising --- a two dimensional Ising model simulator,
	    <item> xpotts --- the two dimensional Potts model,
    	<item> xautomalab ---  a totalistic cellular automaton simulator,
	    <item> xsand --- for the Bak, Tang, Wiesenfeld sandpile model,
    	<item> xwaves --- demonstrates three different wave equations,
    	<item> schrodinger --- play with the Scrodinger equation in an 
            adjustable potential.
      </itemize>

  </descrip>

     
     
    
<sect>Agents
    <p> 
	Also known as intelligent software agents or just agents, this
	area of AI research deals with simple applications of small
	programs that aid the user in his/her work. They can be mobile
	(able to stop their execution on one machine and resume it on
	another) or static (live in one machine). They are usually
	specific to the task (and therefore fairly simple) and meant
	to help the user much as an assistant would. The most popular
	(ie. widely known) use of this type of application to date are
	the web robots that many of the indexing engines
	(eg. webcrawler) use.


    <descrip>


    <label id="Agent">
    <tag/Agent/
    <itemize>
      <item>FTP site: <htmlurl url="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/"
      name="www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/">
    </itemize>

     
      The Agent is a prototype for an Information Agent system. It is
      both platform and language independent, as it stores contained
      information in simple packed strings. It can be packed and shipped
      across any network with any format, as it freezes itself in its
      current state.
     

    <label id="agentTool">
    <tag/agentTool/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://macr.cis.ksu.edu/projects/agentTool/agentool.htm" 
                name="macr.cis.ksu.edu/projects/agentTool/agentool.htm">
            <item>Download site: <htmlurl 
                url="http://macr.cis.ksu.edu/projects/agentTool/registration.htm" 
                name="macr.cis.ksu.edu/projects/agentTool/registration.htm">
        </itemize>

        Another Java based agent development framework. Fairly unique in that
        it emphasizes the use of a GUI for designing the system which will
        "semi-automatically synthesize multiagent systems to meet those
        requirements". You need a java enabled browser to download. :P


    <label id="Aglets">
    <tag/Aglets Workbench/
      <itemize>
        <item>Web site: <htmlurl
                url="http://www.trl.ibm.com/aglets/index_e.htm"
                name="www.trl.ibm.com/aglets/index_e.htm">
      </itemize>

     
      An aglet is a Java object that can move from one host on the
      Internet to another.  That is, an aglet that executes on one host can
      suddenly halt execution, dispatch to a remote host, and resume
      execution there. When the aglet moves, it takes along its program code
      as well as its state (data). A built-in security mechanism makes it
      safe for a computer to host untrusted aglets. The Java Aglet API
      (J-AAPI) is a proposed public standard for interfacing aglets and
      their environment. J-AAPI contains methods for initializing an aglet,
      message handling, and dispatching, retracting,
      deactivating/activating, cloning, and disposing of the aglet. J-AAPI
      is simple, flexible, and stable. Application developers can write
      platform-independent aglets and expect them to run on any host that
      supports J-AAPI.
     

    <label id="AJA">
    <tag/AJA/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://home.arcor.de/michal.badonsky/AJA/"
                name="home.arcor.de/michal.badonsky/AJA/">
        </itemize>

        AJA (Adaptable Java Agents) consists of two programming languages.
        HADL (Higher Agent Definition Language) is a higher-level language used
        for the description of the main agent parts. Java+ is the lower-level
        language used for the programming of the agent parts defined in HADL.
        It is actually Java enriched with the constructs for accessing
        higher-level agent parts defined in HADL.


    <label id="A.L.I.C.E.">
    <tag/A.L.I.C.E./
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.alicebot.org/" 
                name="www.alicebot.org">
        </itemize>
        
        The ALICE software implements AIML (Artificial Intelligence Markup
        Language), a non-standard evolving markup language for creating chat
        robots. The primary design feature of AIML is minimalism. Compared with
        other chat robot languages, AIML is perhaps the simplest. The pattern
        matching language is very simple, for example permitting only one
        wild-card ('*') match character per pattern. AIML is an XML language,
        implying that it obeys certain grammatical meta-rules. The choice of
        XML syntax permits integration with other tools such as XML editors.
        Another motivation for XML is its familiar look and feel, especially to
        people with HTML experience.  


    <label id="Ara">
    <tag/Ara/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html" 
            name="wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html">
      </itemize>

     
      Ara is a platform for the portable and secure execution of
      mobile agents in heterogeneous networks. Mobile agents in this
      sense are programs with the ability to change their host machine
      during execution while preserving their internal state. This
      enables them to handle interactions locally which otherwise had
      to be performed remotely. Ara's specific aim in comparison to
      similar platforms is to provide full mobile agent functionality
      while retaining as much as possible of established programming
      models and languages.


    <label id="BattleBots">
    <tag/BattleBots/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.bluefire.nu/battlebots/" 
                name="www.bluefire.nu/battlebots/">
        </itemize>

    AI programming game where you design the bot by selecting hardware and
    programming its CPU, then competing with other bots. Competitions can have
    teams and special rules for a game. 

    The hardware for use in your bot includes weapons, engine, scanners, CPU,
    etc. The programming lauguage is dependent on the CPU type and is similar
    to an assembly language. 


    <label id="Bee-gent">
    <tag/Bee-gent/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www2.toshiba.co.jp/beegent/index.htm" 
                name="www2.toshiba.co.jp/beegent/index.htm">
        </itemize>

        Bee-gent is a new type of development framework in that it is a 100%
        pure agent system. As opposed to other systems which make only some use
        of agents, Bee-gent completely "Agentifies" the communication that
        takes place between software applications. The applications become
        agents, and all messages are carried by agents. Thus, Bee-gent allows
        developers to build flexible open distributed systems that make optimal
        use of existing applications.


    <label id="Bond">
    <tag/Bond/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://bond.cs.ucf.edu/"
                name="bond.cs.ucf.edu">
        </itemize>

        Yet another java agent system...

        Bond is a Java based distributed object system and agent framework. It
        implements a message based middleware and associated services like
        directory, persistence, monitoring and security. Bond allows to easily
        build multi agent, distributed applications. Another application of
        Bond will be a Virtual Laboratory supporting data annotation and
        metacomputing. 


    <label id="Cadaver">
    <tag/Cadaver/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.erikyyy.de/cadaver/" 
                name="www.erikyyy.de/cadaver/">
        </itemize>
        
        Cadaver is a simulated world of cyborgs and nature in realtime.  The
        battlefield consists of forests, grain, water, grass, carcass (of
        course) and lots of other things. The game server manages the game and
        the rules.  You start a server and connect some clients.  The clients
        communicate with the server using a very primitive protocol.  They can
        order cyborgs to harvest grain, attack enemies or cut forest.  The game
        is not intended to be played by humans!  There is too much to control.
        Only for die-hards: Just telnet to the server and you can enter
        commands by hand.  Instead the idea is that you write artificial  
        intelligence clients to beat the other artificial intelligences.  You
        can choose a language (and operating system) of your choice to do that
        task.  It is enough to write a program that communicates on standard
        input and standard output channels.  Then you can use programs like
        "socket" to connect your clients to the server.  It is NOT needed to
        write TCP/IP code, although i did so :) The battle shall not be boring,
        and so there is the so called spyboss client that displays the action
        graphically on screen.


    <label id="Cougaar">
    <tag/Cougaar/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.cougaar.org/" 
                name="www.cougaar.org/">
        </itemize>

        Cougaar is java-based architecture for the construction of large-scale
        distributed agent-based applications.  It is the product of a
        multi-year DARPA research project into large scale agent systems and
        includes not only the core architecture but also a variety of
        demonstration, visualization and management components to simplify the
        development of complex, distributed applications. [Yet another java
        based agent system -- ed.]


    <label id="D'Agent">
    <tag/D'Agent (was AGENT TCL)/
      <itemize>
        <item>Web site: <htmlurl
            url="http://agent.cs.dartmouth.edu/software/agent2.0/" 
            name="agent.cs.dartmouth.edu/software/agent2.0/">
        <item>FTP site: <htmlurl url="ftp://ftp.cs.dartmouth.edu/pub/agents/" name="ftp.cs.dartmouth.edu/pub/agents/">
      </itemize>

     
      A transportable agent is a program that can migrate from machine
      to machine in a heterogeneous network.  The program chooses when and
      where to migrate.  It can suspend its execution at an arbitrary point,
      transport to another machine and resume execution on the new machine.
      For example, an agent carrying a mail message migrates first to a
      router and then to the recipient's mailbox.  The agent can perform
      arbitrarily complex processing at each machine in order to ensure that
      the message reaches the intended recipient.


    <label id="DIET Agents">
    <tag/DIET Agents/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://diet-agents.sourceforge.net"
                name="diet-agents.sourceforge.net">
        </itemize>

        DIET Agents is a lightweight, scalable and robust multi-agent platform
        in Java. It is especially suitable for rapidly developing P2P prototype
        applications and/or adaptive, distributed applications that use
        bottom-up, nature-inspired techniques.


    <label id="FIPA-OS">
    <tag/FIPA-OS/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://fipa-os.sourceforge.net/" 
                name="fipa-os.sourceforge.net">
            <item>Secondary Web site: <htmlurl 
                url="http://www.nortelnetworks.com/products/announcements/fipa/"
                name="www.nortelnetworks.com/products/announcements/fipa/">
        </itemize>

        FIPA-OS is an open source implementation of the mandatory elements
        contained within the FIPA specification for agent interoperability. In
        addition to supporting the FIPA interoperability concepts, FIPA-OS also
        provides a component based architecture to enable the development of
        domain specific agents which can utilise the services of the FIPA
        Platform agents. It is implemented in Java.


    <label id="FishMarket">
    <tag/FishMarket/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.iiia.csic.es/Projects/fishmarket/newindex.html"
                name="www.iiia.csic.es/Projects/fishmarket/">
        </itemize>
        
        FM - The FishMarket project conducted at the Artificial Intelligence
        Research Institute (IIIA-CSIC) attempts to contribute in that direction
        by developing FM, an agent-mediated electronic auction house which has
        been evolved into a test-bed for electronic auction markets. The
        framework, conceived and implemented as an extension of FM96.5 (a
        Java-based version of the Fishmarket auction house), allows to define
        trading scenarios based on fish market auctions (Dutch auctions). FM
        provides the framework wherein agent designers can perform controlled
        experimentation in such a way that a multitude of experimental market
        scenarios--that we regard as tournament scenarios due to the
        competitive nature of the domain-- of varying degrees of realism and
        complexity can be specified, activated, and recorded; and trading
        (buyer and seller) heterogeneous (human and software) agents compared,
        tuned and evaluated.


    <label id="GNU Robots">
    <tag/GNU Robots/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.gnu.org/software/robots/robots.html" 
                name="www.gnu.org/software/robots/robots.html">
        </itemize>

        GNU Robots is a game/diversion where you construct a program for a
        little robot, then watch him explore a world. The world is
        filled with baddies that can hurt you, objects that you can bump into,
        and food that you can eat. The goal of the game is to collect as
        many prizes as possible before are killed by a baddie or you run out of
        energy. Robots can be written in Guile scheme or using a GUI.


    <label id="Grasshopper">
    <tag/Grasshopper/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.grasshopper.de/" 
                name="www.grasshopper.de/">
        </itemize>

        Another Java agent system. Full featured and actively developed.
        Commercial, but free. Historically targeted at embedded systems.


    <label id="Hive">
    <tag/Hive/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://hive.sourceforge.net/"
                name="hive.sourceforge.net">
        </itemize>
        
        Hive is a Java software platform for creating distributed applications.
        Using Hive, programmers can easily create systems that connect and use
        data from all over the Internet. At its heart, Hive is an environment
        for distributed agents to live, communicating and moving to fulfill
        applications. We are trying to make the Internet alive.


    <label id="ICM">
    <tag/ICM/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.nar.fujitsulabs.com/"
                name="www.nar.fujitsulabs.com/">
            <item>SourceForge site: <htmlurl 
                url="http://sourceforge.net/projects/networkagent/" 
                name="sourceforge.net/projects/networkagent/">
        </itemize>

        The Inter-Agent Communication Model (ICM) is a communication mechanism
        that can be used for sending messages between agents in an asynchronous
        fashion. Its intended application area is as a transportation mechanism
        for agent communication languages (ACLs), such as KQML and FIPA's ACL.  


    <label id="Jacomma">
    <tag/Jacomma/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://jacomma.sourceforge.net/" 
                name="jacomma.sourceforge.net">
            <item>SourceForge site: <htmlurl 
                url="http://sourceforge.net/projects/jacomma/" 
                name="sourceforge.net/projects/jacomma/">
        </itemize>
        
        Jacomma is an agent development platform/framework for developing
        distributed, mobile, and reactive information agents with heterogeneous
        communication capabilities, in Java and JPython.

        Jacomma provides a development framework and an execution environment,
        which sits on top of the Inter-Agent Communication Model
        infrastructure. The ICM defines a communication protocol, a store and
        forward messaging architecture, and low level communication
        infrastructure for message exchange.  Communication is truly
        asynchronous, based on TCP sockets.

        ICM has an entry in this howto, or you can find it via a link off the
        site.



    <label id="Jade">
    <tag/Jade/
        <itemize>
            <item>Web site: <htmlurl
                url="http://sharon.cselt.it/projects/jade/"
                name="sharon.cselt.it/projects/jade/">
        </itemize>
        
        JADE (Java Agent DEvelopment Framework) is a software framework fully
        implemented in Java language. It simplifies the implementation of
        multi-agent systems through a middle-ware that claims to comply with
        the FIPA specifications and through a set of tools that supports the
        debugging and deployment phase. The agent platform can be distributed
        across machines (which not even need to share the same OS) and the
        configuration can be controlled via a remote GUI. The configuration can
        be even changed at run-time by moving agents from one machine to
        another one, as and when required.


    <label id="JAM Agent">
    <tag/JAM Agent/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www.marcush.net/IRS/irs_downloads.html"
                name="www.marcush.net/IRS/irs_downloads.html">
        </itemize>
        
        JAM supports both top-down, goal-based reasoning and bottom-up
        data-driven reasoning. JAM selects goals and plans based on maximal
        priority if metalevel reasoning is not used, or user-developed
        metalevel reasoning plans if they exist. JAM's conceptualization of
        goals and goal achievement is more classically defined (UMPRS is more
        behavioral performance-based than truly goal-based) and makes the
        distinction between plans to achieve goals and plans that simply encode
        behaviors. Goal-types implemented include achievement (attain a
        specified world state), maintenance (re-attain a specified world
        state), and performance. Execution of multiple simultaneous goals are
        supported, with suspension and resumption capabilities for each goal
        (i.e., intention) thread. JAM plans have explicit precondition and
        runtime attributes that restrict their applicability, a postcondition
        attribute, and a plan attributes section for specifying 
        plan/domain-specific plan features. Available plan constructs include:
        sequencing, iteration, subgoaling, atomic (i.e., non-interruptable)
        plan segments, n-branch deterministic and non-deterministic conditional
        execution, parallel execution of multiple plan segments, goal-based or
        world state-based synchronization, an explicit failure-handling
        section, and Java primitive function definition through building it
        into JAM as well as the invocation of predefined (i.e., legacy) class
        members via Java's reflection capabilities without having to build it
        into JAM.


    <label id="JASA">
    <tag/JASA/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.csc.liv.ac.uk/~sphelps/jasa"
                name="www.csc.liv.ac.uk/~sphelps/jasa">
            <item>Alt Web site: <htmlurl 
                url="http://sourceforge.net/projects/jasa/"
                name="sourceforge.net/projects/jasa/">
        </itemize>

        JASA is a high performance auction simulator suitable for conducting
        experiments in agent-based computational economics.  It implements
        various auction mechanisms, trading strategies and experiments
        described in the computational economics literature, and as the
        software matures we hope that it will become a repository for reference
        implementations of commonly used mechanisms, strategies and learning
        algorithms.


    <label id="Jason">
    <tag/Jason/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://jason.sourceforge.net/"
                name="jason.sourceforge.net">
        </itemize>

        A Java-based interpreter for an extended version of AgentSpeak. Unlike
        other BDI (Beliefs-Desires-Intentions) agent tools, Jason implements
        the operational semantics of AgentSpeak, a BDI logic programming
        language extensively discussed in the literature. It is available as
        Open Source under GNU LGPL.


    <label id="JATLite">
    <tag/JATLite/
      <itemize>
        <item>Web site: <htmlurl
                url="http://java.stanford.edu/"
                name="java.stanford.edu/">
      </itemize>

     
      JATLite is providing a set of java packages which makes easy to
      build multi-agent systems using Java. JATLite provides only
      light-weight, small set of packages so that the developers can
      handle all the packages with little efforts. For flexibility
      JATLite provides four different layers from abstract to Router
      implementation. A user can access any layer we are
      providing. Each layer has a different set of assumptions. The
      user can choose an appropriate layer according to the
      assumptions on the layer and user's application. The
      introduction page contains JATLite features and the set of
      assumptions for each layer.


    <label id="JATLiteBeans">
    <tag/JATLiteBeans/
        <itemize>
            <item>Web site: <htmlurl
                url="http://waitaki.otago.ac.nz/JATLiteBean/"
                name="waitaki.otago.ac.nz/JATLiteBean/">
        </itemize>

        <itemize>
        
            <item>Improved, easier-to-use interface to JATLite features
            including KQML message parsing, receiving, and sending.
            
            <item>Extensible architecture for message handling and agent
            "thread of control" management 
            
            <item>Useful functions for parsing of simple KQML message content
            
            <item>JATLiteBean supports automatic advertising of agent
            capabilities to facilitator agents 
        
            <item>Automatic, optional, handling of the "forward" performative
        
            <item>Generic configuration file parser
        
            <item>KQML syntax checker
        
        </itemize>
     

    <label id="Java Agent Template">
    <tag/Java(tm) Agent Template/
      <itemize>
        <item>Web site: <htmlurl
                url="http://www-cdr.stanford.edu/ABE/JavaAgent.html"
                name="www-cdr.stanford.edu/ABE/JavaAgent.html">
      </itemize>

     
      The JAT provides a fully functional template, written entirely in
      the Java language, for constructing software agents which communicate
      peer-to-peer with a community of other agents distributed over the
      Internet. Although portions of the code which define each agent are
      portable, JAT agents are not migratory but rather have a static
      existence on a single host. This behavior is in contrast to many other
      "agent" technologies. (However, using the Java RMI, JAT agents could
      dynamically migrate to a foreign host via an agent resident on that
      host).  Currently, all agent messages use KQML as a top-level protocol
      or message wrapper. The JAT includes functionality for dynamically
      exchanging "Resources", which can include Java classes (e.g. new
      languages and interpreters, remote services, etc.), data files and
      information inlined into the KQML messages.


    <label id="Khepera Sim">
    <tag/Khepera Simulator/
      <itemize>
        <item>Web site: <htmlurl
                url="http://diwww.epfl.ch/lami/team/michel/khep-sim/index.html"
                name="diwww.epfl.ch/lami/team/michel/khep-sim/">
      </itemize>

      Khepera Simulator is a public domain software package written by
      <htmlurl url="http://diwww.epfl.ch/lami/team/michel/" name="Olivier MICHEL">
      during the preparation of his Ph.D. thesis, at the Laboratoire I3S,
      URA 1376 of CNRS and University of Nice-Sophia Antipolis, France. It
      allows to write your own controller for the mobile robot Khepera using
      C or C++ languages, to test them in a simulated environment and
      features a nice colorful X11 graphical interface. Moreover, if you own
      a Khepera robot, it can drive the real robot using the same control
      algorithm. It is mainly oriented toward to researchers studying autonomous
      agents.
     
    <label id="lyntin">
    <tag/lyntin/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://lyntin.sourceforge.net/" 
                name="lyntin.sourceforge.net/">
        </itemize>

        Lyntin is an extensible Mud client and framework for the creation of
        autonomous agents, or bots, as well as mudding in general. Lyntin is
        centered around Python, a dynamic, object-oriented, and fun programming
        language and based on TinTin++ a lovely mud client.


    <label id="Mole">
    <tag/Mole/
      <itemize>
        <item>Web site: <htmlurl
            url="http://mole.informatik.uni-stuttgart.de/"
            name="mole.informatik.uni-stuttgart.de/">
      </itemize>

     
      Mole is an agent system supporting mobile agents programmed in
      Java.  Mole's agents consist of a cluster of objects, which have
      no references to the outside, and as a whole work on tasks given
      by the user or another agent. They have the ability to roam a
      network of "locations" autonomously. These "locations" are an
      abstraction of real, existing nodes in the underlying
      network. They can use location-specific resources by
      communicating with dedicated agents representing these
      services. Agents are able to use services provided by other
      agents and to provide services as well.
     

    <label id="Narval">
    <tag/Narval/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.logilab.org/" 
                name="www.logilab.org">
        </itemize>

        Narval is the acronym of "Network Assistant Reasoning with a Validating
        Agent Language". It is a personal network assistant based on artificial
        intelligence and agent technologies. It executes recipes (sequences of
        actions) to perform tasks. It is easy to specify a new action using XML
        and to implement it using Python.  Recipes can be built and debugged
        using a graphical interface. 


    <label id="NeL">
    <tag/NeL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.nevrax.org/" 
                name="www.nevrax.org">
        </itemize>

        NeL is actually a game development library (for massive multi-player
        games), but I'm including it here as it (will) include a fairly 
        sizable AI library. Here's a blurb from the whitepaper:

        The purpose of the AI library is to provide a pragmatic approach to
        creating a distributed agents platform. Its focus is agents; individual
        entities that communicate regardless of location, using an
        action-reaction model. 


    <label id="OAA">
    <tag/OAA/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.ai.sri.com/&tilde;oaa/"
                name="www.ai.sri.com/&tilde;oaa/">
        </itemize>

        The Open Agent Architecture is a framework in which a community of
        software agents running on distributed machines can work together on
        tasks assigned by human or non-human participants in the community.
        Distributed cooperation and high-level communication are two ideas
        central to the foundation of the OAA.
        
        It defines an interagent communication language and supports multiple
        platforms and programming languages.


    <label id="OpenSteer">
    <tag/OpenSteer/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://opensteer.sourceforge.net/"
                name="opensteer.sourceforge.net">
        </itemize>

        OpenSteer is a C++ library to help build steering behaviors for
        autonomous characters in games and animation. OpenSteer provides an app
        which displays predefined demos of steering behaviors. You can
        prototype, visualize and debug your own as a plug-in.


    <label id="PAI">
    <tag/PAI/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://utenti.quipo.it/claudioscordino/pai.html" 
                name="utenti.quipo.it/claudioscordino/pai.html">
        </itemize>
        
        AI (Programmable Artificial Intelligence) is a program capable of
        having a conversation in its mother tongue, English. Written in 
        C++.


    <label id="Penguin!">
    <tag/Penguin!/
    <itemize>
      <item>FTP site: <htmlurl 
        url="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/"
        name="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/">
    </itemize>

      Penguin is a Perl 5 module. It provides you with a set of functions which
      allow you to:
      <itemize>
        <item>send encrypted, digitally signed Perl code to a remote machine
                to be executed.
	    <item>receive code and, depending on who signed it, execute it in an
	        arbitrarily secure, limited compartment.
      </itemize>
      The combination of these functions enable direct Perl coding of
      algorithms to handle safe internet commerce, mobile
      information-gathering agents, "live content" web browser helper
      apps, distributed load-balanced computation, remote software
      update, distance machine administration, content-based
      information propagation, Internet-wide shared-data applications,
      network application builders, and so on.
     

    <label id="Ps-i">
    <tag/Ps-i/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://ps-i.sourceforge.net/"
                name="ps-i.sourceforge.net">
        </itemize>

        Ps-i is an environment for running agent-based simulations. It is
        cross-platform, with binaries available for Win32. Features include: 

        <itemize>
        <item>declarative language for model specification</item>
        <item>industry standard Tcl/Tk scripting
            with built-in routine optimization, speculative evaluation
            and xf86 JIT compiler users can create complex models without
            sacrificing perfomance </item>
        <item>user friendly interface </item>
        <item>save and restore program runs </item>
        <item>change model parameters on the fly </item>
        <item>data visualization: field display with multiple agent shapes and
            color, statistics window, agent viewer, routine browser and
            highlight agents tool </item>
        </itemize>


    <label id="Pyro">
    <tag/Pyro/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://pyrorobotics.org/"
                name="http://pyrorobotics.org/">
        </itemize>

        Pyro is a library, environment, graphical user interface, and low-level
        drivers to explore AI and robotics using the Python language. It works
        with many real robotics platforms and simulators. Extensive algorithms
        including behavior-based, vision (motion tracking, blobs, etc.),
        learning (back-propagation, self-organizing maps, etc.), evolutionary,
        and more.


    <label id="RealTimeBattle">
    <tag/RealTimeBattle/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www.lysator.liu.se/realtimebattle/"
                name="www.lysator.liu.se/realtimebattle/">
        </itemize>

        RealTimeBattle is a programming game, in which robots controlled by 
        programs are fighting each other. The goal is to destroy the enemies, 
        using the radar to examine the environment and the cannon to shoot. 

        <itemize>
            <item>Game progresses in real time, with the robot programs 
                running as child processes to RealTimeBattle.
            <item>The robots communicate with the main program using the 
                standard input and output.
            <item>Robots can be constructed in almost any programming language.
            <item>Maximum number of robots can compete simultaneously.
            <item>A simple messaging language is used for communication, which
                makes it easy to start constructing robots.
            <item>Robots behave like real physical object.
            <item>You can create your own arenas.
            <item>Highly configurable.
        </itemize>

     
    <label id="Remembrance Agents">
    <tag/Remembrance Agents/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www.remem.org/"
                name="www.remem.org">
        </itemize>

        Remembrance Agents are a set of applications that watch over a user's
        shoulder and suggest information relevant to the current situation.
        While query-based memory aids help with direct recall, remembrance
        agents are an augmented associative memory.  For example, the
        word-processor version of the RA continuously updates a list of
        documents relevant to what's being typed or read in an emacs buffer.
        These suggested documents can be any text files that might be relevant
        to what you are currently writing or reading.  They might be old emails
        related to the mail you are currently reading, or abstracts from papers
        and newspaper articles that discuss the topic of your writing.


    <label id="Robocode">
    <tag/Robocode/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://robocode.sourceforge.net/"
                name="robocode.sourceforge.net">
        </itemize>
        
        A java based robot combat programming game. It provides a simple API
        and class framework. It is designed as a means of learning Java and is
        easy to start using while not constraining the programmer from more
        advanced techniques. It has a built in security manager for running
        other peoples robots in a safe way.
        

    <label id="RoboTournament">
    <tag/RoboTournament/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://robotournament.sourceforge.net/"
                name="robotournament.sourceforge.net/">
        </itemize>

        RoboTournament is a RoboRally inspired game where players program their
        robots to vanquish their opponents. RoboTournament features: Multiple
        Game Types: Death Match, Rally, and Capture The Flag. Multi-Player
        through TCP/IP, Six weapons including BFG, Map Editor, and a wide
        variety of board elements.


    <label id="SimAgent">
    <tag/SimAgent/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.cs.bham.ac.uk/~axs/cogaff/simagent.html"
                name="www.cs.bham.ac.uk/~axs/cogaff/simagent.html">
        </itemize>

        The SimAgent toolkit provides a range of resources for research and
        teaching related to the development of interacting agents in
        environments of various degrees and kinds of complexity. It can be run
        as a pure simulation tool, or installed in a robot with a sufficiently
        powerful on-board computer, e.g. running linux. It was originally
        developed to support exploratory research on human-like intelligent
        agents, but has also been used for student projects developing a
        variety of interactive games and simulations.


    <label id="SimRobot">
    <tag/SimRobot/
      <itemize>
        <item>Web site: <htmlurl
                url="http://www.informatik.uni-bremen.de/simrobot/"
                name="www.informatik.uni-bremen.de/&tilde;simrobot/"> 
        <item>FTP site: <htmlurl 
                url="ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/"
                name="ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/">
      </itemize>

     
      SimRobot is a program for simulation of sensor based robots in a
      3D environment. It is written in C++, runs under UNIX and X11 and
      needs the graphics toolkit XView.
      <itemize>
        <item>Simulation of robot kinematics
	    <item>Hierarchically built scene definition via a simple definition
	        language
	    <item>Various sensors built in: camera, facette eye, distance 
	        measurement, light sensor, etc.
	    <item>Objects defined as polyeders
	    <item>Emitter abstractly defined; can be interpreted e.g. as
	        light or sound
	    <item>Camera images computed according to the raytracing or
	        Z-buffer algorithms known from computer graphics
	    <item>Specific sensor/motor software interface for communicating 
                with the simulation
	    <item>Texture mapping onto the object surfaces: bitmaps in various 
                formats
	    <item>Comprehensive visualization of the scene: wire frame w/o
	        hidden lines, sensor and actor values
	    <item>Interactive as well as batch driven control of the agents
	        and operation in the environment
	    <item>Collision detection
	    <item>Extendability with user defined object types
	    <item>Possible socket communication to e.g. the Khoros image 
                processing software
      </itemize>
     

    <label id="spyse">
    <tag/spyse/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://spyse.sf.net/"
                name="spyse.sf.net">
            <item>Alt Web site: <htmlurl 
                url="http://zope.org/Members/drapmeyer/spyse"
                name="zope.org/Members/drapmeyer/spyse">
        </itemize>

        spyse is a development framework and platform for building multi-agent
        systems using the Python programming language. A multi-agent system
        (MAS) combines concepts from distributed computing and artificial
        intelligence.  Agents are autonomously reasoning software entities that
        can collaborate (or compete) in order to achieve a (common) goal. By
        cooperating they create emergent behaviour in the system (distributed
        artificial intelligence). The architecture of a MAS is specified in the
        FIPA standard.

        Spyse provides multiple means for reasoning (BDI logics, CLIPS expert
        shell, etc.) and communicating locally and remotely.

        Each agent has its own thread of control. Agents within and among
        instances of the platform communicate by exchanging messages based on
        ontologies. Spyse makes use of the Web Ontology Language (OWL) defined
        for the Semantic Web.


    <label id="Sulawesi">
    <tag/Sulawesi/
        <itemize>
            <item>Web site ???: <htmlurl
                url="http://wearables.essex.ac.uk/sulawesi/"
                name="wearables.essex.ac.uk/sulawesi/">
        </itemize>
        
        A framework called Sulawesi has been designed and implemented to
        tackle what has been considered to be important challenges in a
        wearable user interface. The ability to accept input from any 
        number of modalities, and perform if necessary a translation to any
        number of modal outputs. It does this primarily through a set
        of proactive agents to act on the input.



    <label id="TclRobots">
    <tag/TclRobots/
    <itemize>
    	<item>Web site: <htmlurl 
                url="http://www.nyx.net/&tilde;tpoindex/"
                name="www.nyx.net/&tilde;tpoindex/">
    </itemize>

     
      TclRobots is a programming game, similar to 'Core War'.  To play
      TclRobots, you must write a Tcl program that controls a robot.  The
      robot's mission is to survive a battle with other robots.  Two, three,
      or four robots compete during a battle, each running different
      programs (or possibly the same program in different robots.)  Each
      robot is equipped with a scanner, cannon, drive mechanism.  A single
      match continues until one robot is left running.  Robots may compete
      individually, or combine in a team oriented battle.  A tournament
      can be run with any number of robot programs, each robot playing every
      other in a round-robin fashion, one-on-one.  A battle simulator is
      available to help debug robot programs.
      

      The TclRobots program provides a physical environment, imposing
      certain game parameters to which all robots must adhere.  TclRobots
      also provides a view on a battle, and a controlling user interface.
      TclRobots requirements: a wish interpreter built from Tcl 7.4 and Tk
      4.0.

     

    <label id="TKQML">
    <tag/TKQML/
        <itemize>
            <item>Web site: <htmlurl url="http://www.csee.umbc.edu/tkqml/"
name="www.csee.umbc.edu/tkqml/"> 
        </itemize>
        
        TKQML is a KQML application/addition to Tcl/Tk, which allows Tcl
        based systems to communicate easily with a powerful agent
        communication language.



    <label id="Tocoma Project">
    <tag/The Tocoma Project/
      <itemize>
        <item>Web site: <htmlurl url="http://www.tacoma.cs.uit.no/"
        name="www.tacoma.cs.uit.no/">
      </itemize>

     
      An agent is a process that may migrate through a computer network
      in order to satisfy requests made by clients. Agents are an attractive
      way to describe network-wide computations.
      

      The TACOMA project focuses on operating system support for agents and
      how agents can be used to solve problems traditionally addressed by
      operating systems. We have implemented a series of prototype systems
      to support agents.
      

      TACOMA Version 1.2 is based on UNIX and TCP. The system supports
      agents written in C, Tcl/Tk, Perl, Python, and Scheme (Elk). It is
      implemented in C. This TACOMA version has been in public domain since
      April 1996.
      

      We are currently focusing on heterogeneity, fault-tolerance, security
      and management issues. Also, several TACOMA applications are under
      construction. We implemented StormCast 4.0, a wide-area network
      weather monitoring system accessible over the internet, using TACOMA
      and Java. We are now in the process of evaluating this application,
      and plan to build a new StormCast version to be completed by June
      1997.
     

    <label id="UMPRS Agent">
    <tag/UMPRS Agent/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www.marcush.net/IRS/"
                name="http://www.marcush.net/IRS/">
        </itemize>
        
        UMPRS supports top-down, goal-based reasoning and selects goals and
        plans based on maximal priority. Execution of multiple simultaneous
        goals are supported, with suspension and resumption capabilities for
        each goal (i.e., intention) thread. UMPRS plans have an integrated
        precondition/runtime attribute that constrain their applicability.
        Available plan constructs include: sequencing, iteration, subgoaling,
        atomic (i.e., non-interruptable) blocks, n-branch deterministic
        conditional execution, explicit failure-handling section, and C++
        primitive function definition.


    <label id="ViSe">
    <tag/Virtual Secretary Project (ViSe)/ (Tcl/Tk)  
    <itemize>
        <item>Web site: <htmlurl
            url="http://www.vise.cs.uit.no/vise/"
            name="www.vise.cs.uit.no/vise/">
    </itemize>
     
      The motivation of the Virtual Secretary project is to construct
      user-model-based intelligent software agents, which could in
      most cases replace human for secretarial tasks, based on modern
      mobile computing and computer network. The project includes two
      different phases: the first phase (ViSe1) focuses on information
      filtering and process migration, its goal is to create a secure
      environment for software agents using the concept of user
      models; the second phase (ViSe2) concentrates on agents'
      intelligent and efficient cooperation in a distributed
      environment, its goal is to construct cooperative agents for
      achieving high intelligence. (Implemented in Tcl/TclX/Tix/Tk)


    <label id="VWORLD">
    <tag/VWORLD/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://zhar.net/projects/vworld/" 
                name="zhar.net/projects/vworld/">
      </itemize>

     
      Vworld is a simulated environment for research with autonomous
      agents written in prolog. It is currently in something of an
      beta stage. It works well with SWI-prolog, but should work with
      Quitnus-prolog with only a few changes.  It is being designed to
      serve as an educational tool for class projects dealing with
      prolog and autonomous agents. It comes with three demo worlds or
      environments, along with sample agents for them. There are
      two versions now. One written for SWI-prolog and one written for
      LPA-prolog. Documentation is roughly done (with a
      student/professor framework in mind), and a graphical interface
      is planned.
     


      <label id="WebMate">
      <tag/WebMate/
        <itemize>
            <item>Web site: <htmlurl url="http://www.cs.cmu.edu/&tilde;softagents/webmate/" name="www.cs.cmu.edu/&tilde;softagents/webmate/">
        </itemize>

     
      WebMate is a personal agent for World-Wide Web browsing and
      searching. It accompanies you when you travel on the internet
      and provides you what you want. 
      
      Features include:
      <itemize>

        <item>Searching enhancement, including parallel search, searching
        keywords refinement using our relevant keywords extraction technology,
        relevant feedback, etc.

        <item>Browsing assistant, including learning your current interesting,
        recommending you new URLs according to your profile and selected
        resources, monitoring bookmarks of Netscape or IE, sending the current
        browsing page to your friends, etc.

        <item>Offline browsing, including downloading the following pages from
        the current page for offline browsing.

        <item>Filtering HTTP header, including recording http header and all
        the transactions between your browser and WWW servers, etc.

        <item>Checking the HTML page to find the errors or dead links,  etc.

        <item>Programming in Java, independent of operating system, runing in
        multi-thread.

      </itemize>



    <label id="Zeus">
    <tag/Zeus/
        <itemize>
            <item>Web site: <htmlurl
                url="http://more.btexact.com/projects/agents/zeus/"
                name="more.btexact.com/projects/agents/zeus/">
        </itemize>
        
            The construction of multi-agent systems involves long development
            times and requires solutions to some considerable technical 
            difficulties. This has motivated the development of the ZEUS
            toolkit, which provides a library of software components and tools
            that facilitate the rapid design, development and deployment of 
            agent system



  </descrip>

    
<sect>Programming languages
    <p>
    
    While any programming language can be used for artificial
    intelligence/life research, these are programming languages which
    are used extensively for, if not specifically made for, artificial
    intelligence programming.  


    <descrip>
    

    <label id="Allegro CL">
    <tag/Allegro CL/
    <itemize>
        <item>Web site: <htmlurl url="http://www.franz.com/" name="www.franz.com">
    </itemize>

        Franz Inc's free linux version of their lisp development
        environment. You can download it or they will mail you a
        CD free (you don't even have to pay for shipping). It is
        generally considered to be one of the better lisp platforms.
       

    <label id="APRIL">
    <tag/APRIL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://sourceforge.net/projects/networkagent/" 
                name="sourceforge.net/projects/networkagent/">
        </itemize>

        APRIL is a symbolic programming language that is designed for writing
        mobile, distributed and agent-based systems especially in an Internet
        environment. It has advanced features such as a macro sub-language,
        asynchronous message sending and receiving, code mobility, pattern
        matching, higher-order functions and strong typing. The language is
        compiled to byte-code which is then interpreted by the APRIL
        runtime-engine.  APRIL now requires the InterAgent Communications Model
        (ICM) to be installed before it can be installed. [Ed. ICM can be found
        at the same web site]


    <label id="Ciao Prolog">
    <tag/Ciao Prolog/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.clip.dia.fi.upm.es/Software/Ciao/" 
                name="www.clip.dia.fi.upm.es/Software/Ciao/">
        </itemize>

        Ciao is a complete Prolog system subsuming ISO-Prolog with a novel
        modular design which allows both restricting and extending the
        language. Ciao extensions currently include feature terms (records),
        higher-order, functions, constraints, objects, persistent predicates, a
        good base for distributed execution (agents), and concurrency.
        Libraries also support WWW programming, sockets, and external
        interfaces (C, Java, TCL/Tk, relational databases, etc.). An
        Emacs-based environment, a stand-alone compiler, and a toplevel shell
        are also provided.



    <label id="DHARMI">
    <tag/DHARMI/
        <itemize>
            <item>Web site: <htmlurl
                url="http://megazone.bigpanda.com/&tilde;wolf/DHARMI/"
                name="http://megazone.bigpanda.com/&tilde;wolf/DHARMI/">
        </itemize>
        
            DHARMI is a high level spatial, tinker-toy like language who's
            components are transparently administered by a background
            process called the Habitat. As the name suggests, the language
            was designed to make modelling prototypes and handle living
            data. Programs can be modified while running. This is accomplished
            by blurring the distinction between source code, program,
            and data.


    <label id="ECLiPSe">
    <tag/ECLiPSe/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.icparc.ic.ac.uk/eclipse/"
                name="www.icparc.ic.ac.uk/eclipse/">
        </itemize>

        ECLiPSe is a software system for the cost-effective development and
        deployment of constraint programming applications, e.g. in the areas of
        planning, scheduling, resource allocation, timetabling, transport etc.
        It is also ideal for teaching most aspects of combinatorial problem
        solving, e.g.  problem modelling, constraint programming, mathematical
        programming, and search techniques. It contains several constraint
        solver libraries, a high-level modelling and control language,
        interfaces to third-party solvers, an integrated development
        environment and interfaces for embedding into host environments.


    <label id="ECoLisp">
    <tag/ECoLisp/
    <itemize>
        <item>Web site (???): <htmlurl url="http://www.di.unipi.it/&tilde;attardi/software.html" name="www.di.unipi.it/&tilde;attardi/software.html">
    </itemize>

       
        ECoLisp (Embeddable Common Lisp) is an implementation of
        Common Lisp designed for being embeddable into C based
        applications. ECL uses standard C calling conventions for Lisp
        compiled functions, which allows C programs to easily call
        Lisp functions and viceversa. No foreign function interface is
        required: data can be exchanged between C and Lisp with no
        need for conversion. ECL is based on a Common Runtime Support
        (CRS) which provides basic facilities for memory managment,
        dynamic loading and dumping of binary images, support for
        multiple threads of execution. The CRS is built into a library
        that can be linked with the code of the application. ECL is
        modular: main modules are the program development tools (top
        level, debugger, trace, stepper), the compiler, and CLOS. A
        native implementation of CLOS is available in ECL: one can
        configure ECL with or without CLOS. A runtime version of ECL
        can be built with just the modules which are required by the
        application. The ECL compiler compiles from Lisp to C, and
        then invokes the GCC compiler to produce binaries.



    <label id="ESTEREL">
    <tag/ESTEREL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www-sop.inria.fr/meije/esterel/"
                name="www-sop.inria.fr/meije/esterel/">
        </itemize>
        
        Esterel is both a programming language, dedicated to programming
        reactive systems, and a compiler which translates Esterel programs into
        finite-state machines. It is particularly well-suited to programming
        reactive systems, including real-time systems and control automata.
        
        Only the binary is available for the language compiler. :P
       


      <label id="Godel">
      <tag/G&ouml;del/
        <itemize>
    	    <item>Web page: <htmlurl url="http://www.cs.bris.ac.uk/&tilde;bowers/goedel.html" name="www.cs.bris.ac.uk/&tilde;bowers/goedel.html">
        </itemize>
      
       G&ouml;del is a declarative, general-purpose programming language
	in the family of logic programming languages.  It is a strongly typed
	language, the type system being based on many-sorted logic with
	parametric polymorphism.  It has a module system.  G&ouml;del supports
	infinite precision integers, infinite precision rationals, and also
	floating-point numbers.  It can solve constraints over finite domains
	of integers and also linear rational constraints. It supports
	processing of finite sets.  It also has a flexible computation rule
	and a pruning operator which generalizes the commit of the concurrent
	logic programming languages.  Considerable emphasis is placed on
	G&ouml;del's meta- logical facilities which provide significant
	support for meta-programs that do analysis, transformation,
	compilation, verification, debugging, and so on.
       
      
    <label id="CLisp">
    <tag/CLisp (Lisp)/
    <itemize>
      <item>Web page: <htmlurl
                url="http://clisp.sourceforge.net/"
                name="clisp.sourceforge.net">
      <item>Alt Web site: <htmlurl 
                url="http://clisp.cons.org/" 
                name="clisp.cons.org/">
    </itemize>
     
      CLISP is a Common Lisp implementation by Bruno Haible and Michael
      Stoll.  It mostly supports the Lisp described by 
      <htmlurl
        url="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/cltl2.html" 
        name="Common LISP: The Language (2nd edition)">
      and the ANSI Common Lisp
      standard.  CLISP includes an interpreter, a byte-compiler, a large
      subset of CLOS (Object-Oriented Lisp) , a foreign language interface
      and, for some machines, a screen editor.
      

      The user interface language (English, German, French) is chosen at
      run time.  Major packages that run in CLISP include CLX & Garnet.
      CLISP needs only 2 MB of memory.
     
    
    <label id="CMU CL">
    <tag/CMU Common Lisp/
    <itemize>
      <item>Web page: <htmlurl 
            url="http://www.cons.org/cmucl/"
            name="www.cons.org/cmucl/">
      <item>Linux Installation: <htmlurl 
            url="http://www.telent.net/lisp/howto.html" 
            name="www.telent.net/lisp/howto.html">
    </itemize>


      CMU Common Lisp is a public domain "industrial strength" Common
      Lisp programming environment. Many of the X3j13 changes have been
      incorporated into CMU CL. Wherever possible, this has been done so as
      to transparently allow the use of either CLtL1 or proposed ANSI
      CL. Probably the new features most interesting to users are SETF
      functions, LOOP and the WITH-COMPILATION-UNIT macro.
     
    

    <label id="Gnu-CL">
    <tag/GCL (Lisp)/
    <itemize>
      <item>FTP site: <htmlurl 
            url="ftp://ftp.ma.utexas.edu/pub/gcl/" 
            name="ftp.ma.utexas.edu/pub/gcl/">
    </itemize>

     
      GNU Common Lisp (GCL) has a compiler and interpreter for Common
      Lisp.  It used to be known as Kyoto Common Lisp.  It is very portable
      and extremely efficient on a wide class of applications.  It compares
      favorably in performance with commercial Lisps on several large
      theorem-prover and symbolic algebra systems. It supports the CLtL1
      specification but is moving towards the proposed ANSI definition.  GCL
      compiles to C and then uses the native optimizing C compilers (e.g.,
      GCC).  A function with a fixed number of args and one value turns into
      a C function of the same number of args, returning one value, so GCL
      is maximally efficient on such calls.  It has a conservative garbage
      collector which allows great freedom for the C compiler to put Lisp
      values in arbitrary registers.
      

      It has a source level Lisp debugger for interpreted code, with display
      of source code in an Emacs window.  Its profiling tools (based on the
      C profiling tools) count function calls and the time spent in each
      function.  
     

    <label id="GNU Prolog">
    <tag/GNU Prolog/
        <itemize>   
            <item>Web site: <htmlurl
                url="http://gnu-prolog.inria.fr/"
                name="gnu-prolog.inria.fr">
            <item>Web site: <htmlurl
                url="http://pauillac.inria.fr/&tilde;diaz/gnu-prolog/"
                name="pauillac.inria.fr/&tilde;diaz/gnu-prolog/">
        </itemize>


        GNU Prolog is a free Prolog compiler with constraint solving over
        finite domains developed by Daniel Diaz.

        GNU Prolog accepts Prolog+constraint programs and produces native
        binaries (like gcc does from a C source). The obtained executable is
        then stand-alone. The size of this executable can be quite small since
        GNU Prolog can avoid to link the code of most unused built-in
        predicates. The performances of GNU Prolog are very encouraging
        (comparable to commercial systems). 

        Beside the native-code compilation, GNU Prolog offers a classical
        interactive interpreter (top-level) with a debugger.

        The Prolog part conforms to the ISO standard for Prolog with many
        extensions very useful in practice (global variables, OS interface,
        sockets,...). 

        GNU Prolog also includes an efficient constraint solver over Finite
        Domains (FD). This opens contraint logic pogramming to the user
        combining the power of constraint programming to the declarativity of
        logic programming.


    <label id="lush">
    <tag/lush/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://lush.sourceforge.net/"
                name="lush.sourceforge.net">
        </itemize>
        
        Lush is an object-oriented programming language designed for
        researchers, experimenters, and engineers interested in large-scale
        numerical and graphic applications. Lush is designed to be used in
        situations where one would want to combine the flexibility of a
        high-level, weakly-typed interpreted language, with the efficiency of a
        strongly-typed, natively-compiled language, and with the easy
        integration of code written in C, C++, or other languages.
 

    <label id="Maude">
    <tag/Maude/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://maude.cs.uiuc.edu/"
                name="maude.cs.uiuc.edu">
        </itemize>

        Maude is a high-performance reflective language and system supporting
        both equational and rewriting logic specification and programming for a
        wide range of applications. Maude has been influenced in important ways
        by the OBJ3 language, which can be regarded as an equational logic
        sublanguage. Besides supporting equational specification and
        programming, Maude also supports rewriting logic computation. 


    <label id="Mercury">
    <tag/Mercury/
    <itemize>
      <item>Web page: <htmlurl url="http://www.cs.mu.oz.au/research/mercury/" name="www.cs.mu.oz.au/research/mercury/">
    </itemize>

     
      Mercury is a new, purely declarative logic programming language.
      Like Prolog and other existing logic programming languages, it is a
      very high-level language that allows programmers to concentrate on the
      problem rather than the low-level details such as memory management.
      Unlike Prolog, which is oriented towards exploratory programming,
      Mercury is designed for the construction of large, reliable, efficient
      software systems by teams of programmers. As a consequence,
      programming in Mercury has a different flavor than programming in
      Prolog.
     
    
    <label id="Mozart">
    <tag/Mozart/
    <itemize>
      <item>Web page: <htmlurl url="http://www.mozart-oz.org/" 
        name="www.mozart-oz.org/">
    </itemize>

     
    The Mozart system provides state-of-the-art support in two areas: open
    distributed computing and constraint-based inference. Mozart implements
    Oz, a concurrent object-oriented language with dataflow synchronization.
    Oz combines concurrent and distributed programming with logical
    constraint-based inference, making it a unique choice for developing
    multi-agent systems. Mozart is an ideal platform for both general-purpose
    distributed applications as well as for hard problems requiring
    sophisticated optimization and inferencing abilities. We have developed
    applications in scheduling and time-tabling, in placement and
    configuration, in natural language and knowledge representation,
    multi-agent systems and sophisticated collaborative tools.      


    <label id="SWI Prolog">
    <tag/SWI Prolog/
    <itemize>
      <item>Web page: <htmlurl
                url="http://www.swi-prolog.org/"
                name="www.swi-prolog.org">
    </itemize>

     
      SWI is a free version of prolog in the Edinburgh Prolog family
      (thus making it very similar to Quintus and many other versions).
      With: a large library of built in predicates, a module system, garbage
      collection, a two-way interface with the C language, plus many other
      features. It is meant as a educational language, so it's compiled code
      isn't the fastest. Although it similarity to Quintus allows for easy
      porting.
      

      XPCE is freely available in binary form for the Linux version of SWI-prolog.
      XPCE is an object oriented X-windows GUI development package/environment.


    <label id="Kali Scheme">
    <tag/Kali Scheme/
      <itemize>
        <item>Web site: <htmlurl 
            url="http://community.schemewiki.org/kali-scheme/" 
            name="http://community.schemewiki.org/kali-scheme/">
      </itemize>


      Kali Scheme is a distributed implementation of Scheme that
      permits efficient transmission of higher-order objects such as
      closures and continuations. The integration of distributed
      communication facilities within a higher-order programming
      language engenders a number of new abstractions and paradigms
      for distributed computing. Among these are user-specified
      load-balancing and migration policies for threads,
      incrementally-linked distributed computations, agents, and
      parameterized client-server applications. Kali Scheme supports
      concurrency and communication using first-class procedures and
      continuations. It integrates procedures and continuations into a
      message-based distributed framework that allows any Scheme
      object (including code vectors) to be sent and received in a
      message.
     


    <label id="RScheme">
    <tag/RScheme/
      <itemize>
        <item>Web site:<htmlurl 
            url="http://www.rscheme.org/" 
            name="www.rscheme.org">
      </itemize>

     
      RScheme is an object-oriented, extended version of the Scheme
      dialect of Lisp. RScheme is freely redistributable, and offers
      reasonable performance despite being extraordinarily portable.
      RScheme can be compiled to C, and the C can then compiled with a
      normal C compiler to generate machine code. By default, however,
      RScheme compiles to bytecodes which are interpreted by a
      (runtime) virtual machine. This ensures that compilation is fast
      and keeps code size down. In general, we recommend using the
      (default) bytecode code generation system, and only compiling
      your time-critical code to machine code. This allows a nice
      adjustment of space/time tradeoffs.  (see web site for details)
     
    


    <label id="Scheme 48">
    <tag/Scheme 48/
    <itemize>
        <item>Web site: <htmlurl 
            url="http://s48.org/" 
            name="s48.org/">
    </itemize>

     
      Scheme 48 is a Scheme implementation based on a virtual machine
      architecture. Scheme 48 is designed to be straightforward, flexible,
      reliable, and fast. It should be easily portable to 32-bit
      byte-addressed machines that have POSIX and ANSI C support.  In
      addition to the usual Scheme built-in procedures and a development
      environment, library software includes support for hygienic macros (as
      described in the Revised&circ;4 Scheme report), multitasking, records,
      exception handling, hash tables, arrays, weak pointers, and FORMAT.
      Scheme 48 implements and exploits an experimental module system
      loosely derived from Standard ML and Scheme Xerox.  The development
      environment supports interactive changes to modules and interfaces.
     
    


    <label id="SCM">
    <tag>SCM (<bf>Scheme</bf>) 
      <itemize>
        <item>Web site: <htmlurl 
            url="http://www-swiss.ai.mit.edu/&tilde;jaffer/SCM.html" 
            name="www-swiss.ai.mit.edu/&tilde;jaffer/SCM.html">
      </itemize>

     
      SCM conforms to the Revised&circ;4 Report on the Algorithmic Language
      Scheme and the IEEE P1178 specification. Scm is written in C. It uses
      the following utilities (all available at the ftp site).
      <itemize>	
        <item>SLIB (Standard Scheme Library) is a portable Scheme
	        library which is intended to provide compatibility and utility
	        functions for all standard Scheme implementations, including
	        SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme->C,
	        Scheme48, T3.1, and VSCM, and is available as the file
	        slib2c0.tar.gz. Written by Aubrey Jaffer.  
	    <item>JACAL is a symbolic math system written in Scheme, and is
	        available as the file jacal1a7.tar.gz.
	    <item>Interfaces to standard libraries including REGEX string 
                regular expression matching and the CURSES screen management 
                package.
	    <item>Available add-on packages including an interactive debugger, 
                database, X-window graphics, BGI graphics, Motif, and 
                Open-Windows packages.
	    <item>A compiler (HOBBIT, available separately) and dynamic linking
                of compiled modules.
      </itemize>



    <label id="Shift">
    <tag/Shift/
      <itemize>
        <item>Web site: <htmlurl url="http://www.path.berkeley.edu/shift/" name="www.path.berkeley.edu/shift/">
      </itemize>
     
      Shift is a programming language for describing dynamic
      networks of hybrid automata.  Such systems consist of
      components which can be created, interconnected and destroyed
      as the system evolves. Components exhibit hybrid behavior,
      consisting of continuous-time phases separated by
      discrete-event transitions. Components may evolve
      independently, or they may interact through their inputs,
      outputs and exported events. The interaction network itself
      may evolve.



    <label id="YAP Prolog">
    <tag/YAP Prolog/
        <itemize>
            <item>Web site: <htmlurl 
                    url="http://www.ncc.up.pt/&tilde;vsc/Yap/"
                    name="www.ncc.up.pt/&tilde;vsc/Yap/">
            <item>Sourceforge site: <htmlurl 
                    url="http://sourceforge.net/projects/yap/"
                    name="sourceforge.net/projects/yap/">
        </itemize>
        
            YAP is a high-performance Prolog compiler developed at  
            LIACC/Universidade do Porto. Its Prolog engine is based in the WAM
            (Warren Abstract Machine), with several optimizations for better
            performance. YAP follows the Edinburgh tradition, and is largely
            compatible with DEC-10 Prolog, Quintus Prolog, and especially 
            with C-Prolog. Work on the more recent version of YAP strives at
            several goals:
        
            <itemize>
                <item>Portability: The whole system is now written in C. YAP
                    compiles in popular 32 bit machines, such as Suns and 
                    Linux PCs, and in a 64 bit machines, the Alphas running
                    OSF Unix and Linux. 
                <item>Performance: We have optimised the emulator to obtain
                    performance comparable to or better than well-known Prolog
                    systems. In fact, the current version of YAP performs 
                    better than the original one, written in assembly language.
                <item>Robustness: We have tested the system with a large array 
                    of Prolog applications.
                <item>Extensibility: YAP was designed internally from the
                    beginning to encapsulate manipulation of terms. These
                    principles were used, for example, to implement a simple
                    and powerful C-interface. The new version of YAP extends
                    these principles to accomodate extensions to the 
                    unification algorithm, that we believe will be useful to
                    implement extensions such as constraint programming.
                <item>Completeness: YAP has for a long time provided most
                    builtins expected from a Edinburgh Prolog implementation.
                    These include I/O functionality, data-base operations, 
                    and modules. Work on YAP aims now at being compatible with
                    the Prolog standard. 
                <item>Openess: We would like to make new development of YAP
                    open to the user community. 
                <item>Research: YAP has been a vehicle for research within and
                    outside our group. Currently research is going on on 
                    parallelisation and tabulation, and we have started work
                    to support constraint handling. 
            </itemize>


  </descrip>



<sect>MIA
    <p>
    
    These are entires for which I no longer have a valid home page. If you have
    any information regarding where I can find these now please let me know.

    <descrip>
  
    <label id="CASE">
    <tag/CASE/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.iu.hio.no/&tilde;cell/" 
                name="www.iu.hio.no/&tilde;cell/">
            <item>FTP site: <htmlurl 
                url="ftp://ftp.iu.hio.no/pub/" 
                name="ftp.iu.hio.no/pub/">
        </itemize>
     
      CASE (Cellular Automaton Simulation Environment) is a C++
      toolkit for visualizing discrete models in two dimensions:
      so-called cellular automata. The aim of this project is to
      create an integrated framework for creating generalized cellular
      automata using the best, standardized technology of the day.


    <label id="CLIG">
    <tag/CLIG/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.ags.uni-sb.de/&tilde;konrad/clig.html" 
                name="www.ags.uni-sb.de/&tilde;konrad/clig.html">
        </itemize>

    CLIG is an interactive, extendible grapher for visualizing linguistic
    data structures like trees, feature structures, Discourse
    Representation Structures (DRS), logical formulas etc. All of these can
    be freely mixed and embedded into each other. The grapher has been
    designed both to be stand-alone and to be used as an add-on for
    linguistic applications which display their output in a graphical
    manner.
 

    <label id="Corewar VM">
    <tag/Corewar VM/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.jedi.claranet.fr/" 
                name="www.jedi.claranet.fr/">
        </itemize>

        This is a virtual machine written in Java (so it is a virtual machine
        for another virtual machine !) for a Corewar game.


    <label id="Dunce">
    <tag/Dunce/
        <itemize>
            <item>Web site: <htmlurl
                url="http://www.boswa.com/boswabits/"
                name="www.boswa.com/boswabits/"> 
        </itemize>
        
        Dunce is a simple chatterbot (conversational AI) and a language for
        programming such chatterbots. It uses a basic regex pattern matching
        and a semi-neural rule/response firing mechanism (with excitement/decay
        cycles).

        Dunce is listed about halfway down the page.


    <label id="EcoSim">
    <tag/EcoSim/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.offis.de/projekte/projekt.php?id=140"
                name="www.offis.de/projekte/projekt.php?id=140">
        </itemize>

        NOTE: the above web site has info on EcoSim but no code to download. 


        In EcoSim an ecosystem is described by all static and dynamic
        properties of the individuals involved in the system as well as time
        varying properties of the environment. Individuals change their state
        over time or due to internal and external events. The environment is
        also defined via dynamic objects which can change. Supports on the fly
        analysis and animation of generated data. It is a C++ class library
        designed to support individual-oriented modelling and simulation
        of ecological systems.


    <label id="Evo">
    <tag/Evo/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://omicrongroup.org/evo/"
                name="omicrongroup.org/evo/">
        </itemize>

        Evo is a software development framework that allows developers to build
        complex alife simulations. Using Evo, researchers can easily build
        systems of independent agents interacting with one another and with
        their environment. Evo implements biological operators such as genetic
        recombination and mutation to evolve the behavior of agents so that
        they are more adapted to their environment.


      <label id="IDEAL">
      <tag/IDEAL/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://yoda.cis.temple.edu:8080/ideal/"
                name="yoda.cis.temple.edu:8080/ideal/">
        </itemize>
      
	IDEAL is a test bed for work in influence diagrams and
	Bayesian networks. It contains various inference algorithms
	for belief networks and evaluation algorithms for influence
	diagrams. It contains facilities for creating and editing
	influence diagrams and belief networks.

	IDEAL is written in pure Common Lisp and so it will run in
	Common Lisp on any platform. The emphasis in writing IDEAL has
	been on code clarity and providing high level programming
	abstractions. It thus is very suitable for experimental
	implementations which need or extend belief network
	technology.

	At the highest level, IDEAL can be used as a subroutine
	library which provides belief network inference and influence
	diagram evaluation as a package. The code is documented in a
	detailed manual and so it is also possible to work at a lower
	level on extensions of belief network methods.
 
	IDEAL comes with an optional graphic interface written in
	CLIM. If your Common Lisp also has CLIM, you can run the
	graphic interface.
     

    <label id="Illuminator">
    <tag/Illuminator/
        <itemize>
            <item>Web site: <htmlurl 
            url="http://documents.cfar.umd.edu/resources/source/illuminator.html" 
            name="documents.cfar.umd.edu/resources/source/illuminator.html">
        </itemize>

      Illuminator is a toolset for developing OCR and Image
      Understanding applications.  Illuminator has two major parts: a
      library for representing, storing and retrieving OCR
      information, heretofore called dafslib, and an X-Windows "DAFS"
      file viewer, called illum. Illuminator and DAFS lib were
      designed to supplant existing OCR formats and become a standard
      in the industry. They particularly are extensible to handle more
      than just English.
      
      The features of this release: 
      <itemize>
        <item>5 magnification levels for images</item>
    	<item>flagged characters and words</item>
        <item>unicode support -- American, British, French, German, 
                Greek, Italian, MICR, Norwegian, Russian, Spanish, Swedish, 
                keyboards </item>
        <item>reads DAFS, TIFF's, PDA's (image only)</item>
        <item>save to DAFS, ASCII/UTF or Unicode</item>
        <item>Entity Viewer - shows properties, character choices, 
                bounding boxes image fragment for a selected entity, change 
                type, change content, hierarchy mode</item>
      </itemize>


      <label id="SPI">
      <tag/Symbolic Probabilistic Inference (SPI)/
      <itemize>
    	<item>FTP site: <htmlurl 
                url="ftp://ftp.engr.orst.edu/pub/dambrosi/spi/" 
                name="ftp.engr.orst.edu/pub/dambrosi/spi/">
        <item>Paper (ijar-94.ps): <htmlurl 
                url="ftp://ftp.engr.orst.edu/pub/dambrosi/" 
                name="ftp.engr.orst.edu/pub/dambrosi/">
      </itemize>

     
      Contains Common Lisp function libraries to implement SPI type baysean 
      nets. Documentation is very limited.
      Features: 
      <itemize>
          Probabilities, Local Expression Language Utilities, Explanation, 
          Dynamic Models, and a TCL/TK based GUI.
      </itemize>


    <label id="TIN">
    <tag/TIN/
    <itemize>
        <item>Web site: <htmlurl 
            url="http://www.jetlag.demon.nl/" 
            name="www.jetlag.demon.nl"></item>
    </itemize>

      This program simulates primitive life-forms, equipped with some
      basic instincts and abilities, in a 2D environment consisting of
      cells.  By mutation new generations can prove their success, and thus
      passing on "good family values".

      The brain of a TIN can be seen as a collection of processes, each
      representing drives or impulses to behave a certain way, depending on the
      state/perception of the environment ( e.g. presence of food, walls,
      neighbors, scent traces) These behavior process currently are : eating,
      moving, mating, relaxing, tracing others, gathering food and killing. The
      process with the highest impulse value takes control, or in other words:
      the tin will act according to its most urgent need.


    <label id="Ummon">
    <tag/Ummon/
        <itemize>
            <item>Web site: <htmlurl 
                url="http://www.spacetide.com/projects/ummon/" 
                name="www.spacetide.com/projects/ummon/">
        </itemize>

        Ummon is an advanced Open Source chatterbot. The main principle of the
        bot is that it has no initial knowledge of either words or grammar; it
        learns everything "on the fly." Numerous AI techniques will be explored
        in the development of Ummon to achieve realistic "human" communication
        with support for different, customizable personalities.


     
  </descrip>

</article>
