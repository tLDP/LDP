<!doctype linuxdoc system>

<!-- 
************************** begin comment *****************************
     The following is the HOW-TO for PostgreSQL. This document is
     in the SGML format. You must use sgml package to process this 
     document
************************* end of comment *****************************
 -->
<!--
************************** SGML USER GUIDE *****************************
	The SGML user guide on linux is located at /usr/doc/sgml-tools
	Read the example.sgml and guide.html documents.
	Usage:
		HTML	  	sgml2html foo  (Do not give extension .sgml here!!)
		Text	 	sgml2txt foo.sgml
		Latex	  	sgml2latex foo.sgml

		Note: Use 2 dashes - before language, error while compiling
		Postscript 	sgml2latex -language=english -o ps foo.sgml
		DVI  		sgml2latex -d foo.sgml
		Lyx			sgml2lyx foo.sgml
		Richtext 	sgml2rtf foo.sgml
		gnuinfo  	sgml2info foo.sgml
		man			sgml2txt -man foo.sgml
		SGML	 	sgmlcheck foo.sgml
************************* end of comment *****************************
-->

<article>

<!-- Title information -->

<title>Database-SQL-RDBMS HOW-TO document for Linux (PostgreSQL Object Relational Database System)
<!-- chapt change
SQL DATABASE HOW-TO 
A PRACTICAL GUIDE

Covers PostgreSQL Version 6.5.3

-->
<author>Al Dev (Alavoor Vasudevan) 
       <htmlurl url="mailto:alavoor@yahoo.com"
             name="alavoor@yahoo.com">
<date>v28.0, 10 July 2000
<abstract>
This document is a "practical guide" to very quickly setup a SQL Database
engine and
front end tools on a Unix system. It also discusses the International standard
language ANSI/ISO SQL and reviews the merits/advantages of the 
SQL database engine developed by the world-wide internet in an "open 
development" environment.
It is about HOW-TO setup a next generation Object Relational SQL Database 
"PostgreSQL" on Unix system which can be used as a Application Database
Server or as a Web Database Server. PostgreSQL attempts to implement
current and future International ISO/ANSI SQL standards. This 
document also gives information on the database interface programs
like Front End GUIs, RAD tools (Rapid Application Development), ODBC,
JDBC drivers, "C", "C++", Java, Perl programming interfaces and Web
Database Tools.
Information given here applies to all Unix/Windows NT platforms 
and to all other SQL databases. It will be very useful for people who 
are new to Databases, SQL language and PostgreSQL.

This document also has SQL tutorial, SQL syntax which would be very helpful
 for beginners. Experienced people will find this document as a useful 
reference guide. For students, the information given here will enable them
to get the source code for PostgreSQL relational database system, from 
which they can learn as to how a RDBMS SQL database engine is created.

</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Introduction
-->
<sect>Introduction
<p>
The purpose of this document is to provide comprehensive list of pointers/URLs to 
quickly setup PostgreSQL and also to advocate the benefits of Open 
Source Code system like PostgreSQL, Linux.

Each and every computer system in the world needs a database to store/retrieve the information.
The primary reason you use the computer is to store, retrieve and process information and do all these very quickly, thereby saving you time. 
At the same time, the system must be simple, robust, fast, reliable, economical and very easy to use.
Database is the most <bf>VITAL SYSTEM</bf> as it stores mission critical information of every company in this world. 
Each and every industry in this world needs a database system. Industries like telecom, automobile, banks, airlines, etc.. 
will not function efficiently without a database system.
The most popular database systems are based on the International Standard Organisation (ISO) SQL 
specifications and ANSI SQL (American) standards.
The current specifications widely used in the industry are ISO/ANSI SQL 1992. 
Upcoming standard is the SQL 1998/99 which is also called SQL-3 is still under development. Popular database like Oracle, Sybase and Informix systems are based on these standards or are 
trying to implement these standards.
<p>
Without a standard like ANSI/ISO SQL, it would be very difficult for the customer to develop a application once and run on all the database systems. 
End user wants to develop an application ONCE using ISO SQL, ODBC, JDBC and 
deploy on all variety of database systems in the world.
<p>
The world's most popular FREE Database which implements some of the ISO SQL, 
ANSI SQL/98, SQL/92 and ANSI SQL/89 RDBMS is PostgreSQL. PostgreSQL is next generation 
Object relational database and is targeting on full compliance of SQL standards like ISO/ANSI SQL.
PostgreSQL is the only free RDBMS in the world which supports Object databases and SQL. This 
document will tell you how-to install the database, how to set 
up the Web database, application database, front end GUIs and interface programs.
It is strongly advised that you MUST write your database applications 100 &percnt 
compliant to standards of ISO/ANSI SQL, ODBC, JDBC so that your application 
is portable across multiple databases like PostgreSQL, Oracle, Sybase, Informix etc.

You get the highest quality, and lot many features with PostgreSQL as it follows 'Open Source Code development model'. Open Source Code model is the one where the complete source code is given to you and the development takes place on the internet by a extremely vast network of human brains.
Future trend shows that most of the software development will take place on the so called "Information Super-Highway" which spans the whole globe.
In the coming years, internet growth will be explosive which will further fuel rapid adoption of 
PostgreSQL by the industry.

By applying the principles of statistics, mathematics and science to software quality, you get the best quality of software only in a 'Open Source Code System' like PostgreSQL, wherein the source code is open to a very vast number of human brains inter-connected by the information super-highway.
Greater the number of human brains working, the better will be the quality of software.
Open Source Code model will also prevent <bf>RE-INVENTION OF WHEELS</bf>, eliminates <bf>DUPLICATION OF WORK</bf> and will be very economical, saves time in distribution and follows the modern economic laws of optimizing the national and global resources.
Once a software work is done by others, then you <bf>DO NOT</bf> need to re-do that again. You will not be wasting your valuable time on something which had already been <bf>WELL DONE</bf>.
Your time is extremely precious and it must be utilized efficiently, because you have only
8 hours a day for doing work.
As we will be entering the 21st century, there will be a change in the way that you get software for your use.
Everybody will give first preference for the open source 
softwares like PostgreSQL, Linux.

If you buy binaries, you will not get any equity and ownership of source code. Source code is a 
very valuable asset and binaries have no value. Buying software <it>may</it> become a 
thing of the past. You only need to buy good
hardware, it is worth spending money on the hardware and get the software from
internet. Important point is that it is the computer hardware which is 
<bf>doing bulk of the work</bf>. 
Hardware is the real work horse and software
is just driving it.
Computer hardware is so much more complex that only 6 nations in the world so far have
demonstrated the capability of designing and manufacturing computer chips/hardware. 
Design and manufacturing of computer chips is a advanced technology.
It is a very complex process, capital intensive, requires large investments in plant and
production machines which deal with 0.18 micron (even smaller than 0.18) technology. On a single small silicon 
chip millions of transistors/circuits are densely packed.
Companies like Applied Material, AMD, Intel, Cyrix, Hitachi, IBM and others 
spent significant number of man-years
to master the high-technology like Chip Design, Micro-electronics and Nano-electronics.
Micro means (one-millionth of meter 10^-6),
Nano  means (one-billionth of meter 10^-9). Current technology uses 
micro-electronics of about 0.35 micron using aluminum as conductors and 
0.25 micron sizes using copper as conductors of electrons. 
In near future the technology of 0.10 micron with copper and 
even nano-electronics will be used to make computer chips. Aluminum conductors will be
phased out by copper on computer chips, as copper is a better conductor of electrons.
In photolithography process extreme ultraviolet, X-ray or electron-beam techniques
will be used to etch circuits for feature size less than 0.15 micron.
In about 20 years from now, silicon chips will be phased out by 
molecular computers and bio chips which will be billions of times faster than 
silicon chips. Molecules are a group of atoms. And atoms are tiny particles which 
makes up everything that you see in this world. Molecular computers will 
use the molecules of matter as ultra-fast electronic on/off 
switches. When the switch is ON it indicates 1, 
and when it is OFF it indicates 0. All the computer programs in 
this world are based on binary (numbers 1 and 0).
Table below shows the progress and future advancement trends 
of computer chips.
<tscreen><verb>
		     Advancement of chip capabilities in future
		    ********************************************
+--------------------------+---------+---------+---------+---------+--------+---------+
| Item/Year                | 1997    | 1999    | 2001    | 2003    | 2012   | 2020    |
+--------------------------+---------+---------+---------+---------+--------+---------+
| Feature size(micron)     | 0.25    | 0.18    | 0.15    | 0.13    | 0.05   |< 0.00001|
+--------------------------+---------+---------+---------+---------+--------+---------+
| Wafer size(mm)           | 200     | 300     | 300     | 300     | 450    | Mol/Bio |
+--------------------------+---------+---------+---------+---------+--------+---------+
| Min Operating Voltage    | 1.8-2.5 | 1.5-1.8 | 1.2-1.5 | 1.2-1.5 | 0.5-0.6| < 0.001 |
+--------------------------+---------+---------+---------+---------+--------+---------+
| Max power dissipation    | 70      | 90      | 110     | 130     | 175    | 600     |
+--------------------------+---------+---------+---------+---------+--------+---------+
| On-chip frequencey (MHz) | 750     | 1,250   | 1,500   | 2,100   | 10,000 | > 50,000|
+--------------------------+---------+---------+---------+---------+--------+---------+
| DRAM capacity            | 256 MB  | 1 GB    | 2 GB    | 4 GB    | 256 GB | > 1000GB|
+--------------------------+---------+---------+---------+---------+--------+---------+
</verb></tscreen>
As you can see, it is hardware that is high technology 
and important and software is labor intensive but is a less difficult technology.

On other hand, each and every country in the world develops/makes software.
In fact, any person in this world with a small low-cost PC can
write software. 

Databases like Oracle, Informix, Sybase, IBM DB2 (Unix) are written using the 
"C" language and binaries are created by compiling the source code
and then they are shipped out to customers. Oracle, Sybase, Informix databases are
100 &percnt "C" programs!!

<p>
Since a lot of work had been done on PostgreSQL for the past 14 years, it does
not make
sense to re-create from scratch another database system which satisfies ANSI/ISO SQL.
It will be a great advantage to take the existing code and add 
missing features or enhancements to PostgreSQL and start using it immediately.
 
Prediction is that demand for "Internet products" like PostgreSQL will 
grow exponentially as it is capable of 
maintaining a high quality, low cost, extremely large user-base and
developer-base. Those nations which do not use the 'Internet products' 
will be seriously missing "World-wide Internet Revolution" and will be
left far behind other countries. The reason is "Internet" itself is the world's
<bf>LARGEST</bf> "software company" and is a large software "power house"!
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Laws of Physics apply to Software!
-->
<sect> Laws of Physics apply to Software!
<p>
In this chapter, it will be shown how science plays a important role in the creation of
various objects like software, this universe, mass, atoms, energy and even yourself! 
This chapter also shows why knowledge of science is very important before you start 
using the products of science.

The golden rule is - <it>"You MUST not use a product without 
understanding how it is created!!"</it> This rule applies
to everything - database sytems, computer system, operating system, this universe and 
even your own human body! It means that you should have complete source 
code and information about the system. It is important to understand how human body
and atoms inside human body works since humans are creating PostgreSQL, MS Windows95 etc..

Creation is a very important step. Persons who are using the objects of science
must know how it is created. This applies to even computer systems and PostgreSQL.
A majority of people do not have knowledge of science and hence do not 
know how systems like MS Windows NT/95, Oracle, human body and this universe are 
created. A vast majority of people do not 
know what made the universe and MS Windows 95/NT
and what is inside it. Complex systems are built from very
simple basic building blocks like - millions of universes are created, 
each universe in turn has millions of super-clusters, each super-cluster has 
millions of galaxies, each galaxy has millions of stars, some stars 
system have many planets, each planet in turn is made up 
billions of atoms.<it>(In the history of this world, <bf>only one universe was 
created by a man</bf> in ancient India eons ago, but no other case had been 
reported in the modern history. Nations around the world are trying to create
a universe).</it> Creating a universe is a much more advanced 
technology and is more advanced than the atomic bomb which was dropped on 
Hiroshima and Nagasaki causing 
<bf>horrible destruction</bf>. 
Modern nuclear weapons are so tiny and powerful 
that if such a single nuclear bomb is dropped in pacific ocean then it 
can completely vaporise the planet earth! 
The total variety of weapons are infinity!! Nuclear weapons and other 
more <bf>powerful divine weapons</bf> were used 
in the battle field in ancient India! Nobody believed Albert 
Eienstein (a scientist of 1900's) when he said nuclear weapons can 
be made which can vaporise big cities. And today nobody believes
that man can create a universe.

Software like MS Windows 95 is created simply by "C"
and assembler language programs which simply uses 1 and 0 and <it><bf>universes like 
ours are created simply by dashing TWO dissimilar but proper of combination of 
tiny atomic particles of other dimensions.</bf></it>
<it>(Something interesting happened <bf>just before</bf> dashing of tiny particles)</it>
A human body is created by dashing two dissimilar but 
proper combination of tiny cells!! 
<it>(Something interesting happened <bf>just before</bf> dashing of tiny cells)</it>
Humans inherited the properties of this universe.
The universe you are
currently living in was NOT there - all the atoms inside the universe was not there 
and not even TIME was existing!! Baby universe was born during big bang and started 
expanding and kept growing. Even today our universe is still expanding!! 
A person from another universe by name <bf>'Brahma'</bf> created 
this universe you are currently living in. 
It is indeed possible for man to create a new universe.
Total number of universes that can be created 
is <bf>INFINITY</bf> and similarly total number of operating systems that 
can be created is also <bf>infinity</bf>!! Infinite number 
universes and infinite
variety of multi-dimensional atoms collapse down 
into few <it>primary-dimensional-universe</it>. Very advanced mathematical 
equations support this theory.

The laws of science and statistics favour the open-source 
code system like PostgreSQL and Linux. 
As the internet speed is increasing everyday, and
internet is becoming more and MORE reliable, the open-source code system will 
gain very rapid momentum.
And, if rules of statistics and laws of physics are correct, awareness of science
grows and when <bf>IGNORANT</bf> people start learning science then the 
closed source-code systems will eventually vanish from this planet.

Developing a project like PostgreSQL requires resources like energy and time, hence
PostgreSQL is a product of energy and time.
Since energy and time can be explained only by 
science, there is a direct co-relation between 
physics and software projects like PostgreSQL, Linux.
Laws of science (Physics) applies everywhere and at all the times,
to anything that you do, even while you are developing the software projects.

Physics is in action even while you are talking (sound waves), walking 
(friction between ground and your feet), reading a book or writing software. 
Every science in this world has a deep root in mathematics, including
PostgreSQL. PostgreSQL uses 'Modern Algebra' which is a tiny branch of mathematics.
Modern algebra deals with 'Set Theory', 'Relational Algebra', science of Groups, Rings, 
Collections, Sets, Unions, Intersections, Exclusions, Domains, Lists, etc...

The software like PostgreSQL is existing today because of the energy and time.
And mass and energy are ONE and the <bf>SAME</bf> entity.
The fact that mass and energy are same was unknown to people 100 years ago!
And even <bf>today</bf> it is unknown to world population that internet is the 
largest software "power house" and the largest "software company" in the world!

Cells in the human brains consume energy while processing
(creating software), by converting the chemical energy from food into electrical and 
heat energy.
Even while you are reading this paragraph, the cells in your brain are burning out the
fuel and are using tiny amounts of energy.
All of these implies that human brain is a thermodynamic heat engine.
Because human brain is a thermodynamic engine, the laws of thermodynamics applies to brain
and hence thermodynamics has indirect effects on software like PostgreSQL.

There can be infinite number of colors, computer langauages, computer chip designs and
 theories but there CANNOT be ONE SINGLE PERFECT color, computer language, design or system!
What you can have is only a  NEAR PERFECT color(wavelength), system, database, or theory!
<bf>Nature is like a <it>KALIEDOSCOPE</it></bf> - there are infinite number of dimensions, infinite variety 
particles of other dimensions but they all combine into very few primary 
dimensions and vice-versa. 

By combining the energies of
millions of people around the world via internet it is possible to achieve
a <bf>NEAR PERFECT</bf> system (including a database software system). Individually, 
the energy of each
person will be minute, but by networking a large number of people, the
total energy will be huge which can be focused on a 
project to generate a near perfect system.

The energy is measured in Joules, kiloJoules or kilograms of mass, and time is
measured in seconds or hours.
And power is energy divided by time and is measured in Watts or kiloWatts .
<code>
	Energy of each person = y Joules
or in terms of mass
	Energy of each person = y grams
The conversion factor between mass and energy is E = m * c * c  
where 'c' is the speed of light and 'm' is the mass.
	Time = 8 hours (This is constant since each person has only 8 hours a day)
	Power = Energy / Time
		  = (y / (8 * 60 * 60) ) Watts
	Total Power of the world = n * (y / (8 * 60 * 60) ) Watts
where n = number of persons working on the project.
</code>
From the above equation it is clear that increasing the 'n' will greatly improve
the quality of product. Greater the 'n' then greater will be the power (in KiloWatts).
You can wonder how much total 
energy (in KiloJoules) and total power (in KiloWatts)
the global internet can focus on a system like Linux and PostgreSQL!

It is very clear that internet can network a vast number of people, which implies
internet has a lot of energy and time which can produce much higher quality 
software products in much shorter time as 
compared to commercial companies. Even very big companies like Microsoft 
and IBM cannot overpower and overrule the laws of Physics but 
will eventually <bf>SURRENDER UNTO</bf> laws of science!

Conclusion is - because of laws of science, 'open source code' system like PostgreSQL, Linux
will prevail and will be always much better than 'closed source code' system 
and it is possible to prove this statement scientifically. Man should not waste 
time creating too many duplicate software products.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>What is PostgreSQL ?
-->
<sect>What is PostgreSQL ?
<p>
PostgreSQL is a free database, complete 
source code is given to you and is a Object-Relational Database System 
targetting on ANSI ISO/SQL 1998, 92 and runs on 
diverse hardware platforms and Operating systems.
The ultimate objective and the final goal of PostgreSQL is to become 100 &percnt 
compliant to ANSI/ISO SQL and also to become the number ONE open generic Database in the world. 

Today, PostgreSQL is the <bf>most advanced</bf> system in the world and
it is surprising that many commercial database systems could not match 
the quality, features and
capabilities of PostgreSQL !! PostgreSQL is the joint effort of many
nations around the globe and is a project similar to <bf>International
Space Station</bf>. PostgreSQL will remain 
the <bf>number one database system</bf> for many decades 
into future since it is a open-source code system.

The fundamental idea behind PostgreSQL is - once a module of code is written
than you should not waste even a milli-second of your time trying to re-invent it!!

Informix Universal server (released 1997) is based on earlier version of
PostgreSQL because Informix bought
Illustra Inc. and integrated with Informix. Illustra database was 
based on Postgres (earlier version of PostgreSQL).

     PostgreSQL is an enhancement of the POSTGRES database management
     system, a next-generation DBMS research prototype.  While
     PostgreSQL retains the powerful data model and rich data types of
     POSTGRES, it replaces the PostQuel query language with an
     extended subset of SQL. 


     PostgreSQL development is being performed by a team of Internet
     developers who all subscribe to the PostgreSQL development
     mailing list. The current coordinator is Marc G. Fournier
<itemize>
<item>       <htmlurl url="mailto:scrappy@postgreSQL.org"
             name="scrappy@postgreSQL.org">
</itemize>
     This team is now responsible for all
     current and future development of PostgreSQL.
     Ofcourse, the database customer himself is the developer of PostgreSQL!
     The development load is distributed among a very large
     number of database end-users on internet.

     The authors of PostgreSQL 1.01 were Andrew Yu and Jolly Chen.
     The original Postgres code, from
     which PostgreSQL is derived, was the effort of many graduate
     students, undergraduate students, and staff programmers and working
     under the direction of Professor Michael Stonebraker at the
     University of California, Berkeley.

Millions of PostgreSQL is installed as Database servers, Web database servers and Application data servers. 
It is very sophisticated object relational database system (ORDBMS).

PostgreSQL runs on Solaris, SunOS, HPUX, AIX, Linux, Irix, 
Digital Unix, BSDi,NetBSD, FreeBSD, SCO unix, NEXTSTEP, Unixware and 
all and every flavor of Unix. Port to Windows NT is done using 
Cygnus cygwin32 package.

PostgreSQL and related items in this document are subject to the 
COPYRIGHT from University of California, Berkeley.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1>White Paper
<p>
PostgreSQL details in nutshell:
<itemize>
<item>  Title:             PostgreSQL SQL RDBMS Database (Object Relational Database Management System)
<item>  Current Version:   7.0.1
<item>  Age:	     	     PostgreSQL is 15 years old. Developed since 1985
<item>  Authors:           Developed by millions/universities/companies on internet 
for the past 15 YEARS
</itemize>
The white paper on PostgreSQL is at  
<url url="http://www.greatbridge.com">
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Which one? PostgreSQL or MySQL ?
-->
<sect>Which one? PostgreSQL or MySQL ?
<p>
MySQL is another open-source SQL server, but it does not support
transactions. It is suitable for very small databases and does not
support advanced SQL functionalities. Whereas PostgreSQL is a enterprise strength database
supporting transactions and almost all SQL constructs.
PostgreSQL is much more advanced than commercial databases like Oracle, Sybase
and Informix. PostgreSQL supports very advanced locking mechanisms and many more
advanced features which are not available in commercial database systems!!

In near future development of MySQL will be dropped, 
since MySQL is duplicate product working towards ANSI SQL. 
And all the MySQL users will be migrated to PostgreSQL. 
Also MySQL is a 'quasi-commercial' product unlike 
PostgreSQL which is open-source and there is no license fee.
There is no need for another SQL database system as PostgreSQL is already
here in this world!!

Duplicate products like MySQL confuse the user base and causes division of
resources. For a <bf>"NEAR PERFECT"</bf> system there must be <bf>only one</bf>
system and everybody in the world must work on it!!
Duplicate products cause more harm than good and hence division of 
resources must be strongly discouraged. This already happened in case of
commercial database systems like Oracle, Sybase, Informix and MS SQL server
which caused splintering of user base and often they are incompatible.

<bf>WARNING: </bf> It is possible to create infinite number of database systems
for a given specification like ANSI SQL!!

MySQL is at <url url="http://www.tcx.se">
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Where to get it ?
-->
<sect>Where to get it ?
<p>
You can buy Redhat Linux CDROM, Debian Linux CDROM or Slackware
Linux CDROM which already contains the PostgreSQL in 
package form (both source code and binaries) from :
<itemize>
<item>Linux System Labs Web site:  <url url="http://www.lsl.com/">  (7 U.S. dollars)
<item>Cheap Bytes Inc Web site:  <url url="http://www.cheapbytes.com/"> (7 U.S. dollars)
<item>Debian Main Web site : <url url="http://www.debian.org/vendors.html">
</itemize>
<p>
PostgreSQL organisation is also selling 'PostgreSQL CDROM' which
contains the complete source code and binaries for many Unix operating
systems as well as full documentation.
<itemize>
<item>PostgreSQL CDROM from main Web site at : <url url="http://www.postgresql.org"> 30 (U.S. dollars)
</itemize>

Binaries only distribution of PostgreSQL:
<itemize>
<item> The maintainer of PostgreSQL RPMs is Lamar Owen and is at 
<htmlurl url= "mailto:lamar.owen@wgcr.org"
	name="lamar.owen@wgcr.org">
<item>PostgreSQL source RPM and binaries RPM <url url="http://www.ramifordistat.net/postgres">
<item>PostgreSQL source RPM and binaries RPM <url url="http://www.postgresql.org"> Click on "Latest News" and click on Redhat RPMs.
<item>PostgreSQL source RPM and binaries RPM <url url="http://www.redhat.com/pub/contrib/i386/">
and ftp site is at <url url="ftp://ftp.redhat.com/pub/contrib/i386/">
<item>Binaries site for Solaris, HPUX, AIX, IRIX, Linux :  <url url="ftp://ftp.postgresql.org/pub/bindist">
</itemize>

<p>
WWW Web sites:
<itemize>
<item>Primary Web site:  <url url="http://www.postgresql.org/">
<item>Secondary Web site:     <url url="http://logical.thought.net/postgres95/">
<item>		     <url url="http://www.itm.tu-clausthal.de/mirrors/postgres95/">
<item>		     <url url="http://s2k-ftp.cs.berkeley.edu:8000/postgres95/">
<item>  <url url="http://xenium.pdi.net/PostgreSQL/">
<item>  <url url="http://s2k-ftp.cs.berkeley.edu:8000/postgres95/">

</itemize>

<p>
The ftp sites are listed below :-
<itemize>
<item>Primary FTP:       <url url="ftp://ftp.postgresql.org/pub">
<item>Secondary FTP:     <url url="ftp://ftp.chicks.net/pub/postgresql">
<item>		     <url url="ftp://ftp.emsi.priv.at/pub/postgres/">
<item>		<url url="ftp://ftp.itm.tu-clausthal.de/pub/mirrors/postgres95">
<item>		     <url url="ftp://rocker.sch.bme.hu/pub/mirrors/postgreSQL">
<item>		     <url url="ftp://ftp.jaist.ac.jp/pub/dbms/postgres95">
<item>		     <url url="ftp://ftp.luga.or.at/pub/postgres95">
<item>		     <url url="ftp://postgres95.vnet.net:/pub/postgres95">
<item>	<url url="ftp://ftpza.co.za/mirrors/postgres">
<item>	<url url="ftp://sunsite.auc.dk/pub/databases/postgresql">
<item>	<url url="ftp://ftp.task.gda.pl/pub/software/postgresql">
<item>	<url url="ftp://xenium.pdi.net/pub/PostgreSQL">

</itemize>

<p>
PostgreSQL source code is also available at all the mirror sites of sunsite unc (total of about 1000 sites around the globe). It is inside the Red Hat Linux distribution in /pub/contrib/i386/postgresql.rpm file. 
<itemize>
<item>	For list of mirror sites go to <url url="ftp://sunsite.unc.edu">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>PostgreSQL Quick-Installation Instructions
-->
<sect>PostgreSQL Quick-Installation Instructions <label id="Quick-Installation">
<p>
This chapter will help you to install and run the database very quickly in less than 5 minutes.

<sect1> Install and Test
<p>
Quick Steps to Install, Test, Verify and run PostgreSQL
Login as root.
<code>
# cd /mnt/cdrom/RedHat/RPMS
# man rpm
# ls postgre*.rpm
# rpm -qpl postgre*.rpm | less (to see list of files)
# rpm -qpi postgre*.rpm (to see info of package)
# cat /etc/passwd | grep postgres
</code>
  Note: If you see a 'postgres' user, you may need to backup and clean
  up the postgres home directory ~postgres and delete the unix user 'postgres'
  or rename the unix user 'postgres' to something like 'postgres2'.
  Install must be "clean slate"
<code>
# rpm -i postgre*.rpm (Must install all packages clients, devel, data
         and main for pgaccess to work )
# man chkconfig
# chkconfig --add postgresql  (to start pg during booting)
# /etc/rc.d/init.d/postgresql start  (to start up postgres)
# man xhost
# xhost +  (To give display access for pgaccess)
# su - postgres
bash$ man createdb
bash$ createdb mydatabase
bash$ man psql
bash$ psql mydatabase
..... in psql press up/down arrow keys for history line editing or \s

bash$ export DISPLAY=<hostname>:0.0
bash$ man pgaccess
bash$ pgaccess mydatabase
</code>
  Now you can start <bf>rapidly BANGING away</bf> SQL commands at psql or pgaccess !!
<code>
bash$ cd /usr/doc/postgresql*
</code>
Here read all the FAQs, User, Programmer, Admin guides and tutorials.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> PostgreSQL RPMs
<p>
See also <it>"Installation Steps"</it> from <url url="http://www.ramifordistat.net/postgres">

The maintainer of PostgreSQL RPMs is Lamar Owen and is at 
<htmlurl url= "mailto:lamar.owen@wgcr.org"
	name="lamar.owen@wgcr.org">
More details about PostgreSQL is at <url url="http://www.postgresql.org">
<!--
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Maximum RPM
<p>
Familiarize with RedHat RPM package manager to manage the PostgreSQL installations.
Download the 'Maximum RPM' textbook from <url url="http://www.RPM.org"> look for the 
filename maximum-rpm.ps.gz
And read it on linux using the gv command -
<code>
# gv maximum-rpm.ps.gz
</code>
There is also rpm2deb which converts the RPM packages to Debian linux packages.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Examples RPM <label id="Examples RPM">
<p>
Examples are needed to do testing of various interfaces to PostgreSQL.
Install the postgresql examples directory from  -
<itemize>
<item> Linux cdrom - postgresql-*examples.rpm
<item> postgresql-*examples.rpm from <url url="http://www.aldev.8m.com"> 
or <url url="http://www.aldev.webjump.com">
<item> PostgreSQL source code tree postgresql*.src.rpm and look for examples, 
testing or tutorial directories
</itemize>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing PyGreSQL - Python interface <label id="Testing PyGreSQL">
<p>
Install examples package, see <ref id="Examples RPM"> and then do -
<code>
bash$ cd /usr/lib/pgsql/python
bash$ createdb thilo
bash$ psql thilo
thilo=> create table test (aa char(30), bb char(30) );
bash$ /usr/bin/python
>>> import _pg
>>> db = _pg.connect('thilo', 'localhost')
>>> db.query("INSERT INTO test VALUES ('ping', 'pong')")
>>> db.query("SELECT * FROM test")
eins|zwei
----+----
ping|pong
(1 row)
>>>CTRL+D
bash$
..... Seems to work - now install it properly
bash$ su - root
# cp /usr/lib/pgsql/python/_pg.so /usr/lib/python1.5/lib-dynload
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing Perl - Perl interface <label id="Testing Perl">
<p>
Install examples package, see <ref id="Examples RPM"> and then do -
<code>
bash$ cd /usr/doc/postgresql-6.5.3/examples/perl5
bash$ perl ./example.pl
</code>
Note: If the above command does not work then do this.
	  Gloabl var @INC should include the Pg.pm module in
      directory site_perl hence use -I option below
<code>
bash$ perl -I/usr/lib/perl5/site_perl/5.005/i386-linux-thread ./example.pl
</code>
.... You ran the perl which is accessing PostgreSQL database!!

Read the example.pl file for using perl interface.
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing libpq, libpq++ interfaces <label id="Testing libpq">
<p>
Install examples package, see <ref id="Examples RPM"> and then do -
<code>
bash$ su root   --> to change ownership of examples
# chown -R postgres /usr/doc/postgresql-6.5.3/examples
# exit

bash$ cd /usr/doc/postgresql-6.5.3/examples/libpq
bash$ gcc testlibpq.c -I/usr/include/pgsql -lpq
bash$ export PATH=$PATH:.
bash$ a.out

bash$ cd /usr/doc/postgresql-6.5.3/examples/libpq++
bash$ g++ testlibpq0.cc -I/usr/include/pgsql -I/usr/include/pgsql/libpq++
-lpq++ -lpq -lcrypt
bash$ ./a.out  (Note: Ignore Error messages if you get any - as below)
> create table foo (aa int, bb char(4));
No tuples returned...
status = 1
Error returned: fe_setauthsvc: invalid name: , ignoring...
> insert into foo values ('4535', 'vasu');
No tuples returned...
status = 1
Error returned: fe_setauthsvc: invalid name: , ignoring...
> select * from foo;
aa   |bb   |
-----|-----|
4535 |vasu |
Query returned 1 row.
>
>CTRL+D
bash$
</code>
.... You ran direct C/C++ interfaces to PostgreSQL database!!
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing Java interfaces <label id="Testing Java">
<p>
Install examples package, see <ref id="Examples RPM"> and 
also install the following - 
<itemize>
<item> Get JDK jdk-*glibc*.rpm from <url url="ftp://ftp.redhat.com/pub/contrib/i386">
or from <url url="http://www.blackdown.org">
<item> Get postgresql-jdbc-*.rpm <url url="ftp://ftp.redhat.com/pub/contrib/i386">
</itemize>
<code>
bash$ cd /usr/doc/postgresql-6.5.3/examples/jdbc
bash$ echo $CLASSPATH
 --> Should show  CLASSPATH=/usr/lib/jdk-x.x.x/lib/classes.zip
where x.x.x is proper version numbers.
bash$ export CLASSPATH=$CLASSPATH:.:/usr/lib/pgsql/jdbc6.5-1.2.jar
Edit all psql.java file  and comment out the 'package' line.
bash$ javac psql.java
bash$ java psql jdbc:postgresql:template1 postgres &lt password&gt
[1] select * from pg_tables;
tablename       tableowner      hasindexes      hasrules
pg_type postgres        true    false   false
pg_attribute    postgres        true    false   false
[2]
CTRL+C
bash$
</code>
.... You ran direct Java interfaces to PostgreSQL database!
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing ecpg interfaces <label id="Testing ecpg">
<p>
Install examples package, see <ref id="Examples RPM"> and then do -
<code>
bash$ cd /usr/doc/postgresql-6.5.3/examples/ecpg
bash$ ecpg test1.pgc -I/usr/include/pgsql
bash$ cc test1.c -I/usr/include/pgsql -lecpg -lpq -lcrypt
bash$ createdb mm
bash$ ./a.out
</code>
.... You ran Embedded "C"-SQL to PostgreSQL database!
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing SQL examples - User defined types and functions <label id="Testing SQL">
<p>
Install examples package, see <ref id="Examples RPM"> and then do -
<code>
bash$ cd /usr/doc/postgresql-6.5.3/examples/sql
Under-development..
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing Tcl/Tk interfaces
<p>
Example of Tcl/Tk interfaces is pgaccess program.
Read the file /usr/bin/pgaccess using a editor -
<code>
bash$ view /usr/bin/pgaccess
bash$ export DISPLAY=<hostname of your machine>:0.0
bash$ createdb mydb
bash$ pgaccess mydb
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing ODBC interfaces
<p>
<enum>
<item> Get the win32 pgsql odbc driver from
        <url url="http://www.insightdist.com/psqlodbc/">
<item> See also /usr/lib/libpsqlodbc.a
</enum>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Testing MPSQL Motif-worksheet interfaces
<p>
Get the RPMs from <url url="http://www.mutinybaysoftware.com">
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Verification
<p>
To verify the top quality of PostgreSQL, run the Regression test package :-
Login as root -
<code>
# rpm -i postgresql*test.rpm
And see README file or install the source code tree which has regress directory
# rpm -i postgresql*.src.rpm
# cd /usr/src/redhat/SPECS
# more postgresql*.spec   (to see what system RPM packages you need to
install)
# rpm -bp postgresql*.spec  (.. this will prep the package)

Regression test needs the Makefiles and some header files like *fmgr*.h
which can be built by -
# rpm --short-circuit -bc postgresql*.spec ( .. use short circuit to
bypass!)
Abort the build by CTRL+C, when you see 'make -C common  SUBSYS.o'
By this time configure is successful and all makefiles and headers
are created. You do not need to proceed any further
# cd /usr/src/redhat/BUILD
# chown -R postgres postgresql*
# su - postgres
bash$ cd /usr/src/redhat/BUILD/postgresql-6.5.3/src/test/regress
bash$ more README
bash$ make clean; make all runtest
bash$ more regress.out
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Emergency Bug fixes
<p>
	Sometimes emergency bug fix patches are released after the
	GA release of PostgreSQL. You can apply these optional patches
	depending upon the needs of your application. Follow these 
	steps to apply the patches -
	Change directory to postgresql source directory
<tscreen><verb>
		# rpm -i postgresql*.src.rpm
		# cd /usr/src/postgresql6.5.3
		# man patch
		# patch -p0 < patchfile
		# make clean
		# make
</verb></tscreen>
The patch files are located in
<itemize>
<item>PostgreSQL patches : <url url="ftp://ftp.postgresql.org/pub/patches">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Quick Start Guide
-->
<sect> Quick Start Guide
<p>
Refer also to <ref id="Quick-Installation" name="Quick Installation"> chapter.
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Creating, Dropping, Renaming Database
<p>
You can use the user friendly GUI called 'pgaccess' to create and drop databases,
or you can use the command line 'psql' utility.
<code>
If you are logged in as root, switch user to 'postgres' :
# xhost +  (To give display access for pgaccess)
# su - postgres
bash$ man createdb
bash$ createdb mydatabase
bash$ man psql
bash$ psql mydatabase
..... in psql press up/down arrow keys for history line editing or \s

bash$ export DISPLAY=<hostname>:0.0
bash$ man pgaccess
bash$ pgaccess mydatabase
</code>
Now you can start <bf>rapidly BANGING away</bf> SQL commands at psql or pgaccess !!

To drop the database do :
<code>
bash$ man dropdb
bash$ dropdb <dbname>
</code>
It is also possible to destroy a database from within an SQL session by using:
<code>
> drop database <dbname>
</code>
To rename a database see <ref id="backup_restore" name="Backup and Restore">
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Creating, Dropping users
<p>
To create new users, login as unix user 'postgres'. 
You can use user friendly GUI tool called 'pgacess' to create, drop users.
<code>
bash$ man pgaccess
bash$ pgaccess <database_name>
</code>
and click on "Users" tab and then click Object|New or Object|Delete

You can also use command line scripts.
Use the shell script called 'createuser' which invokes psql
<code>
bash$ man createuser
bash$ createuser <username>
bash$ createuser -h host -p port -i userid <username>
</code>

To drop a postgres user, use shell script 'destroyuser' -
<code>
bash$ man destroyuser
bash$ destroyuser
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Creating, Dropping Groups
<p>
Currently, there is no easy interface to set up user groups. You have
to explicitly insert/update the <bf>pg_group</bf> table. For example:
<code>
bash$ su - postgres
bash$ psql <database_name>
..... in psql press up/down arrow keys for history line editing or \s

psql=> insert into pg_group (groname, grosysid, grolist)
psql=> values ('posthackers', '1234', '{5443, 8261}' );
INSERT 58224
psql=> grant insert on foo to group posthackers;
CHANGE
psql=>
</code>
The fields in <bf>pg_group</bf> are:
<bf>groname</bf> The group name. This name should be purely alphanumeric; do not
include underscores or other punctuation.

<bf>grosysid</bf> The group id. This is an int4, and should be unique for each group.

<bf>grolist</bf> The list of <bf>pg_user</bf> IDs that belong in the group. This is
an int4[].

To drop the group:
<code>
bash$ su - postgres
bash$ psql <database_name>
..... in psql press up/down arrow keys for history line editing or \s

psql=> delete from pg_group where groname = 'posthackers';
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Create, Edit, Drop a table
<p>
You can use user friendly GUI tool 'pgaccess' or command line tool 'psql'
to create, edit or drop a table in a database.
<code>
bash$ man pgaccess
bash$ pgaccess <database_name>
</code>
Click on Table | New | Design buttons.
<code>
bash$ man psql
bash$ psql <database_name>
..... in psql press up/down arrow keys for history line editing or \s
</code>
At psql prompt, give standard SQL statements like 'create table', 'alter table'
or 'drop table' to manipulate the tables.
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Create, Edit, Drop records in a table
<p>
You can use user friendly GUI tool 'pgaccess' or command line tool 'psql'
to create, edit or drop records in a database table.
<code>
bash$ man pgaccess
bash$ pgaccess <database_name>
</code>
Click on Table | &lt pick a table &gt | Open buttons.
<code>
bash$ man psql
bash$ psql <database_name>
..... in psql press up/down arrow keys for history line editing or \s

</code>
At psql prompt, give standard SQL statements like 'insert into table_name', 'update table_name'
or 'delete from table_name' to manipulate the tables.
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Switch active Database
<p>
You can use user friendly GUI tool 'pgaccess' or command line tool 'psql'
to switch active database.
<code>
bash$ man pgaccess
bash$ pgaccess <database_name>
</code>
Click on Database | Open buttons.
<code>
bash$ man psql
bash$ psql <database_name>
..... in psql press up/down arrow keys for history line editing or \s

psql=> connect <database_name> <user>
</code>
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Backup and Restore database <label id="backup_restore">
<p>
PostgreSQL provides two utilities to back up your system: <bf>pg_dump</bf>
to backup individual databases, and <bf>pg_dumpall</bf> to back up all the
databases in just one step.
<code>
bash$ su - postgres
bash$ man pd_dump
bash$ pd_dump <database_name> > database_name.pgdump
</code>
and can be restored using:
<code>
bash$ cat database_name.pgdump | psql <database_name>
</code>
This technique can be used to move databases to new locations, and to rename 
existing databases.

<bf>WARNING:</bf> Every database should be backed up on a regular basis. Since
PostgreSQL manages its own files in the file sysetem, it is not advisable to rely
on system backups of your file system for your database backups; there is 
no guarantee that the files will be in a usable, consistent 
state after restoration.

<bf>BACKUP LARGE DATABASES:</bf> Since Postgres allows tables larger than the
maximum file size on your system, it can be problematic to dump the table to
a file, because the resulting file likely will be larger than the maximum
size allowed by your system. As <bf>pg_dump</bf> writes to <bf>stdout</bf>,
you can just use standard unix tools to work around this possible problem:

Use compressed dumps:
<code>
bash$ pg_dump <database_name> | gzip > filename.dump.gz
</code>
reload with:
<code>
bash$ createdb <database_name>
bash$ gunzip -c filename.dump.gz | psql <database_name>
</code>
or
<code>
bash$ cat filename.dump.gz | gunzip | psql <database_name>
</code>

Use split:
<code>
bash$ pg_dump <database_name> | split -b 1m - filename.dump.
</code>
Note: There is a dot (.) after filename.dump in the above command!! You can 
reload with:
<code>
bash$ man createdb 
bash$ createdb <database_name>
bash$ cat filename.dump.* | pgsql <database_name>
</code>
Of course, the name of the file (filename) and the content of the <bf>pg_dump</bf>
output need not match the name of the database. Also, the restored database
can have an arbitrary new name, so this mechanism is also suitable for
renaming databases.

To dump all the databases in PostgreSQL use <bf>pg_dumpall</bf>
<code>
bash$ man pg_dumpall
bash$ pg_dumpall -o > db.out
To reload:
bash$ psql -e template1 < db.out
</code>
<!-- 



	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Security of database
<p>
See the chapter on <ref id="security" name="PostgreSQL Security">.
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Online help
<p>
It is very important that you should know how to use online help facilities of PostgreSQL,
since it will save you lot of time and provides very quick access to information.

See the online man pages on various commands like createdb, createuser, etc..
<code>
bash$ man createdb
</code>

See also online help of psql, by typing \h at psql prompt
<code>
bash$ psql mydatabase
psql> \h

Tip: In psql press up/down arrow keys for history line editing or \s
</code>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> PostgreSQL Documentation
<p>
More questions, read the fine manuals of PostgreSQL which are very
extensive.
PostgreSQL documentation is distributed with package. See the
'User's Guide', 'Programmer's Guide', 'Administrator's Guide' and
other manuals.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>PostgreSQL Supports Extremely Large Databases greater than 200 Gig
-->
<sect>PostgreSQL Supports Extremely Large Databases greater than 200 Gig
<p>
Performance of 32-bit cpu machines will decline rapidly when the database size
exceeds 5 GigaByte. You can run 30 gig database on 32-bit cpu but the 
performance will be degraded. 
Machines with 32-bit cpu imposes a limitation of 2 GB on RAM, 2 GB on file system sizes
and other limitations on the operating system. Use the special filesystems for linux
made by SGI, IBM or HP or ext3-fs to support file-sizes greater
than 2 GB on 32-bit linux machines.

For extremely large databases, it is strongly advised 
to use 64-bit machines like Digital Alpha cpu, Sun Ultra-sparc 64-bit cpu,
Silicon graphics 64-bit cpu, Intel Merced IA-64 cpu,
HPUX 64bit machines or IBM 64-bit machines. Compile PostgreSQL under 64-bit
cpu and it can support huge databases and large queries. Performance of 
PostgreSQL for queries on large tables and databases will be several times
faster than PostgreSQL on 32-bit cpu machines. Advantage of 64-bit machines
are that you get very large memory addressing space and the operating system 
can support very large file-systems, provide better performance with 
large databases, support much larger memory (RAM), have more capabilities etc..
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>How can I trust PostgreSQL ?
-->
<sect>How can I trust PostgreSQL ? Regression Test Package builds customer confidence
<p>
Thanks to <it>"Laws of Physics"</it>, it is possible to <bf>SCIENTIFICALLY</bf> 
verify whether PostgreSQL is working as per ISO/ANSI SQL specifications. 
To validate PostgreSQL, regression test package (src/test/regress) is 
included in the distribution. 
Regression test package will verify the standard SQL operations as well 
as the extensibility capabilities of PostgreSQL.
The test package already contains hundreds of SQL test programs. 

You should use the computer's high-speed power to validate the PostgreSQL, instead of using human brain power.
Computers can carry out software regression tests millions or even
billions of times faster than humans can.
Modern computers can run billions of SQL tests in a very short time. 
In the near future the speed of computer will be several zillion times
faster than human brain! 
Hence, it makes sense to use the power of computer to
validate the software.

You can add more tests just in case you need to, and can upload to the primary
PostgreSQL web site if you feel that it will be useful to others on internet.
Regression test package helps build customer confidence and trust in PostgreSQL
and facilitates rapid deployment of PostgreSQL on production systems.

Regression test package can be taken as a <bf>"VERY SOLID"</bf> technical document 
mutually agreed upon between the developers and end-users. PostgreSQL
developers extensively use the regression test package during development
period and also before releasing the software to public to ensure good quality.

Capablilities of PostgreSQL are directly reflected by the regression test package.
If a functionality, syntax or feature exists in the regression test package 
then it is supported, and all others which are NOT listed in the 
package MAY not be supported by PostgreSQL!! You may need to verify those and
add it to regression test package.
<!-- 

	*******************************************
	************ End of Section ***************
	*******************************************



<chapt> Security of Database <label id="security">
-->
<sect> Security of Database <label id="security">
<p>
Database security is addressed at several levels:
<itemize>
<item> Database file protection. All files stored within the database are 
protected from reading by any account other than the <it>postgres</it>
superuser account
<item> Connections from a client to the database server are, by default,
allowed only via a local UNIX socket, not via TCP/IP sockets. The back-end
must be started with the -i option to allow nonlocal clients to connect.
<item> Client connections can be restricted by IP address and/or username
via the <bf>pg_hba.conf</bf> file in <bf>$PG_DATA</bf>.
<item> Client connections may be authenticated via other external packages.
<item> Each user in Postgres is assigned a username and (optionally) a password.
By default, users do not have write access to databases they did not create.
<item> Users may be assigned to groups, and table access may be restricted based
on group priveleges.
</itemize>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> User Authentication
<p>
Authentication is the process by which the backend server and postmaster 
ensure that the user requesting access to data is in fact who he/she 
claims to be. All users who invoke Postgres are checked against the contents
of the <bf>pg_user</bf> class to ensure that they are authorized to do so. However,
verification of the user's actual identity is performed in a variety 
of ways: 
<itemize>
<item> <bf>From the user shell:</bf> A backend server started from a user shell 
notes the user's (effective) user-id before performing a 
<bf>setuid</bf> to the user-id of user <bf>postgres</bf>. The effective user-id is used as
the basis for access control checks. No other authentication is conducted. 
<item> <bf>From the network:</bf> If the Postgres system is built as distributed, access to the 
Internet TCP port of the postmaster process is available to anyone. The DBA
configures the <bf>pg_hba.conf</bf> file in the <bf>$PGDATA</bf> directory to specify what 
authentication system is to be used according to the host making the connection
and which database it is connecting to. 
See <bf>pg_hba.conf(5)</bf> (man 5 pg_hba.conf) 
for a description
of the authentication systems available. Of course, host-based authentication 
is not fool-proof in Unix, either. It is possible for determined intruders
to also masquerade the origination host. Those security issues are beyond
the scope of Postgres.
</itemize>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Host-Based Access Control
<p>
Host-based access control is the name for the basic controls PostgreSQL
exercises on what clients are
allowed to access a database and how the users on those clients must 
authenticate themselves.
Each database system contains a file named <bf>pg_hba.conf</bf>, in its 
<bf>$PGDATA</bf> directory, which controls who 
can connect to each database.
Every client accessing a database must be covered by one of the 
entries in <bf>pg_hba.conf</bf>. Otherwise all
attempted connections from that client will be rejected with a
<bf>"User authentication failed"</bf> error message.

See online man page of <bf>pg_hba.conf(5)</bf> (man 5 pg_hba.conf).

The general format of the <bf>pg_hba.conf</bf> file is of a set of records, one
per line. Blank lines and lines
beginning with a hash character ("#") are ignored. A record is made up of
a number of fields which
are
separated by spaces and/or tabs.

Connections from clients can be made using Unix domain sockets or Internet
domain sockets (ie.
TCP/IP). Connections made using Unix domain sockets are controlled using
records of the following
format:
<code>
local database authentication method
</code>
where

<bf>database</bf> specifies the database that this record applies to. The value 
<bf>all</bf> specifies that it applies to
all databases.
 
<bf>authentication method</bf> specifies the method a user must use to authenticate
themselves when
connecting to that database using Unix domain sockets. The different 
methods are described
below.
 
Connections made using Internet domain sockets are controlled using 
records of the following format.
 
<code>
host database TCP/IP-address TCP/IP-mask authentication method
</code>
 
The <bf>TCP/IP</bf> address is <it>logically and'ed</it> to both the specified TCP/IP mask
and the TCP/IP address of the
connecting client. If the two resulting values are equal then the record 
is used for this connection. If a
connection matches more than one record then the earliest one in the
file is used. Both the TCP/IP
address and the TCP/IP mask are specified in dotted decimal notation.
If a connection fails to match any record then the reject authentication 
method is applied (see <ref id="auth_method" name="Authentication Methods">).
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Authentication Methods <label id="auth_method">
<p>
The following authentication methods are supported for both Unix and TCP/IP domain sockets:
<itemize>
<item> <bf>trust</bf>
The connection is allowed unconditionally.
<item> <bf>reject</bf>
The connection is rejected unconditionally.
<item> <bf>crypt</bf>
The client is asked for a password for the user. This is sent encrypted (using crypt(3)) and compared
against the password held in the pg_shadow table. If the passwords match, the connection is allowed.
<item> <bf>password</bf>
The client is asked for a password for the user. This is sent in clear and compared against the
password held in the <bf>pg_shadow</bf> table. If the passwords match, the connection is allowed. An
optional password file may be specified after the password keyword which is used to match the
supplied password rather than the <bf>pg_shadow</bf> table. See <bf>pg_passwd</bf>.
</itemize>

The following authentication methods are supported for TCP/IP domain sockets only:
<itemize>
<item> <bf>krb4</bf>
Kerberos V4 is used to authenticate the user.
<item> <bf>krb5</bf>
Kerberos V5 is used to authenticate the user.
<item> <bf>ident</bf>
The ident server on the client is used to authenticate the user (RFC 1413). An optional map name
may be specified after the <bf>ident</bf> keyword which allows ident user names to be mapped onto Postgres
user names. Maps are held in the file <bf>$PGDATA/pg_ident.conf</bf>.
</itemize>

Here are some examples:
<code>
# Trust any connection via Unix domain sockets.
local   trust
# Trust any connection via TCP/IP from this machine.
host    all 127.0.0.1   255.255.255.255     trust
# We don't like this machine.
host    all 192.168.0.10    255.255.255.0       reject
# This machine can't encrypt so we ask for passwords in clear.
host    all 192.168.0.3 255.255.255.0       password
# The rest of this group of machines should provide encrypted passwords.
host    all 192.168.0.0 255.255.255.0       crypt
</code>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Access Control
<p>
Postgres provides mechanisms to allow users to limit the access to their data that is provided to other
users.
<itemize>
<item> <bf>Database superusers</bf>
Database super-users (i.e., users who have <bf>pg_user.usesuper</bf> set) silently bypass all of the access
controls described below with two exceptions: manual system catalog updates are not permitted if the
user does not have <bf>pg_user.usecatupd</bf> set, and destruction of system catalogs (or modification of their
schemas) is never allowed.
<item> <bf>Access Privilege</bf>
The use of access privilege to limit reading, writing and setting of rules on 
classes is covered in SQL <bf>grant/revoke(l)</bf>.
<item> <bf>Class removal and schema modification</bf>
Commands that destroy or modify the structure of an existing class, such as alter, drop table, and
drop index, only operate for the owner of the class. As 
mentioned above, these operations are never 
permitted on system catalogs. 
</itemize>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Secure TCP/IP Connection via SSH
<p>
You can use <bf>ssh</bf> to encrypt the network connection between clients and a Postgres server. Done properly,
this should lead to an adequately secure network connection.

The documentation for <bf>ssh</bf> provides most of the information to get started. Please refer to
<url url="http://www.heimhardt.de/htdocs/ssh.html"> for better insight.
A step-by-step explanation can be done in just two steps.

<bf>Running a secure tunnel via ssh: </bf>
A step-by-step explanation can be done in just two steps.
<itemize>
<item> Establish a tunnel to the back-end machine, like this:
<code>
ssh -L 3333:wit.mcs.anl.gov:5432 postgres@wit.mcs.anl.gov
</code>
<item> The first number in the <bf>-L</bf> argument, <bf>3333</bf>, is the port number of your end of the tunnel. The
second number, <bf>5432</bf>, is the remote end of the tunnel -- the port number your backend is using.
The name or the address in between the port numbers belongs to the server machine, as does the
last argument to <bf>ssh</bf> that also includes the optional user name. Without the user name, <bf>ssh</bf> will try 
the name you are currently logged on as on the client machine. You can use any user name the
server machine will accept, not necessarily those related to postgres.
<item> Now that you have a running <bf>ssh</bf> session, you can connect a postgres client to your local host at the
port number you specified in the previous step. If it's <bf>psql</bf>, you will need another shell because the
shell session you used in step 1 is now occupied with <bf>ssh</bf>.
<code>
psql -h localhost -p 3333 -d mpw
</code>
<item> Note that you have to specify the <bf>-h</bf> argument to cause your client to use the TCP socket instead
of the Unix socket. You can omit the port argument if you chose <bf>5432</bf> as your end of the tunnel.
</itemize>
<!-- 


	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Kerberos Authentication
<p>
Kerberos is an industry-standard secure authentication system suitable for distributed computing over a
public network.

<bf>Availability: </bf>
The Kerberos authentication system is not distributed with Postgres. Versions of Kerberos are typically
available as optional software from operating system vendors. In addition, a source code distribution may
be obtained through MIT Project Athena.

<code>
Note: You may wish to obtain the MIT version even if your vendor provides a version, since
some vendor ports have been deliberately crippled or rendered non-interoperable with the MIT
version.
</code>

Inquiries regarding your Kerberos should be directed to your vendor or MIT Project Athena. Note that
FAQLs (Frequently-Asked Questions Lists) are periodically posted to the Kerberos mailing list (send mail
to subscribe), and USENET news group.

<bf>Installation: </bf>
Installation of Kerberos itself is covered in detail in the Kerberos Installation Notes . Make sure that the
server key file (the <bf>srvtab</bf> or <bf>keytab</bf>) is somehow readable by the Postgres account.
Postgres and its clients can be compiled to use either Version 4 or Version 5 of the MIT Kerberos
protocols by setting the KRBVERS variable in the file <bf>src/Makefile.global</bf> to the appropriate value. You
can also change the location where Postgres expects to find the associated libraries, header files
and its   
own server key file.
After compilation is complete, Postgres must be registered as a Kerberos service. See the Kerberos
Operations Notes and related manual pages for more details on registering services.

<bf>Operation: </bf>
After initial installation, Postgres should operate in all ways as a normal Kerberos service. For details on
the use of authentication, see the <it>PostgreSQL User's Guide</it> reference sections for <bf>postmaster</bf> and <bf>psql</bf>.

In the Kerberos Version 5 hooks, the following assumptions are made about user and service naming(also, see Table below):
<itemize>
<item> User principal names (anames) are assumed to contain the actual Unix/Postgres user name in the
first component.
<item> The Postgres service is assumed to be have two components, the service name and a hostname,
canonicalized as in Version 4 (i.e., with all domain suffixes removed).
</itemize>

<code>
		Table: Kerberos Parameter Examples
 ------------------------------------------------------
 Parameter 	Example
 ------------------------------------------------------
 user 		frew@S2K.ORG
 user 		aoki/HOST=miyu.S2K.Berkeley.EDU@S2K.ORG
 host 		postgres_dbms/ucbvax@S2K.ORG 
 ------------------------------------------------------
</code>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>GUI FrontEnd Tool for PostgreSQL (Graphical User Interface)
-->
<sect>GUI FrontEnd Tool for PostgreSQL (Graphical User Interface)
<p>
Web browser will be the most popular GUI front-end in the future.
It is recommended that you migrate all of your "legacy" Windows 95/NT 
applications to  Web-based application.

You should use Web-Application Servers like <ref id="Enhydra"> (Java based) 
or <ref id="Zope"> (Python based).

Best web-scripting (and compiling) language 
is <ref id="PHP" name="PHP+Zend compiler"> 
<bf>PHP</bf> is extremely
powerful as it combines the power of Perl, Java, C++, Javascript into one
single language and it runs on all OSes - unixes and Windows NT/95.

The best tools in the order of preference are -
<itemize>
<item> Enhydra at <ref id="Enhydra"> plus Borland Java JBuilder for Linux <url url="http://www.inprise.com">
<item> Zope at <ref id="Zope">
<item> PHP script and Zend compiler at <ref id="PHP" name="PHP+Zend compiler">
<item> X-Designer supports C++, Java and MFC <url url="http://www.ist.co.uk/xd">
<item> Qt for Windows95 and Unix at <url url="http://www.troll.no"> and <url url="ftp://ftp.troll.no">
<item> Code Crusader is on linux cdrom, freeware based on MetroWorks Code Warrior <url url="http://www.kaze.stetson.edu/cdevel/code_crusader/about.html">
<item> Code Warrior from MetroWorks <url url="http://www.metrowerks.com">
<item> GNU Prof C++ IDE from <url url="http://www.redhat.com" name="(Redhat)"> Cygnus <url url="http://www.cygnus.com"> 
<item> Borland C++ Builder for Linux <url url="http://www.inprise.com">
<item> Borland Java JBuilder for Linux <url url="http://www.inprise.com">
</itemize>

Language choices in the order of preference are -
<enum>
<item> Java but its programs run very slow and has license
fees. C++ is <bf>5 times faster</bf> than Java!!
<item> Python (Powerful object oriented scripting language).
<item> PHP Web server scripting, HTML, DHTML with Javascrpt client scripting and Java-Applets.
<item> Perl scripting language using Perl-Qt or Perl-Tk <ref id="Perl Database Interface">
<item> Omnipresent and Omnipotent language C++ (GNU g++):
	<itemize>
	<item>Fast CGI(written in GNU C++) with Javascript/Java-Applets as Web-GUI-frontend.
	<item> GNU C++ and QtEZ or QT
	<item> GNU C++ with Lesstiff or Motif.
	</itemize>
</enum>

There are other tools available -
PostgreSQL has Tcl/Tk interface library in the distribution called 'pgTcl'. 
There is a IDE (integrated development environment) for Tcl/Tk called SpecTcl. 

<itemize>
<item> Lesstiff Motif tool <url url="ftp://ftp.redhat.com/pub/contrib/i386/lesstiff*.rpm">
<item> Vibe Java/C++ is at <url url="http://www.LinuxMall.com/products/00487.html">
<item> JccWarrior <url url="ftp://ftp.redhat.com/pub/contrib/i386/jcc*.rpm">
<item> Tcl/Tk <url url="http://www.scriptics.com">
<item> Object oriented extension of Tcl called INCR at <url url="http://www.tcltk.com">
<item> Visual TCL site <url url="http://www.neuron.com">
<item> Visual TCL Redhat rpm at <url url="ftp://ftp.redhat.com/pub/contrib/i386/visualtcl*.rpm">
<item> <url url="http://sunscript.sun.com/">
<item> <url url="http://sunscript.sun.com/TclTkCore/">
<item> <url url="ftp://ftp.sunlabs.com/pub/tcl/tcl8.0a2.tar.Z">
<item> Java FreeBuilder <url url="ftp://ftp.redhat.com/pub/contrib/i386/free*.rpm">
<item> SpecTCL <url url="ftp://ftp.redhat.com/pub/contrib/i386/spec*.rpm">
<item> Java RAD Tool for PostgreSQL Kanchenjunga <url url="http://www.man.ac.uk/~whaley/kj/kanch.html">
<item> Applixware Tool <url url="http://www.redhat.com">
<item> XWPE X Windows Programming Environment 
 <url url="http://www.identicalsoftware.com/xwpe/">
or at <url url="http://www.rpi.edu/~payned/xwpe/"> 
 <url url="ftp://ftp.redhat.com/pub/contrib/i386/xwpe*.rpm">
<item> XWB X Windows Work Bench <url url="ftp://ftp.redhat.com/pub/contrib/i386/xwb*.rpm">
<item> NEdit <url url="ftp://ftp.redhat.com/pub/contrib/i386/nedit*.rpm">
</itemize>
You can also use Borland C++ Builder, Delphi, Borland JBuilder, 
PowerBuilder on Windows95 connecting to PostgreSQL on unix box through ODBC/JDBC drivers. 
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Interface Drivers for PostgreSQL
-->
<sect>Interface Drivers for PostgreSQL
<p>
<sect1>ODBC Drivers for PostgreSQL
<p>
ODBC stands for 'Open DataBase Connectivity' established by Microsoft, is a popular standard 
for accessing information from various databases from different 
vendors. Applications written using the ODBC drivers are guaranteed to work with 
various databases like PostgreSQL, Oracle, Sybase, Informix etc..

<itemize>
<item> <url url="http://www.insightdist.com/psqlodbc" name="PostODBC"> is already included in the distribution. See main web site <url url="http://www.postgresql.org">. It is included on the PostgreSQL CDROM. 
<item> Open source code ODBC project is at <url url="http://www.iodbc.org">
<item> <url url="http://www.openlinksw.com"> Open Link Software Corporation is selling ODBC for PostgreSQL and other databases. 
Open Link also is giving away free ODBC (limited seats) check them out.

<item> Insight ODBC for PostgreSQL <url url="http://www.insightdist.com/psqlodbc"> This is the official PostODBC site.
<item> FreeODBC package <url url="http://www.ids.net/~bjepson/freeODBC/"> This is a free of cost version of ODBC.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>UDBC Drivers for PostgreSQL
<p>
UDBC is a static version of ODBC independent of driver managers and DLL support, used to embed database connectivity support directly into applications.
<itemize>
<item> <url url="http://www.openlinksw.com"> Open Link Software Corporation is selling UDBC for PostgreSQL and other databases.
Open Link also is giving away free UDBC (limited seats) check them out.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>JDBC Drivers for PostgreSQL 
<p>
JDBC stands for 'Java DataBase Connectivity'. Java is a platform independent programming language developed by Sun Microsystems. Java programmers are encouraged to write database applications using the JDBC to facilitate portability across databases like PostgreSQL, Oracle, informix, etc. If you write Java applications you can get JDBC drivers for PostgreSQL from the following sites:

JDBC driver is already included in the PostgreSQL distribution in postgresql-jdbc*.rpm.

<itemize>
<item> <url url="http://www.demon.co.uk/finder/postgres/index.html"> Sun's Java connectivity to PostgreSQL
<item> <url url="ftp://ftp.ai.mit.edu/people/rst/rst-jdbc.tar.gz">
<item> <url url="http://www.openlinksw.com"> Open Link Software Corporation is selling JDBC for PostgreSQL and other databases.
Open Link also is giving away free JDBC (limited seats) check them out.
<item> JDBC UK site <url url="http://www.retep.org.uk/postgres">
<item> JDBC FAQ site <url url="http://eagle.eku.edu/tools/jdbc/faq.html">
</itemize>

The JDBC home, guide and FAQ are located at -
<itemize>
<item> JDBC HOME <url url="http://splash.javasoft.com/jdbc">
<item> JDBC guide <url url="http://www.javasoft.com/products/jdk/1.1/docs/guide/jdbc">
<item> JDBC FAQ <url url="http://javanese.yoyoweb.com/JDBC/FAQ.txt">
</itemize>
See the section - <ref id="Testing Java" name="Testing Java PostgreSQL interface">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Java for PostgreSQL
<p>
Java programmers can find these for PostgreSQL very useful.
<itemize>
<item> <url url="ftp://ftp.redhat.com/pub/contrib/i386"> and see postgresql-jdbc-*.rpm
<item> <url url="http://www.blackdown.org">
</itemize>
See the section - <ref id="Testing Java" name="Testing Java PostgreSQL interface">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Perl Database Interface (DBI) Driver for PostgreSQL <label id="Perl Database Interface">
-->
<sect> Perl Database Interface (DBI) Driver for PostgreSQL <label id="Perl Database Interface">
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Perl 5 interface for PostgreSQL
<p>
PERL is an acronym for 'Practical Extraction and Report Language'.
Perl is available on each and every operating system and hardware platform in the world. 
You can use
Perl on Windows95/NT, Apple Macintosh iMac, all flavors of Unix (Solaris, HPUX, AIX, Linux, Irix, SCO etc..),
mainframe MVS, desktop OS/2, OS/400, Amdahl UTS and many others. 
Perl runs <bf>EVEN</bf> on many unpopular or generally-unknown operating systems and hardware!!
So do not be surprised if you see perl running on a very rarely used operating system.
You can imagine the vast extent of the user base and developer base of Perl.

Perl interface for PostgreSQL is included in the distribution of PostgreSQL. Check in src/pgsql_perl5 directory.
<itemize>
<item> Pgsql_perl5 contact Email: 
       <htmlurl url="mailto:E.Mergl@bawue.de"
             name="E.Mergl@bawue.de">
<item> Another source from -
<url url="ftp://ftp.kciLink.com/pub/PostgresPerl-1.3.tar.gz">
<item> Perl Home page : <url url ="http://www.perl.com/perl/index.html">
<item> Perl tutorial, look for Tutorial title at : <url url="http://reference.perl.com/">
<item> Perl FAQ is at : <url url="http://www.yahoo.com/Computers_and_Internet/Programming_Languages/Perl/">
<item> Perl GUI User Interfaces Perl-Qt rpm : <url url="ftp://ftp.redhat.com/pub/contrib/i386"> 
and look for PerlQt-1.06-1.i386.rpm
<item> Perl GUI User Interfaces Perl-Qt : <url url ="http://www.accessone.com/~jql/perlqt.html">
<item> Perl GUI User Interfaces Perl-XForms : <url url="ftp://ftp.redhat.com/pub/contrib/i386"> and look for Xforms4Perl-0.8.4-1.i386.rpm
<item> Perl GUI User Interfaces Perl-Tk : <url url="ftp://ftp.redhat.com/pub/contrib/i386">
<item> Perl GUI kits : <url url="http://reference.perl.com/query.cgi?ui">
<item> Perl Database Interfaces : <url url="http://reference.perl.com/query.cgi?database">
<item> Perl to "C" translator : <url url="http://www.perl.com/CPAN-local/modules/by-module/B/">
and look for Compiler-a3.tar.gz
<item> Bourne shell to Perl translator : <url url="http://www.perl.com/CPAN/authors/id/MERLYN/sh2perl-0.02.tar.gz">
<item> awk to Perl a2p and sed to Perl s2p is included with the PERl distribution.
<item> See also the newsgroups for PERL at comp.lang.perl.*
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Perl Database Interface DBI
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2> WHAT IS DBI ?
<p>
The Perl Database Interface (DBI) is a database access Application Programming Interface (API) for the Perl Language. The
Perl DBI API specification defines a set of functions, variables and conventions that provide a consistent database interface
independent of the actual database being used. 
<itemize>
<item> DBI FAQ author Descartes Hermetica is at <htmlurl url="mailto:descarte@hermetica.com"
	       name="descarte@hermetica.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2> DBI driver for PostgreSQL DBD-Pg-0.89
<p>
Get DBD-Pg-0.89.tar.gz from below
<itemize>
<item> DBD-Pg-0.89 : <url url="http://www.perl.com/CPAN/modules/by-module/DBD/">
<item> Comprehensive Perl Archive Network CPAN <url url="http://www.perl.com/CPAN">
<item> DBI drivers list and DBI module pages <url url="http://www.hermetica.com/technologia/perl/DBI">
<item> DBI information is at <url url="http://www.fugue.com/dbi/">
<item> Primary ftp site <url url="ftp://ftp.demon.co.uk/pub/perl/db">
<item> Miscellaneous DBI link <url url="http://www-ccs.cs.umass.edu/db.html">
<item> Miscellaneous DBI link <url url="http://www.odmg.org/odmg93/updates_dbarry.html">
<item> Miscellaneous DBI link <url url="http://www.jcc.com/sql_stnd.html">
<item> PostgreSQL database <url url="http://www.postgresql.org">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Technical support for DBI
<p>
<itemize>
<item> Send comments and bug-reports to 
and include the output of perl -v, and perl -V, the version of PostgreSQL,
the version of DBD-Pg, and the version of DBI in your bug-report.
<htmlurl url="mailto:E.Mergl@bawue.de"
             name="E.Mergl@bawue.de">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>What is DBI, DBperl, Oraperl and *perl?
<p>
To quote Tim Bunce, the architect and author of DBI:

    ``DBI is a database access Application Programming Interface (API)
      for the Perl Language. The DBI API Specification defines a set
      of functions, variables and conventions that provide a consistent
      database interface independent of the actual database being used.''

In simple language, the DBI interface allows users to access multiple
database types transparently. So, if you connecting to an Oracle, Informix,
mSQL, Sybase or whatever database, you don't need to know the underlying
mechanics of the 3GL layer. The API defined by DBI will work on all these
database types.

A similar benefit is gained by the ability to connect to two different
databases of different vendor within the one perl script, ie, I want to read
data from an Oracle database and insert it back into an Informix database
all within one program. The DBI layer allows you to do this simply and
powerfully.

<!-- 
	************ Begin New page pagebreak here ***************
-->
Here's a list of DBperl modules, their corresponding DBI counterparts and
support information. DBI driver queries should be directed to the dbi-users mailing
list.
<tscreen><verb>
    Module Name Database Required   Author          DBI
    ----------- -----------------   ------          ---
    Sybperl     Sybase              Michael Peppler DBD::Sybase
				    <mpeppler@datamig.com>
				    http://www.mbay.net/~mpeppler
    Oraperl     Oracle 6 & 7        Kevin Stock     DBD::Oracle
                                    <dbi-users@fugue.com>
    Ingperl     Ingres              Tim Bunce &     DBD::Ingres
                                    Ted Lemon
                                    <dbi-users@fugue.com>
    Interperl   Interbase           Buzz Moschetti  DBD::Interbase
                                    <buzz@bear.com>
    Uniperl     Unify 5.0           Rick Wargo      None
                                    <rickers@coe.drexel.edu>
    Pgperl      Postgres            Igor Metz       DBD::Pg
                                    <metz@iam.unibe.ch>
    Btreeperl   NDBM                John Conover    SDBM?
                                    <john@johncon.com>
    Ctreeperl   C-Tree              John Conover    None
                                    <john@johncon.com>
    Cisamperl   Informix C-ISAM     Mathias Koerber None
                                    <mathias@unicorn.swi.com.sg>
    Duaperl     X.500 Directory     Eric Douglas    None
                User Agent
</verb></tscreen>
However, some DBI modules have DBperl emulation layers, so, DBD::Oracle
comes with an Oraperl emulation layer, which allows you to run legacy
oraperl scripts without modification. The emulation layer translates the
oraperl API calls into DBI calls and executes them through the DBI switch.

<!-- 
	************ Begin New page pagebreak here ***************
-->
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2> DBI specifications
<p>
There are a few information sources on DBI.
<itemize>
<item> DBI Specification <url url="http://www.hermetica.com/technologia/perl/DBI/doc/dbispec">
</itemize>
POD documentation
     PODs are chunks of documentation usually embedded within perl programs
     that document the code ``in place'', providing a useful resource for
     programmers and users of modules. POD for DBI and drivers is beginning
     to become more commonplace, and documentation for these modules can be
     read with the following commands.

<code>
The POD for the DBI Specification can be read with the command 
	$ perldoc DBI

Users of the Oraperl emulation layer bundled with DBD::Oracle, may
read up on how to program with the Oraperl interface by typing:
	$ perldoc Oraperl

Users of the DBD::mSQL module may read about some of the private
functions and quirks of that driver by typing:
	$ perldoc DBD::mSQL

The Frequently Asked Questions is also available as
POD documentation. Read this by typing:
	$ perldoc DBI::FAQ

POD in general - Information on writing POD, and on the philosophy of POD in
general, can be read by typing:
	$ perldoc perlpod
</code>
          Users with the Tk module installed may be interested to learn
          there is a Tk-based POD reader available called tkpod, which
          formats POD in a convenient and readable way.

See also -
<itemize>
<item> Information from DBI mailing lists <url url="http://www.hermetica.com/technologia/perl/DBI/tidbits">
<item> DBI Perl Journal website <url url="http://www.tpj.com">
<item> ``DBperl'' This article, published in the 
November 1996 edition of ``Dr. Dobbs Journal''.
<item> ``The Perl5 Database Interface''
     a book to be written by Alligator Descartes 
     and published by O'Reilly and Associates.
</itemize>

The mailing lists that users may participate in are:
<itemize>
<item> Mailing lists <url url="http://www.fugue.com/dbi">
<item> <bf>dbi-announce</bf>
Email: <htmlurl url="mailto:dbi-announce-request@fugue.com"
		       name="dbi-announce-request@fugue.com">
	      with a message body of 'subscribe'
<item> <bf>dbi-dev</bf>
          For developers 
Email: <htmlurl url="mailto:dbi-dev-request@fugue.com"
		       name="dbi-dev-request@fugue.com">
	      with a message body of 'subscribe'

<item> <bf>dbi-users</bf> general discussion 
Email: <htmlurl url="mailto:dbi-users-request@fugue.com"
		       name="dbi-users-request@fugue.com">
	      with a message body of 'subscribe'
<item> US Mailing List Archives <url url="http://outside.organic.com/mail-archives/dbi-users/">
<item> European Mailing List Archives <url url="http://www.rosat.mpe-garching.mpg.de/mailing-lists/PerlDB-Interest">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Compilation problems or "It fails the test"
<p>
If you have a core dump, try the Devel::CoreStack module for
generating a stack trace from the core dump.
Devel::CoreStack can be found on CPAN at:
<itemize>
<item>              <url url="http://www.perl.com/cgi-bin/cpan_mod?module=Devel::CoreStack">
</itemize>

Email the dbi-users Mailing List stack trace, module versions, perl version, test cases,
operating system versions and any other pertinent information.
The more information you send, the quicker developers can track
problems down.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Is DBI supported under Windows 95 / NT platforms?
<p>
The DBI and DBD::Oracle Win32 ports are now a standard part of DBI, so,
downloading DBI of version higher than 0.81 should work fine. 
You can access Microsoft Access and SQL-Server databases from DBI via ODBC.
Supplied with DBI-0.79 (and later) is an experimental DBI 'emulation
layer' for the Win32::ODBC module. It's called DBI::W32ODBC.
You will need the Win32::ODBC module.
<itemize>
<item> Win32 DBI   <url url="http://www.hermetica.com/technologia/perl/DBI/win32">
<item> Win32 ODBC   <url url="http://www.roth.net">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Is DBI any use for CGI programming?
<p>
In a word, yes! DBI is hugely useful for CGI programming! In fact,
CGI programming is one of two top uses for DBI.

DBI confers the ability to CGI programmers to power WWW-fronted databases to
their users, which provides users with vast quantities of ordered data to
play with. DBI also provides the possibility that, if a site is receiving
far too much traffic than their database server can cope with, they can
upgrade the database server behind the scenes with no alterations to the CGI
scripts.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How do I get faster connection times with DBD Oracle and CGI?
<p>
The Apache httpd maintains a pool of httpd children to service client
requests.
Using the Apache mod_perl module by Doug MacEachern, the perl interpreter is
embedded with the httpd children. The CGI, DBI, and your other favorite
modules can be loaded at the startup of each child. These modules will not
be reloaded unless changed on disk.
For more information on Apache, see the Apache Project's WWW site:
<itemize>
<item> Apache Project WWW site <url url="http://www.apache.org">
<item> Mod_perl module <url url="http://www.perl.com/cgi-bin/cpan_mod?module=mod_perl">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How do I get persistent connections with DBI and CGI?
<p>
Using Edmund Mergl's Apache::DBI module, database logins are stored in a
hash with each of these httpd child. If your application is based on a
single database user, this connection can be started with each child.
Currently, database connections cannot be shared between httpd children.
Apache::DBI can be downloaded from CPAN via:
<itemize>
<item>    <url url="http://www.perl.com/cgi-bin/cpan_mod?module=Apache::DBI">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>``When I run a perl script from the command line, it works, but, when I run it under the httpd, it fails!'' Why?
<p>
Basically, a good chance this is occurring is due to the fact that the user
that you ran it from the command line as has a correctly configured set of
environment variables, in the case of DBD::Oracle, variables like
$ORACLE_HOME, $ORACLE_SID or TWO_TASK.
The httpd process usually runs under the user id of nobody, which implies
there is no configured environment. Any scripts attempting to execute in
this situation will correctly fail.
To solve this problem, set the environment for your database in a BEGIN ( )
block at the top of your script. This will solve the problem.
Similarly, you should check your httpd error logfile for any clues, as well
as the ``Idiot's Guide To Solving Perl / CGI Problems'' and ``Perl CGI
Programming FAQ'' for further information. It is unlikely the problem is
DBI-related. Read BOTH these documents carefully!
<itemize>
<item> Guide to Solving Perl CGI problems <url url="http://www.perl.com/perl/faq/index.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Multi-threading with DBI?
<p>
For some OCI example code for Oracle that has multi-threaded SELECT
statements, see:
<itemize>
<item>    <url url="http://www.hermetica.com/technologia/oracle/oci/orathreads.tar.gz">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How can I invoke stored procedures with DBI?
<p>
Assuming that you have created a stored procedure within the target
database, eg, an Oracle database, you can use $dbh->do to immediately
execute the procedure. For example,

    $dbh->do( "BEGIN someProcedure END" );
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How can I get return values from stored procedures with DBI?
<p>
Remember to perform error checking, though!
<tscreen><verb>
    $sth = $dbh->prepare( "BEGIN foo(:1, :2, :3); END;" );
    $sth->bind_param(1, $a);
    $sth->bind_param_inout(2, \$path, 2000);
    $sth->bind_param_inout(3, \$success, 2000);
    $sth->execute;
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How can I create or drop a database with DBI?
<p>
Database creation and deletion are concepts that are entirely too abstract
to be adequately supported by DBI. For example, Oracle does not support the
concept of dropping a database at all! Also, in Oracle, the database server
essentially is the database, whereas in mSQL, the server process runs
happily without any databases created in it. The problem is too disparate to
attack.
Some drivers, therefore, support database creation and deletion through the
private func methods. You should check the documentation for the drivers you
are using to see if they support this mechanism.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>How are NULL values handled by DBI?
<p>
NULL values in DBI are specified to be treated as the value undef. NULLs can
be inserted into databases as NULL, for example:
<tscreen><verb>
    $rv = $dbh->do( "INSERT INTO table VALUES( NULL )" );
</verb></tscreen>
but when queried back, the NULLs should be tested against undef. This is
standard across all drivers.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>What are these func methods all about?
<p>
The func method is defined within DBI as being an entry point for
database-specific functionality, eg, the ability to create or drop
databases. Invoking these driver-specific methods is simple, for example, to
invoke a createDatabase method that has one argument, we would write:
<tscreen><verb>
    $rv = $dbh->func( 'argument', 'createDatabase' );
</verb></tscreen>
Software developers should note that the func methods are non-portable
between databases.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Commercial Support and Training
<p>
<bf>PERL CLINIC : </bf>
     The Perl Clinic can arrange commercial support contracts for Perl, DBI,
     DBD::Oracle and Oraperl. Support is provided by the company with whom
     Tim Bunce, author of DBI, works. For more information on their
     services, please see :
<itemize>
<item>         <url url="http://www.perl.co.uk/tpc">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Testing Perl interface 
<p>
See the section - <ref id="Testing Perl" name="Testing Perl PostgreSQL interface">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> PostgreSQL Management Tools
-->
<sect> PostgreSQL Management Tools
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> PGACCESS - A GUI Tool for PostgreSQL Management
<p>
PgAccess is a Tcl/Tk interface to PostgreSQL.
It is already included in the distribution of PostgreSQL.
You may want to check out this web site for a newer copy
<itemize>
<item> <url url="http://www.flex.ro/pgaccess">
<item> If you have any comment, suggestion for improvements, e-mail to :
       <htmlurl url="mailto:teo@flex.ro"
		name="teo@flex.ro">
</itemize>
Usage of pgaccess -
<code>
# man xhost
# xhost +
# su - postgres
bash$ man pgaccess
bash$ export DISPLAY=<hostname>:0.0
bash$ pgaccess mydatabase
</code>

Features of PgAccess

PgAccess windows - Main window, Table builder,
Table(query) view, Visual query builder.

Tables
<itemize>
<item>opening tables for viewing, max 200 records (changed by preferences menu)
<item>column resizing, dragging the vertical grid line (better in table space
rather than in the table header)
<item>text wrap in cells - layout saved for every table
<item>import/export to external files (SDF,CSV)
<item>filter capabilities (enter filter like (price>3.14)
<item>sort order capabilities (enter manually the sort field(s))
<item>editing in place
<item>improved table generator assistant
<item>improved field editing
</itemize>

Queries
<itemize>
<item>define , edit and stores "user defined queries"
<item>store queries as views
<item>execution of queries
<item>viewing of select type queries result
<item>query deleting and renaming
<item>Visual query builder with drag & drop capabilities. For any of
you who had installed the Tcl/Tk plugin for Netscape Navigator, you can see
it at work clicking here
</itemize>

Sequences
<itemize>
<item>defines sequences, delete them and inspect them
Functions
<item>define, inspect and delete functions in SQL language
</itemize>

Future implementation will have
<itemize>
<item>table design (add new fields, renaming, etc.)
<item>function definition
<item>report generator
<item>basic scripting
</itemize>

INFORMATION ABOUT LIBGTCL

You will need the PostgreSQL to Tcl interface library libgtcl, lined as a
Tcl/Tk 'load'-able module. The libpgtcl and the source is located
in the PostgreSQL directory /src/interfaces/libpgtcl. Specifically, you
will need a libpgtcl library that is 'load'-able from Tcl/Tk. This is
technically different from an ordinary PostgreSQL loadable object file,
because libpgtcl is a collection of object files. Under Linux, this is
called libpgtcl.so.
You can download from the above site a version already compiled for Linux i386
systems. Just copy libpgtcl.so into your system library director (/usr/lib). 
One of the solutions is to remove from the source the line
containing load libpgtcl.so and to load pgaccess.tcl not with wish, but
with pgwish (or wishpg) that wish that was linked with libpgtcl library.

If you get crypt not found during compilation pgaccess source tree then use -lcrypt.

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Windows Interactive Query Tool for PostgreSQL (WISQL or MPSQL)
<p>
MPSQL provides users with a graphical SQL interface to PostgresSQL. 
MPSQL is similar to Oracle's SQL Worksheet and Microsoft SQL Server's query tool WISQL.
It has nice GUI and has history of commands. Also you can cut and paste and it has other nice features to improve your productivity.
<itemize>
<item> <url url="http://www.troubador.com/~keidav/index.html">
<item> Email:
       <htmlurl url="mailto:keidav@whidbey.com"
             name="keidav@whidbey.com">
<item> <url url="http://www.ucolick.org/~de/"> in file tcl_syb/wisql.html
<item> <url url="http://www.troubador.com/~keidav/index.html">
<item>Email: 
       <htmlurl url="mailto:de@ucolick.org"
             name="de@ucolick.org">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Interactive Query Tool (ISQL) for PostgreSQL called PSQL
<p>
ISQL is for character command line terminals.
This is included in the distribution, and is called "psql". Very similar to 
Sybase ISQL, Oracle SQLplus. At unix prompt give command 'psql' which will put you in psql&gt prompt. 
<tscreen><verb>
bash# su - postgres
bash$ man psql
bash$ psql mydatabase
Type \h to see help of commands.
</verb></tscreen>
Very user friendly and easy to use.
Can also be accessed from shell scripts.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> MPMGR - A Database Management Tool for PostgresSQL
<p>
MPMGR will provide a graphical management interface for PostgresSQL. You can find
it at
<itemize>
<item> <url url="http://www.mutinybaysoftware.com/">
<item> Email:
       <htmlurl url="mailto:keidav@mutinybaysoftware.com"
             name="keidav@mutinybaysoftware.com">
<item> <url url="http://www.troubador.com/~keidav/index.html">
<item> Email:
       <htmlurl url="mailto:keidav@whidbey.com"
             name="keidav@whidbey.com">
<item> <url url="http://www.ucolick.org/~de"> in file tcl_syb/wisql.html
<item> WISQL for PostgreSQL <url url="http://www.ucolick.org/~de/Tcl/pictures">
<item>Email: 
       <htmlurl url="mailto:de@ucolick.org"
             name="de@ucolick.org">
</itemize>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>CPUs for PostgreSQL
-->
<sect>CPUs for PostgreSQL
<p>
The following CPUs (both 64-bit and 32-bit) are available for PostgreSQL. All these
CPUs run Linux.
<itemize>
<item> GNU/GPL Freedom 64-bit F-CPU  <url url="http://f-cpu.tux.org">
<item> Russian E2k 64-bit CPU (The world's fastest CPU as of June, 2000 ???!!!)
   website : <url url="http://www.elbrus.ru/roadmap/e2k.html">
   Elbrus is now partnered (alliance) with Sun Microsystems of USA
<item> Korean CPU from Samsung 64-bit CPU original from DEC Alpha
    <url url="http://www.samsungsemi.com">
   Alpha-64bit CPU is at <url url="http://www.alpha-processor.com">
   Now there is collaboration between Samsumg, Compaq of USA on Alpha CPU
<item> Intel IA 64 <url url="http://developer.intel.com/design/ia-64">
<item> Transmeta crusoe CPU and in near future Transmeta's 64-bit CPU
<item> Sun Ultra-sparc 64-bit CPU  
<item> Silicon Graphics MIPS Architecture CPUs <url url="http://www.sgi.com/processors">
<item> IBM Power PC (motorola) <url url="http://www.motorola.com/SPS/PowerPC/index.html">
<item> Seimens Pyramid CPU from Pyramid Technologies
<item> Intel X86 series 32-bit CPUs Pentiums, Celeron etc..
<item> AMDs X86 series 32-bit CPUs K-6, Athlon etc..
<item> National's Cyrix X86 series 32-bit CPUs Cyrix etc..
<item> European Space Agency's ESA-32bit and ESA-64bit CPUs
<item> Other CPUs from other countries ?? Let me know...
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Setting up multi-boxes PostgreSQL with just one monitor
-->
<sect> Setting up multi-boxes PostgreSQL with just one monitor
<p>
If you do want to spend money on hardware switches than
you can <bf>use VNC (Virtual Network Computing) Technology</bf> from the telecom 
giant AT &amp T. VNC is GPLed and is a free software. Using VNC you can run 
PostgreSQL programs on computers without monitors and display on remote boxes with
monitors!! But the boxes must be connected via ethernet Network Interface Cards.
VNC is at <url url="http://www.uk.research.att.com/vnc">

You can stack up multiple CPU-boxes and connect to just one monitor and use 
the KVM (Keyboard, Video, Monitor) switch box to select the host. 
This saves space and avoids a lot of clutter and also eliminates monitor, 
keyboard and the mouse (saving anywhere from 100 to 500 US dollars per set).

Using this switch box, you can stack up many PostgreSQL servers (development, 
test, production), Web servers,
ftp servers, Intranet servers, Mail servers, News servers in a tower shelf. The switch box
can be used for controlling Windows 95/NT or OS/2 boxes as well.

Please check out these sites:
<itemize>
<item> DataComm Warehouse Inc at 1-800-328-2261. They supply all varieties of 
computer hardware <url url="http://www.warehouse.com"> 4-port Manual KVM switch (PS/2) is about $89.99 Part No. DDS1354
<item> Network Technologies Inc <url url="http://www.networktechinc.com/servswt.html"> (120 dollars/PC 8 ports) which lists 
'Server Switches' and 'Video only switches'
<item> Scene Double Inc, England <url url="http://www.scene.demon.co.uk/qswitch.htm">
<item> Cybex corporation <url url="http://www.cybex.com">
<item> Raritan Inc <url url="http://www.raritan.com">
<item> RealStar Solutions Inc <url url="http://www.real-star.com/kvm.htm">
<item> Belkin Inc <url url="http://www.belkin.com">
<item> Better Box Communications Ltd. <url url="http://www.betterbox.com/info.html">
<item> Go to nearest hardware store and ask for "Server Switch" also known as "KVM Auto Switches".
</itemize>

Search engine yahoo to find more companies with "Server Switches" or 
"KVM Switches".

It is strongly recommended to have a dedicated unix box for each PostgreSQL data-server for 
better performance. No other application program/processes should run on this
box. See the Business section of your local newspapers for local vendors selling 
only intel box, 13" monochrome monitor (very low cost monitor). Local vendors
sell just the hardware <bf>without</bf> any Microsoft Windows/DOS.
You do not need a color monitor for the database server, as you can do
remote administration from color PC workstation. 

You can buy bare-bone computer hardware from online stores. You can get good
rates in "Online Auctions"
<itemize>
<item>Online store and auction hall <url url="http://www.egghead.com">
<item>Online store <url url="http://www.buy.com">
<item>Bidding store <url url="http://www.ubid.com">
</itemize>

Get RedHat (or some other distribution of) Linux cdrom from below -
<itemize>
<item>Linux System Labs Web site:  <url url="http://www.lsl.com/">  7 (U.S. dollars)
<item>Cheap Bytes Inc Web site:  <url url="http://www.cheapbytes.com/"> 7 (U.S. dollars)
</itemize>
Make sure that the hardware you purchase is supported by Redhat Linux. Check the ftp site of 
Redhat for recommended hardware like SCSI adapters, video cards before buying.
For just &dollar 600 you will get a powerful intel box with Redhat Linux running
PostgreSQL.
Use odbc/jdbc/perl/tcl to connect to PostgreSQL from Windows95, OS/2, Unix Motif or web browser (e.g. Redbaron, Opera, Netscape, 20 others). 
(Web browsers are very fast becoming the standard GUI client).

Using KVM switch you can control many cpu boxes by just one monitor and one keyboard!
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Web-Application-Servers for PostgreSQL
-->
<sect>Web-Application-Servers for PostgreSQL
<p>
Several Web-Application-Servers work with PostgreSQL both open-source and
commercial versions. The popular open-source Web-Application-Servers are
Enhydra and Zope and commercial Web-Application-Servers are IBM Websphere,
BEA Weblogic.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Lutris Corp "Enhydra" <label id="Enhydra">
<p>
Enhydra supports PostgreSQL database.
Enhydra is a immensely popular Java/XML Web-Application-Server created by 'Lutris Corporation'. It is the world's best Java/XML Web-Application server.
It supports EJB, Servlets, JSP, JNDI, JDBC, JTA, CORBA, XMLC/Rocks, DODS
and internationalization.
It is written in 100% pure Java and is available from
<url url="http://www.enhydra.org">. Enhydra is a open source code project but is
commercially sold and supported by Lutris Corp. Visit
<url url="http://www.lutris.com">

You would use Borland Corp's JBuilder along with Enhydra. JBuilder is at
<url url="http://www.inprise.com">

See also Enterprise Java HOWTO at 
<url url="http://www.linuxdoc.org/HOWTO/Enterprise-Java-for-Linux-HOWTO.html">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Zope <label id="Zope">
<p>
Python is becoming immensely popular "pure" object-oriented scripting language.
Zope is a Web-Application server and provides interfaces to PostgreSQL.
Zope is available at <url url="http://www.zope.org">
Python is at <url url="http://www.python.org">
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Applications and Tools for PostgreSQL
-->
<sect>Applications and Tools for PostgreSQL
<p>
<sect1>PostgreSQL 4GL for web database applications - AppGEN Development System
<p>
AppGEN can be downloaded from 
<itemize>
<item> <url url="http://www.man.ac.uk/~whaley/ag/appgen.html">
<item> <url url="ftp://ftp.mcc.ac.uk/pub/linux/ALPHA/AppGEN">.
</itemize>
AppGEN is a high level fourth generation language and application generator for producing World Wide Web (WWW) based
applications. These applications are typically used over the internet or within a corporate intranet. AppGEN applications are
implemented as C scripts conforming to the Common Gateway Interface (CGI) standard supported by most Web Servers. 
     
To use AppGEN you will need the following :- 
      
      PostgresSQL, relational database management system 
      
      A CGI compatible web server such as NCSA's HTTPD 
      
      An ansi C compiler such as GCC 

AppGEN consists of the following Unix (Linux) executables :-

<itemize>
<item>      defgen, which produces a basic template application from a logical data structure. The applications are capable of adding, updating, deleting and searching for records within the database whilst automatically maintaining referential integrity. 
      
<item>      appgen, the AppGEN compiler which compiles the appgen source code into CGI executable C source and HTML formatted documents ready for deployment on a web server. 
      
<item>      dbf2sql, a utility fo converting dBase III compatible .dbf files into executable SQL scripts. This enables data stored in most DOS/Windows based database packages to be migrated to a SQL server such as PostgresSQL. 

<item>In addition, AppGEN comprises of a collection of HTML documents, GIF files and Java applets which are used at runtime by the system. And of course, like all good software, the full source code is included. 
</itemize>
 
      The author, Andrew Whaley, can be contacted on 
<itemize>
<item>       <htmlurl url="mailto: andrew@arthur.smuht.nwest.nhs.uk"
             name="andrew@arthur.smuht.nwest.nhs.uk">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************



-->
<sect1>WWW Web interface for PostgresSQL - DBENGINE
<p>
dbengine a plug 'n play Web interface for PostgreSQL created by Ingo Ciechowski. It
is at
<itemize>
<item>  <url url="http://www.cis-computer.com/software/dbengine">
</itemize>
<bf>About DBENGINE : </bf>
dbengine is an interface between the WWW and Postgres95 which provides
simple access to any existing database within just a few minutes.

PHP gives you a Perl like language in your documents, but no real
Perl while AppGen and wdb-p95 require that you create some configuration
file for each of your databases -- sound's like you'll first of all have to
learn some sort of new meta language before you can get started.

Unlike other tools you don't have to learn any special programming or
scripting language to get started with dbengine. Also there's no
configuration file for each database, so you don't have to get familiar
with such a new structure.
However - in case you want to gain access to the full features of dbengine
it'd be a good idea to know the Perl language.

The whole system can be configured by simple manipulations of an additional
database that contains closer information about how to visualize your
database access.
You can even specify virtual Fields which are calculated on the fly right
before they're displayed on the screen.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1>Apache Webserver Module for PostgreSQL - NeoSoft NeoWebScript
<p>
Apache is a well-known Web Server. And a module to interface PostgreSQL to Apache Webserver is at -
<itemize>
<item>  <url url="http://www.neosoft.com/neowebscript/">
</itemize>
NeoWebScript is a programming language that allows both
simple and complex programs to be embedded into HTML files. 

When an HTML page containing embedded NeoWebScript is
requested, the NeoWebScript-enabled webserver executes the
embedded script(s), producing a webpage containing customized
content created by the program. 

NeoWebScript is a fast, secure, easy to learn way to do powerful,
server-based interactive programming directly in the HTML code in
web pages. With NeoWebScript, counters, email forms, graffiti
walls, guest books and visitor tracking are all easy, even for a
beginning programmer. See how well NeoWebScript holds its'
own vs. PERL and JavaScript. 

If you'd like to install NeoWebScript on your webserver, your
Webmaster needs to read our Sysop FAQ to get started. Theory of
Operations will explain how NeoWebScript works, while
installation will take them through the steps. Management deals with
configuration issues and running the server, tests let you verify correct
NeoWebScript operation, and troubleshooting deals with server
problems. 

There is no cost to you to use
NeoWebScript-2.2 for your ISP, your intranet, or your extranet.
You'll see a full license when you register to download, but it costs 
 &dollar 99 if you want to embed it in your own
product or use it in a commerce (eg. SSL) server. 

NeoWebScript is a module for the Apache webserver that allows
you to embed the Tcl/Tk programming language in your webpages as
a scripting tool. It was invented by Karl Lehenbauer, NeoSoft's
Chief Technical Officer, and documented, enhanced and extended
by NeoSoft's programmers and technical writers. 

The Apache webserver is the world's most popular webserver,
accounting for 68 &percnt of the sites polled.

Tcl/Tk is the powerful, free, cross-platform scripting language
developed by Dr. John Ousterhout. In his own words 

"Tcl/Tk lets software developers get the job done ten
times faster than with toolkits based on C or C++. It's
also a great glue language for making existing
applications work together and making them more
graphical and Internet-aware."

Karl Lehenbauer, Founder and Chief Technical Officer of NeoSoft,
has been part of Tcl/Tk development from the very beginning.
Together with Mark Diehkans, they authored Extended Tcl, also
known as TclX or NeoSoft Tcl, a powerful set of extensions to the
language. Many of the current core Tcl commands originated in
Extended Tcl, and were then imported into the core language by Dr.
Ousterhout. 

NeoSoft Inc., 1770 St. James Place, Suite 500, Houston, TX 77056 USA
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> HEITML server side extension of HTML and a 4GL language for PostgreSQL
<p>
          Tool heitml is another way to interface postgres 
          with the world wide web. 
For more details contact 
<tscreen><verb>
          Helmut Emmelmann H.E.I. Informationssyteme GmbH 
          Wimpfenerstrasse 23 Tel. 49-621-795141 
          68259 Mannheim Germany Fax. 49-621-795161 
</verb></tscreen>
<itemize>
<item>   E-mail Mr.Helmut Emmelmann at <htmlurl url="mailto: emmel@h-e-i.de"
          name="emmel@h-e-i.de">
<item> Heitml main web site <url url="http://www.heitml.com">
<item> Heitml secondary web site <url url="http://www.h-e-i.deom">
</itemize>

          heitml is a server side extension of HTML and a 4GL language 
          at the same time. People can write web applications 
          in the HTML style by using new HTML-like tags. 

          heitml (pronounced "Hi"-TML) is an extension of HTML and a 
          full-featured 4th generation language that enables 
          Web-based Applications to interact with data stored in SQL 
          databases, without resorting to complex CGI scripts. 

          heitml extends HTML on the sever side, dynamically 
          converting ".hei" files to HTML format and so is 
          compatible with any web browser.It embraces the familiar, 
          easy-to-use HTML syntax and provides a large assortment of 
          pre-developed Tags and Libraries to take care of tasks 
          that formerly required CGI. As XML, heitml provides user 
          defined tags. With heitml the user defined markup can 
          be translated to HTML and send to a browser. 

          heitml targets both HTML designers and professional 
          programmers alike. HTML designers can use heitml Tags to 
          build dynamic web pages, access SQL databases, or create 
          complete web applications. Counters, registration 
          databases, search forms, email forms, or hierarchical 
          menues can all be created simply by using the 
          pre-developed HTML-like Tags found in the many Component 
          Libraries. 

          For programmers heitml embeds a complete forth generation 
          language in HTML 
<tscreen><verb>
	  (e.g. <if>, <while>, and <let> Tags), 
</verb></tscreen>
          plus powerful expression evaluation with integer, real, 
          boolean, string, and tuple data types. Tuples have 
          reference semantics as in modern object oriented languages 
          and are stored on a heap. heitml variables including all 
          complex data structures stored on the heap maintain their 
          values between pages using the Session Mode. It is 
          possible to define your own tags or environment tags and 
          even re-define HTML-tags. 

          heitml makes it possible to 

          - - - develop Web Sites in a structured and modular way, 
          drastically reducing maintenance overhead. 

          - - - develop intelligent and interactive Web Sites, with 
          content that dynamically adapts itself to user needs. 

          - - - show the content of SQL databases with no programming 
          other than to use our library of prefined "dba" Tags. 

          - - - develop complex database and Catalog Shopping applications 
          using Session Variables 

          heitml runs on Linux with any Web Server using the CGI 
          interface, and is especially fast (avoiding the CGI 
          overhead) within the APACHE Web Server using the apache API. Currently MSQL 
          (Version 1 and 2), PostgreSQL (Version 6), mysql, 
          and the yard databases are supported). heitml also 
          works on Linux, BSDi, Solaris and SunOS, as well as 
          Windows NT with CGI and ISAPI and ODBC and Windows 95. 

          heitml (on linux) is free for research, non-commercial and 
          private usage. Commercial Web Sites must pay a licensing 
          fee. The fully operational version of heitml is available 
          for a trial period downloaded freely. (Note, however, that 
          each ".hei" Web Page you develop will display a message 
          identifying it as the version for non-commercial 
          use. After registration, you will receive a key to switch 
          off the message without having to re-install the program.) 

heitml (pronounced "Hi"-TML) significantly extends
and enhances the functionality of HTML by definable
tags and full programming features. This makes
dynamic content and database applications possible
simply within the HTML world, without CGI and without
external scripting or programming languages.
This means you, as an HTML author, can embed
applications in your web pages, simply by using some
new tags without CGI and without programming. As an
advanced user or programmer on the other hand you can
create and program powerful tag libraries. This
approach makes heitml suitable for HTML newcomers and
professional programmers alike.
heitml runs on the web server and dynamically
generates HTML, so heitml is compatible with the
internet standards and with any web browser. It
allows full access to databases while shielding the
user from any unneccessary CGI complexity. heitml has
been developed according to the newst research and
in compiler construction and transaction
systems.

heitml pages are developed just the same way as HTML
pages, with a text editor or HTML editor, and placed
on the web server as usual. However now pages can
contain dynamic heitml tags and access tag libraries.
You can use these tags to access the database, to
create dynamic content, to send emails, and even to
create powerful applications like registration
databases and shopping systems.

HTML newcomers and professional programmers alike
will be amazed at how quickly and easily they can
design exciting applications like our Interactive
Guestbook without resorting to complex and difficult
to learn CGI scripts, simply by using the tools
provided in our dba Library.

heitml is accompanied by a wide range of tag
libraries, to create guestbooks, database maintenance
applications, extensible query forms, powerful email
forms or structure your web site using a hierarchic
menu. These tools are ready to go, just add the
corresponding tags to your web site.

As an experienced programmer you can make fully use
of the heitml persistent dynamic tuple architecture :
heitml is not just a scripting language with dynamic
typing, full power expression evaluation, recursive
procedures and extensive parameter passing features,
but it also features persistent dynamic tuples to
automatically keep session data of any size.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1>America On-line AOL Web server for PostgreSQL
<p>
The no-cost commercial webserver, AOLserver supports database connections to PostgreSQL
for more information see
<itemize>
<item> AOL Web Server home <url url="http://www.aolserver.com">
<item>	Introduction to AOLserver by Philip Greenspun
<url url="http://photo.net/wtr/aolserver/introduction-1.html">
</itemize>
	AOLserver is a fast, fully multithreaded, Tcl enabled webserver. But
not only that, it is a complete database-backed web development
platform.
	With AOLserver you can have multiple pooled connections to PostgreSQL
(and other RBDMSs) that can be shared among different threads. AOLserver
has a Tcl and C APIs that allow you to develop powerful dynamic
websites. All this since 1995. It is licensed under the APL (AOLserver
Public License) or the GPL, thus being totally free software.
	The Tcl API is the most useful for web sites. AOLserver has a set of
powerful Tcl calls, such as ns_sendmail (to send e-mail), ns_httpget (to
fetch a URL), ns_schedule (a cron-like feature to schedule procedures to
run at specific times), etc. You can also extend AOLserver's
capabilities very easily with the Tcl API. Each AOLserver virtual server
can have its own "library" of private Tcl scripts that are parsed by
AOLserver and become accessible to any page within that virtual server.
	You can develop pages for AOLserver in three ways: 
	- Plain HTML
	- .tcl pages -- these are tcl programs that can return HTML via the
ns_write call.
	- .adp pages -- AOL Dynamic Pages. You develop your pages in plain HTML
but you can scape to Tcl code by using <% %> or <%= %> much alike PHP or
ASP.
	While AOLserver is a great webserver with a superb architecture, where
it really shines is in database connectivity. AOLserver has its own
database abstraction layer that enables you to have it connected to
different RDBMSs without changing your code at all. The connections do
the RDBMS are pooled, persistent and are shared among different threads.
This allows for very fast connections and efficient use of resources.
	AOLserver has drivers for all major RDBMSs: PostgreSQL, Oracle, Sybase,
Informix, Illustra, Solid, Interbase, MySQL.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Problem/Project Tracking System Application Tool for PostgreSQL
<p>
This is at
<itemize>
<item>	<url url="http://www.homeport.org/~shevett/pts/">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Convert dbase dbf files to PostgreSQL
<p>
The program dbf2msql works fine with mSQL and PostgreSQL. You can find it at 
<itemize>
<item> <url url="ftp://ftp.nerosworld.com/pub/SQL/dbf2sql/">
<item> <url url="ftp://ftp.postgresql.org/pub/incoming/dbf2pg-3.0.tar.gz">
</itemize>

This program was written by Maarten Boekhold, 
Faculty of Electrical Engineering TU Delft, NL
Computer Architecture and Digital Technique section
<itemize>
<item> <htmlurl url="mailto: M.Boekhold@et.tudelft.nl"
	name="M.Boekhold@et.tudelft.nl">
</itemize>

You can also use a python method to read dbf files and load into a postgres
database.
<itemize>
<item> See <url url="http://www.python.org">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1> Convert Microsoft Access MDB database files to PostgreSQL
<p>
MDB Tools is a planned set of libraries and utilities to facilitate exporting data 
from MS Access databases (mdb files) into a multiuser database 
such as Oracle, Sybase, DB2, Informix, MySQL, Postgresql, or similar.
<itemize>
<item> Get MDB tool from <url url="http://mdbtools.sourceforge.net">
<item> Mailing list <url url="http://lists.sourceforge.net/mailman/listinfo/mdbtools-dev">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Web Database Design/Implementation tool for PostgreSQL - EARP
-->
<sect>Web Database Design/Implementation tool for PostgreSQL - EARP
<p>
<itemize>
<item> <url url="http://www.oswego.edu/Earp">
<item> <url url="ftp://ftp.oswego.edu"> in the directory 'pub/unix/earp'.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
What is EARP ?
<p>
The "Easily Adjustable Response Program" (EARP) created by David Dougherty. 
EARP is a Web Database Design/Implementation tool, built on top of the PostgreSQL database system. Its functionality includes: 

<itemize>
<item>     A Visual Design System. 
<item>     A sendmail interface. (can handle incoming and outgoing mail) 
<item>     An Enhanced Security Mechanism. 
<item>     A cgi driver. 
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Implementation
<p>
The main implementation of EARP is a CGI binary which runs under the http daemon to provide access to the database server. All of the design tools are built into the driver, no design takes place over anything but the web. The tools themselves require a graphical browser, the compatibility of objects designed with the tools is implementation independent, based on designing individuals preferences. 
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
How does it work ?
<p>
One of the main features of EARP is that it uses an Object
Oriented approach to producing html pages which interface to
the database. Most pages will consist of several objects. Each
object is produced by some sort of tool and given a name,
objects are then linked together in a callable sequence by the
page tool. Objects are also reusable across multiple pages.
Basic tools exist for HTML, Querys, Grabbing input from
forms, Extendable Formatting of Query and Input objects, and
Linking together of objects into other objects. More advanced
tools include the mail tool and the multithreaded query tool. 

Another feature of EARP is advanced security. Access to
various areas of the EARP system can be limited in a variety
of ways. To facilitate its advanced security, EARP performs
checks for each connection to the system, determining what
ids and groups the connecting agent belongs to. Access to
areas is defined seperately, and the combination decides if
access to a specific area of Earp is allowed. Moreover, all that
is required to implement the security features is an http server
that supports basic (or better) user authentication. 
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Where to get EARP ?
<p>
EARP is available via anonymous ftp from 
<itemize>
<item> <url url="ftp://ftp.oswego.edu"> in the directory 'pub/unix/earp'. 
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>PHP Hypertext Preprocessor - Server-side html-embedded scripting language for PostgreSQL 
-->
<sect>PHP Hypertext Preprocessor - Server-side html-embedded scripting language for PostgreSQL  <label id="PHP">
<p>
WWW Interface Tool is at -
<itemize>
<item> <url url="http://www.php.net">
<item> <url url="http://www.vex.net/php">
</itemize>
PHP also has a compiler called Zend which will vastly improve the performance.
First you will write your application in PHP scripting language 
during development, testing and debugging. Once the project is ready for 
deployment you will use the Zend compiler to 
compile the PHP to create executable which will run very fast.

Old name is Professional Home Pages (PHP) and new name is PHP Hypertext Pre-Processor
<itemize>
<item> Mirror sites are in many countries like www.COUNTRYCODE.php.net
<item> <url url="http://www.fe.de.php.net">
<item> <url url="http://www.sk.php.net">
<item> <url url="http://php.iquest.net/">
<item> Questions e-mail to :
	<htmlurl url="mailto:rasmus@lerdorf.on.ca"
             name="rasmus@lerdorf.on.ca">
</itemize>

PHP is a server-side html-embedded scripting language. It lets
you write simple scripts right in your .HTML files much like
JavaScript does, except, unlike JavaScript PHP is not
browser-dependant. JavaScript is a client-side html-embedded
language while PHP is a server-side language. 
PHP is similar in concept to Netscape's LiveWire Pro product. 
If you like free fast-moving software that comes
with full source code you will probably like PHP.

<itemize>
<item> The PostgreSQL support code was written by Adam Sussman
	<htmlurl url="mailto: asussman@vidya.com"
             name="asussman@vidya.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> Major Features
<p>
<itemize>
<item>Standard CGI, FastCGI and Apache module support - 
As a standard CGI program, PHP can be installed on any
Unix machine running any Unix web server. With support for
the new FastCGI standard, PHP can take advantage of the
speed improvements gained through this mechanism. As an
Apache module, PHP becomes an extremely powerful and
<bf>lightning fast</bf> alternative to CGI programmimg.

<item> Access Logging - 
With the access logging capabilities of PHP, users can
maintain their own hit counting and logging. It does not use
the system's central access log files in any way, and it
provides real-time access monitoring. The Log Viewer Script
provides a quick summary of the accesses to a set of pages
owned by an individual user. In addition to that, the package
can be configured to generate a footer on every page which
shows access information. See the bottom of this page for an
example of this.

<item> Access Control - 
A built-in web-based configuration screen handles access
control configuration. It is possible to create rules for all
or some web pages owned by a certain person which place
various restrictions on who can view these pages and how they
will be viewed. Pages can be password protected, completely
restricted, logging disabled and more based on the client's
domain, browser, e-mail address or even the referring
document.

<item> PostgresSQL Support - 
Postgres is an advanced free RDBMS. PHP supports embedding
PostgreSQL "SQL queries" directly in .html files.

<item> RFC-1867 File Upload Support - 
File Upload is a new feature in Netscape 2.0. It lets users
upload files to a web server. PHP provides the actual Mime
decoding to make this work and also provides the additional
framework to do something useful with the uploaded file once
it has been received.

<item> HTTP-based authentication control -
PHP can be used to create customized HTTP-based
authentication mechanisms for the Apache web server.

<item> Variables, Arrays, Associative Arrays - 
PHP supports typed variables, arrays and even Perl-like
associative arrays. These can all be passed from one web page
to another using either GET or POST method forms.

<item> Conditionals, While Loops - 
PHP supports a full-featured C-like scripting language.
You can have if/then/elseif/else/endif conditions as well as
while loops and switch/case statements to guide the logical
flow of how the html page should be displayed.

<item> Extended Regular Expressions - 
Regular expressions are heavily used for pattern matching,
pattern substitutions and general string manipulation. PHP 
supports all common regular expression operations.

<item> Raw HTTP Header Control - 
The ability to have web pages send customized raw HTTP
headers based on some condition is essential for high-level
web site design. A frequent use is to send a Location: URL
header to redirect the calling client to some other URL. It
can also be used to turn off cacheing or manipulate the last
update header of pages.

<item> On-the-fly GIF image creation - 
PHP has support for Thomas Boutell's GD image library
which makes it possible to generate GIF images on the fly.

<item> ISP "Safe Mode" support - 
PHP supports a unique "Safe Mode" which makes it safe to
have multiple users run PHP scripts on the same server.

<item> Many more new features are being added in newer releases of PHP.
Visit the main web site at <url url="http://www.php.net">

<item> It's Free! - 
One final essential feature. The package is completely free.
It is licensed under the GNU/GPL which allows you to use the
software for any purpose, commercial or otherwise. 
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
PHP - Brief History
<p>
PHP began life as a simple little cgi wrapper written in Perl. 
The name of this first package was Personal Home Page Tools, which
later became Personal Home Page Construction Kit.

A tool was written to easily embed SQL queries into web pages. It 
was basically another CGI wrapper that parsed SQL queries and 
made it easy to create forms and tables
based on these queries. This tool was named FI (Form Interpreter).

PHP/FI version 2.0 is a complete rewrite of these two packages combined
into a single program. 
It evolved to a simple programming language embedded inside HTML files. 
PHP eliminates the need for numerous small Perl cgi programs
by allowing you to place simple scripts directly in your HTML files. This
speeds up the overall performance of your web pages since the overhead of
forking Perl several times has been eliminated. 
It also makes it easier to manage large web sites by placing 
all components of a web page in a single html file. 
By including support for various databases, it also makes it
trivial to develop database enabled web pages. Many people find the
embedded nature much easier to deal with than trying to create separate
HTML and CGI files.

Now PHP/FI is renamed as PHP.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
So, what can I do with PHP ?
<p>
The first thing you will notice if you run a page through PHP is that it
adds a footer with information about the number of times your page has been
accessed (if you have compiled access logging into the binary). This is
just a very small part of what PHP can do for you. It serves another
very important role as a form interpreter cgi, hence the FI part of the
old name. For example, if you create a form on one of your web pages, you need
something to process the information on that form. Even if you just want to
pass the information to another web page, you will have to have a cgi
program do this for you. PHP makes it extremely easy to take form data
and do things with it.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
A simple example
<p>
Suppose you have a form:
<tscreen><verb>
<FORM ACTION="/cgi-bin/php.cgi/~userid/display.html" METHOD=POST> 
<INPUT TYPE="text" name="name"> 
<INPUT TYPE="text" name="age"> 
<INPUT TYPE="submit"> 
<FORM> 
</verb></tscreen>
Your display.html file could then contain something like:
<tscreen><verb>
&lt ?echo "Hi &dollar name, you are &dollar age years old!<p>" &gt
</verb></tscreen>
It's that simple! PHP automatically creates a variable for each form
input field in your form. You can then use these variables in the ACTION
URL file.

The next step once you have figured out how to use variables is to start
playing with some logical flow tags in your pages. For example, if you
wanted to display different messages based on something the user inputs,
you would use if/else logic. In our above example, we can display different
things based on the age the user entered by changing our display.html to:
<tscreen><verb>
<?
    if($age>50);
        echo "Hi $name, you are ancient!<p>";
    elseif($age>30);
        echo "Hi $name, you are very old!<p>";
    else;
        echo "Hi $name.";
    endif;
>
</verb></tscreen>
PHP provides a very powerful scripting language which will do much more
than what the above simple example demonstrates. See the section on the
PHP Script Language for more information.

You can also use PHP to configure who is allowed to access your pages.
This is done using a built-in configuration screen. With this you could for
example specify that only people from certain domains would be allowed to
see your pages, or you could create a rule which would password protect
certain pages. See the Access Control section for more details.

PHP is also capable of receiving file uploads from any RFC-1867
compliant web browser. This feature lets people upload both text and binary
files. With PHP's access control and logical functions, you have full
control over who is allowed to upload and what is to be done with the file
once it has been uploaded. See the File Upload section for more details.

PHP has support for the PostgreSQL database package. It supports
embedded SQL queries in your .HTML files.

PHP also has support for the mysql database package. It supports
embedded SQL queries in your .HTML files.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
CGI Redirection
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Apache 1.0.x Notes
<p>
     A good way to run PHP is by using a cgi redirection module with the
     Apache server. Please note that you do not need to worry about
     redirection modules if you are using the Apache module version of
     PHP. There are two of these redirection modules available. One is
     developed by Dave Andersen 
<itemize>
<item>       <htmlurl url="mailto:angio@aros.net"
             name="angio@aros.net">
</itemize>
     and it is available at
<itemize>
<item>     <url url="ftp://ftp.aros.net/pub/util/apache/mod_cgi_redirect.c"> 
</itemize>
and the other
     comes bundled with Apache and is called mod_actions.c. The modules are
     extremely similar. They differ slightly in their usage. Both have been
     tested and both work with PHP.

     Check the Apache documentation on how to add a module. Generally you
     add the module name to a file called Configuration. The line to be
     added if you want to use the mod_actions module is:

     Module action_module mod_actions.o

     If you are using the mod_cgi_redirect.c module add this line:

     Module cgi_redirect_module mod_cgi_redirect.o

     Then compile your httpd and install it. To configure the cgi
     redirection you need to either create a new mime type in your
     mime.types file or you can use the AddType command in your srm.conf
     file to add the mime type. The mime type to be added should be
     something like this:
<tscreen><verb>
     application/x-httpd-php phtml
</verb></tscreen>
     If you are using the mod_actions.c module you need to add the
     following line to your srm.conf file:
<tscreen><verb>
     Action application/x-httpd-php /cgi-bin/php.cgi
</verb></tscreen>
     If you are using mod_cgi_redirect.c you should add this line to
     srm.conf:
<tscreen><verb>
     CgiRedirect application/x-httpd-php /cgi-bin/php.cgi
</verb></tscreen>
     Don't try to use both mod_actions.c and mod_cgi_redirect.c at the same
     time.

     Once you have one of these cgi redirection modules installed and
     configured correctly, you will be able to specify that you want a file
     parsed by PHP simply by making the file's extension .phtml.
     Furthermore, if you add index.phtml to your DirectoryIndex
     configuration line in your srm.conf file then the top-level page in a
     directory will be automatically parsed by php if your index file is
     called index.phtml.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>Netscape HTTPD
<p>
     You can automatically redirect requests for files with a given
     extension to be handled by PHP by using the Netscape Server CGI
     Redirection module. This module is available in the File Archives on
     the PHP Home Page. The README in the package explicitly explains
     how to configure it for use with PHP.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>NCSA HTTPD
<p>
     NCSA does not currently support modules, so in order to do cgi
     redirection with this server you need to modify your server source
     code. A patch to do this with NCSA 1.5 is available in the PHP file
     archives.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Running PHP from the command line
<p>
If you build the CGI version of PHP, you can use it from the command
line simply typing: php.cgi filename where filename is the file you want to
parse. You can also create standalone PHP scripts by making the first
line of your script look something like:
<tscreen><verb>
    #!/usr/local/bin/php.cgi -q
</verb></tscreen>
The "-q" suppresses the printing of the HTTP headers. You can leave off
this option if you like.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************

-->
<sect1> PHPGem package
<p>
PHPGem is a PHP-script which accelerates the creation of PHP-scripts
for working with tables. It works with different SQL-servers such as
PostgreSQL, MySQL, mSQL, ODBC, and Adabas. You input a description of
and parameters for your tables' fields (field name, on/off searching
in the field, etc.), and PHPGem outputs another PHP-script which will
work with the tables (view/add/edit/delete/duplicate entries and
search). PHPGem works with multi-level nested tables. PHPGem allows
you to specify a level of access for each table and for each field for
each user. PHPGem also support images.

PHPGem is at <url url="http://sptl.org/phpgem">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Python Interface for PostgreSQL
-->
<sect>Python Interface for PostgreSQL
<p>
Python in an interpreted, object orientated scripting language. 
It is simple to use (light syntax, simple and straighforward statements), and has
many extensions for building GUIs, interfacing with WWW, etc. An
intelligent web browser (HotJava like) is currently under development
(november 1995), and this should open programmers many doors. Python is
copyrighted by Stichting S Mathematisch Centrum, Amsterdam, The
Netherlands, and is freely distributable.
It contains
support for dynamic loading of objects, classes, modules, and exceptions.
Adding interfaces to new system libraries through C code is straightforward,
making Python easy to use in custom settings. 
Python is a very high level scripting language with X interface.
Python package is distributed on Linux cdroms includes most of 
the standard Python modules, along with
modules for interfacing to the Tix widget set for Tk.

PyGreSQL is a python module that interfaces to a PostgreSQL database. It
embeds the PostgreSQL query library to allow easy use of the powerful
PostgreSQL features from a Python script.
PyGreSQL is written by D'Arcy J.M. Cain and Pascal Andre.
<itemize>
<item> New site of PyGreSQL <url url="http://www.druid.net/pygresql/">
<item> Maintained by D'Arcy at <url url="http://www.druid.net/~darcy/">
<item> Old site is at <url url="ftp://ftp.via.ecp.fr/pub/python/contrib/Database/PyGres95.README ">
<item> D'Arcy J.M. Cain <htmlurl url="mailto:darcy@druid.net"
             name="darcy@druid.net">
<item> Pascal Andre <htmlurl url="mailto:andre@chimay.via.ecp.fr"
             name="andre@chimay.via.ecp.fr">
<item> Pascal Andre <htmlurl url="mailto:andre@via.ecp.fr"
             name="andre@via.ecp.fr">
</itemize>

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Where to get PyGres ?
<p>
The home sites of the differents packages are:
<itemize>
<item> Python <url url="ftp://ftp.python.org:/pub/www.python.org/1.5/python1.5b2.tar.gz">
<item> PyGreSQL <url url="ftp://ftp.druid.net/pub/distrib/PyGreSQL-2.1.tgz">
<item> Old site <url url="ftp://ftp.via.ecp.fr/pub/python/contrib/Database/PyGres95-1.0b.tar.gz ">
</itemize>
You should anyway try to find some mirror site closer of your site. Refer to
the information sources to find these sites. PyGreSQL should reside in the 
contrib directories of Python and PostgreSQL sites.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Information and support
<p>
If you need information about these packages please check their web sites:
<itemize>
<item> Python :     <url url="http://www.python.org/">
<item> PostgreSQL : <url url="http://epoch.cs.berkeley.edu:8000/postgres95/index.html">
<item> PyGreSQL <url url="ftp://ftp.druid.net/pub/distrib/PyGreSQL-2.1.tgz">
<item> Old site PyGreSQL :   <url url="http://www.via.ecp.fr/via/products/pygres.html">
</itemize>

For support :
<itemize>
<item> Mailing list for PyGreSQL. You can join by sending email to
<htmlurl url="mailto:majordomo@vex.net"
             name="majordomo@vex.net">
with the line "subscribe pygresql name@domain" in the
body replacing "name@domain" with your own email address.
<item> Newsgroup for Python :     newsgroup comp.lang.python
<item>  PyGreSQL :   contact Andre at 
       <htmlurl url="mailto:andre@via.ecp.fr"
             name="andre@via.ecp.fr">
   for bug reports, ideas, remarks
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Testing Python interface 
<p>
See the section - <ref id="Testing PyGreSQL" name="Testing Python PostgreSQL interface">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Gateway between PostgreSQL and the WWW - WDB-P95
-->
<sect>Gateway between PostgreSQL and the WWW - WDB-P95
<p>
<sect1>About wdb-p95
<p>
WDB-P95 - A Web interface to PostgreSQL Databases was created by J. Douglas Dunlop
It is at  
<itemize>
<item> New WDB from J Rowe is at <url url="http://www.lava.net/beowulf/programming/wdb">
<item> New versions of WWW-WDB is at <url url="http://www.eol.ists.ca/~dunlop/wdb-p95/">
<item> For questions or to join Mailing lists contact
<htmlurl url="mailto:dunlop@eol.ists.ca"
             name="dunlop@eol.ists.ca">
</itemize>
This is a modified version of wdb-1.3a2 which provides a gateway to a the
WWW for PostgreSQL. This version also requires a Browser that is capable of
handling HTML Tables for the tabular output. This is not required by the
original wdb and can be fairly easily reverted.

You can try out CASI Tape and Image Query. You can have a peek at the
Form Definition File (FDF) which is used to create the CASI Tape and Image
Query too, which includes a JOIN of 2 tables.

This release contains all files necessary to install and run WDB-P95 as an
interface to your PostgreSQL databases. To port this system to other
database should be relatively easy - provided that it supports standard SQL
and has a Perl interface.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Does the PostgreSQL server, pgperl, and httpd have to be on the same host?
<p>
No - the PostgreSQL server does not have to be on the same host. As WDB-P95
is called by the http daemon, they have to be on the same host. - And as
WDB-P95 was written to use Pg.pm - pgperl has to be on the same host too.
Pgperl was written using the libpq library, so it will be able to access
any PostgreSQL server anywhere in the net, just like any other PostgreSQL
client. As illustrated below

(WWW Client (Netscape)) => (HTTP Server (NCSA's http) + WDB-P95 + pgperl + libpq)=> (PostgreSQL server)

Curly brackets () represent machines.

Each machine can be of a different type : NT, SUN, HP, ... but you need the
libpq interface library for the machine type where you plan to use WDB-P95,
as you need it to compile pgperl. (The system was designed to use HTML
tables so a recent WWW client is best)
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Miscellaneous Interface Tools
-->
<sect>"C", "C++", ESQL/C language Interfaces and Bitwise Operators for PostgreSQL
<p>
<sect1> "C" interface 
<p>
It is included in distribution and is called 'libpq'. Similar to Oracle OCI, Sybase DB-lib, Informix CLI libraries.

<sect1> "C++" interface 
<p>
It is included in distribution and is called 'libpq++'.
See the section - <ref id="Testing libpq" name="Testing C and C++ PostgreSQL interface">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> ESQL/C 
<p>
ESQL/C 'Embedded C Pre-compiler' for PostgreSQL ESQL/C is like Oracle Pro*C, Informix ESQL/C.
The PostgreSQL ESQL/C is an SQL application-programming interface (API) enables the C programmer to create custom applications with database-management capabilities. The PostgreSQL ESQL/C allows you to use a third-generation language with which you are familiar and still take advantage of the Structured Query Language (SQL).

ESQL/C consists of the following pieces of software:
<itemize>
<item> The ESQL/C libraries of C functions provide access to the database server.
<item> The ESQL/C header files provide definitions for the data structures, constants, and macros useful to the ESQL/C program.
<item> The ESQL/C preprocessor, is a source-code preprocessor that converts a C file containing SQL statements into an executable file.
</itemize>
It is at
<itemize>
<item> ESQL/C for PostgreSQL is already included in the distribution.
<item> Main site <url url="ftp://ftp.lysator.liu.se/pub/linus">
<item>Email : 
       <htmlurl url="mailto:linus@epact.se"
             name="linus@epact.se">
</itemize>
See the section - <ref id="Testing ecpg" name="Testing Embedded SQL/C interface to PostgreSQL">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>BitWise Operators for PostgreSQL
<p>
Bitwise operators was written by Nicolas Moldavsky       
<itemize>
<item>       <htmlurl url="mailto:nico@overnet.com.ar"
        	name="nico@overnet.com.ar">
</itemize>
"C" functions that implement bitwise operators (AND, OR,
XOR, bit complement) on pgsql. Get them by anonymous FTP from
<itemize>
<item> <url url="ftp://ftp.overnet.com.ar/pub/utils/linux/bitpgsql.tgz">
</itemize>
Makefile for Linux is included.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect>Japanese Kanji Code for PostgreSQL
<p>
It is at the following site
<itemize>
<item>  <url url="ftp://ftp.sra.co.jp/pub/cmd/postgres/">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>PostgreSQL Port to Windows 95/Windows NT
-->
<sect>PostgreSQL Port to Windows 95/Windows NT
<p>
PostgreSQL binaries for Windows NT is available from :
<itemize>
<item> Windows NT PostgreSQL binaries <url url="http://www.askesis.nl">
<item> <url url="http://www.postgresql.org">
</itemize>
Download the binaries and unpack and follow instructions in 
<ref id="installpgsql" name="Install PostgreSQL">
from step 13.

If you want to re-compile the source tree then follow the instructions given below.
Porting to NT is done using Cygnus cygwin32 package which 
has gcc, gmake for Win NT/95. 
<itemize>
<item> Cygwin 32 package is at <url url="http://www.cygnus.com/misc/gnu-win32">
</itemize>
At this site and get the file cdk.exe (self-extractor file for gnu-win32)
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Authors of NT port
<p>
The authors of Windows NT port of PostgreSQL are -
<itemize>
<item> Daniel Horak 
	<htmlurl url="mailto:horak@mmp.plzen-city.cz"
             name="horak@mmp.plzen-city.cz">
<item> Joost Kraaijeveld
	<htmlurl url="mailto:JKraaijeveld@askesis.nl"
		name="JKraaijeveld@askesis.nl">
<item> Kevin Lo
	<htmlurl url="mailto:kevlo@FreeBSD.org"
		name="kevlo@FreeBSD.org">
<item> Home page of NT port is at <url url="http://www.freebsd.org/~kevlo/postgres/portNT.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Install the Cygwin package 
<p>
<enum>
<item> Download  
<url url="ftp://go.cygnus.com/pub/sourceware.cygnus.com/cygwin/latest/full.exe">
<item> Run full.exe and install in c:\Unix\Root directory. 
<item> Run Cygwin, Type 'mount --help' for docs. You can use -f switch to force mount.
And then run "umount / " and "mount c:\Unix\Root /" 
</enum>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Tuneup Bash Window
<p>
After installing the Cygwin package, do the following to setup the
working environment:

1. Install the Vi editor 'Vim'. See 
<url url="http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html">  

2. The default window of cygwin bash is black-background window with
24 lines. To set the background color and size of bash window, click on
NT-Start->Control-panel->MS DOS console and change the background color
to grey and size to 70 lines.

(OR) right click on Window titlebar and change property.
 
3. Edit cygnus.bat in c:\cygnus\cywinb20 and set the following -
<code>
set HOME=c:\cygnus\cygwinb20
bash --login
</code>
 
And also edit the ~/.bash_profile and put these lines
<code>
set -o vi
PATH=$PATH:/usr/local/bin:/usr/bin
export PATH
</code>

4. To enable the command-line history editing give -

bash$ set -o vi
 
Using the l,k,j,h you can use the vi commands to edit the command line
history commands. You can repeat or modify previous commands, saves
typing time.
 
5. You can do mount of drives/directories using this command -
<code>
bash$ umount /
bash$ mount "c:\cygnus"  /
bash$ mount "c:\cygnus\cygwin-b20\postgres" /usr/local/pgsql
</code>
 
6. See online help with -
<code>
bash$ mount --help
bash$ ls --help
</code>
<!--
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Install the Andy Piper tools 
<p>
<enum>
<item>Go to <url url="ftp://ftp.xemacs.org/pub/xemacs/aux/"> and download 
cygwin-b20-local.tar.bz2 in the 
c:/Unix/Root directory. 
<item> cd c:/Unix/Root; bunzip2 cygwin-b20-local.tar.bz2 
<item> tar -xvf cygwin-b20-local.tar 
<item> cd /local/bin; sh check_cygwin_setup.sh 
<item> After doing step 4, you see the following message: 
<code>
You don't have /bin would you like to mount cygwin as /bin?" 
&lsqb y/n &rsqb   
Select 'n',  and the other options are selected 'y' 
</code>
<item> mount c:/Unix/Root/cygwin-b20/H-i586-cygwin32/i586-cygwin32/bin 
/bin 
<item> cd c:/Unix/Root/cygwin-b20/H-i586-cygwin32/i586-cygwin32; mkdir 
libexec share 
man etc sbin info 
<item> cp -R /local/&lcub bin,libexec,share,man,etc,sbin,info,include &rcub
</enum>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Install Ludovic Lange's Cygwin32 IPC package 
<p>
<enum>
<item> Go to <url url="http://www.multione.capgemini.fr/tools/pack_ipc"> and 
download 
cygwin32_ipc-1.03.tgz in c:/Unix/Root directory. 
<item> tar -zxvf cygwin32_ipc-1.03.tgz 
<item> cd cygwin32_ipc-1.03/src and run 'make' 
<item> mkdir -p c:/usr/local/{bin,include,lib,include/sys} 
<code>
cp /cygwin32_ipc-1.03/bin/* c:/usr/local/bin 
cp /cygwin32_ipc-1.03/include/sys/* c:/usr/local/include/sys 
cp /cygwin32_ipc-1.03/lib/* c:/usr/local/lib 
cp c:/usr/local/bin/* /bin 
cp c:/Unix/Root/cygwin-b20/H-i586-cygwin32/bin/* /bin 
</code>
<item> mount c:/usr/local/bin /usr/local/bin 
<code>
mount c:/usr/local/include /usr/local/include 
mount c:/usr/local/lib /usr/local/lib 
cp /local/lib/* /usr/local/lib 
</code>
</enum>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Install PostgreSQL <label id="installpgsql">
<p>
<enum>
<item> Download the latest PostgreSQL source code 
<item> Postgres treats all files as binary files so the lf/cf stuff 
appeard, so we do steps 2, 3, 4, and 5: 
<code>
mkdir -p c:/Postgres/{Source,Binary} 
mkdir c:/Postgres/Binary/pgsql 
mkdir -p /usr/src/pgsql 
mkdir -p /usr/local/pgsql 
</code>
<item> Copy Postgres source code to c:/Postgres/Source directory, then 
tar -zxvf postgresql-6.5.3.tar.gz 
<item> mv postgresql-6.5.3 pgsql 
<item> Mount directories now -
<code>
mount -b c:/Postgres/Binary/pgsql /usr/local/pgsql 
mount c:/Postgres/Source/pgsql /usr/src/pgsql 
mount c:/Unix/Root/cygwin-b20/share /sw/cygwin-b20/share 
</code>
<item> mkdir -p /usr/local/pgsql/{bin,include,lib,data} 
<item> cd /usr/src/pgsql/src/win32 
<item> Copy header files -
<code>
cp un.h c:/Unix/Root/cygwin-b20/H-i586-cygwin32/i586-cygwin32/include/sys 
cp endian.h c:/Unix/Root/cygwin-b20/H-i586-cygwin32/i586-cygwin32/include 
cp tcp.h c:/Unix/Root/cygwin-b20/H-i586-cygwin32/i586-cygwin32/include/netinet 
</code>
<item> ln -s /usr/local/lib /usr/src/pgsql/src/backend/libpostgres.a 
<item> cd /usr/src/pgsql/src, then run './configure' 
<item> make > make.txt 2>&1 
<item> make install  > make.install.txt 2>&1 
<item> cp /usr/local/pgsql/lib/pq.dll /usr/local/pgsql/bin 
<item> After the make install you had to change all the text files in 
the bin and lib diectories so 
that they did not contain cr/lf and eof stuff. 
<item> Using any editor to create .bashrc in / directory as belows: 
<code>
PATH=$PATH:/usr/local/pgsql/bin:/usr/local/bin 
PGDATA=/usr/local/pgsql/data 
PGLIB=/usr/local/pgsql/lib 
LD_LIBRARY_PATH=/usr/local/pgsql/lib:/usr/local/lib 
export LD_LIBRARY_PATH PATH PGDATA PGLIB 
</code>
<item> source /.bashrc, then run 'initdb --username=xxxx' 
Note that the owner of the DB system have to be different from 
root/administrator 
<item> Edit the file /usr/local/pgsql/data/pg_hba.conf, such as: 
<code>
host        all     163.17.11.109   255.255.255.0   trust 
</code>
<item> ipc-daemon.exe& 
<item> postmaster -i& 
<item> Run ' psql -h host_name template1'
</enum>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Mailing Lists
-->
<sect>Mailing Lists
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>E-mail account for PostgreSQL
<p>
Get free e-mail accounts from 
<itemize>
<item> In Yahoo <url url="http://www.yahoo.com"> click on e-mail
<item> In Lycos <url url="http://www.lycos.com"> click on new e-mail accounts
<item> In hotmail <url url="http://www.hotmail.com"> click on new e-mail accounts
</itemize>
Subscribe to PostgreSQL mailing list and Yahoo has additional feature of
creating a seperate folder for PostgreSQL e-mails, so that your regular
e-mail is not cluttered. Select menu Email- &gt Options- &gt Filters and
pick seperate folder for email.
With this e-mail account you can access mail from anywhere in the world
as long as you have access to a web page.

If you have any other e-mail, you can use "Mail Filters" to receive automatically
the PostgreSQL mails into a seperate folder. This will avoid mail cluttering.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>English Mailing List
<p>
See the Mailing Lists Item on the main web page at : 
<itemize>
<item> <url url="http://www.postgresql.org/">
<item>Email questions to: 
	<htmlurl url="mailto:pgsql-questions@postgresql.org"
             name="pgsql-questions@postgresql.org">
<item> Developers <htmlurl url="mailto:pgsql-hackers@postgresql.org"
             name="pgsql-hackers@postgresql.org">
<item> Port specific questions <htmlurl url="mailto:pgsql-ports@postgresql.org"
             name="pgsql-ports@postgresql.org">
<item> Documentation questions <htmlurl url="mailto:pgsql-docs@postgresql.org"
             name="pgsql-docs@postgresql.org">
</itemize>
You will get the answers/replies back by e-mail in less than a day.

You can also subscribe to mailing lists.
To subscribe or unsubscribe from the list, send mail to 
<itemize>
<item> <htmlurl url="mailto:pgsql-questions-request@postgresql.org"
             name="pgsql-questions-request@postgresql.org">
<item> <htmlurl url="mailto:pgsql-hackers-request@postgresql.org"
             name="pgsql-hackers-request@postgresql.org">
<item> <htmlurl url="mailto:pgsql-ports-request@postgresql.org"
             name="pgsql-ports-request@postgresql.org">
<item> <htmlurl url="mailto:pgsql-docs-request@postgresql.org"
             name="pgsql-docs-request@postgresql.org">
</itemize>
The body of the message should contain the single line
<p>
subscribe 
<p>
(or) 
<p>
unsubscribe
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Archive of Mailing List
<p>
Also mailing lists are archived in html format at the following location -
<itemize>
<item> Date-wise listing available via MHonarc via the WWW at
        <url url="http://www.postgresql.org/mhonarc/pgsql-questions">
<item> <url url="ftp://ftp.postgresql.org"> directory is /pub/majordomo
</itemize>
There is also search engine available on the PostgreSQL main web site 
specifically for pgsql questions.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>Spanish Mailing List
<p>
Now there is an "unofficial" list of postgreSQL in Spanish.
To subscribe the user has to send a message to:
<itemize>
<item> <htmlurl url="mailto:majordomo@tlali.iztacala.unam.mx"
             name="majordomo@tlali.iztacala.unam.mx">
</itemize>
The body of the message should contain the single line:

inscripcion pgsql-ayuda
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Documentation and Reference Books
-->
<sect>Documentation and Reference Books
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
User Guides and Manuals
<p>
The following are included in the PostgreSQL distribution in the
postscript, HTML formats and unix man-pages. They are located 
in /usr/doc/postgresql* directory. 
If you have access to internet, you can find the documents listed below
at <url url="http://www.postgresql.org/docs"> 

<itemize>
<item> "Installation Guide"
<item> "User Guide" for PostgreSQL
<item> "Implementation Guide" detailing database internals of PostgreSQL.
<item> Online manuals.
<item> Online manuals in HTML formats.
<item> Also manuals in Postscript format for printing hard copies.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Online Documentation
<p>
<itemize>
<item> Listing and description of default data types and operators
<tscreen><verb>
Is a a part of PSQL command
</verb></tscreen>
<item> Listing of supported SQL keywords 
<tscreen><verb>
There is a script in the /tools directory in source code tree.
</verb></tscreen>
<item> Listings of supported statements -
<tscreen><verb>
Use the command psql \h
</verb></tscreen>
<item> Basic relational database concepts under PostgreSQL (implementation)
and several online examples (queries) -
<tscreen><verb>
Look at the regression tests at src/test. There you can find the directories
regress/sql and suite/*.sql and also see 
<ref id="Examples RPM">
</verb></tscreen>
<item> Tutorial for PostgreSQL.
<tscreen><verb>
SQL tutorial scripts is in the directory src/tutorial
</verb></tscreen>
See also "SQL Tutorial for beginners"
in Appendix B of this document <ref id="Appendix B"> 
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Useful Reference Textbooks
<p>
<itemize>
<item> "Understanding the New SQL: A Complete Guide" - by Jim Melton and Alan R.Simon
<tscreen><verb>
Morgan Kaufman Publisher is one of best SQL books. This deals with SQL92.
</verb></tscreen>
<item> "A Guide to THE SQL STANDARD" - by C.J.Date 
<tscreen><verb>
Addison-Wesley Publishing company is also a good book. Very popular book for SQL.
</verb></tscreen>
<item>SQL - The Standard Handbook,  November 1992 
<tscreen><verb>
Stephen Cannan and Gerard Otten
McGraw-Hill Book Company Europe , Berkshire, SL6 2QL, England
</verb></tscreen>
<item>SQL Instant Reference, 1993 
<tscreen><verb>
Martin Gruber, Technical Editor: Joe Celko
SYBEX Inc.  2021 Challenger Drive Alameda, CA 94501
</verb></tscreen>
<item> C.J.Date, "An introduction to Database Systems" 
(6th Edition), Addison-Wesley, 1995, ISBN 0-201-82458-2   
<tscreen><verb>
This book is the Bible of Database Management Systems.
The book details normalization, SQL, recovery, concurrency, security, 
integrity, and extensions to the original relational model, current issues 
like client/server systems and the Object Oriented model(s). Many 
references are included for further reading. Recommended for most users.
</verb></tscreen>
<item> Stefan Stanczyk, "Theory and Practice of Relational Databases", 
UCL Press Ltd, 1990, ISBN 1-857-28232-9  
<tscreen><verb>
Book details theory of relational databases, relational algebra, calculus
and normalisation. But it does not cover real world issues and examples
beyond simple examples. Recommended for most users.
</verb></tscreen>
<item>"The Practical SQL Handbook" Third Edition,
Addison Wesley Developers Press  
ISBN 0-201-44787-8
<tscreen><verb>
Recommended for most users.
</verb></tscreen>
<item> Michael Stonebraker, "Readings in Database Systems",
Morgan Kaufmann, 1988, ISBN 0-934613-65-6  
<tscreen><verb>
This book is a collection of papers that have been published over the 
years on databases. It's not for the casual user but it is really a 
reference for advanced (post-graduate) students or database system 
developers.
</verb></tscreen>
<item> C.J.Date, "Relational Database - Selected Readings", 
Addison-Wesley, 1986, ISBN 0-201-14196-5  
<tscreen><verb>
This book is a collection of papers that have been published over the
years on databases. It's not for the casual user but it is really a
reference for advanced (post-graduate) students or database system 
developers. 
</verb></tscreen>
<item> Nick Ryan and Dan Smith, "Database Systems Engineering", 
International Thomson Computer Press, 1995, ISBN 1-85032-115-9  
<tscreen><verb>
This book goes into the details of access methods, storage techniques.
</verb></tscreen>
<item> Bipin C. Desai, "An introduction to Database Systems", 
West Publishing Co., 1990, ISBN 0-314-66771-7  
<tscreen><verb>
It's not for the casual user but it is for advanced (post-graduate)
students or database system developers. 
</verb></tscreen>
<item> Joe Celko "INSTANT SQL Programming"
<tscreen><verb>
Wrox Press Ltd.
Unit 16, 20 James Road, Tyseley
Birmingham, B11 2BA, England
1995
</verb></tscreen>
<item> Michael Gorman "Database Management Systems: Understanding and Applying Database"
<tscreen><verb>
Technology
QED and John Wiley
1991
</verb></tscreen>
<item> Michael Gorman "Enterprise Database for a Client/Server Environment"
QED and John Wiley
<tscreen><verb>
Presents the requirements of building client/server database
applications via repository metamodels and the use of ANSI standard SQL
1993
</verb></tscreen>
</itemize>

Hundreds of other titles on SQL are available! Check out a bookstore.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> ANSI/ISO SQL Specifications documents  - SQL 1992, SQL 1998 
<p>
ANSI/ISO SQL specifications documents can be found at these sites listed
below -
<itemize>
<item> <url url="http://www.naiua.org/std-orgs.html">

<item> <url url="http://www.ansi.org/docs"> and click on file
cat_c.html and search with "Database SQL"

<item> SQL92 standard <url url="http://www.jcc.com"> and click
on file sql_stnd.html

<item> ANSI/ISO SQL specifications <url url="http://www.contrib.andrew.cmu.edu/~shadow/sql.html"> You will find SQL Reference here.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Syntax of ANSI/ISO SQL 1992
<p>
See Appendix A of this document <ref id="Appendix A">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Syntax of ANSI/ISO SQL 1998
<p>
The SQL 1998 (SQL 3) specification is still under development. 
See 'Electronic Access to the SQL3 Working Draft' of this document at <ref id="SQL 1998">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> 
SQL Tutorial for beginners
<p>
See Appendix B of this document <ref id="Appendix B">
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Temporal Extension to SQL92
<p>
<itemize>
<item>Document for Temporal Extension to SQL-92
<url url="ftp://FTP.cs.arizona.edu/tsql/tsql2/">

<item> Temporal SQL-3 specification
<url url="ftp://FTP.cs.arizona.edu/tsql/tsql2/sql3/">
</itemize>

This directory contains the language specification for a temporal
extension to the SQL-92 language standard. This new language is
designated TSQL2.

The language specification present here is the final version of the
language.

Correspondence may be directed to the chair of the TSQL2 Language
Design Committee, Richard T.Snodgrass, Department of Computer
Science, University of Arizona, Tucson, AZ 85721,
<itemize>
<item>       <htmlurl url="mailto:rts@cs.arizona.edu"
		name="rts@cs.arizona.edu">
</itemize>
The affiliations and e-mail addresses of the
TSQL2 Language Design Committee members may be found in a separate
section at the end of the language specification.

The contents of this directory are as follows.

spec.dvi,.ps	TSQL2 Language Specification, published in September, 1994

bookspec.ps	TSQL2 Language Specification, as it appears in the TSQL2
		book, published in September, 1995 (see below).

sql3		change proposals submitted to the ANSI and ISO SQL3
		committees.

Associated with the language specification is a collection of commentaries
which discuss design decisions, provide examples, and consider how the
language may be implemented. These commentaries were originally proposals to
the TSQL2 Language Design Committee. They now serve a different purpose: to
provide examples of the constructs, motivate the many decisions made during
the language design, and compare TSQL2 with the many other language
proposals that have been made over the last fifteen years. It should be
emphasized that these commentaries are not part of the TSQL2 language
specification per se, but rather supplement and elaborate upon it. The
language specification proper is the final word on TSQL2.

The commentaries, along with the language specification, several
indexes, and other supporting material, has been published as a book:

Snodgrass, R.T., editor, The TSQL2 Temporal Query Language, Kluwer
Academic Publishers, 1995, 674+xxiv pages.

The evaluation commentary appears in the book in an abbreviated form; the
full commentary is provided in this directory as file eval.ps

The file tl2tsql2.pl is a prolog program that tranlates allowed temporal
logic to TSQL2. This program was written by Michael Boehlen
<itemize>
<item>       <htmlurl url="mailto:boehlen@iesd.auc.dk"
		name="boehlen@iesd.auc.dk">
</itemize>
He may be contacted for a paper that describes this
translation. This is a rather dated version of that program. Newer versions
are available at 
<itemize>
<item> <url url="http://www.cs.auc.dk/general/DBS/tdb/TimeCenter/Software">
</itemize>
(the TimeDB and Tiger systems).
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 0 - Acquiring ISO/ANSI SQL Documents <label id="SQL 1998">
<p>
  This document shows you how to (legally) acquire a copy
  of the SQL-92 standard and how to acquire a copy of the "current" SQL3
  Working Draft.

  The standard is copyrighted ANSI standard by ANSI, the ISO standard by ISO.

  There are two (2) current SQL standards, an ANSI publication
  and an ISO publication. The two standards are word-for-word identical
  except for such trivial matters as the title of the document, page
  headers, the phrase "International Standard" vs "American Standard", and
  so forth.

                    Buying the SQL-92 Standard

  The ISO standard, ISO/IEC 9075:1992, Information Technology - Database
  Languages - SQL, is currently (March, 1993) available and in stock from
  ANSI at:
<tscreen><verb>
     American National Standards Institute
     1430 Broadway
     New York, NY 10018 (USA)
     Phone (sales): +1.212.642.4900
</verb></tscreen>
  at a cost of US$230.00. The ANSI version, ANSI X3.135-1992, American
  National Standard for Information Systems - Database Language SQL, was
  not available from stock at this writing, but was expected to be
  available by some time between late March and early May, 1993). It is
  expected to be be priced at US$225.00.

  If you purchase either document from ANSI, it will have a handling
  charge of 7% added to it (that is, about US$9.10). Overseas shipping
  charges will undoubtedly add still more cost. ANSI requires a hardcopy
  of a company purchase order to accompany all orders; alternately, you
  can send a check drawn on a US bank in US dollars, which they will cash
  and clear before shipping your order. (An exception exists: If your
  organization is a corporate member of ANSI, then ANSI will ship the
  documents and simply bill your company.)

  The ISO standard is also available outside the United States from local
  national bodies (country standardization bodies) that are members of
  either ISO (International Organization for Standardization) or IEC
  (International Electrotechnical Commission). Copies of the list of
  national bodies and their addresses are available from ANSI or from
  other national bodies. They are also available from ISO:
<tscreen><verb>
     International Organization for Standardization
     Central Secretariat
     1, rue de Varembi
     CH-1211 Genhve 20
     Switzerland
</verb></tscreen>
  If you prefer to order the standard in a more convenient and quick
  fashion, you'll have to pay for the privilege. You can order ISO/IEC
  9075:1992, Information Technology - Database Languages - SQL, from:
<tscreen><verb>
     Global Engineering Documents
     2805 McGaw Ave
     Irvine, CA 92714 (USA)
     USA
     Phone (works from anywhere): +1.714.261.1455
     Phone (only in the USA): (800)854-7179
</verb></tscreen>
  for a cost of US$308.00. I do not know if that includes shipping or not,
  but I would guess that international shipping (at least) would cost
  extra. They will be able to ship you a document fairly quickly and will
  even accept "major credit cards". Global does not yet have the ANSI
  version nor do they have a price or an expected date (though I would
  expect it within a few weeks following the publication by ANSI and at a
  price near US$300.00).

             Buying a copy of the SQL3 Working Draft

  You can purchase a hardcopy of the SQL3 working draft from the ANSI X3
  Secretariat, CBEMA (Computer and Business Equipment Manufacturers
  Association). They intend to keep the "most recent" versions of the SQL3
  working draft available and sell them for about US$60.00 to US$65.00.
  You can contact CBEMA at:
<tscreen><verb>
     CBEMA, X3 Secretariat
     Attn: Lynn Barra
     1250 Eye St.
     Suite 200
     Washington, DC 20005 (USA)
</verb></tscreen>
  Lynn Barra can also be reached by telephone at +1.202.626.5738 to
  request a copy, though mail is probably more courteous.

           Electronic Access to the SQL3 Working Draft

  The most recent version (as of the date of this writing) of the SQL3
  (both ANSI and ISO) working draft (and all of its Parts) is available by
  "anonymous ftp" or by "ftpmail" on:
<tscreen><verb>
     gatekeeper.dec.com

  at

     /pub/standards/sql/
</verb></tscreen>
  In this directory are a number of files.  There are PostScript. files
  and "plain text" (not prettily formatted, but readable on a screen
  without special software).

  In general, you can find files with names like:
<tscreen><verb>
     sql-bindings-mar94.ps
     sql-bindings-mar94.txt
     sql-cli-mar94.ps
     sql-cli-mar94.txt
     sql-foundation-mar94.ps
     sql-foundation-mar94.txt
     sql-framework-mar94.ps
     sql-framework-mar94.txt
     sql-psm-mar94.ps
     sql-psm-mar94.txt
</verb></tscreen>
  As new versions of the documents are produced, the "mar94" will change
  to indicate the new date of publication (e.g., "aug94" is the expected
  date of the next publication after "mar94").

  In addition, for those readers unable to get a directory listing by FTP,
  we have placed a file with the name:
<tscreen><verb>
     ls
</verb></tscreen>
  into the same directory.  This file (surprise!) contains a directory
  listing of the directory.

               Retrieving Files Directly Using ftp

  This is a sample of how to use FTP. Specifically, it shows how to
  connect to gatekeeper.dec.com, get to the directory where the base
  document is kept, and transfer the document to your host. Note that your
  host must have Internet access to do this. The login is 'ftp' and the
  password is your email address (this is sometimes referred to as
  'anonymous ftp'). The command 'type binary' is used to ensure that no
  bits are stripped from the file(s) received. 'get' gets one file at a
  time. Comments in the script below are inside angle brackets &lt like so &gt .
<tscreen><verb>
  % ftp gatekeeper.dec.com
  Connected to gatekeeper.dec.com.
  220- *** /etc/motd.ftp ***
       Gatekeeper.DEC.COM is an unsupported service of DEC Corporate Research.
       <...this goes on for a while...>
  220 gatekeeper.dec.com FTP server (Version 5.83 Sat ... 1992) ready.
  Name (gatekeeper.dec.com:<yourlogin here>): ftp  <anonymous also works>
  331 Guest login ok, send ident as password.
  Password: <enter your email address here >
  230 Guest login ok, access restrictions apply.
  Remote system type is UNIX.  <or whatever>
  Using binary mode to transfer files.
  ftp> cd pub/standards/sql
  250 CWD command successful.
  ftp> dir
  200 PORT command successful.
  150 Opening ASCII mode data connection for /bin/ls.
  total 9529
  -r--r--r--  1 root     system     357782 Feb 25 10:18 x3h2-93-081.ps
  -r--r--r--  1 root     system     158782 Feb 25 10:19 x3h2-93-081.txt
  -r--r--r--  1 root     system     195202 Feb 25 10:20 x3h2-93-082.ps
  -r--r--r--  1 root     system      90900 Feb 25 10:20 x3h2-93-082.txt
  -r--r--r--  1 root     system    5856284 Feb 25 09:55 x3h2-93-091.ps
  -r--r--r--  1 root     system    3043687 Feb 25 09:57 x3h2-93-091.txt
  226 Transfer complete.
  ftp> type binary
  200 Type set to I.
  ftp> get x3h2-93-082.txt
  200 PORT command successful.
  150 Opening BINARY mode data connection for x3h2-93-082.txt (90900 bytes).
  226 Transfer complete.
  90900 bytes received in 0.53 seconds (166.11 Kbytes/s)
  ftp> quit
  % <the file is now in your directory as x3h2-93-082.txt>
</verb></tscreen>
           Retrieving Files Without Direct ftp Support

  Digital Equipment Corporation, like several other companies, provides
  ftp email service. The response can take several days, but it does
  provide a service equivalent to ftp for those without direct Internet
  ftp access. The address of the server is:

     ftpmail@decwrl.dec.com

  The following script will retrieve the PostScript for the latest version
  of the SQL3 document:
<tscreen><verb>
     reply joe.programmer@imaginary-corp.com
     connect gatekeeper.dec.com anonymous
     binary
     compress
</verb></tscreen>
  The following script will retrieve the PostScript for the latest version
  of the SQL3 document:
<tscreen><verb>
     reply joe.programmer@imaginary-corp.com
     connect gatekeeper.dec.com anonymous
     binary
     compress
     uuencode
     chdir /pub/standards/sql
     get x3h2-93-091.ps
     quit
</verb></tscreen>
  The first line in the script commands the server to return the requested
  files to you; you should replace "joe.programmer@imaginary-corp.com"
  with your Internet address. The file in this example, x3h2-93-091.ps,
  is returned in "compress"ed "uuencode"d format as 34 separate email
  messages. If your environment does not provide tools for reconstructing
  such files, then you could retrieve the file as plain text with the
  following script:
<tscreen><verb>
     reply joe.programmer@imaginary-corp.com
     connect gatekeeper.dec.com anonymous
     chdir /pub/standards/sql
     get x3h2-93-091.ps
     quit
</verb></tscreen>
  But be warned, the .ps file will probably be sent to you in more than 70
  parts!

  To retrieve any particular file, other than x3h2-93-091.ps, simply
  replace "x3h2-93-091.ps" with the name of the desired file. To get a
  directory listing of all files available, replace "get x3h2-93-091.ps"
  with "dir".
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 1 - ISO/ANSI SQL Current Status
<p>
This chapter is a source of information about the SQL
standards process and its current state.

Current Status:

Development is currently underway to enhance SQL into a computationally
complete language for the definition and management of persistent, complex
objects. This includes: generalization and specialization hierarchies,
multiple inheritance, user defined data types, triggers and assertions,
support for knowledge based systems, recursive query expressions, and
additional data administration tools. It also includes the specification of
abstract data types (ADTs), object identifiers, methods, inheritance,
polymorphism, encapsulation, and all of the other facilities normally
associated with object data management.

In the fall of 1996, several parts of SQL3 went through a ISO CD ballot.
Those parts were SQL/Framework, SQL/Foundation, and SQL/Bindings. Those
ballots failed (as expected) with 900 or so comments. In Late January, there
was an ISO DBL editing meeting that processed a large number of problem
solutions that were either included with ballot comments or submitted as
separate papers. Since the DBL editing meeting was unable to process all of
the comments, the editing meeting has been extended. The completion of the
editing meeting is scheduled for the end of July, 1997, in London.

Following the July editing meeting, the expectation is that a Final CD
ballot will be requested for these parts of SQL. The Final CD process will
take about 6 months and a DBL editing meeting, after which there will be a
DIS ballot and a fairly quick IS ballot.

The ISO procedures have changed since SQL/92, so the SQL committees are
still working through the exact details of the process.

If everything goes well, these parts of SQL3 will become an official ISO/IEC
standard in late 1998, but the schedule is very tight.

In 1993, the ANSI and ISO development committees decided to split future SQL
development into a multi-part standard. The Parts are:

<itemize>
<item>   Part 1: Framework A non-technical description of how the document is
     structured.
<item>   Part 2: Foundation The core specification, including all of the new ADT
     features.
<item>   Part 3: SQL/CLI The Call Level Interface.
<item>   Part 4: SQL/PSM The stored procedures specification, including
     computational completeness.
<item>   Part 5: SQL/Bindings The Dynamic SQL and Embedded SQL bindings taken
     from SQL-92.
<item>   Part 6: SQL/XA An SQL specialization of the popular XA Interface
     developed by X/Open
<item>   Part 7:SQL/TemporalAdds time related capabilities to the SQL standards.
</itemize>

In the USA, the entirety of SQL3 is being processed as both an ANSI Domestic
("D") project and as an ISO project. The expected time frame for completion
of SQL3 is currently 1999.

The SQL/CLI and SQL/PSM are being processed as fast as possible as addendums
to SQL-92. In the USA, these are being processed only as International ("I")
projects. SQL/CLI was completed in 1995. SQL/PSM should be completed
sometime in late 1996.

In addition to the SQL3 work, a number of additional projects are being
persued:

<itemize>
<item>   SQL/MM An ongoing effort to define standard multi-media packages using
     the SQL3 ADT capabilities.
<item>   Remote Data Access (RDA)
</itemize>

Standards Committee and Process

There are actually a number of SQL standards committees around the world.
There is an international SQL standards group as a part of ISO. A number of
countries have committees that focus on SQL. These countries (usually) send
representatives to ISO/IEC JTC1/SC 21/WG3 DBL meetings. The countries that
actively participate in the ISO SQL standards process are:

<itemize>
<item>   Australia
<item>   Brazil
<item>   Canada
<item>   France
<item>   Germany
<item>   Japan
<item>   Korea
<item>   The Netherlands
<item>   United Kingdom
<item>   United States
</itemize>

NIST Validation

SQL implementations are validated (in the Unites States) by the National
Institute of Standards and Training (NIST). NIST currently has a validation
test suite for entry level SQL-92. The exact details of the NIST validation
requirements are defined as a Federal Information Processing Standard
(FIPS). The current requirements for SQL are defined in FIPS 127-2. The
Postscript and Text versions of this document can be retrieved from NIST.
The current SQL Validated Products List can also be retrieved from NIST.

Standard SQL Publications and Articles

There are two versions of the SQL standard. Both are available from ANSI:

<itemize>
<item>   ISO/IEC 9075:1992, "Information Technology --- Database Languages ---
     SQL"
<item>   ANSI X3.135-1992, "Database Language SQL"
</itemize>

The two versions of the SQL standard are identical except for the front
matter and references to other standards. Both versions are available from:
<tscreen><verb>
     American National Standards Institute
     1430 Broadway
     New York, NY 10018
     USA
     Phone (sales): +1.212.642.4900
</verb></tscreen>
In additon to the SQL-92 standard, there is now a Technical Corrigendum (bug
fixes):
<tscreen><verb>
   * Technical Corrigendum 1:1994 to ISO/IEC 9075:1992
</verb></tscreen>
TC 1 should also be available from ANSI. There is only an ISO version of TC
1 -- it applies both to the ISO and ANSI versions of SQL-92.

In addition to the standards, several books have been written about the 1992
SQL standard. These books provide a much more readable description of the
standard than the actual standard.

Related Standards

A number of other standards are of interest to the SQL community. This
section contains pointers to information on those efforts. These pointers
will be augmented as additional information becomes available on the web.

<itemize>
<item>  SQL Environments (FIPS 193)
<item>   Next Generation Repository Systems (X3H4) - a News Release calling for
     particpation in "Developing Standards for the Next Generation
     Repository Systems."
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 2 - ISO/ANSI SQL Foundation
<p>
A significant portion of the SQL3 effort is in the SQL Foundation document:

<itemize>
<item>   Base SQL/PSM capabilities (moved form SQL/PSM-92)
<item>   New data types
<item>   Triggers
<item>   Subtables
<item>   Abstract Data Types (ADT)
<item>   Object Oriented Capabilities
</itemize>

There are several prerequisites to the object oriented capabilities:

<itemize>
<item>   Capability of defining complex operations
<item>   Store complex operations in the database
<item>   External procedure calls  Some operations may not be in SQL, or may
     require external interactions
</itemize>

These capabilities are defined as a part of SQL/PSM

A great deal of work is currently being done to refine the SQL-3 object
model and align it with the object model proposed by ODMG. This effort is
described in the X3H2 and ISO DBL paper: Accomodating SQL3 and ODMG. A
recent update on the SQL3/OQL Merger is also available.

SQL3 Timing

Work on SQL3 is well underway, but the final standards is several years
away.

<itemize>
<item>   International ballot to progress SQL3 Foundation from Working Draft to
     Committee Draft (CD) taking place fall, 1996.
<item>   Ballot is expected to generate numerous comments
<item>   A second CD ballot is likely to be required
<item>   Draft International Standard ballot is likely to be take place in mid
     1998
<item>   International Standard could be completed by mid 1999.
</itemize>

The ANSI version of the standard will be on a similar schedule.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 3 - ISO/ANSI SQL Call Level Interface
<p>
The SQL/CLI is a programing call level interface to SQL databases. It is
designed to support database access from shrink-wrapped applications. The
CLI was originally created by a subcommittee of the SQL Access Group (SAG).
The SAG/CLI specification was published as the Microsoft Open DataBase
Connectivity (ODBC) specification in 1992. In 1993, SAG submitted the CLI to
the ANSI and ISO SQL committees. (The SQL Access Group has now merged with
X/Open consortium.)

SQL/CLI provides an international standard for:

<itemize>
<item>   Implementation-independent CLI to access SQL databases
<item>   Client-server tools can easily access database through dynamic Link
     Libraries
<item>   Supports and encourages rich set of Client-server tools
</itemize>

SQL/CLI Timing

For the standards process, SQL/CLI is being processed with blinding speed.

<itemize>
<item>   SQL/CLI is an addendum to 1992 SQL standard (SQL-92)
<item>   Completed as an ISO standard in 1995
<item>   ISO/IEC 9075-3:1995 Information technology -- Database languages -- SQL
     -- Part 3: Call-Level Interface (SQL/CLI)
<item>   Current SQL/CLI effort is adding support for SQL3 features
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 4 - ISO/ANSI SQL Persistent Stored Modules
<p>
SQL/PSM expands SQL by adding:

<itemize>
<item>   Procedural language extensions
<item>   Multi-statement and Stored Procedures
<item>   External function and procedure calls
</itemize>

In addition to being a valuable application development tool, SQL/PSM
provides the foundation support for the object oriented capabilities in
SQL3.

Multi-statement and Stored Procedures

Multi-statement and stored procedures offer a variety of advantages in a
client/server environment:

<itemize>
<item>   Performance - Since a stored procedure can perform multiple SQL
     statements, network interaction with the client are reduced.
<item>   Security - A user can be given the right to call a stored procedure
     that updates a table or set of tables but denied the right to update
     the tables directly
<item>   Shared code - The code in a stored procedure does not have to be
     rewritten and retested for each client tool that accesses the database.
<item>   Control - Provides a single point of definition and control for
     application logic.
</itemize>

Procedural Language Extensions

Procedural language add the power of a traditional programming language to
SQL through flow control statements and a variety of other programming
constructs.

Flow Control Statements

<itemize>
<item>   If-then-else
<item>   Looping constructs
<item>   Exception handling
<item>   Case statement
<item>   Begin-End blocks
</itemize>

The procedural language extensions include other programming language
constructs:

<itemize>
<item>   Variable declarations
<item>   Set statements for value assignment
<item>   Get diagnostics for process and status information
</itemize>

In addition, all of the traditional SQL statements can be included in
multi-statement procedures.

External Procedure and Function Calls

One feature frequently mentioned in the wish lists for many database
products, and implemented in some, is a capability augmenting the built-in
features with calls to user-written procedures external to the database
software.

<itemize>
<item>   Allows a particular site or application to add their own database
     functions
<item>   Can be used throughout the database applications
</itemize>

The benefit of this capability is that it gives the database (and therefore
database applications) access to a rich set of procedures and functions too
numerous to be defined by a standards committee.

SQL/PSM Timing

SQL/PSM is proceeding quickly:

<itemize>
<item>   SQL/PSM is an addendum to SQL-92
<item>   International ballot to progress SQL/PSM from a Draft International
     Standard to an International Standard ended January, 1996.
<item>   Editing meeting in May, 1996 did not resolve all of the comments
<item>   Continuation of PSM Editing meeting is scheduled for September 30
     through October 4, 1996
<item>   The schedule is tight but there is a chance that PSM will be published
     with a 1996 date.
<item>   The official designation will be:
     ISO/IEC DIS 9075-4:199? Information technology -- Database languages --
     SQL -- Part 4: SQL Persistent Stored Modules (SQL/PSM)
<item>   Work is well underway on adding SQL/PSM support for SQL3 features.
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 5 - ISO/ANSI SQL/Bindings
<p>
For ease of reference, the programming language bindings have been pulled
out into a separate document. The current version is simply an extract of
the dynamic and embedded bindings from SQL-92.

A variety of issues remain unresolved for the programming language bindings.

For traditional programming language, mappings exist for the SQL-92
datatypes. However, mappings must be defined between SQL objects and
programming language variables.

For object oriented languages, mapping must be defined for the current SQL
datatypes and between the SQL object model and the object model of the
object-oriented language.

The object model needs to stabilize before these can be addressed.

The language bindings will be completed as a part of SQL3.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 6 - ISO/ANSI SQL XA Interface Specialization (SQL/XA)
<p>
This specification would standardize an application program interface (API)
between a global Transaction Manager and an SQL Resource Manager. It would
standardize the function calls, based upon the semantics of ISO/IEC 10026,
"Distributed Transaction Processing", that an SQL Resource Manager would
have to support for two-phase commit. The base document is derived from an
X/Open publication, with X/Open permission, that specifies explicit input
and output parameters and semantics, in terms of SQL data types, for the
following functions: xa_close, xa_commit, xa_complete, xa_end, xa_forget,
xa_open, xa_prepare, xa_recover, xa_rollback, and xa_start.

ISO is currently attempting to fast-track the X/Open XA specification. The
fast-track process adopts a current industry specification with no changes.
The XA fast-track ballot at the ISO SC21, JTC 1 level started on April 27,
1995 and ends on October 27, 1995. If the XA specification is approved by
75% of the votes, and by 2/3 of the p-members of JTC 1, it will become an
International Standard. If the fast-track ballot is approved, SQL/XA could
become a standard in 1996.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 7 - ISO/ANSI SQL Temporal
<p>
Temporal SQL deals with time-related data. The concept is that it is useful
to query data to discover what it looked like at a particular point in time.
Temporal SQL is a December, 1994 paper by Rick Snodgrass describing the
concepts.

X3 Announces the Approval of a New Project, ISO/IEC 9075 Part 7:
SQL/Temporal is a press release related to SQL/Temporal.
<tscreen><verb>
----------------------------------------------------------------------------
				Temporal SQL
				************
Rick Snodgrass (chair of the TSQL2 committee)
31-Dec-1994
</verb></tscreen>
Several people have questioned the need for additional support for time in
SQL3 (as proposed by DBL RIO-75, requesting a new part of SQL to support
temporal databases). The claim is that abstract data types (ADT's) are
sufficient for temporal support. In this informational item, I argue, using
concrete examples, that using columns typed with abstract data types is
inadequate for temporal queries. In particular, many common temporal queries
are either difficult to simulate in SQL, or require embedding SQL in a
procedural language. Alternatives are expressed in TSQL2, a temporal
extension to SQL-92.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>INTRODUCTION
<p>
Valid-time support goes beyond that of a temporal ADT. With the later, a
column is specified as of a temporal domain, such as DATE or INTERVAL
(examples will be given shortly). With valid time, the rows of a table vary
over time, as reality changes. The timestamp associated with a row of a
valid-time table is interpreted by the query language as the time when the
combination of values of the columns in the row was valid. This implicit
timestamp allows queries to be expressed succinctly and intuitively.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>A CASE STUDY - STORING CURRENT INFORMATION
<p>
The University of Arizona's Office of Appointed Personnel has some
information in a database, including each employee's name, their current
salary, and their current title. This can be represented by a simple table.
<tscreen><verb>
        Employee(Name, Salary, Title)
</verb></tscreen>
Given this table, finding an employee's salary is easy.
<tscreen><verb>
        SELECT Salary
        FROM Employee
        WHERE Name = 'Bob'
</verb></tscreen>
Now the OAP wishes to record the date of birth. To do so, a column is added
to the table, yielding the following schema.
<tscreen><verb>
        Employee(Name, Salary, Title, DateofBirth DATE)
</verb></tscreen>
Finding the employee's date of birth is analogous to determining the salary.
<tscreen><verb>
        SELECT DateofBirth
        FROM Employee
        WHERE Name = 'Bob'
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>A CASE STUDY - STORING HISTORY INFORMATION
<p>
The OAP wishes to computerize the employment history. To do so, they append
two columns, one indicating when the information in the row became valid,
the other indicating when the information was no longer valid.

Employee (Name, Salary, Title, DateofBirth, Start DATE, Stop DATE)

To the data model, these new columns are identical to DateofBirth. However,
their presence has wide-ranging consequences.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>A CASE STUDY - PROJECTION
<p>
To find an employee's current salary, things are more difficult.
<tscreen><verb>
        SELECT Salary
        FROM Employee
        WHERE Name = 'Bob' AND Start <= CURRENT_DATE AND CURRENT_DATE <= Stop
</verb></tscreen>
This query is more complicated than the previous one. The culprit is
obviously the two new columns. The OAP wants to distribute to each employee
their salary history. Specifically, for each person, the maximal intervals
at each salary needs to be determined. Unfortunately, this is not possible
in SQL. An employee could have arbitrarily many title changes between salary
changes.
<tscreen><verb>
Name    Salary  Title             DateofBirth   Start           Stop
----    ------  -----             -----------   -----           ----
Bob     60000   Assistant Provost 1945-04-09    1993-01-01      1993-05-30
Bob     70000   Assistant Provost 1945-04-09    1993-06-01      1993-09-30
Bob     70000   Provost           1945-04-09    1993-10-01      1994-01-31
Bob     70000   Professor         1945-04-09    1994-02-01      1994-12-31

                               Figure 1
</verb></tscreen>
Note that there are three rows in which Bob's salary remained constant at
$70,000. Hence, the result should be two rows for Bob.
<tscreen><verb>
Name    Salary  Start           Stop
----    ------  -----           ----
Bob     60000   1993-01-01      1993-05-30
Bob     70000   1993-06-01      1994-12-31
</verb></tscreen>
One alternative is to give the user a printout of Salary and Title
information, and have user determine when his/her salary changed. This
alternative is not very appealing or realistic. A second alternative is to
use SQL as much as possible.
<tscreen><verb>
CREATE TABLE Temp(Salary, Start, Stop)
AS      SELECT Salary, Start, Stop
        FROM Employee;
</verb></tscreen>
repeat
<tscreen><verb>
        UPDATE Temp T1
        SET (T1.Stop) = (SELECT MAX(T2.Stop)
                         FROM Temp AS T2
                         WHERE T1.Salary = T2.Salary AND T1.Start < T2.Start
                                AND T1.Stop >= T2.Start AND T1.Stop < T2.Stop)
        WHERE EXISTS (SELECT *
                      FROM Temp AS T2
                      WHERE T1.Salary = T2.Salary AND T1.Start < T2.Start
                                AND T1.Stop >= T2.Start AND T1.Stop < T2.Stop)
        until no rows updated;

DELETE FROM Temp T1

WHERE EXISTS (SELECT *
              FROM Temp AS T2
              WHERE T1.Salary = T2.Salary
                        AND ((T1.Start > T2.Start AND T1.Stop <= T2.Stop)
                        OR (T1.Start >= T2.Start AND T1.Stop < T2.Stop))
</verb></tscreen>
The loop finds those intervals that overlap or are adjacent and thus should
be merged. The loop is executed log N times in the worst case, where N is
the number of rows in a chain of overlapping or adjacent value-equivalent
rows. The reader can simulate the query on the example table to convince
him/herself of its correctness.

A third alternative is to use SQL only to open a cursor on the table. A
linked list of periods is maintained, each with a salary. This linked list
should be initialized to empty.
<tscreen><verb>
DECLARE emp_cursor CURSOR FOR
        SELECT Salary, Title, Start, Stop
        FROM Employee;
OPEN emp_cursor;
loop:
        FETCH emp_cursor INTO :salary, :start, :stop;
        if no-data returned then goto finished;
        find position in linked list to insert this information;
        goto loop;
finished:
CLOSE emp_cursor;
</verb></tscreen>
iterate through linked list, printing out dates and salaries

The linked list may not be necessary in this case if the cursor is ORDER BY
Start.

In any case, the query, a natural one, is quite difficult to express using
the facilities present in SQL-92. The query is trivial in TSQL2.
<tscreen><verb>
        SELECT Salary
        FROM Employee
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>A CASE STUDY - JOIN
<p>
A more drastic approach is to avoid the problem of extracting the salary
history by reorganizing the schema to separate salary, title, and date of
birth information (in the following, we ignore the date of birth, for
simplicity).
<tscreen><verb>
        Employee1 (Name, Salary, Start DATE, Stop DATE)
        Employee2 (Name, Title, Start DATE, Stop DATE)
</verb></tscreen>
The Employee1 table is as follows.
<tscreen><verb>
Name    Salary  Start           Stop
----    ------  -----           ----
Bob     60000   1993-01-01      1993-05-30
Bob     70000   1993-06-01      1993-12-31
</verb></tscreen>
Here is the example Employee2 table.
<tscreen><verb>
Name    Title                   Start           Stop
----    ------                  -----           ----
Bob     Assistant Provost       1993-01-01      1993-09-30
Bob     Provost                 1993-10-01      1994-01-31
Bob     Professor               1994-02-01      1994-12-31
</verb></tscreen>
With this change, getting the salary information for an employee is now
easy.
<tscreen><verb>
        SELECT Salary, Start, Stop
        FROM Employee1
        WHERE Name = 'Bob'
</verb></tscreen>
But what if the OAP wants a table of salary, title intervals (that is,
suppose the OAP wishes a table to be computed in the form of Figure 1)? One
alternative is to print out two tables, and let the user figure out the
combinations. A second alternative is to use SQL entirely. Unfortunately,
this query must do a case analysis of how each row of Employee1 overlaps
each row of Employee2; there are four possible cases.
<tscreen><verb>
SELECT Employee1.Name, Salary, Dept, Employee1.Start, Employee1.Stop
FROM Employee1, Employee2
WHERE Employee1.Name = Employee2.Name
     AND Employee2.Start <= Employee1.Start AND Employee1.Stop < Employee2.Stop
UNION
SELECT Employee1.Name, Salary, Dept, Employee1.Start, Employee2.Stop
FROM Employee1, Employee2
WHERE Employee1.Name = Employee2.Name
     AND Employee1.Start >= Employee2.Start AND Employee2.Stop < Employee1.Stop
        AND Employee1.Start < Employee2.Stop
UNION
SELECT Employee1.Name, Salary, Dept, Employee2.Start, Employee1.Stop
FROM Employee1, Employee2
WHERE Employee1.Name = Employee2.Name
     AND Employee2.Start > Employee1.Start AND Employee1.Stop < Employee2.Stop
        AND Employee2.Start < Employee1.Stop
UNION
SELECT Employee1.Name, Salary, Dept, Employee2.Start, Employee2.Stop
FROM Employee1, Employee2
WHERE Employee1.Name = Employee2.Name
     AND Employee2.Start > Employee1.Start AND Employee2.Stop < Employee1.Stop
</verb></tscreen>
Getting all the cases right is a challenging task. In TSQL2, performing a
temporal join is just what one would expect.
<tscreen><verb>
        SELECT Employee1.Name, Salary, Dept
        FROM Employee1, Employee2
        WHERE Employee1.Name = Employee2.Name
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>A CASE STUDY - AGGREGATES
<p>
Now the OAP is asked, what is the maximum salary? Before adding time, this
was easy.
<tscreen><verb>
        SELECT MAX(Salary)
        FROM Employee
</verb></tscreen>
Now that the salary history is stored, we'd like a history of the maximum
salary over time. The problem, of course, is that SQL does not provide
temporal aggregates. The easy way to do this is to print out the
information, and scan manually for the maximums. An alternative is to be
tricky and convert the snapshot aggregate query into a non-aggregate query,
then convert that into a temporal query. The non-aggregate query finds those
salaries for which a greater salary does not exist.
<tscreen><verb>
        SELECT Salary
        FROM Employee AS E1
        WHERE NOT EXISTS (SELECT *
                          FROM Employee AS E2
                          WHERE E2.Salary > E1.Salary)
</verb></tscreen>
Converting this query into a temporal query is far from obvious. The
following is one approach.
<tscreen><verb>
CREATE TABLE Temp (Salary, Start, Stop)
AS      SELECT Salary, Start, Stop
        FROM Employee;
INSERT INTO Temp
        SELECT T.Salary, T.Start, E.Start
        FROM Temp AS T, Employee AS E
        WHERE E.Start >= T.Start AND E.Start < T.Stop AND E.Salary > T.Salary;

INSERT INTO Temp
        SELECT T.Salary, T.Stop, E.Stop
        FROM Temp AS T, Employee AS E
        WHERE E.Stop > T.Start AND E.Stop <= T.Stop AND E.Salary > T.Salary;
DELETE FROM Temp T
WHERE EXISTS (SELECT *
              FROM Employee AS E
              WHERE ((T.Start => E.Start AND T.Start < E.Stop)
                        OR (E.Start >= T.Start AND E.Start < T.Stop))
                    AND E.Salary > T.Salary;
</verb></tscreen>
This approach creates an auxiliary table. We add to this table the lower
period of a period subtraction and the upper period of a period subtraction.
We then delete all periods that overlap with some row defined by the
subquery, thereby effecting the NOT EXISTS. Finally we generate from the
auxiliary table maximal periods, in the same way that the salary information
was computed above. As one might imagine, such SQL code is extremely
inefficient to execute, given the complex nested queries with inequality
predicates.

A third alternative is to use SQL as little as possible, and instead compute
the desired maximum history in a host language using cursors.

The query in TSQL2 is again straightforward and intuitive.
<tscreen><verb>
        SELECT MAX(Salary)
        FROM Employee
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect2>SUMMARY
<p>
Time-varying data is manipulated in most database applications. Valid-time
support is absent in SQL. Many common temporal queries are either difficult
to simulate in SQL, or require embedding SQL in a procedural language, due
to SQL's lack of support for valid-time tables in its data model and query
constructs.

Elsewhere, we showed that adding valid-time support requires few changes to
the DBMS implementation, can dramatically simplify some queries and enable
others, and can later enable optimizations in storage structures, indexing
methods, and optimization strategies that can yield significant performance
improvements.

With a new part of SQL3 supporting time-varying information, we can begin to
address such applications, enabling SQL3 to better manage temporal data.
<tscreen><verb>
----------------------------------------------------------------------------
           Accredited Standards Committee* X3, Information Technology
NEWS RELEASE

Doc. No.:       PR/96-0002

Reply to:       Barbara Bennett at bbennett@itic.nw.dc.us

             X3 Announces the Approval of a New Project, ISO/IEC

                         9075 Part 7:  SQL/Temporal

Washington D.C., January 1996 
----------------------------------------------------------------------------
</verb></tscreen>
-- Accredited Standards Committee
X3, Information Technology is announcing the approval of a new 
project on SQL/Temporal Support, ISO/IEC 9075 Part 7, with the work 
being done in Technical Committee X3H2, Database.  
The scope of this proposed standard specifies a new Part of the emerging 
SQL3 standard, e.g., Part 7, Temporal SQL, to be extensions to the SQL 
language supporting storage, retrieval, and manipulation of temporal data 
in an SQL database environment.  
The next X3H2 meeting is scheduled for March 11-14, 1996 in 
Kansas.

Inquiries regarding this project should be sent to the 
<tscreen><verb>
	Chairman of X3H2, 
	Dr. Donald R. Deutsch, 
	Sybase, Inc., Suite 800, 
	6550 Rock Spring
	Drive, Bethesda, MD  20817. 
	Email: deutsch@sybase.com.
</verb></tscreen>
An initial call for possible patents and other pertinent issues 
(copyrights, trademarks) is now being issued.  Please submit 
information on these issues to the 
<tscreen><verb>
	X3 Secretariat at 
	1250 Eye Street
	NW, Suite 200,
	Washington DC  20005.
	Email: x3sec@itic.nw.dc.us
	FAX:  (202)638-4922.
</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1>
Part 8 - ISO/ANSI SQL MULTIMEDIA (SQL/MM)
<p>
A new ISO/IEC international standardization project for development of an
SQL class library for multimedia applications was approved in early 1993.
This new standardization activity, named SQL Multimedia (SQL/MM), will
specify packages of SQL abstract data type (ADT) definitions using the
facilities for ADT specification and invocation provided in the emerging
SQL3 specification. SQL/MM intends to standardize class libraries for
science and engineering, full-text and document processing, and methods for
the management of multimedia objects such as image, sound, animation, music,
and video. It will likely provide an SQL language binding for multimedia
objects defined by other JTC1 standardization bodies (e.g. SC18 for
documents, SC24 for images, and SC29 for photographs and motion pictures).

The Project Plan for SQL/MM indicates that it will be a multi-part standard
consisting of an evolving number of parts. Part 1 will be a Framework that
specifies how the other parts are to be constructed. Each of the other parts
will be devoted to a specific SQL application package. The following SQL/MM
Part structure exists as of August 1994:

<itemize>
<item>   Part 1: Framework A non-technical description of how the document is
     structured.
<item>   Part 2: Full Text Methods and ADTs for text data processing. About 45
     pages.
<item>   Part 3: Spatial Methods and ADTs for spatial data management. About 200
     pages with active contributions from Spatial Data experts from 3
     national bodies.
<item>   Part 4: General Purpose Methods and ADTs for complex numbers,
     Facilities include trig and exponential functions, vectors, sets, etc.
     Currently about 90 pages.
</itemize>

There are a number of standards efforts in the area of Spatial and
Geographic information:

<itemize>
<item>   ANSI X3L1 - Geographic Information Systems.
     Mark Ashworth of Unisys is the liason between X3L1 and ANSI X3H2. He is
     also the editor for parts 1, 3, and 4 of the SQL/MM draft.
<item>   ISO TC 211 - Geographic information/Geomatics
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Technical support for PostgreSQL
-->
<sect>Technical support for PostgreSQL
<p>
If you have any technical question or encounter any problem you can e-mail
to: 
<itemize>
<item>	<htmlurl url="mailto:pgsql-questions@postgresql.org"
             name="pgsql-questions@postgresql.org">
<item> Newsgroup <url url="comp.databases.postgresql.general">
<item> Newsgroup <url url="comp.databases.postgresql.hackers">
<item> Newsgroup <url url="comp.databases.postgresql.doc">
<item> Newsgroup <url url="comp.databases.postgresql.bugs">
<item> Newsgroup <url url="linux.postgres">
<item> Other Mailing lists <url url="http://www.postgresql.org">
</itemize>
and expect e-mail answer in less than a day. As the user-base of internet product
is very vast, and users support other users, internet will be capable 
of giving technical support to billions of users 
easily. Email support is 
much more convenient than telephone support as you can cut and paste error 
messages, program output etc.. and easily transmit to mailing list/newsgroup.

<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<sect1>Commercial Support
<p>
PostgreSQL organisation is selling technical support to
companies, the revenue generated will be used for maintaining
several mirror sites (web and ftp) around the world. The revenue will also be
used to produce printed documentation, guides, textbooks which will help the 
customers. They are at 
<url url="http://www.postgresql.org">

Another company called 'Great Bridge Corporation' is doing development, sales
and support of PostgreSQL. They are at 
<url url="http://www.greatbridge.com">. It is a public company setup by 'Landmark 
Communications corp' and other venture capital firms to exclusively sell and 
support PostgreSQL
to very large enterprises and corporations all over the world.

You can also take help from professional consulting firms like RedHat, Anderson, 
WGS (Work Group Solutions). Contact them for help, since they have very good expertise
in "C", "C++" (PostgreSQL is written in "C") -
<itemize>
<item> Redhat Corp - Database consulting division <url url="http://www.redhat.com">
<item> Work Group Solutions <url url="http://www.wgs.com">
<item> Anderson Consulting <url url="http://www.ac.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt>Economic and Business Aspects
-->
<sect>Economic and Business Aspects
<p>
Commercial databases pay many taxes like federal, state, sales, employment,
social security, medicare taxes, health care for employees, bunch of benefits 
for employees, marketing and advertisement costs. All these costs do not go
directly for the development of the database and do not improve the quality or
technology of the database. When you buy a commercial database,
some portion of the amount goes for overheads like taxes, expenses and balance
for database R&amp;D costs. 

Also commercial databases have to pay for buildings/real-estates and 
purchase Unix machines, install and maintain them. All of these costs 
are passed onto customers.

PostgreSQL has the advantage over commercial databases as there is no direct
taxes since it is made on the internet. A very vast group of people contribute 
to the development of the PostgreSQL. For example, in a hypothetical case, if
there are one million companies in U.S.A and each contribute about &dollar 10
(worth of software to PostgreSQL) then each and every company will get ten 
million dollars!! This is the <bf>GREAT MAGIC</bf> of software development on internet.
<p>
Currently, PostgreSQL source code is 
about 2,50,000 lines of "C", "C++" code. If cost of each line of "C" code 
is &dollar 2 then the PostgreSQL is worth about 
&dollar 5,00,000 (half a million dollars!).
<p>
Many companies already develop in-house vast amount of "C", "C++" code. Hence 
by taking in the source code of PostgreSQL and collaborating with other 
companies on internet will greatly benefit the company saving time and efforts.
<!--
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> List of Other Databases
-->
<sect> List of Other Databases
<p>
Listed below are other SQL databases for Unix, Linux.
<itemize>
<item> Click and go to Applications->databases.
<url url="http://www.caldera.com/tech-ref/linuxapps/linapps.html">
<item> Click and go to Applications->databases.
<url url="http://www.xnet.com/~blatura/linapps.shtml">

<item> Database resources <url url="http://linas.org/linux/db.html">
This was written by Linas Vepstas: 
<htmlurl url="mailto:linas@fc.net" 
	name="linas@fc.net">

<item> Free Database List
<url url="http://cuiwww.unige.ch:80/~scg/FreeDB/FreeDB.list.html">

<item> Browne's RDBMS List
<url url="http://www.hex.net/~cbbrowne/rdbms.html">
written by Christopher B. Browne 
<htmlurl url="mailto:cbbrowne@hex.net" 
	name="cbbrowne@hex.net">

<item> SAL's List of Relational DBMS
<url url="http://SAL.KachinaTech.COM/H/1/">

<item> SAL's List of Object-Oriented DBMS
<url url="http://SAL.KachinaTech.COM/H/2/">

<item> SAL's List of Utilites and Other Databases
<url url="http://SAL.KachinaTech.COM/H/3/">

<item> ACM SIGMOD Index of Publicly Available Database Software
<url url="http://bunny.cs.uiuc.edu/sigmod/databaseSoftware/">

</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Internet World Wide Web Searching Tips
-->
<sect> Internet World Wide Web Searching Tips
<p>
Internet is very vast and it has vast number of software and has a ocean of
information underneath. It is growing at the rate of 300% annually world
wide. It is estimated that there are about 10 million Web sites world wide!

To search for a information you would use search engines like "Yahoo",
"Netscape", "Lycos" etc. Go to Yahoo, click on search.
Use filtering options to narrow down your search criteria. The default 
search action is "Intelligent search" which is more general and lists
all possiblities. Click on "Options" to select
"EXACT phrase" search, "AND" search, "OR" search, etc.. This way you
would find the information you need much faster. Also in the search menu, there are
radio-buttons for searching in Usenet, Web-sites and Yahoo sites.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Conclusion
-->
<sect> Conclusion
<p>
After researching all the available databases which are <bf>free</bf> and source code 
is available, it was found that ONLY PostgreSQL is the MOST mature, most 
widely used and robust RDBMS SQL free database (object relational) in the world.

PostgreSQL is very appealing since lot of work had already been done. It
has ODBC and JDBC drivers, using these it is possible to write applications
independent of the databases. The applications written in PostgreSQL using 
ODBC, JDBC drivers are easily portable to other databases like Oracle, 
Sybase and Informix and vice versa. 

You may ask "But why PostgreSQL ?" The answer is, since it takes 
lot more time to develop a database
system from scratch, it makes sense to pick up a database system 
which satisfies the following conditions -

A database system
<itemize>
<item> Whose source code is available - Must be a 'Open Source Code' system
<item> Has no license strings, no ownership strings attached to it
<item> Which can be distributed on internet
<item> Which had been on development for several years.
<item> Which satisfies standards like ISO/ANSI SQL 92 (and SQL 89)
<item> Which can satisfy future needs like SQL 3 (SQL 98)
<item> Which has advanced capabilities
</itemize>
And it just happens to be 'PostgreSQL' which satisfies all these
conditions and is an appropriate software for this situation.
You may say 'PostgreSQL' is a very strange name. But my argument is - why 
change the name. This world is stuck with "PostgreSQL" forever!!
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> FAQ - Questions on PostgreSQL
-->
<sect> FAQ - Questions on PostgreSQL
<p>
Please refer to the latest version of FAQ for General, Linux and Irix at 
<itemize>
<item> <url url="http://www.postgresql.org/docs/faq-english.shtml">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Other Formats of this Document
-->
<sect> Other Formats of this Document
<p>
This document is published in 11 different formats namely - DVI, Postscript, 
Latex, Adobe Acrobat PDF,
LyX, GNU-info, HTML, RTF(Rich Text Format), Plain-text, Unix man pages and SGML.
<itemize>
<item>
You can get this HOWTO document as a single file tar ball in HTML, DVI, 
Postscript or SGML formats from -
<url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/other-formats/">

<item>Plain text format is in: <url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">

<item>Translations to other languages like French, German, Spanish, 
Chinese, Japanese are in
<url url="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">
Any help from you to translate to other languages is welcome.
</itemize>
The document is written using a tool called "SGML-Tools" which can be got from - 
<url url="http://www.sgmltools.org">
Compiling the source you will get the following commands like
<itemize>
<item>sgml2html databasehowto.sgml     (to generate html file)
<item>sgml2rtf  databasehowto.sgml     (to generate RTF file)
<item>sgml2latex databasehowto.sgml    (to generate latex file)
</itemize>

LaTeX documents may be converted into PDF files simply by 
producing a Postscript output using <bf>sgml2latex</bf> ( and dvips) and running the
output through the Acrobat <bf>distill</bf> (<url url="http://www.adobe.com">) command as follows: 
<code>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &
</code>
Or you can use Ghostscript command <bf>ps2pdf</bf>.
ps2pdf is a work-alike for nearly all the functionality of 
Adobe's Acrobat Distiller product: it
converts PostScript files to Portable Document Format (PDF) files. 
<bf>ps2pdf</bf> is implemented as a very small command script (batch file) that invokes Ghostscript, selecting a special "output device"
called <bf>pdfwrite</bf>. In order to use ps2pdf, the pdfwrite device must be included in the makefile when Ghostscript was compiled;
see the documentation on building Ghostscript for details.

This howto document is located at -
<itemize>
<item> <url url="http://sunsite.unc.edu/LDP/HOWTO/PostgreSQL-HOWTO.html">
</itemize>

Also you can find this document at the following mirrors sites -
<itemize>
<item> <url url="http://www.caldera.com/LDP/HOWTO/PostgreSQL-HOWTO.html">
<item> <url url="http://www.WGS.com/LDP/HOWTO/PostgreSQL-HOWTO.html">
<item> <url url="http://www.cc.gatech.edu/linux/LDP/HOWTO/PostgreSQL-HOWTO.html">
<item> <url url="http://www.redhat.com/linux-info/ldp/HOWTO/PostgreSQL-HOWTO.html">

<item> Other mirror sites near you (network-address-wise) can be found at
<url url="http://sunsite.unc.edu/LDP/hmirrors.html">
select a site and go to directory /LDP/HOWTO/PostgreSQL-HOWTO.html
</itemize>


In order to view the document in dvi format, use the xdvi program. The xdvi
program is located in tetex-xdvi*.rpm package in Redhat Linux which can be
located through ControlPanel | Applications | Publishing | TeX menu buttons.
	To read dvi document give the command -
<tscreen><verb>
	xdvi -geometry 80x90 howto.dvi
	man xdvi
</verb></tscreen>
	And resize the window with mouse.
	To navigate use Arrow keys, Page Up, Page Down keys, also
	you can use 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' letter
	keys to move up, down, center, next page, previous page etc.
	To turn off expert menu press 'x'.

You can read postscript file using the program 'gv' (ghostview) or 
'ghostscript'.
The ghostscript program is in ghostscript*.rpm package and gv 
program is in gv*.rpm package in Redhat Linux
which can be located through ControlPanel | Applications | Graphics menu 
buttons. The gv program is much more user friendly than ghostscript.
Also ghostscript and gv are available on other platforms like OS/2,
Windows 95 and NT, you view this document even on those platforms.
 
<itemize>
<item>Get ghostscript for Windows 95, OS/2, and for all OSes from <url url="http://www.cs.wisc.edu/~ghost">
</itemize>

To read postscript document give the command -
<tscreen><verb>
		gv howto.ps
		ghostscript howto.ps
</verb></tscreen>
<bf>CAUTION: </bf>This document is large, total number of pages (postscript)
if printed will be approximately 113 pages.

You can read HTML format document using Netscape Navigator, Microsoft Internet
explorer, Redhat Baron Web browser or any of the 10 other web browsers.

You can read the latex, LyX output using LyX a X-Windows front end to latex.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt change> Copyright and License
-->
<sect> Copyright and License
<p>
Copyright Al Dev (Alavoor Vasudevan) 1997-2000.

License policy is GNU/GPL as per LDP (Linux Documentation project).
LDP is a GNU/GPL project.
Additional restrictions are - you must retain the author's name, email address
and this copyright notice on all the copies. If you make any changes 
or additions to this document then you should 
intimate all the authors of this document.

NO LIABILITY FOR CONSEQUENTIAL DAMAGES. In no event 
shall the author/authors of this document be liable for any 
damages whatsoever (including without limitation,
special, incidental, consequential, or direct/indirect damages for personal
injury, loss of business profits, business
interruption, loss of business information, or any other pecuniary loss)
arising out of the use of this document. 

Author/authors offers no warranties or guarantees on fitness, usability, 
merchantability of this document. Brands, companies and product names 
mentioned in this document are 
trademarks or registered trademarks of their respective holders.
Please refer to individual copyright notices of brands, companies and
products mentioned in this document. It is your responsibility to read and 
understand the copyright notices of the organisations/companies/products/authors
mentioned in this document before using their respective information.
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




-->
<appendix>
<!-- 
	***********************************************************
	************ Beginning of APPENDIX Sections ***************
	***********************************************************




<chapt> Appendix A - Syntax of ANSI/ISO SQL 1992 <label id="Appendix A">
-->
<sect> Appendix A - Syntax of ANSI/ISO SQL 1992 <label id="Appendix A">
<p>
<tscreen><verb>
This file contains a depth-first tree traversal of the BNF
for the  language done at about 27-AUG-1992 11:03:41.64.
The specific version of the BNF included here is:  ANSI-only, SQL2-only.


<SQL terminal character> ::=
      <SQL language character>
    | <SQL embedded language character>

<SQL language character> ::=
      <simple Latin letter>
    | <digit>
    | <SQL special character>

<simple Latin letter> ::=
      <simple Latin upper case letter>
    | <simple Latin lower case letter>

<simple Latin upper case letter> ::=
          A | B | C | D | E | F | G | H | I | J | K | L | M | N | O
    | P | Q | R | S | T | U | V | W | X | Y | Z

<simple Latin lower case letter> ::=
          a | b | c | d | e | f | g | h | i | j | k | l | m | n | o
    | p | q | r | s | t | u | v | w | x | y | z

<digit> ::=
    0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

<SQL special character> ::=
      <space>
    | <double quote>
    | <percent>
    | <ampersand>
    | <quote>
    | <left paren>
    | <right paren>
    | <asterisk>
    | <plus sign>
    | <comma>
    | <minus sign>
    | <period>
    | <solidus>
    | <colon>
    | <semicolon>
    | <less than operator>
    | <equals operator>
    | <greater than operator>
    | <question mark>
    | <underscore>
    | <vertical bar>

<space> ::= !! <EMPHASIS>(space character in character set in use)

<double quote> ::= "

<percent> ::= %

<ampersand> ::= &

<quote> ::= '

<left paren> ::= (

<right paren> ::= )

<asterisk> ::= *

<plus sign> ::= +

<comma> ::= ,

<minus sign> ::= -

<period> ::= .

<solidus> ::= /

<colon> ::= :

<semicolon> ::= ;

<less than operator> ::= <

<equals operator> ::= =

<greater than operator> ::= >

<question mark> ::= ?

<underscore> ::= _

<vertical bar> ::= |

<SQL embedded language character> ::=
      <left bracket>
    | <right bracket>

<left bracket> ::= [

<right bracket> ::= ]

<token> ::=
      <nondelimiter token>
    | <delimiter token>

<nondelimiter token> ::=
      <regular identifier>
    | <key word>
    | <unsigned numeric literal>
    | <national character string literal>
    | <bit string literal>
    | <hex string literal>

<regular identifier> ::= <identifier body>

<identifier body> ::=
    <identifier start> [ ( <underscore> | <identifier part> )... ]

<identifier start> ::= <EMPHASIS>(!! See the Syntax Rules)

<identifier part> ::=
      <identifier start>
    | <digit>

<key word> ::=
      <reserved word>
    | <non-reserved word>

<reserved word> ::=
      ABSOLUTE | ACTION | ADD | ALL
    | ALLOCATE | ALTER | AND
    | ANY | ARE
    | AS | ASC
    | ASSERTION | AT
    | AUTHORIZATION | AVG
    | BEGIN | BETWEEN | BIT | BIT_LENGTH
    | BOTH | BY
    | CASCADE | CASCADED | CASE | CAST
    | CATALOG
    | CHAR | CHARACTER | CHAR_LENGTH
    | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE
    | COLLATE | COLLATION
    | COLUMN | COMMIT
    | CONNECT
    | CONNECTION | CONSTRAINT
    | CONSTRAINTS | CONTINUE
    | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS
    | CURRENT
    | CURRENT_DATE | CURRENT_TIME
    | CURRENT_TIMESTAMP | CURRENT_USER | CURSOR
    | DATE | DAY | DEALLOCATE | DEC
    | DECIMAL | DECLARE | DEFAULT | DEFERRABLE
    | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR
    | DIAGNOSTICS
    | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP
    | ELSE | END | END-EXEC | ESCAPE
    | EXCEPT | EXCEPTION
    | EXEC | EXECUTE | EXISTS
    | EXTERNAL | EXTRACT
    | FALSE | FETCH | FIRST | FLOAT | FOR
    | FOREIGN | FOUND | FROM | FULL
    | GET | GLOBAL | GO | GOTO
    | GRANT | GROUP
    | HAVING | HOUR
    | IDENTITY | IMMEDIATE | IN | INDICATOR
    | INITIALLY | INNER | INPUT
    | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT
    | INTERVAL | INTO | IS
    | ISOLATION
    | JOIN
    | KEY
    | LANGUAGE | LAST | LEADING | LEFT
    | LEVEL | LIKE | LOCAL | LOWER
    | MATCH | MAX | MIN | MINUTE | MODULE
    | MONTH
    | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO
    | NOT | NULL
    | NULLIF | NUMERIC
    | OCTET_LENGTH | OF
    | ON | ONLY | OPEN | OPTION | OR
    | ORDER | OUTER
    | OUTPUT | OVERLAPS
    | PAD | PARTIAL | POSITION | PRECISION | PREPARE
    | PRESERVE | PRIMARY
    | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC
    | READ | REAL | REFERENCES | RELATIVE | RESTRICT
    | REVOKE | RIGHT
    | ROLLBACK | ROWS
    | SCHEMA | SCROLL | SECOND | SECTION
    | SELECT
    | SESSION | SESSION_USER | SET
    | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE
    | SQLERROR | SQLSTATE
    | SUBSTRING | SUM | SYSTEM_USER
    | TABLE | TEMPORARY
    | THEN | TIME | TIMESTAMP
    | TIMEZONE_HOUR | TIMEZONE_MINUTE
    | TO | TRAILING | TRANSACTION
    | TRANSLATE | TRANSLATION | TRIM | TRUE
    | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE
    | USER | USING
    | VALUE | VALUES | VARCHAR | VARYING | VIEW
    | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE
    | YEAR
    | ZONE

<non-reserved word> ::=
    
      ADA
    | C | CATALOG_NAME
    | CHARACTER_SET_CATALOG | CHARACTER_SET_NAME
    | CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_CATALOG
    | COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_FUNCTION
    | COMMITTED
    | CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_NAME
    | CONSTRAINT_SCHEMA | CURSOR_NAME
    | DATA | DATETIME_INTERVAL_CODE
    | DATETIME_INTERVAL_PRECISION | DYNAMIC_FUNCTION
    | FORTRAN
    | LENGTH
    | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS
    | NAME | NULLABLE | NUMBER
    | PASCAL | PLI
    | REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_SQLSTATE
    | ROW_COUNT
    | SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_ORIGIN
    | TABLE_NAME | TYPE
    | UNCOMMITTED | UNNAMED

<unsigned numeric literal> ::=
      <exact numeric literal>
    | <approximate numeric literal>

<exact numeric literal> ::=
      <unsigned integer> [ <period> [ <unsigned integer> ] ]
    | <period> <unsigned integer>

<unsigned integer> ::= <digit>...

<approximate numeric literal> ::= <mantissa> E <exponent>

<mantissa> ::= <exact numeric literal>

<exponent> ::= <signed integer>

<signed integer> ::= [ <sign> ] <unsigned integer>

<sign> ::= <plus sign> | <minus sign>

<national character string literal> ::=
    N <quote> [ <character representation>... ] <quote>
      [ ( <separator>... <quote> [ <character representation>... ] <quote> )... ]

<character representation> ::=
      <nonquote character>
    | <quote symbol>

<nonquote character> ::= !! <EMPHASIS>(See the Syntax Rules.)

<quote symbol> ::= <quote><quote>

<separator> ::= ( <comment> | <space> | <newline> )...

<comment> ::=
    <comment introducer> [ <comment character>... ] <newline>

<comment introducer> ::= <minus sign><minus sign>[<minus sign>...]

<comment character> ::=
      <nonquote character>
    | <quote>

<newline> ::= !! <EMPHASIS>(implementation-defined end-of-line indicator)

<bit string literal> ::=
    B <quote> [ <bit>... ] <quote>
      [ ( <separator>... <quote> [ <bit>... ] <quote> )... ]

<bit> ::= 0 | 1

<hex string literal> ::=
    X <quote> [ <hexit>... ] <quote>
      [ ( <separator>... <quote> [ <hexit>... ] <quote> )... ]

<hexit> ::= <digit> | A | B | C | D | E | F | a | b | c | d | e | f

<delimiter token> ::=
      <character string literal>
    | <date string>
    | <time string>
    | <timestamp string>
    | <interval string>
    | <delimited identifier>
    | <SQL special character>
    | <not equals operator>
    | <greater than or equals operator>
    | <less than or equals operator>
    | <concatenation operator>
    | <double period>
    | <left bracket>
    | <right bracket>

<character string literal> ::=
    [ <introducer><character set specification> ]
    <quote> [ <character representation>... ] <quote>
      [ ( <separator>... <quote> [ <character representation>... ] <quote> )... ]

<introducer> ::= <underscore>

<character set specification> ::=
      <standard character repertoire name>
    | <implementation-defined character repertoire name>
    | <user-defined character repertoire name>
    | <standard universal character form-of-use name>
    | <implementation-defined universal character form-of-use name>

<standard character repertoire name> ::= <character set name>

<character set name> ::= [ <schema name> <period> ]
      <SQL language identifier>

<schema name> ::=
    [ <catalog name> <period> ] <unqualified schema name>

<catalog name> ::= <identifier>

<identifier> ::=
    [ <introducer><character set specification> ] <actual identifier>

<actual identifier> ::=
      <regular identifier>
    | <delimited identifier>

<delimited identifier> ::=
    <double quote> <delimited identifier body> <double quote>

<delimited identifier body> ::= <delimited identifier part>...

<delimited identifier part> ::=
      <nondoublequote character>
    | <doublequote symbol>

<nondoublequote character> ::= <EMPHASIS>(!! See the Syntax Rules)

<doublequote symbol> ::= <double quote><double quote>

<unqualified schema name> ::= <identifier>

<SQL language identifier> ::=
    <SQL language identifier start>
       [ ( <underscore> | <SQL language identifier part> )... ]

<SQL language identifier start> ::= <simple Latin letter>

<SQL language identifier part> ::=
      <simple Latin letter>
    | <digit>

<implementation-defined character repertoire name> ::=
    <character set name>

<user-defined character repertoire name> ::= <character set name>

<standard universal character form-of-use name> ::=
    <character set name>

<implementation-defined universal character form-of-use name> ::=
    <character set name>

<date string> ::=
    <quote> <date value> <quote>

<date value> ::=
    <years value> <minus sign> <months value>
        <minus sign> <days value>

<years value> ::= <datetime value>

<datetime value> ::= <unsigned integer>

<months value> ::= <datetime value>

<days value> ::= <datetime value>

<time string> ::=
    <quote> <time value> [ <time zone interval> ] <quote>

<time value> ::=
    <hours value> <colon> <minutes value> <colon> <seconds value>

<hours value> ::= <datetime value>

<minutes value> ::= <datetime value>

<seconds value> ::=
      <seconds integer value> [ <period> [ <seconds fraction> ] ]

<seconds integer value> ::= <unsigned integer>

<seconds fraction> ::= <unsigned integer>

<time zone interval> ::=
    <sign> <hours value> <colon> <minutes value>

<timestamp string> ::=
    <quote> <date value> <space> <time value>
        [ <time zone interval> ] <quote>

<interval string> ::=
    <quote> ( <year-month literal> | <day-time literal> ) <quote>

<year-month literal> ::=
      <years value>
    | [ <years value> <minus sign> ] <months value>

<day-time literal> ::=
      <day-time interval>
    | <time interval>

<day-time interval> ::=
    <days value>
      [ <space> <hours value> [ <colon> <minutes value>
        [ <colon> <seconds value> ] ] ]

<time interval> ::=
      <hours value> [ <colon> <minutes value> [ <colon> <seconds value> ] ]
    | <minutes value> [ <colon> <seconds value> ]
    | <seconds value>

<not equals operator> ::= <>

<greater than or equals operator> ::= >=

<less than or equals operator> ::= <=

<concatenation operator> ::= ||

<double period> ::= ..

<module> ::=
    <module name clause>
    <language clause>
    <module authorization clause>
    [ <temporary table declaration>... ]
    <module contents>...

<module name clause> ::=
    MODULE [ <module name> ]
      [ <module character set specification> ]

<module name> ::= <identifier>

<module character set specification> ::=
    NAMES ARE <character set specification>

<language clause> ::=
    LANGUAGE <language name>

<language name> ::=
    ADA | C | COBOL | FORTRAN | MUMPS | PASCAL | PLI

<module authorization clause> ::=
      SCHEMA <schema name>
    | AUTHORIZATION <module authorization identifier>
    | SCHEMA <schema name>
          AUTHORIZATION <module authorization identifier>

<module authorization identifier> ::=
    <authorization identifier>

<authorization identifier> ::= <identifier>

<temporary table declaration> ::=
    DECLARE LOCAL TEMPORARY TABLE
        <qualified local table name>
      <table element list>
      [ ON COMMIT ( PRESERVE | DELETE ) ROWS ]

<qualified local table name> ::=
    MODULE <period> <local table name>

<local table name> ::= <qualified identifier>

<qualified identifier> ::= <identifier>

<table element list> ::=
      <left paren> <table element> [ ( <comma> <table element> )... ] <right paren>

<table element> ::=
      <column definition>
    | <table constraint definition>

<column definition> ::=
    <column name> ( <data type> | <domain name> )
    [ <default clause> ]
    [ <column constraint definition>... ]
    [ <collate clause> ]

<column name> ::= <identifier>

<data type> ::=
      <character string type>
           [ CHARACTER SET <character set specification> ]
    | <national character string type>
    | <bit string type>
    | <numeric type>
    | <datetime type>
    | <interval type>

<character string type> ::=
      CHARACTER [ <left paren> <length> <right paren> ]
    | CHAR [ <left paren> <length> <right paren> ]
    | CHARACTER VARYING <left paren> <length> <right paren>
    | CHAR VARYING <left paren> <length> <right paren>
    | VARCHAR <left paren> <length> <right paren>

<length> ::= <unsigned integer>

<national character string type> ::=
      NATIONAL CHARACTER [ <left paren> <length> <right paren> ]
    | NATIONAL CHAR [ <left paren> <length> <right paren> ]
    | NCHAR [ <left paren> <length> <right paren> ]
    | NATIONAL CHARACTER VARYING <left paren> <length> <right paren>
    | NATIONAL CHAR VARYING <left paren> <length> <right paren>
    | NCHAR VARYING <left paren> <length> <right paren>

<bit string type> ::=
      BIT [ <left paren> <length> <right paren> ]
    | BIT VARYING <left paren> <length> <right paren>

<numeric type> ::=
      <exact numeric type>
    | <approximate numeric type>

<exact numeric type> ::=
      NUMERIC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
    | DECIMAL [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
    | DEC [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
    | INTEGER
    | INT
    | SMALLINT

<precision> ::= <unsigned integer>

<scale> ::= <unsigned integer>

<approximate numeric type> ::=
      FLOAT [ <left paren> <precision> <right paren> ]
    | REAL
    | DOUBLE PRECISION

<datetime type> ::=
      DATE
    | TIME [ <left paren> <time precision> <right paren> ]
          [ WITH TIME ZONE ]
    | TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]
          [ WITH TIME ZONE ]

<time precision> ::= <time fractional seconds precision>

<time fractional seconds precision> ::= <unsigned integer>

<timestamp precision> ::= <time fractional seconds precision>

<interval type> ::= INTERVAL <interval qualifier>

<interval qualifier> ::=
      <start field> TO <end field>
    | <single datetime field>

<start field> ::=
    <non-second datetime field>
        [ <left paren> <interval leading field precision> <right paren> ]

<non-second datetime field> ::= YEAR | MONTH | DAY | HOUR
    | MINUTE

<interval leading field precision> ::= <unsigned integer>

<end field> ::=
      <non-second datetime field>
    | SECOND [ <left paren> <interval fractional seconds precision> <right paren> ]

<interval fractional seconds precision> ::= <unsigned integer>

<single datetime field> ::=
      <non-second datetime field>
          [ <left paren> <interval leading field precision> <right paren> ]
    | SECOND [ <left paren> <interval leading field precision>
          [ <comma> <interval fractional seconds precision> ] <right paren> ]

<domain name> ::= <qualified name>

<qualified name> ::=
    [ <schema name> <period> ] <qualified identifier>

<default clause> ::=
      DEFAULT <default option>

<default option> ::=
      <literal>
    | <datetime value function>
    | USER
    | CURRENT_USER
    | SESSION_USER
    | SYSTEM_USER
    | NULL

<literal> ::=
      <signed numeric literal>
    | <general literal>

<signed numeric literal> ::=
    [ <sign> ] <unsigned numeric literal>

<general literal> ::=
      <character string literal>
    | <national character string literal>
    | <bit string literal>
    | <hex string literal>
    | <datetime literal>
    | <interval literal>

<datetime literal> ::=
      <date literal>
    | <time literal>
    | <timestamp literal>

<date literal> ::=
    DATE <date string>

<time literal> ::=
    TIME <time string>

<timestamp literal> ::=
    TIMESTAMP <timestamp string>

<interval literal> ::=
    INTERVAL [ <sign> ] <interval string> <interval qualifier>

<datetime value function> ::=
      <current date value function>
    | <current time value function>
    | <current timestamp value function>

<current date value function> ::= CURRENT_DATE

<current time value function> ::=
      CURRENT_TIME [ <left paren> <time precision> <right paren> ]

<current timestamp value function> ::=
      CURRENT_TIMESTAMP [ <left paren> <timestamp precision> <right paren> ]

<column constraint definition> ::=
    [ <constraint name definition> ]
    <column constraint>
      [ <constraint attributes> ]

<constraint name definition> ::= CONSTRAINT <constraint name>

<constraint name> ::= <qualified name>

<column constraint> ::=
      NOT NULL
    | <unique specification>
    | <references specification>
    | <check constraint definition>

<unique specification> ::=
    UNIQUE | PRIMARY KEY

<references specification> ::=
    REFERENCES <referenced table and columns>
      [ MATCH <match type> ]
      [ <referential triggered action> ]

<referenced table and columns> ::=
     <table name> [ <left paren> <reference column list> <right paren> ]

<table name> ::=
      <qualified name>
    | <qualified local table name>

<reference column list> ::= <column name list>

<column name list> ::=
    <column name> [ ( <comma> <column name> )... ]

<match type> ::=
      FULL
    | PARTIAL

<referential triggered action> ::=
      <update rule> [ <delete rule> ]
    | <delete rule> [ <update rule> ]

<update rule> ::= ON UPDATE <referential action>

<referential action> ::=
      CASCADE
    | SET NULL
    | SET DEFAULT
    | NO ACTION

<delete rule> ::= ON DELETE <referential action>

<check constraint definition> ::=
    CHECK
        <left paren> <search condition> <right paren>

<search condition> ::=
      <boolean term>
    | <search condition> OR <boolean term>

<boolean term> ::=
      <boolean factor>
    | <boolean term> AND <boolean factor>

<boolean factor> ::=
    [ NOT ] <boolean test>

<boolean test> ::=
    <boolean primary> [ IS [ NOT ]
          <truth value> ]

<boolean primary> ::=
      <predicate>
    | <left paren> <search condition> <right paren>

<predicate> ::=
      <comparison predicate>
    | <between predicate>
    | <in predicate>
    | <like predicate>
    | <null predicate>
    | <quantified comparison predicate>
    | <exists predicate>
    | <unique predicate>
    | <match predicate>
    | <overlaps predicate>

<comparison predicate> ::=
    <row value constructor> <comp op>
        <row value constructor>

<row value constructor> ::=
       <row value constructor element>
    | <left paren> <row value constructor list> <right paren>
    | <row subquery>

<row value constructor element> ::=
      <value expression>
    | <null specification>
    | <default specification>

<value expression> ::=
      <numeric value expression>
    | <string value expression>
    | <datetime value expression>
    | <interval value expression>

<numeric value expression> ::=
      <term>
    | <numeric value expression> <plus sign> <term>
    | <numeric value expression> <minus sign> <term>

<term> ::=
      <factor>
    | <term> <asterisk> <factor>
    | <term> <solidus> <factor>

<factor> ::=
    [ <sign> ] <numeric primary>

<numeric primary> ::=
      <value expression primary>
    | <numeric value function>

<value expression primary> ::=
      <unsigned value specification>
    | <column reference>
    | <set function specification>
    | <scalar subquery>
    | <case expression>
    | <left paren> <value expression> <right paren>
    | <cast specification>

<unsigned value specification> ::=
      <unsigned literal>
    | <general value specification>

<unsigned literal> ::=
      <unsigned numeric literal>
    | <general literal>

<general value specification> ::=
      <parameter specification>
    | <dynamic parameter specification>
    | <variable specification>
    | USER
    | CURRENT_USER
    | SESSION_USER
    | SYSTEM_USER
    | VALUE

<parameter specification> ::=
    <parameter name> [ <indicator parameter> ]

<parameter name> ::= <colon> <identifier>

<indicator parameter> ::=
    [ INDICATOR ] <parameter name>

<dynamic parameter specification> ::= <question mark>

<variable specification> ::=
    <embedded variable name> [ <indicator variable> ]

<embedded variable name> ::=
    <colon><host identifier>

<host identifier> ::=
      <Ada host identifier>
    | <C host identifier>
    | <COBOL host identifier>
    | <Fortran host identifier>
    | <MUMPS host identifier>
    | <Pascal host identifier>
    | <PL/I host identifier>

<Ada host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<C host identifier> ::=
    !! <EMPHASIS>(See the Syntax Rules.)

<COBOL host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<Fortran host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<MUMPS host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<Pascal host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<PL/I host identifier> ::= !! <EMPHASIS>(See the Syntax Rules.)

<indicator variable> ::=
    [ INDICATOR ] <embedded variable name>

<column reference> ::= [ <qualifier> <period> ] <column name>

<qualifier> ::=
      <table name>
    | <correlation name>

<correlation name> ::= <identifier>

<set function specification> ::=
      COUNT <left paren> <asterisk> <right paren>
    | <general set function>

<general set function> ::=
      <set function type>
          <left paren> [ <set quantifier> ] <value expression> <right paren>

<set function type> ::=
    AVG | MAX | MIN | SUM | COUNT

<set quantifier> ::= DISTINCT | ALL

<scalar subquery> ::= <subquery>

<subquery> ::= <left paren> <query expression> <right paren>

<query expression> ::=
      <non-join query expression>
    | <joined table>

<non-join query expression> ::=
      <non-join query term>
    | <query expression> UNION  [ ALL ]
          [ <corresponding spec> ] <query term>
    | <query expression> EXCEPT [ ALL ]
          [ <corresponding spec> ] <query term>

<non-join query term> ::=
      <non-join query primary>
    | <query term> INTERSECT [ ALL ]
          [ <corresponding spec> ] <query primary>

<non-join query primary> ::=
      <simple table>
    | <left paren> <non-join query expression> <right paren>

<simple table> ::=
      <query specification>
    | <table value constructor>
    | <explicit table>

<query specification> ::=
    SELECT [ <set quantifier> ] <select list> <table expression>

<select list> ::=
      <asterisk>
    | <select sublist> [ ( <comma> <select sublist> )... ]

<select sublist> ::=
      <derived column>
    | <qualifier> <period> <asterisk>

<derived column> ::= <value expression> [ <as clause> ]

<as clause> ::= [ AS ] <column name>

<table expression> ::=
    <from clause>
    [ <where clause> ]
    [ <group by clause> ]
    [ <having clause> ]

<from clause> ::= FROM <table reference>
    [ ( <comma> <table reference> )... ]

<table reference> ::=
      <table name> [ [ AS ] <correlation name>
          [ <left paren> <derived column list> <right paren> ] ]
    | <derived table> [ AS ] <correlation name>
          [ <left paren> <derived column list> <right paren> ]
    | <joined table>

<derived column list> ::= <column name list>

<derived table> ::= <table subquery>

<table subquery> ::= <subquery>

<joined table> ::=
      <cross join>
    | <qualified join>
    | <left paren> <joined table> <right paren>

<cross join> ::=
    <table reference> CROSS JOIN <table reference>

<qualified join> ::=
    <table reference> [ NATURAL ] [ <join type> ] JOIN
      <table reference> [ <join specification> ]

<join type> ::=
      INNER
    | <outer join type> [ OUTER ]
    | UNION

<outer join type> ::=
      LEFT
    | RIGHT
    | FULL

<join specification> ::=
      <join condition>
    | <named columns join>

<join condition> ::= ON <search condition>

<named columns join> ::=
    USING <left paren> <join column list> <right paren>

<join column list> ::= <column name list>

<where clause> ::= WHERE <search condition>

<group by clause> ::=
    GROUP BY <grouping column reference list>

<grouping column reference list> ::=
    <grouping column reference>
        [ ( <comma> <grouping column reference> )... ]

<grouping column reference> ::=
    <column reference> [ <collate clause> ]

<collate clause> ::= COLLATE <collation name>

<collation name> ::= <qualified name>

<having clause> ::= HAVING <search condition>

<table value constructor> ::=
    VALUES <table value constructor list>

<table value constructor list> ::=
    <row value constructor> [ ( <comma> <row value constructor> )... ]

<explicit table> ::= TABLE <table name>

<query term> ::=
      <non-join query term>
    | <joined table>

<corresponding spec> ::=
    CORRESPONDING [ BY <left paren> <corresponding column list> <right paren> ]

<corresponding column list> ::= <column name list>

<query primary> ::=
      <non-join query primary>
    | <joined table>

<case expression> ::=
      <case abbreviation>
    | <case specification>

<case abbreviation> ::=
      NULLIF <left paren> <value expression> <comma>
            <value expression> <right paren>
    | COALESCE <left paren> <value expression>
            ( <comma> <value expression> )... <right paren>

<case specification> ::=
      <simple case>
    | <searched case>

<simple case> ::=
    CASE <case operand>
      <simple when clause>...
      [ <else clause> ]
    END

<case operand> ::= <value expression>

<simple when clause> ::= WHEN <when operand> THEN <result>

<when operand> ::= <value expression>

<result> ::= <result expression> | NULL

<result expression> ::= <value expression>

<else clause> ::= ELSE <result>

<searched case> ::=
    CASE
      <searched when clause>...
      [ <else clause> ]
    END

<searched when clause> ::= WHEN <search condition> THEN <result>

<cast specification> ::=
    CAST <left paren> <cast operand> AS
        <cast target> <right paren>

<cast operand> ::=
      <value expression>
    | NULL

<cast target> ::=
      <domain name>
    | <data type>

<numeric value function> ::=
      <position expression>
    | <extract expression>
    | <length expression>

<position expression> ::=
    POSITION <left paren> <character value expression>
        IN <character value expression> <right paren>

<character value expression> ::=
      <concatenation>
    | <character factor>

<concatenation> ::=
    <character value expression> <concatenation operator>
        <character factor>

<character factor> ::=
    <character primary> [ <collate clause> ]

<character primary> ::=
      <value expression primary>
    | <string value function>

<string value function> ::=
      <character value function>
    | <bit value function>

<character value function> ::=
      <character substring function>
    | <fold>
    | <form-of-use conversion>
    | <character translation>
    | <trim function>

<character substring function> ::=
    SUBSTRING <left paren> <character value expression> FROM <start position>
                [ FOR <string length> ] <right paren>

<start position> ::= <numeric value expression>

<string length> ::= <numeric value expression>

<fold> ::= ( UPPER | LOWER )
     <left paren> <character value expression> <right paren>

<form-of-use conversion> ::=
    CONVERT <left paren> <character value expression>
        USING <form-of-use conversion name> <right paren>

<form-of-use conversion name> ::= <qualified name>

<character translation> ::=
    TRANSLATE <left paren> <character value expression>
        USING <translation name> <right paren>

<translation name> ::= <qualified name>

<trim function> ::=
    TRIM <left paren> <trim operands> <right paren>

<trim operands> ::=
    [ [ <trim specification> ] [ <trim character> ] FROM ] <trim source>

<trim specification> ::=
      LEADING
    | TRAILING
    | BOTH

<trim character> ::= <character value expression>

<trim source> ::= <character value expression>

<bit value function> ::=
    <bit substring function>

<bit substring function> ::=
    SUBSTRING <left paren> <bit value expression> FROM <start position>
        [ FOR <string length> ] <right paren>

<bit value expression> ::=
      <bit concatenation>
    | <bit factor>

<bit concatenation> ::=
    <bit value expression> <concatenation operator> <bit factor>

<bit factor> ::= <bit primary>

<bit primary> ::=
      <value expression primary>
    | <string value function>

<extract expression> ::=
    EXTRACT <left paren> <extract field>
        FROM <extract source> <right paren>

<extract field> ::=
      <datetime field>
    | <time zone field>

<datetime field> ::=
      <non-second datetime field>
    | SECOND

<time zone field> ::=
      TIMEZONE_HOUR
    | TIMEZONE_MINUTE

<extract source> ::=
      <datetime value expression>
    | <interval value expression>

<datetime value expression> ::=
      <datetime term>
    | <interval value expression> <plus sign> <datetime term>
    | <datetime value expression> <plus sign> <interval term>
    | <datetime value expression> <minus sign> <interval term>

<interval term> ::=
      <interval factor>
    | <interval term 2> <asterisk> <factor>
    | <interval term 2> <solidus> <factor>
    | <term> <asterisk> <interval factor>

<interval factor> ::=
    [ <sign> ] <interval primary>

<interval primary> ::=
      <value expression primary> [ <interval qualifier> ]

<interval term 2> ::= <interval term>

<interval value expression> ::=
      <interval term>
    | <interval value expression 1> <plus sign> <interval term 1>
    | <interval value expression 1> <minus sign> <interval term 1>
    | <left paren> <datetime value expression> <minus sign>
          <datetime term> <right paren> <interval qualifier>

<interval value expression 1> ::= <interval value expression>

<interval term 1> ::= <interval term>

<datetime term> ::=
      <datetime factor>

<datetime factor> ::=
      <datetime primary> [ <time zone> ]

<datetime primary> ::=
      <value expression primary>
    | <datetime value function>

<time zone> ::=
    AT <time zone specifier>

<time zone specifier> ::=
      LOCAL
    | TIME ZONE <interval value expression>

<length expression> ::=
      <char length expression>
    | <octet length expression>
    | <bit length expression>

<char length expression> ::=
    ( CHAR_LENGTH | CHARACTER_LENGTH )
        <left paren> <string value expression> <right paren>

<string value expression> ::=
      <character value expression>
    | <bit value expression>

<octet length expression> ::=
    OCTET_LENGTH <left paren> <string value expression> <right paren>

<bit length expression> ::=
    BIT_LENGTH <left paren> <string value expression> <right paren>

<null specification> ::=
    NULL

<default specification> ::=
    DEFAULT

<row value constructor list> ::=
    <row value constructor element>
        [ ( <comma> <row value constructor element> )... ]

<row subquery> ::= <subquery>

<comp op> ::=
      <equals operator>
    | <not equals operator>
    | <less than operator>
    | <greater than operator>
    | <less than or equals operator>
    | <greater than or equals operator>

<between predicate> ::=
    <row value constructor> [ NOT ] BETWEEN
      <row value constructor> AND <row value constructor>

<in predicate> ::=
    <row value constructor>
      [ NOT ] IN <in predicate value>

<in predicate value> ::=
      <table subquery>
    | <left paren> <in value list> <right paren>

<in value list> ::=
    <value expression> ( <comma> <value expression> )...

<like predicate> ::=
    <match value> [ NOT ] LIKE <pattern>
      [ ESCAPE <escape character> ]

<match value> ::= <character value expression>

<pattern> ::= <character value expression>

<escape character> ::= <character value expression>

<null predicate> ::= <row value constructor>
    IS [ NOT ] NULL

<quantified comparison predicate> ::=
    <row value constructor> <comp op> <quantifier> <table subquery>

<quantifier> ::= <all> | <some>

<all> ::= ALL

<some> ::= SOME | ANY

<exists predicate> ::= EXISTS <table subquery>

<unique predicate> ::= UNIQUE <table subquery>

<match predicate> ::=
    <row value constructor> MATCH [ UNIQUE ]
        [ PARTIAL | FULL ] <table subquery>

<overlaps predicate> ::=
    <row value constructor 1> OVERLAPS <row value constructor 2>

<row value constructor 1> ::= <row value constructor>

<row value constructor 2> ::= <row value constructor>

<truth value> ::=
      TRUE
    | FALSE
    | UNKNOWN

<constraint attributes> ::=
      <constraint check time> [ [ NOT ] DEFERRABLE ]
    | [ NOT ] DEFERRABLE [ <constraint check time> ]

<constraint check time> ::=
      INITIALLY DEFERRED
    | INITIALLY IMMEDIATE

<table constraint definition> ::=
    [ <constraint name definition> ]
    <table constraint> [ <constraint attributes> ]

<table constraint> ::=
      <unique constraint definition>
    | <referential constraint definition>
    | <check constraint definition>

<unique constraint definition> ::=
            <unique specification> even in SQL3)
    <unique specification>
      <left paren> <unique column list> <right paren>

<unique column list> ::= <column name list>

<referential constraint definition> ::=
    FOREIGN KEY
        <left paren> <referencing columns> <right paren>
      <references specification>

<referencing columns> ::=
    <reference column list>

<module contents> ::=
      <declare cursor>
    | <dynamic declare cursor>
    | <procedure>

<declare cursor> ::=
    DECLARE <cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR
      FOR <cursor specification>

<cursor name> ::= <identifier>

<cursor specification> ::=
    <query expression> [ <order by clause> ]
      [ <updatability clause> ]

<order by clause> ::=
    ORDER BY <sort specification list>

<sort specification list> ::=
    <sort specification> [ ( <comma> <sort specification> )... ]

<sort specification> ::=
    <sort key> [ <collate clause> ] [ <ordering specification> ]

<sort key> ::=
      <column name>
    | <unsigned integer>

<ordering specification> ::= ASC | DESC

<updatability clause> ::=
    FOR
        ( READ ONLY |
          UPDATE [ OF <column name list> ] )

<dynamic declare cursor> ::=
    DECLARE <cursor name> [ INSENSITIVE ] [ SCROLL ] CURSOR
        FOR <statement name>

<statement name> ::= <identifier>

<procedure> ::=
    PROCEDURE <procedure name>
        <parameter declaration list> <semicolon>
      <SQL procedure statement> <semicolon>

<procedure name> ::= <identifier>

<parameter declaration list> ::=
      <left paren> <parameter declaration>
          [ ( <comma> <parameter declaration> )... ] <right paren>
    | <parameter declaration>...

<parameter declaration> ::=
      <parameter name> <data type>
    | <status parameter>

<status parameter> ::=
    SQLCODE | SQLSTATE

<SQL procedure statement> ::=
      <SQL schema statement>
    | <SQL data statement>
    | <SQL transaction statement>
    | <SQL connection statement>
    | <SQL session statement>
    | <SQL dynamic statement>
    | <SQL diagnostics statement>

<SQL schema statement> ::=
      <SQL schema definition statement>
    | <SQL schema manipulation statement>

<SQL schema definition statement> ::=
      <schema definition>
    | <table definition>
    | <view definition>
    | <grant statement>
    | <domain definition>
    | <character set definition>
    | <collation definition>
    | <translation definition>
    | <assertion definition>

<schema definition> ::=
    CREATE SCHEMA <schema name clause>
      [ <schema character set specification> ]
      [ <schema element>... ]

<schema name clause> ::=
      <schema name>
    | AUTHORIZATION <schema authorization identifier>
    | <schema name> AUTHORIZATION
          <schema authorization identifier>

<schema authorization identifier> ::=
    <authorization identifier>

<schema character set specification> ::=
    DEFAULT CHARACTER
        SET <character set specification>

<schema element> ::=
      <domain definition>
    | <table definition>
    | <view definition>
    | <grant statement>
    | <assertion definition>
    | <character set definition>
    | <collation definition>
    | <translation definition>

<domain definition> ::=
    CREATE DOMAIN <domain name>
        [ AS ] <data type>
      [ <default clause> ]
      [ <domain constraint>... ]
      [ <collate clause> ]

<domain constraint> ::=
    [ <constraint name definition> ]
    <check constraint definition> [ <constraint attributes> ]

<table definition> ::=
    CREATE [ ( GLOBAL | LOCAL ) TEMPORARY ] TABLE
        <table name>
      <table element list>
      [ ON COMMIT ( DELETE | PRESERVE ) ROWS ]

<view definition> ::=
    CREATE VIEW <table name> [ <left paren> <view column list>
                                  <right paren> ]
      AS <query expression>
      [ WITH [ <levels clause> ] CHECK OPTION ]

<view column list> ::= <column name list>

<levels clause> ::=
    CASCADED | LOCAL

<grant statement> ::=
   GRANT <privileges> ON <object name>
     TO <grantee> [ ( <comma> <grantee> )... ]
       [ WITH GRANT OPTION ]

<privileges> ::=
      ALL PRIVILEGES
    | <action list>

<action list> ::= <action> [ ( <comma> <action> )... ]

<action> ::=
      SELECT
    | DELETE
    | INSERT [ <left paren> <privilege column list> <right paren> ]
    | UPDATE [ <left paren> <privilege column list> <right paren> ]
    | REFERENCES [ <left paren> <privilege column list> <right paren> ]
    | USAGE

<privilege column list> ::= <column name list>

<object name> ::=
      [ TABLE ] <table name>
    | DOMAIN <domain name>
    | COLLATION <collation name>
    | CHARACTER SET <character set name>
    | TRANSLATION <translation name>

<grantee> ::=
      PUBLIC
    | <authorization identifier>

<assertion definition> ::=
    CREATE ASSERTION <constraint name> <assertion check>
      [ <constraint attributes> ]

<assertion check> ::=
    CHECK
        <left paren> <search condition> <right paren>

<character set definition> ::=
    CREATE CHARACTER SET <character set name>
        [ AS ]
      <character set source>
      [ <collate clause> | <limited collation definition> ]

<character set source> ::=
      GET <existing character set name>

<existing character set name> ::=
      <standard character repertoire name>
    | <implementation-defined character repertoire name>
    | <schema character set name>

<schema character set name> ::= <character set name>

<limited collation definition> ::=
    COLLATION FROM <collation source>

<collation source> ::=
      <collating sequence definition>
    | <translation collation>

<collating sequence definition> ::=
      <external collation>
    | <schema collation name>
    | DESC <left paren> <collation name> <right paren>
    | DEFAULT

<external collation> ::=
    EXTERNAL <left paren> <quote> <external collation name> <quote> <right paren>

<external collation name> ::=
      <standard collation name>
    | <implementation-defined collation name>

<standard collation name> ::= <collation name>

<implementation-defined collation name> ::= <collation name>

<schema collation name> ::= <collation name>

<translation collation> ::=
    TRANSLATION <translation name>
        [ THEN COLLATION <collation name> ]

<collation definition> ::=
    CREATE COLLATION <collation name> FOR
        <character set specification>
      FROM <collation source>
        [ <pad attribute> ]

<pad attribute> ::=
      NO PAD
    | PAD SPACE

<translation definition> ::=
    CREATE TRANSLATION <translation name>
      FOR <source character set specification>
        TO <target character set specification>
      FROM <translation source>

<source character set specification> ::= <character set specification>

<target character set specification> ::= <character set specification>

<translation source> ::=
      <translation specification>

<translation specification> ::=
      <external translation>
    | IDENTITY
    | <schema translation name>

<external translation> ::=
    EXTERNAL <left paren> <quote> <external translation name> <quote> <right paren>

<external translation name> ::=
      <standard translation name>
    | <implementation-defined translation name>

<standard translation name> ::= <translation name>

<implementation-defined translation name> ::= <translation name>

<schema translation name> ::= <translation name>

<SQL schema manipulation statement> ::=
      <drop schema statement>
    | <alter table statement>
    | <drop table statement>
    | <drop view statement>
    | <revoke statement>
    | <alter domain statement>
    | <drop domain statement>
    | <drop character set statement>
    | <drop collation statement>
    | <drop translation statement>
    | <drop assertion statement>

<drop schema statement> ::=
    DROP SCHEMA <schema name> <drop behavior>

<drop behavior> ::= CASCADE | RESTRICT

<alter table statement> ::=
    ALTER TABLE <table name> <alter table action>

<alter table action> ::=
      <add column definition>
    | <alter column definition>
    | <drop column definition>
    | <add table constraint definition>
    | <drop table constraint definition>

<add column definition> ::=
    ADD [ COLUMN ] <column definition>

<alter column definition> ::=
    ALTER [ COLUMN ] <column name> <alter column action>

<alter column action> ::=
      <set column default clause>
    | <drop column default clause>

<set column default clause> ::=
    SET <default clause>

<drop column default clause> ::=
    DROP DEFAULT

<drop column definition> ::=
    DROP [ COLUMN ] <column name> <drop behavior>

<add table constraint definition> ::=
    ADD <table constraint definition>

<drop table constraint definition> ::=
    DROP CONSTRAINT <constraint name> <drop behavior>

<drop table statement> ::=
    DROP TABLE <table name> <drop behavior>

<drop view statement> ::=
    DROP VIEW <table name> <drop behavior>

<revoke statement> ::=
    REVOKE [ GRANT OPTION FOR ]
        <privileges>
        ON <object name>
      FROM <grantee> [ ( <comma> <grantee> )... ] <drop behavior>

<alter domain statement> ::=
    ALTER DOMAIN <domain name> <alter domain action>

<alter domain action> ::=
      <set domain default clause>
    | <drop domain default clause>
    | <add domain constraint definition>
    | <drop domain constraint definition>

<set domain default clause> ::= SET <default clause>

<drop domain default clause> ::= DROP DEFAULT

<add domain constraint definition> ::=
    ADD <domain constraint>

<drop domain constraint definition> ::=
    DROP CONSTRAINT <constraint name>

<drop domain statement> ::=
    DROP DOMAIN <domain name> <drop behavior>

<drop character set statement> ::=
    DROP CHARACTER SET <character set name>

<drop collation statement> ::=
    DROP COLLATION <collation name>

<drop translation statement> ::=
    DROP TRANSLATION <translation name>

<drop assertion statement> ::=
    DROP ASSERTION <constraint name>

<SQL data statement> ::=
      <open statement>
    | <fetch statement>
    | <close statement>
    | <select statement: single row>
    | <SQL data change statement>

<open statement> ::=
    OPEN <cursor name>

<fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ]
      <cursor name> INTO <fetch target list>

<fetch orientation> ::=
      NEXT
    | PRIOR
    | FIRST
    | LAST
    | ( ABSOLUTE | RELATIVE ) <simple value specification>

<simple value specification> ::=
      <parameter name>
    | <embedded variable name>
    | <literal>

<fetch target list> ::=
    <target specification> [ ( <comma> <target specification> )... ]

<target specification> ::=
      <parameter specification>
    | <variable specification>

<close statement> ::=
    CLOSE <cursor name>

<select statement: single row> ::=
    SELECT [ <set quantifier> ] <select list>
      INTO <select target list>
        <table expression>

<select target list> ::=
    <target specification> [ ( <comma> <target specification> )... ]

<SQL data change statement> ::=
      <delete statement: positioned>
    | <delete statement: searched>
    | <insert statement>
    | <update statement: positioned>
    | <update statement: searched>

<delete statement: positioned> ::=
    DELETE FROM <table name>
      WHERE CURRENT OF <cursor name>

<delete statement: searched> ::=
    DELETE FROM <table name>
      [ WHERE <search condition> ]

<insert statement> ::=
    INSERT INTO <table name>
      <insert columns and source>

<insert columns and source> ::=
      [ <left paren> <insert column list> <right paren> ]
            <query expression>
    | DEFAULT VALUES

<insert column list> ::= <column name list>

<update statement: positioned> ::=
    UPDATE <table name>
      SET <set clause list>
        WHERE CURRENT OF <cursor name>

<set clause list> ::=
    <set clause> [ ( <comma> <set clause> )... ]

<set clause> ::=
    <object column> <equals operator> <update source>

<object column> ::= <column name>

<update source> ::=
      <value expression>
    | <null specification>
    | DEFAULT

<update statement: searched> ::=
    UPDATE <table name>
      SET <set clause list>
      [ WHERE <search condition> ]

<SQL transaction statement> ::=
      <set transaction statement>
    | <set constraints mode statement>
    | <commit statement>
    | <rollback statement>

<set transaction statement> ::=
    SET TRANSACTION <transaction mode>
        [ ( <comma> <transaction mode> )... ]

<transaction mode> ::=
      <isolation level>
    | <transaction access mode>
    | <diagnostics size>

<isolation level> ::=
    ISOLATION LEVEL <level of isolation>

<level of isolation> ::=
      READ UNCOMMITTED
    | READ COMMITTED
    | REPEATABLE READ
    | SERIALIZABLE

<transaction access mode> ::=
      READ ONLY
    | READ WRITE

<diagnostics size> ::=
    DIAGNOSTICS SIZE <number of conditions>

<number of conditions> ::= <simple value specification>

<set constraints mode statement> ::=
    SET CONSTRAINTS <constraint name list>
        ( DEFERRED | IMMEDIATE )

<constraint name list> ::=
      ALL
    | <constraint name> [ ( <comma> <constraint name> )... ]

<commit statement> ::=
    COMMIT [ WORK ]

<rollback statement> ::=
    ROLLBACK [ WORK ]

<SQL connection statement> ::=
      <connect statement>
    | <set connection statement>
    | <disconnect statement>

<connect statement> ::=
    CONNECT TO <connection target>

<connection target> ::=
      <SQL-server name>
        [ AS <connection name> ]
          correspondence with Tony Gordon)
        [ USER <user name> ]
    | DEFAULT

<SQL-server name> ::= <simple value specification>

<connection name> ::= <simple value specification>

<user name> ::= <simple value specification>

<set connection statement> ::=
    SET CONNECTION <connection object>

<connection object> ::=
      DEFAULT
    | <connection name>

<disconnect statement> ::=
    DISCONNECT <disconnect object>

<disconnect object> ::=
      <connection object>
    | ALL
    | CURRENT

<SQL session statement> ::=
      <set catalog statement>
    | <set schema statement>
    | <set names statement>
    | <set session authorization identifier statement>
    | <set local time zone statement>

<set catalog statement> ::=
    SET CATALOG <value specification>

<value specification> ::=
      <literal>
    | <general value specification>

<set schema statement> ::=
    SET SCHEMA <value specification>

<set names statement> ::=
    SET NAMES <value specification>

<set session authorization identifier statement> ::=
    SET SESSION AUTHORIZATION
        <value specification>

<set local time zone statement> ::=
    SET TIME ZONE
        <set time zone value>

<set time zone value> ::=
      <interval value expression>
    | LOCAL

<SQL dynamic statement> ::=
      <system descriptor statement>
    | <prepare statement>
    | <deallocate prepared statement>
    | <describe statement>
    | <execute statement>
    | <execute immediate statement>
    | <SQL dynamic data statement>

<system descriptor statement> ::=
      <allocate descriptor statement>
    | <deallocate descriptor statement>
    | <set descriptor statement>
    | <get descriptor statement>

<allocate descriptor statement> ::=
    ALLOCATE DESCRIPTOR <descriptor name>
       [ WITH MAX <occurrences> ]

<descriptor name> ::=
    [ <scope option> ] <simple value specification>

<scope option> ::=
      GLOBAL
    | LOCAL

<occurrences> ::= <simple value specification>

<deallocate descriptor statement> ::=
    DEALLOCATE DESCRIPTOR <descriptor name>

<set descriptor statement> ::=
    SET DESCRIPTOR <descriptor name>
        <set descriptor information>

<set descriptor information> ::=
      <set count>
    | VALUE <item number>
        <set item information> [ ( <comma> <set item information> )... ]

<set count> ::=
    COUNT <equals operator> <simple value specification 1>

<simple value specification 1> ::= <simple value specification>

<item number> ::= <simple value specification>

<set item information> ::=
    <descriptor item name> <equals operator> <simple value specification 2>

<descriptor item name> ::=
      TYPE
    | LENGTH
    | OCTET_LENGTH
    | RETURNED_LENGTH
    | RETURNED_OCTET_LENGTH
    | PRECISION
    | SCALE
    | DATETIME_INTERVAL_CODE
    | DATETIME_INTERVAL_PRECISION
    | NULLABLE
    | INDICATOR
    | DATA
    | NAME
    | UNNAMED
    | COLLATION_CATALOG
    | COLLATION_SCHEMA
    | COLLATION_NAME
    | CHARACTER_SET_CATALOG
    | CHARACTER_SET_SCHEMA
    | CHARACTER_SET_NAME

<simple value specification 2> ::= <simple value specification>

<item number> ::= <simple value specification>

<get descriptor statement> ::=
    GET DESCRIPTOR <descriptor name> <get descriptor information>

<get descriptor information> ::=
      <get count>
    | VALUE <item number>
        <get item information> [ ( <comma> <get item information> )... ]

<get count> ::=
    <simple target specification 1> <equals operator>
         COUNT

<simple target specification 1> ::= <simple target specification>

<simple target specification> ::=
      <parameter name>
    | <embedded variable name>

<get item information> ::=
    <simple target specification 2> <equals operator> <descriptor item name>>

<simple target specification 2> ::= <simple target specification>

<prepare statement> ::=
    PREPARE <SQL statement name> FROM <SQL statement variable>

<SQL statement name> ::=
      <statement name>
    | <extended statement name>

<extended statement name> ::=
    [ <scope option> ] <simple value specification>

<SQL statement variable> ::= <simple value specification>

<deallocate prepared statement> ::=
    DEALLOCATE PREPARE <SQL statement name>

<describe statement> ::=
      <describe input statement>
    | <describe output statement>

<describe input statement> ::=
    DESCRIBE INPUT <SQL statement name> <using descriptor>

<using descriptor> ::=
    ( USING | INTO ) SQL DESCRIPTOR <descriptor name>

<describe output statement> ::=
    DESCRIBE [ OUTPUT ] <SQL statement name> <using descriptor>

<execute statement> ::=
    EXECUTE <SQL statement name>
      [ <result using clause> ]
      [ <parameter using clause> ]

<result using clause> ::= <using clause>

<using clause> ::=
      <using arguments>
    | <using descriptor>

<using arguments> ::=
    ( USING | INTO ) <argument> [ ( <comma> <argument> )... ]

<argument> ::= <target specification>

<parameter using clause> ::= <using clause>

<execute immediate statement> ::=
    EXECUTE IMMEDIATE <SQL statement variable>

<SQL dynamic data statement> ::=
      <allocate cursor statement>
    | <dynamic open statement>
    | <dynamic fetch statement>
    | <dynamic close statement>
    | <dynamic delete statement: positioned>
    | <dynamic update statement: positioned>

<allocate cursor statement> ::=
    ALLOCATE <extended cursor name> [ INSENSITIVE ]
        [ SCROLL ] CURSOR
      FOR <extended statement name>

<extended cursor name> ::=
    [ <scope option> ] <simple value specification>

<dynamic open statement> ::=
    OPEN <dynamic cursor name> [ <using clause> ]

<dynamic cursor name> ::=
      <cursor name>
    | <extended cursor name>

<dynamic fetch statement> ::=
    FETCH [ [ <fetch orientation> ] FROM ] <dynamic cursor name>
        <using clause>

<dynamic close statement> ::=
    CLOSE <dynamic cursor name>

<dynamic delete statement: positioned> ::=
    DELETE FROM <table name>
      WHERE CURRENT OF
          <dynamic cursor name>

<dynamic update statement: positioned> ::=
    UPDATE <table name>
      SET <set clause>
          [ ( <comma> <set clause> )... ]
        WHERE CURRENT OF
            <dynamic cursor name>

<SQL diagnostics statement> ::=
    <get diagnostics statement>

<get diagnostics statement> ::=
    GET DIAGNOSTICS <sql diagnostics information>

<sql diagnostics information> ::=
      <statement information>
    | <condition information>

<statement information> ::=
    <statement information item> [ ( <comma> <statement information item> )... ]

<statement information item> ::=
    <simple target specification> <equals operator> <statement information item name>

<statement information item name> ::=
      NUMBER
    | MORE
    | COMMAND_FUNCTION
    | DYNAMIC_FUNCTION
    | ROW_COUNT

<condition information> ::=
    EXCEPTION <condition number>
      <condition information item> [ ( <comma> <condition information item> )... ]

<condition number> ::= <simple value specification>

<condition information item> ::=
    <simple target specification> <equals operator> <condition information item name>

<condition information item name> ::=
      CONDITION_NUMBER
    | RETURNED_SQLSTATE
    | CLASS_ORIGIN
    | SUBCLASS_ORIGIN
    | SERVER_NAME
    | CONNECTION_NAME
    | CONSTRAINT_CATALOG
    | CONSTRAINT_SCHEMA
    | CONSTRAINT_NAME
    | CATALOG_NAME
    | SCHEMA_NAME
    | TABLE_NAME
    | COLUMN_NAME
    | CURSOR_NAME
    | MESSAGE_TEXT
    | MESSAGE_LENGTH
    | MESSAGE_OCTET_LENGTH

<embedded SQL host program> ::=
      <embedded SQL Ada program>
    | <embedded SQL C program>
    | <embedded SQL COBOL program>
    | <embedded SQL Fortran program>
    | <embedded SQL MUMPS program>
    | <embedded SQL Pascal program>
    | <embedded SQL PL/I program>

<embedded SQL Ada program> ::= !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL C program> ::=
      !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL COBOL program> ::= !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL Fortran program> ::=
    !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL MUMPS program> ::= !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL Pascal program> ::=
    !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL PL/I program> ::= !! <EMPHASIS>(See the Syntax Rules.)

<embedded SQL declare section> ::=
      <embedded SQL begin declare>
        [ <embedded character set declaration> ]
        [ <host variable definition>... ]
      <embedded SQL end declare>
    | <embedded SQL MUMPS declare>

<embedded SQL begin declare> ::=
    <SQL prefix> BEGIN DECLARE SECTION
        [ <SQL terminator> ]

<SQL prefix> ::=
      EXEC SQL
    | <ampersand>SQL<left paren>

<SQL terminator> ::=
      END-EXEC
    | <semicolon>
    | <right paren>

<embedded character set declaration> ::=
    SQL NAMES ARE <character set specification>

<host variable definition> ::=
      <Ada variable definition>
    | <C variable definition>
    | <COBOL variable definition>
    | <Fortran variable definition>
    | <MUMPS variable definition>
    | <Pascal variable definition>
    | <PL/I variable definition>

<Ada variable definition> ::=
    <Ada host identifier> [ ( <comma> <Ada host identifier> )... ] :
    <Ada type specification> [ <Ada initial value> ]

<Ada type specification> ::=
      <Ada qualified type specification>
    | <Ada unqualified type specification>

<Ada qualified type specification> ::=
      SQL_STANDARD.CHAR [ CHARACTER SET
         [ IS ] <character set specification> ]
          <left paren> 1 <double period> <length> <right paren>
    | SQL_STANDARD.BIT
          <left paren> 1 <double period> <length> <right paren>
    | SQL_STANDARD.SMALLINT
    | SQL_STANDARD.INT
    | SQL_STANDARD.REAL
    | SQL_STANDARD.DOUBLE_PRECISION
    | SQL_STANDARD.SQLCODE_TYPE
    | SQL_STANDARD.SQLSTATE_TYPE
    | SQL_STANDARD.INDICATOR_TYPE

<Ada unqualified type specification> ::=
      CHAR
          <left paren> 1 <double period> <length> <right paren>
    | BIT
          <left paren> 1 <double period> <length> <right paren>
    | SMALLINT
    | INT
    | REAL
    | DOUBLE_PRECISION
    | SQLCODE_TYPE
    | SQLSTATE_TYPE
    | INDICATOR_TYPE

<Ada initial value> ::=
    <Ada assignment operator> <character representation>...

<Ada assignment operator> ::= <colon><equals operator>

<C variable definition> ::=
      [ <C storage class> ]
      [ <C class modifier> ]
      <C variable specification>
    <semicolon>

<C storage class> ::=
      auto
    | extern
    | static

<C class modifier> ::= const | volatile

<C variable specification> ::=
      <C numeric variable>
    | <C character variable>
    | <C derived variable>

<C numeric variable> ::=
    ( long | short | float | double )
      <C host identifier> [ <C initial value> ]
            [ ( <comma> <C host identifier> [ <C initial value> ] )... ]

<C initial value> ::=
    <equals operator> <character representation>...

<C character variable> ::=
    char [ CHARACTER SET
             [ IS ] <character set specification> ]
      <C host identifier>
        <C array specification> [ <C initial value> ]
        [ ( <comma> <C host identifier>
          <C array specification>
                 [ <C initial value> ] )... ]

<C array specification> ::=
    <left bracket> <length> <right bracket>

<C derived variable> ::=
      <C VARCHAR variable>
    | <C bit variable>

<C VARCHAR variable> ::=
    VARCHAR [ CHARACTER SET [ IS ]
        <character set specification> ]
        <C host identifier>
            <C array specification> [ <C initial value> ]
          [ ( <comma> <C host identifier>
              <C array specification>
                      [ <C initial value> ] )... ]

<C bit variable> ::=
    BIT <C host identifier>
        <C array specification> [ <C initial value> ]
      [ ( <comma> <C host identifier>
        <C array specification>
                   [ <C initial value> ] )... ]

<COBOL variable definition> ::=
    (01|77) <COBOL host identifier> <COBOL type specification>
      [ <character representation>... ] <period>

<COBOL type specification> ::=
      <COBOL character type>
    | <COBOL bit type>
    | <COBOL numeric type>
    | <COBOL integer type>

<COBOL character type> ::=
    [ CHARACTER SET [ IS ]
          <character set specification> ]
    ( PIC | PICTURE ) [ IS ] ( X [ <left paren> <length> <right paren> ] )...

<COBOL bit type> ::=
    ( PIC | PICTURE ) [ IS ]
        ( B [ <left paren> <length> <right paren> ] )...

<COBOL numeric type> ::=
    ( PIC | PICTURE ) [ IS ]
      S <COBOL nines specification>
    [ USAGE [ IS ] ] DISPLAY SIGN LEADING SEPARATE

<COBOL nines specification> ::=
      <COBOL nines> [ V [ <COBOL nines> ] ]
    | V <COBOL nines>

<COBOL nines> ::= ( 9 [ <left paren> <length> <right paren> ] )...

<COBOL integer type> ::=
      <COBOL computational integer>
    | <COBOL binary integer>

<COBOL computational integer> ::=
    ( PIC | PICTURE ) [ IS ] S<COBOL nines>
      [ USAGE [ IS ] ] ( COMP | COMPUTATIONAL )

<COBOL binary integer> ::=
    ( PIC | PICTURE ) [ IS ] S<COBOL nines>
      [ USAGE [ IS ] ] BINARY

<Fortran variable definition> ::=
    <Fortran type specification>
    <Fortran host identifier>
        [ ( <comma> <Fortran host identifier> )... ]

<Fortran type specification> ::=
      CHARACTER [ <asterisk> <length> ]
          [ CHARACTER SET [ IS ]
                <character set specification> ]
    | BIT [ <asterisk> <length> ]
    | INTEGER
    | REAL
    | DOUBLE PRECISION

<MUMPS variable definition> ::=
    ( <MUMPS numeric variable> | <MUMPS character variable> )
        <semicolon>

<MUMPS numeric variable> ::=
    <MUMPS type specification>
      <MUMPS host identifier> [ ( <comma> <MUMPS host identifier> )... ]

<MUMPS type specification> ::=
      INT
    | DEC
          [ <left paren> <precision> [ <comma> <scale> ] <right paren> ]
    | REAL

<MUMPS character variable> ::=
    VARCHAR <MUMPS host identifier> <MUMPS length specification>
      [ ( <comma> <MUMPS host identifier> <MUMPS length specification> )... ]

<MUMPS length specification> ::=
    <left paren> <length> <right paren>

<Pascal variable definition> ::=
    <Pascal host identifier> [ ( <comma> <Pascal host identifier> )... ] <colon>
      <Pascal type specification> <semicolon>

<Pascal type specification> ::=
      PACKED ARRAY
          <left bracket> 1 <double period> <length> <right bracket>
        OF CHAR
          [ CHARACTER SET [ IS ]
                <character set specification> ]
    | PACKED ARRAY
          <left bracket> 1 <double period> <length> <right bracket>
        OF BIT
    | INTEGER
    | REAL
    | CHAR [ CHARACTER SET
                                [ IS ] <character set specification> ]
    | BIT

<PL/I variable definition> ::=
    (DCL | DECLARE)
        (   <PL/I host identifier>
          | <left paren> <PL/I host identifier>
                [ ( <comma> <PL/I host identifier> )... ] <right paren> )
    <PL/I type specification>
    [ <character representation>... ] <semicolon>

<PL/I type specification> ::=
      ( CHAR | CHARACTER ) [ VARYING ]
          <left paren><length><right paren>
          [ CHARACTER SET
                [ IS ] <character set specification> ]
    | BIT [ VARYING ] <left paren><length><right paren>
    | <PL/I type fixed decimal> <left paren> <precision>
          [ <comma> <scale> ] <right paren>
    | <PL/I type fixed binary> [ <left paren> <precision> <right paren> ]
    | <PL/I type float binary> <left paren> <precision> <right paren>

<PL/I type fixed decimal> ::=
      ( DEC | DECIMAL ) FIXED
    | FIXED ( DEC | DECIMAL )

<PL/I type fixed binary> ::=
      ( BIN | BINARY ) FIXED
    | FIXED ( BIN | BINARY )

<PL/I type float binary> ::=
      ( BIN | BINARY ) FLOAT
    | FLOAT ( BIN | BINARY )

<embedded SQL end declare> ::=
    <SQL prefix> END DECLARE SECTION
        [ <SQL terminator> ]

<embedded SQL MUMPS declare> ::=
    <SQL prefix>
      BEGIN DECLARE SECTION
        [ <embedded character set declaration> ]
        [ <host variable definition>... ]
      END DECLARE SECTION
    <SQL terminator>

<embedded SQL statement> ::=
    <SQL prefix>
      <statement or declaration>
    [ <SQL terminator> ]

<statement or declaration> ::=
      <declare cursor>
    | <dynamic declare cursor>
    | <temporary table declaration>
    | <embedded exception declaration>
    | <SQL procedure statement>

<embedded exception declaration> ::=
    WHENEVER <condition> <condition action>

<condition> ::=
    SQLERROR | NOT FOUND

<condition action> ::=
    CONTINUE | <go to>

<go to> ::=
    ( GOTO | GO TO ) <goto target>

<goto target> ::=
      <host label identifier>
    | <unsigned integer>
    | <host PL/I label variable>

<host label identifier> ::= !!<EMPHASIS>(See the Syntax Rules.)

<host PL/I label variable> ::= !!<EMPHASIS>(See the Syntax Rules.)

<preparable statement> ::=
      <preparable SQL data statement>
    | <preparable SQL schema statement>
    | <preparable SQL transaction statement>
    | <preparable SQL session statement>
    | <preparable implementation-defined statement>

<preparable SQL data statement> ::=
      <delete statement: searched>
    | <dynamic single row select statement>
    | <insert statement>
    | <dynamic select statement>
    | <update statement: searched>
    | <preparable dynamic delete statement: positioned>
    | <preparable dynamic update statement: positioned>

<dynamic single row select statement> ::= <query specification>

<dynamic select statement> ::= <cursor specification>

<preparable dynamic delete statement: positioned> ::=
   DELETE [ FROM <table name> ]
      WHERE CURRENT OF <cursor name>

<preparable dynamic update statement: positioned> ::=
   UPDATE [ <table name> ]
      SET <set clause list>
      WHERE CURRENT OF <cursor name>

<preparable SQL schema statement> ::=
      <SQL schema statement>

<preparable SQL transaction statement> ::=
      <SQL transaction statement>

<preparable SQL session statement> ::=
      <SQL session statement>

<preparable implementation-defined statement> ::=
    !! <EMPHASIS>(See the Syntax Rules.)

<direct SQL statement> ::=
    <directly executable statement> <semicolon>

<directly executable statement> ::=
      <direct SQL data statement>
    | <SQL schema statement>
    | <SQL transaction statement>
    | <SQL connection statement>
    | <SQL session statement>
    | <direct implementation-defined statement>

<direct SQL data statement> ::=
      <delete statement: searched>
    | <direct select statement: multiple rows>
    | <insert statement>
    | <update statement: searched>
    | <temporary table declaration>

<direct select statement: multiple rows> ::=
    <query expression> [ <order by clause> ]

<direct implementation-defined statement> ::=
    !!<EMPHASIS>(See the Syntax Rules)

<SQL object identifier> ::=
    <SQL provenance> <SQL variant>

<SQL provenance> ::= <arc1> <arc2> <arc3>

<arc1> ::= iso | 1 | iso <left paren> 1 <right paren>

<arc2> ::= standard | 0 | standard <left paren> 0 <right paren>

<arc3> ::= 9075

<SQL variant> ::= <SQL edition> <SQL conformance>

<SQL edition> ::= <1987> | <1989> | <1992>

<1987> ::= 0 | edition1987 <left paren> 0 <right paren>

<1989> ::= <1989 base> <1989 package>

<1989 base> ::= 1 | edition1989 <left paren> 1 <right paren>

<1989 package> ::= <integrity no> | <integrity yes>

<integrity no> ::= 0 | IntegrityNo <left paren> 0 <right paren>

<integrity yes> ::= 1 | IntegrityYes <left paren> 1 <right paren>

<1992> ::= 2 | edition1992 <left paren> 2 <right paren>

<SQL conformance> ::= <low> | <intermediate> | <high>

<low> ::= 0 | Low <left paren> 0 <right paren>

<intermediate> ::= 1 | Intermediate <left paren> 1 <right paren>

<high> ::= 2 | High <left paren> 2 <right paren>

</verb></tscreen>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix B - SQL Tutorial for beginners <label id="Appendix B">
-->
<sect> Appendix B - SQL Tutorial for beginners <label id="Appendix B">
<p>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Tutorial for PostgreSQL
<p>
SQL tutorial is also distributed with PostgreSQL. The SQL tutorial 
scripts is in the directory src/tutorial
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> Internet URL pointers
<p>
The SQL tutorial for beginners can be found at 
<itemize>
<item> <url url="http://w3.one.net/~jhoffman/sqltut.htm">
</itemize>
Comments or suggestions? Mail to 
<itemize>
<item> Jim Hoffman <htmlurl url="mailto: jhoffman@one.net"
	       name="jhoffman@one.net">
</itemize>
The following are the sites suggested by John Hoffman:
<itemize>
<item> SQL Reference <url url="http://www.contrib.andrew.cmu.edu/~shadow/sql.html">
<item> Ask the SQL Pro <url url="http://www.inquiry.com/techtips/thesqlpro/">
<item> SQL Pro's Relational DB Useful Sites <url url="http://www.inquiry.com/techtips/thesqlpro/usefulsites.html">
<item> Programmer's Source <url url="http://infoweb.magi.com/~steve/develop.html">
<item> DBMS Sites <url url="http://info.itu.ch/special/wwwfiles"> Go here and see file comp_db.html
<item> DB Ingredients <url url="http://www.compapp.dcu.ie/databases/f017.html">
<item> Web Authoring <url url="http://www.stars.com/Tutorial/CGI/">
<item> Computing Dictionary <url url="http://wfn-shop.princeton.edu/cgi-bin/foldoc">
<item> DBMS Lab/Links <url url="http://www-ccs.cs.umass.edu/db.html">
<item> SQL FAQ <url url="http://epoch.CS.Berkeley.EDU:8000/sequoia/dba/montage/FAQ"> Go here and see file SQL_TOC.html
<item> SQL Databases <url url="http://chaos.mur.csu.edu.au/itc125/cgi/sqldb.html">
<item> RIT Database Design Page <url url="http://www.it.rit.edu/~wjs/IT/199602/icsa720/icsa720postings.html">
<item> Database Jump Site <url url="http://www.pcslink.com/~ej/dbweb.html">
<item> Programming Tutorials on the Web <url url="http://www.eng.uc.edu/~jtilley/tutorial.html">
<item> Development Resources <url url="http://www.ndev.com/ndc2/support/resources.htp">
<item> Query List <url url="http://ashok.pair.com/sql.htm">
<item> IMAGE SQL Miscellaneous <url url="http://jazz.external.hp.com/training/sqltables/main.html">
<item> Internet Resource List <url url="http://www.eit.com/web/netservices.html">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************
-->
<sect1> On-line SQL tutorials
<p>
Visit the following sites for on-line SQL tutorials
<itemize>
<item> SQL beginner course <url url="http://sqlcourse.com">
<item> SQL advanced course <url url="http://sqlcourse2.com">
</itemize>
<!-- 
	*******************************************
	************ End of Section ***************
	*******************************************




<chapt> Appendix C - Linux Quick Install Instructions <label id="Appendix C">
-->
<sect> Appendix C - Linux Quick Install Instructions <label id="Appendix C">
<p>
If you are planning to use PostgreSQL on Linux, and need help in installing Linux, then please visit the pointers given in this Appendix. They cover the following topics -
<itemize>
<item> Salient Features of Linux - Why Linux is better as a database server when compared with Windows 95/NT
<item> 10 minutes Linux Quick Install Instructions
<item> Microsoft-Linux Analogy List
<item> Quick Steps to Recompile the Linux Kernel
</itemize>

<itemize>
<item> Main site is at <url url="http://www.aldev.8m.com">
<item> Mirror site <url url="http://www.aldev.webjump.com">
<item> Mirror site <url url="http://www.homepages.infoseek.com/~aldev1/index.html">
<item> Mirror site <url url="http://www3.bcity.com/aldev/">
<item> Mirror site <url url="http://www.members.spree.com/technology/aldev/"> 
</itemize>




</article>
