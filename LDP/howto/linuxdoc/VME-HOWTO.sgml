<!doctype linuxdoc system>

<article>
<!-- Title information -->

<title>Linux VME Howto
<author>John Huggins and Michael Wyrick, <tt/vmelinux@va.net/
<date>$Revision$, $Date$
<abstract>
This document came about to show the embedded system community how to run Linux on their VMEbus Pentium and other PCI local bus based VMEbus processor designs.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Beginning -->
<sect> Introduction

<sect1> Knowledge Required
<p>
Using Linux on an embedded VMEbus processor board is not very difficult.  However, 
more than fundamental knowledge is required.  This document is not a primer
on how to fully configure a Linux machine. 

<p>
In order to understand this HOWTO document it is assumed that you
are thoroughly familiar with the following:

<itemize>
<item> Configuring and compiling a Linux kernel to operate the various peripherals on your board.
<htmlurl url="http://sunsite.unc.edu/LDP/HOWTO/Kernel-HOWTO.html" name="Kernel-HOWTO">
<item> Setting up and configuring of network devices
<htmlurl url="http://sunsite.unc.edu/mdw/HOWTO/NET-3-HOWTO.html" name="NET-3 HOWTO">
<item> Setting up of inetd
<htmlurl url="http://sunsite.unc.edu/mdw/HOWTO/NET-3-HOWTO.html" name="NET-3 HOWTO">
<item> Setting up and use of the Tundra Universe PCI to VME Bridge Chip <htmlurl url="http://www.tundra.com/Tundra/unidex.html" name="Tundra Universe">.  The new VMEUtils program makes knowledge of the Universe unnecessary for those who do not wish to deal with register level Universe access.
<item> Compiling and installing various network packages like 
<htmlurl url="http://www.apache.org/" name="Apache Site">
<htmlurl url="http://www.cetis.hvu.nl/~koos/wu-ftpd-faq.html" name="Wu-Ftpd FAQ">
<item> The VMEbus Rev. D and VME64.  Excellent information may be found at the <htmlurl url="http://www.vita.com/" name=" VMEbus International Trade Association (VITA)">.
</itemize>

If you are uncertain of how to proceed with any of the above it is STRONGLY
recommended that you use the links provided to familiarize yourself with all
packages. We may not reply to any mail regarding any of the above.  Please
direct any questions to the appropriate author of the HOWTO or consult the respective hardware manufacturer.
<p>
This document describes the installation and use of VMELinux on a Xycom XVME-655 6U VME processor board. Other brands of VME boards that use a Pentium and the Tundra Universe chip should be capable of running VMELinux.  Please consult the Board Support Section of the VMELinux web site for tested boards.
<htmlurl url="http://www.vmelinux.org/" name="VMELinux Project Web Site">


<sect1> Why use Linux on VMEbus systems?
<p>
Operating systems for VMEbus computers are usually Real-time Operating Systems (RTOS) which have high cost and a significant learning curve. In return the RTOS offers quick response to real world events for control of machinery or response to a process.
<p>
The VMEbus provides a rugged computer enclosure and interconnection system. Many system integrators require this ruggedness and also need very fast real-time response.
However, there are many times when there is little need for real-time response, but the software still needs:
<itemize>
<item> networking capability,
<item> remote access via telnet or similar program,
<item> file transfer via FTP or similar programs,
<item> remote booting via BOOTP or similar method,
<item> a way to respond to system interrupts.
</itemize>
Linux has all these capabilities. Thus, the VMELinux Project exists.


<sect1> Purpose
<p>
The purpose of VMELinux is to give the VME system integrator another choice in operating systems. Rich in features, high in reliability and low in cost, Linux offers benefits to the embedded computer industry. High cost operating systems economically prohibit the use of VME in many applications. With Linux and the VMELinux drivers, the rugged VMEbus has new possibilities.
<p>
The purpose of the VMELinux Project is to:
<itemize>
<item> Maintain and improve the free VMELinux Kernel Driver software,
<item> Offer added value software components such as the VMEUtils program and VMEShell utilities.
<item> Test the software on various makes and brands of manufacturer supplied VME processor boards,
<item> Maintain web based documentation on each tested brand and make of boards,
<item> Maintain this HOWTO.
<item> Integrate user suggested and user supplied improvements into the virgin code so we may all benefit from the programming talents of others.
<item> Become the original source for all the above software so VMELinux users can be assured of original code from the authors.
</itemize>

<sect1> Feedback

<p>
As VMELinux is tested in the field, we encourage comments about how well or how bad it works. Please feel free to send comments to <htmlurl url="mailto:vmelinux@va.net" name="The VMELinux Project">

<p>
As we get experience about each brand of VME CPU, we will list the different configurations in this HOWTO. For now we will describe only the Xycom board.

<sect1> VMELinux Revision History
<p>
Linux Kernel Driver
<itemize>
<item> November 1997, v0.2 - Initial version on Xycom Board
<item> December 1997, v0.3 - Useable version used for actual work with project.
<item> February 1998, v0.6 - DMA mode added to VME access modes.
<item> June, 1998, v0.8 - Fixed a few things to allow the new VMEUtils to work.
<item> June 24, 1998, v0.8a - Last version for the 2.0.x kernels
<item> April 2000, v0.95 - First version for the 2.2.x kernels
</itemize>
<p>
VMEUtils Program
<itemize>
<item> February, 1998, v0.6 - Created a command line interpreter to access the VMEbus
<item> June, 1998, v0.8 - Fixed several issues to allow VMEShell Utilities to function
<item> June 24, 1998, v0.8a -  Previous working release.
<item> April 2000, v0.95 - Pretty much the same as before.  Better install instructions.
</itemize>
<p>
VMEShell Utilities
<itemize>
<item> June, 1998, v0.8 - Created command line utilities that allow access to the VMEbus from the Linux shell prompt.  These shell programs interface with the VMEUtils program.
<item> June 24, 1998, v0.8a - Changed the name of all the shell programs so they all begin with "vme."  Current version made available on the website.
<item> April 2000, v 0.95 - Improved installation scripts.
</itemize>

<sect1> Copyright/Distribution
<p>
This document is Copyright 1997-1998 by John Huggins and the VMELinux Project.

<p>
A verbatim copy may be reproduced or distributed in any medium physical or electronic without permission of the author.  Translations are similarly permitted without express permission if it includes a notice on who translated it.  Commercial redistribution is allowed and encouraged; however please notify <htmlurl url="mailto:vmelinux@va.net" name="The VMELinux Project"> of any such distributions.

<p>
Excerpts from the document may be used without prior consent provided that the derivative work contains the verbatim copy or a pointer to a verbatim copy.

<p>
Permission is granted to make and distribute verbatim copies of this document provided the copyright notice and this permission notice are preserved on all copies.

<p>
In short, we wish to promote dissemination of this information through as many channels as possible. However, we wish to retain copyright on this HOWTO document, and would like to be notified of any plans to redistribute this HOWTO.

<sect> Installation of the VMELinux Kernel Driver

<sect1> Download the Source
<p>
Download the distribution from the <htmlurl url="http://www.vmelinux.org/" name="VMELinux Web Site">.

<sect1> Install the source to the software
<p>
Place the file in your source directory; We suggest /usr/src. Untar the zipped/tarred file by typing...
<verb>
tar -xzf VMELinux_0.95.tar.gz
</verb>
<p>
Then:
<verb>
cd vmelinux
</verb>
You should see three directories:
<verb>
ca91c042
vmeshell
vmeutils
</verb>
<p>
In ca91c042 you should find:
<verb>
ca91c042/                    
ca91c042/Makefile            
ca91c042/ca91c042.c          
ca91c042/ca91c042.h          
ca91c042/README              
ca91c042/e                   
ca91c042/ins                 
ca91c042/stat                
ca91c042/uns                                        
</verb>
<p>
In vmeshell you should find:
<verb>
vmeshell/vmer    
vmeshell/README  
vmeshell/vmeseek 
vmeshell/cmd.vme 
vmeshell/vmew    
vmeshell/vmeregw 
vmeshell/vmeregr 
vmeshell/vmefa   
vmeshell/vmecall 
vmeshell/e       
vmeshell/ec      
vmeshell/fa.vme  
vmeshell/map.vme 
vmeshell/tmp.vme 
vmeshell/vmedb   
vmeshell/vmedl   
vmeshell/vmedw   
vmeshell/vmemap  
vmeshell/vmerb   
vmeshell/vmerf   
vmeshell/vmerl   
vmeshell/vmerw   
vmeshell/vmewb 
vmeshell/vmewf 
vmeshell/vmewl 
vmeshell/vmeww 
vmeshell/makelinks
</verb>
<p>
In the vmeutils directory you should find:
<verb>
vmeutils/commands.cpp 
vmeutils/commands.h   
vmeutils/universe.h   
vmeutils/Makefile     
vmeutils/vmeutils.h   
vmeutils/unilib.h     
vmeutils/unilib.cpp   
vmeutils/vmeutils.cpp 
vmeutils/README       
</verb>
<sect1> Compile the VMELinux components
<p>
Enter the "ca91c042" directory and make the VMELinux device driver module.
<verb>
make
</verb>
<p>
Now you must create the several /dev driver files.  Type:
<verb>
make devices
</verb>
<p>
DON'T FORGET TO MAKE THE /dev/vme* DEVICES!!!
<p>
Once made, you should see the file "ca91c042.o" in the directory.  This is a loadable module.  See below for loading information.  Plus, you should find several "vme..." files in the /dev directory.
Here is how the files should look:
<verb>
hostname:/dev# ls -l vme*                                           
crw-rw-rw-   1 root     root      70,   8 Jul 30 10:51 vme_ctl    
crw-rw-rw-   1 root     root      70,   0 Jul 30 10:51 vme_m0     
crw-rw-rw-   1 root     root      70,   1 Jul 30 10:51 vme_m1     
crw-rw-rw-   1 root     root      70,   2 Jul 30 10:51 vme_m2     
crw-rw-rw-   1 root     root      70,   3 Jul 30 10:51 vme_m3     
crw-rw-rw-   1 root     root      70,   4 Jul 30 10:51 vme_s0     
crw-rw-rw-   1 root     root      70,   5 Jul 30 10:51 vme_s1     
crw-rw-rw-   1 root     root      70,   6 Jul 30 10:51 vme_s2     
crw-rw-rw-   1 root     root      70,   7 Jul 30 10:51 vme_s3     
hostname:/dev#                                                      
</verb>
<p>
Change to the "vmeutils" directory and type make there.
<verb>
make
</verb>
<p>
This will compile the "vmeutils" program.  This program directly speaks to the kernel driver.  It is a reference work for those of you who wish to write your own programs to directly speak with the driver.
<p>
Copy the program "vmeutils" to your user binary directory or let the makelinks script do this for your in the next step.  On our system this is "/usr/local/bin."  Alternatively, you can create a link in the user bin directory to the "vmeutils" program.
<p>
Change to the "vmeshell" directory.  There are no files to be compiled here.  These are shell programs that use the "vmeutils" program to access the VMEbus.  All the files beginning with "vme" should with have a link made or be copied to the "/usr/local/bin" directory.
<p>
just type:
<verb>
./makelinks
</verb>
<p>
You are now ready to try the driver.

<sect1>Load the VMELinux Kernel Module
<p>
Make sure you are root and insert "load" the VMELinux Kernel Module for the Universe chip by typing...
<verb>
insmod ca91c042
</verb>
<p> Or just type "./ins" to let the shell script do this for you.  Once complete, type...
<verb>
./stat
</verb>
<p>
or
<verb>
more /proc/ca91c042
</verb>
You should see a list of registers displayed on your screen.  Something like this...
<verb>
Universe driver info:                                  
  Control Pointer = 0000                               
  Stats  reads = 0  writes = 0  ioctls = 0             
  LSI0_CTL = 00800000    LSI1_CTL = 00800000           
  LSI0_BS  = C0000000    LSI1_BS  = 00000000           
  LSI0_BD  = C0010000    LSI1_BD  = 00000000           
  LSI0_TO  = 40009000    LSI1_TO  = 00000000           
  LSI2_CTL = 00800000    LSI3_CTL = 00800000           
  LSI2_BS  = 00000000    LSI3_BS  = 00000000           
  LSI2_BD  = 00000000    LSI3_BD  = 00000000           
  LSI2_TO  = 00000000    LSI3_TO  = 00000000           
  image_va0   = 00000000     image_va1   = 00000000    
  image_va2   = 00000000     image_va3   = 00000000    
                                                       
Driver Program Status:                                 
  DMACTL 0    = 00000000 DMACTL 1    = 00000000        
  DMACTL 2    = 00000000 DMACTL 3    = 00000000        
  OkToWrite 0 = 0        OkToWrite 1 = 0               
  OkToWrite 2 = 0        OkToWrite 3 = 0               
  Mode 0      = 0        Mode 1      = 0               
  Mode 2      = 0        Mode 3      = 0               
</verb>                                           
 If not, something went wrong.
<sect1> Difficulties
<p>
The Universe driver does a good job of finding the Universe chip on a PCI bus, but differences in board design may prevent this.  We tested all our routines on a Xycom XVME-655 board.  There is little reason why this should not work on any other Intel board with a PCI bus and the Universe PCI-VME bridge chip.  If you encounter problems, please let us know at the <htmlurl url="mailto:vmelinux@va.net" name="The VMELinux Project">

<sect> How to talk to the VMEbus with the VMEUtils and the VMEShell Packages
<sect1> What is the VMEUtils program
<p>
This program can be run as is.  Once started, you will see a command prompt.  Type ? And you will see a list of commands.  While useful, I think you will find the VMEShell scripts a better way to go.  They do use this program to speak with the kernel driver so it is necessary to have this program available in the current PATH.
<p>
The source code for "vmeutils" is also instruction on how to speak directly to the kernel driver.  For those of you who wish to create programs that directly speak with the driver, these source files are good examples.
<sect1> What are the VMEShell Scripts
<p>
The VMEShell programs are unix shell scripts.  They offer the operator a simple way to access the data on a VMEbus.  Using these commands creates temporary files in the user's working directory which store information on the last access you did.  This is nice because it will be possible to log off the machine, log back in and proceed from where you left off without having to re-enter VMEbus information again.  Plus, these files are stored in the current working directory, so you can have different VME access configuration just by setting up different directories for each VME board of interest.
<p>
Assuming you placed the shell programs and the "vmeutils" program in the /usr/local/bin directory, you should be able to log in as a regular user and run them.  What follows assumes exactly this.
<sect1> The "vmemap" command.
<p>
Login as a regular user and create a directory to experiment with.  Once in this directory type:
<verb>
vmemap
</verb>
You should get a help screen like this...
<verb>
Usage:  map address count space size type                   
  where address is VME Address to set Universe image to     
                                                            
    Space = 0 CR/CSR    Space = 1 A16                       
    Space = 2 A24       Space = 3 A32                       
                                                            
    Size  = 1 8 bit     Size  = 2 16 bit                    
    Size  = 3 32 bit    Size  = 4 64 bit                    
                                                            
    Type  = 0 USR/DATA  Type  = 1 USR/PRG                   
    Type  = 2 SUP/DATA  Type  = 3 SUP/PRG                   
</verb>
This is where you tell VMELinux how you want to access the VMEbus.  We assume you already know about the VMEbus' many modes of operation, but here is a short list to help you.
<itemize>
<item> <bf>address</bf> is the actual VMEbus address you wish to see.  This should be set to the lower most value of the address range of interest.
<item> <bf>count</bf> is the number of bytes you consider a valid range to view.  This is the number of bytes starting at the address specified above.
<item> <bf>space</bf> is the addressing space (mode).  For those of you who do not know what we are talking about here, the VMEbus has four overlapping address spaces that can be called independant of each other.  A16 is a 64 KiloByte space.  A24 is a 16 MegaByte space.  A32 is a 4 GigaByte space.  There is an A64 space defined the VME specification, but the Universe does not support it.
<item> <bf>Size</bf> refers to the maximum datawidth allowed for the VME board you are accessing.  Some VMEbus board only handle 8 bit data paths.  Others transfer 32 bits (four bytes) at a time.  Some can handle a special VME block mode which can move 64 bits per transaction.  The Universe can handle all these modes allowing you to mix inexpensive serial port boards with hugh memory arrays.
<item> <bf>Type</bf> is the type of VME transaction performed.  Some VME boards make a distinction between "User" access (USR) and "Supervisior" access (SUP).  Also, some boards allow access to two "pages" of memory: Program (PRG) and Data.  The Universe supports all modes.
</itemize>
Typing...
<verb>
vmemap 0x8000 0x100 1 2 0
</verb>
sets up the VMELinux driver to access an A16 board at base address 8000 Hex with a range of 100H bytes with 16 bit data width and USR/DATA mode.
<p>
You will find two new files in your current directory.
<itemize>
<item> fa.vme
<item> map.vme
</itemize>
<bf>fa.vme</bf> stores a "fixed adder" value that will be added to all subsequent accesses with the programs below.
<p>
<bf>map.vme</bf> store the parameters above so you do not have to enter them every time.
<p>
All the following shell utilities read values from these two files to performs VME accesses.

<sect1> Read Byte, Word or Long
<p>
Syntax:
<itemize>
<item> vmerb -&lsqb;options&rsqb; address size
<item> vmerw  -&lsqb;options&rsqb; address size
<item> vmerl -&lsqb;options&rsqb; address size
</itemize>
<sect1> Write Byte, Word or Long
<p>
Syntax:
<itemize>
<item> vmewb -&lsqb;options&rsqb; address value
<item> vmeww  -&lsqb;options&rsqb; address value
<item> vmewl -&lsqb;options&rsqb; address value
</itemize>
<sect1> Read the VMEbus to a file
<p>
Syntax:
<itemize>
<item> vmerf -&lsqb;options&rsqb; address size filename
</itemize>
<sect1> Write a file to the VMEbus
<p>
Syntax:
<itemize>
<item> vmewf -&lsqb;options&rsqb; address filename
</itemize>
<sect1> Parameters
<p>
There are several parameters used with these commands: address, size and filename.
<itemize>
<item> address - The actual hexadecimal VMEbus address you wish to read.  If the map command is set to access A16 VME address space, the address should be 0xABCD.  If the space is A24 then use 0xABCDEF.  For A32 space use 0xABCDEFGH.
<item> size - The number of bytes to read.  This value is always the number of bytes regardless of the data word size read.  For example, if you want to read 16 bytes of information and use vmerl, the display will show 16 bytes displayed as 4 long words.
<item> filename - The name of the file to send "read" VMEbus data to or "write" VMEbus data from.
<item> value - a hex value written as "0xXXXX."
</itemize>
<sect1> Options
<p>
Available options are defined with a single dash with the any combination of the following:
<itemize>
<item> q - Hides details on the access to the vmeutils program (default)
<item> Q - Shows details on the access to the vmeutils program
<item> p - Single access PCI addressing mode (opposite of d) (default)
<item> d - DMA access PCI addressing mode (opposite of p) (very fast access to the VMEbus)
<item> 0, 1, 2, or 3 - Which Universe chip "Image" to use (defaults to 0)
<item> b - binary mode off (default)
<item> B - binary mode on
<item> v - turn off verbose parameter printing (default)
<item> V - turn on verbose parameter printing to see how the driver is begin used
</itemize>
<sect1> A Note about DMA mode.
<p>
VMELinux offers access to all the features of the Universe Chip.  Especially useful is access to the DMA engine on the chip.  With this feature the Universe chip transfers data on the PCI bus by becoming a PCI master.  This is nice, but the real benefit comes from the VMEbus accesses.  Even if the VMEbus interface is not using block mode transfers, the Universe chip can complete VMEbus transfers under 400 nanoseconds sustained.  This is the direct result of the Universe taking complete control of both the PCI bus and the VMEbus.  Thus, it is possible to access non block mode VMEbus peripherals much faster than older technologies.

<sect> How to talk to the Tundra Universe PCI-VME bridge using the devices drivers.

<sect1> The device drivers used with VMELinux
<p>
<itemize>
<item> /dev/vme_ioctl
<item> /dev/vme_m0
<item> /dev/vme_m1
<item> /dev/vme_m2
<item> /dev/vme_m3
<item> /dev/vme_s0
<item> /dev/vme_s1
<item> /dev/vme_s2
<item> /dev/vme_s3
</itemize>
<sect1> VMEMaster Device Drivers
<p>
/dev/vme_m* are drivers used to access the VMEbus as a bus master.
<p>
The Universe chip offers the programmer four VMEMaster windows to the VMEbus.  These windows are called Images.  The details of the registers within these windows is beyond the scope of this Howto.  Please refer to the Universe documentation for details. <htmlurl url="http://www.tundra.com/Tundra/unidex.html" name="Tundra Universe">
<sect1> VMESlave Device Drivers
<p>
/dev/vme_s* are drivers used to allow another VMEbus master to access this device.
<p>
The Universe chip offers the programmer four VMESlave windows to the VMEbus.  These windows are called Images.  The details of the registers within these windows is beyond the scope of this Howto.  Please refer to the Universe documentation for details. <htmlurl url="http://www.tundra.com/Tundra/unidex.html" name="Tundra Universe">
<p>
Slave VME modes are not yet supported by VMELinux.
<sect1> Direct Control of the Universe Registers
<p>
/dev/vme_ioctl allows read and write access to the Universe registers.
<p>
For experienced users, this device allows direct access to the Universe chip's internal registers.  Explanation of these registers and what they do is beyond the scope of this howto. Please consult the Universe documentation available from <htmlurl url="http://www.tundra.com/Tundra/unidex.html" name="Tundra Universe">
<sect1> read()
<p>
n = read(vme_handle,buf,len);
<p>
Where:
<itemize>
<item> vme_handle = The value returned by "open,"
<item> buf = pointer to data block,
<item> len = number of bytes to read from the VMEbus.
</itemize>
<sect1> write()
<p>
write(vme_handle,buf,len);
<p>
Where:
<itemize>
<item> vme_handle = The value returned by "open,"
<item> buf = pointer to data block,
<item> len = number of bytes to write to the VMEbus.
</itemize>
<sect1> lseek()
<p>
lseek(vme_handle,vme_pnt,Seek_Type);
<p>
Where:
<itemize>
<item> vme_handle = The value returned by "open,"
<item> vme_pnt = The actual VME address to access,
<item> Seek_Type = SEEK_SET or SEEK_CUR
</itemize>
<sect1> ioctl()
<p>
ioctl(vme_handle, command, argument);
<p>
Where:
<itemize>
<item> vme_handle = The value returned by "open,"
<item> command = IOCTL_SET_CTL or IOCTL_SET_MODE or IOCTL_SET_BS or IOCTL_SET_BD or IOCTL_SET_TO
<item> argument to be sent
</itemize>
And:
<itemize>
<item> IOCTL_SET_CTL = Sets the image CTL register to argument. Argument must be 32 bits.
<item> IOCTL_SET_MODE = "MODE_DMA" or "MODE_PROGRAMMED" - Sets the mode by which the Universe chips communicates to the PCI bus (Not VME Block Mode)
<item> IOCTL_SET_BS = Sets the image BS register to arguments.  NOTE: The BD register must already be set prior to making this call.
<item> IOCTL_SET_BD = Sets the image BD register to argument.
<item> IOCTL_SET_TO = Set the image TO register to argument.
</itemize>
<sect1> open() and close()
<p>
Here is where you open and close the four VMELinux Master or Slave devices plus the Control device.  Slave images are not yet supported.
<itemize>
<item> vme_handle = open("//dev//vme_m0",O_RDWR,0);
<item> uni_handle = open("//dev//vme_ctl",O_RDWR,0);
</itemize>
<p>
<itemize>
<item> close(vme_handle);
<item> close(uni_handle);
</itemize>

<sect> Advantages of the VMEbus, Linux and VMELinux
<sect1> Pin and socket connectors
<p>
The VMEbus standard uses pin and socket connectors. This is superior to edge connections in that the connection is not exposed to humidity and other environmental conditions. It is a more expensive way of doing things, but offers longer times before failure.
<sect1> Eurocard assembly
<p>
A VMEboard is either a 3U (160 x 100 mm) or a 6U size (160 x 233.35 mm). These sizes correspond to the Eurocard standard for board modules and card cages. Eurocard is a popular format used by many different busses including CompactPCI. This popularity makes the materials needed for cage assembly inexpensive and easy to obtain.
<sect1> Linux is Low Cost
<p>
The nature of Linux is in its user supported and freely available format. The number of people using Linux is growing. The number of people contributing to the continued development of the Linux software base is growing. It is unfair to state that Linux is a good value because it is available for little to no charge. Linux is a good value because it works.
<sect1> Linux is Stable
<p>
There are those who say that Linux us an unstable operating system. It is true that the new Linux kernels in development are experimental and should not be relied on for critical applications. However, stable versions of the Linux OS are always available and provide very stable operation. VMELinux is always based on the stable versions of the kernel source; Today's stable kernels are the 2.0.X series.
<sect1> Linux is Dynamic
<p>
Because so many people are developing Linux, you do not have to wait long for improvements, fixes or new features to become part of the Linux distribution.
<sect> Current and planned Board Support
<p>
While the VMELinux driver should work with any PCI based design, the following boards have actually run our software.
<sect1> Xycom XVME655 Pentium VMEbus Board
<p>
<itemize>
<item> This XyCom board is compatible with the standard VMELinux kernel driver package from <htmlurl url="http://www.vmelinux.org/" name="VMELinux Project">
<item> A prepared kernel will be available soon.  It will be based on the newest version of the Linux kernel and will include appropriate drivers for the onboard NE2100 Ethernet interface.  Check the website for details.
</itemize>
<sect1> XyCom XVME656 Pentium VMEBus Board
<p>
<itemize>
<item> This XyCom board is compatible with the standard VMELinux kernel driver package from <htmlurl url="http://www.vmelinux.org/" name="VMELinux Project">
<item> A prepared kernel will be available soon.  It will be based on the newest version of the Linux kernel and will include appropriate drivers for the onboard AHA2940/AIC7000 SCSI and 82558 Intel EtherExpress Ethernet peripherals.  Check the website for details.
</itemize>
<sect1> Dynatem DPC1-0367
<p>
<itemize>
<item> This board is compatible with the standard VMELinux kernel driver package from <htmlurl url="http://www.vmelinux.org/" name="VMELinux Project">
<item> A prepared kernel will be available soon.  It will be based on the newest version of the Linux kernel and will include appropriate drivers for the onboard SCSI and Tulip Ethernet peripherals.  Check the website for details.
</itemize>
<sect1> SBS/Or Computer VP7
<p>
<itemize>
<item> This board is compatible with the standard VMELinux kernel driver package from <htmlurl url="http://www.vmelinux.org/" name="VMELinux Project">
<item> A prepared kernel will be available soon.  It will be based on the newest version of the Linux kernel and will include appropriate drivers for PCNET Ethernet peripheral.  Check the website for details.
<item> The VP7 has a nice feature which performs the BOOTP protocol without need of a bootrom or similar modification.  However, you must ask SBS for an updated BIOS with this modification.
</itemize>
<sect1> DY4 179, A Power PC board
<p>
<itemize>
<item> An independant engineer finds this board is compatible with the standard VMELinux kernel driver package from <htmlurl url="http://www.vmelinux.org/" name="VMELinux Project">
</itemize>
<sect1> Planned Board Support
<p>
If you do not see VMELinux support for your board let us know. Maybe the manufacture will lend us a board for development.
<sect> Conclusion
<p>
VMELinux offers the user a low cost way to implement a VMEbus system quickly, reliably and with all the advantages of a unix environment.  We are using VMELinux in our projects so you can be sure future developments will come quick.  On the drawing board for this year are:
<itemize>
<item> Porting to other brands of Intel VMEbus boards,
<item> Porting of VMELinux to other processors that use the Universe chip,
<item> A study of running the VMELinux kernel driver module as a RT-Linux task.
</itemize>
<p>
This document outlines the steps you need to install the VMELinux Kernel Driver into the example Xycom XVME-655 Pentium VME board.  It is our hope that others will attempt installation of VMELinux into other boards and let us know their success.

<p>
Mail any responses to 
<htmlurl url="mailto:vmelinux@va.net" name="The VMELinux Project">.  If you have a 
question or an update to the document let us know and we will add it.


<sect> 
FAQ
<p>
<sect1> The Shell utilities return a bunch of stars (*) when I access a board I know is there.  What gives?
<p>
Check to be sure the /dev/vme... files have their permissions set to 666.  If not, the shell utilities will return a * in place of data to indicate an error condition similar to a VME bus error.

<sect1> The Shell utilities still return a bunch of stars (*) when I access a board I know is there.  Now what?
<p>
It is possible the ca91c042 Linux kernel module has been compromised.  Get root access and type "lsmod" to review the loaded modules.  Do you see the ca91c042?  If yes, try removing it and reinstalling it with "rmmod ca91c042" and then "insmod /path/to/the/ca91c042.o" to get things up again.  If it is not there check to see if you are loading the module when you boot the machine, etc.

<sect1> The Shell utilities still return a bunch of stars (*) when I access a board I know is there.  HELP?
<p>
Time to get a VMetro board into the VME cage and see if any accesses are occuring.  Also look at the /proc/ca91c042 file to see if the read and write counters are incrementing.

<sect1> How does VMELinux handle interrupts?
<p>
The driver does handle interrupts, but if you compile your interrupt handler program as a Linux loadable module, that program can handle the interrupts directly.  Examples of this will be available soon.  It is important to note that user level program can be made to handle interrupts, but it is a much better idea to have your interrupt handlers as part of the Linux kernel via loadable modules.  Yes, you can totally hose the kernel if you do something wrong, but that is the trade off between safety and performance.

<sect1> I have RedHat 5.1 and can't get VMELinux programs to compile.
<p>
RedHat 5.1 includes a new compiler.  If you manually edit the Makefile in each directory to call up the new egcs compiler, things should compile.  We fully intend to support RedHat 5.1 installations, but for now I suggest using 5.0 or Slackware.

<sect1> I have RedHat 6.x so I assume the above issue is fixed.  Right?
<p>
Maybe.  RedHat threw us, and many other kernel module driver writers, a curveball with the move to the egcs compiler.  Thankfully, the two compiler camps, GCC and egcs, have united their efforts.  All this incompatibility should just go away.  For the moment, however, VMELinux will only be tested with GCC 2.95.x so that is what we suggest you use for a compiler.  If you type "gcc --version" at your prompt and get an "egcs..." back then we cannot say it will work for you.


<!-- Ending -->

</article>
